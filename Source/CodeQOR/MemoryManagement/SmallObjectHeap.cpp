//SmallObjectHeap.cpp

// Copyright Querysoft Limited 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "SystemQOR.h"
#include <new>
#include "CodeQOR/MemoryManagement/SmallObjectHeap.h"
#include "CodeQOR/MemoryManagement/ManagedAllocator.h"

//--------------------------------------------------------------------------------
namespace nsCodeQOR
{
	//--------------------------------------------------------------------------------
	CSmallObjectHeap::CSmallObjectHeap()
	{		
		m_uiTotalAlloc = 0;
	}

	//--------------------------------------------------------------------------------
	CSmallObjectHeap::~CSmallObjectHeap()
	{
		if( m_uiTotalAlloc != 0 )
		{
			m_uiTotalAlloc = 0;
		}
	}

	//--------------------------------------------------------------------------------
	int CSmallObjectHeap::Bucket( Cmp_uint_ptr uiAllocSize )
	{
		Cmp_uint_ptr uiBucket = 0;
		CSmallObjectBucket* pBucket = 0;
		do
		{
			pBucket = m_Buckets[ uiBucket ];

			if( pBucket == 0 && ( uiAllocSize <= (Cmp_uint_ptr)( 4 << uiBucket ) ) )
			{
				void* pMem = FastNew< void >( sizeof( CSmallObjectBucket ), __LINE__, __FILE__ );
				m_Buckets[ uiBucket ] = pBucket = new( pMem ) CSmallObjectBucket( 4 << uiBucket );
			}
		}while( ( uiAllocSize > (Cmp_uint_ptr)( 4 << uiBucket ) ) && ( ++uiBucket < suiRootBuckets ) );

		return uiBucket;
	}

	//--------------------------------------------------------------------------------
	void CSmallObjectHeap::FreeBucket( int iBucket, CSmallObjectBucket* pBucket )
	{
		m_Buckets[ iBucket ] = 0;
		FastHeap().Free/*< CSmallObjectBucket >*/( pBucket );
	}

	//--------------------------------------------------------------------------------
	CSmallObjectBucket* CSmallObjectHeap::Page( int iBucket )
	{
		CSmallObjectBucket* pPage = 0;
		if( iBucket >= 0 && iBucket < suiRootBuckets )
		{
			pPage = m_Buckets[ iBucket ];
		}
		return pPage;
	}

	//--------------------------------------------------------------------------------
	unsigned char* CSmallObjectHeap::DeferToFastAllocator( Cmp_uint_ptr uiSize )
	{
		return reinterpret_cast< unsigned char* >( FastNew< void >( uiSize, __LINE__, __FILE__ ) );
	}

	//--------------------------------------------------------------------------------
	void CSmallObjectHeap::DeferToFastFree( void* pMem, Cmp_uint_ptr uiCount )
	{
		FastHeap().Free/*< void >*/( pMem, uiCount );
	}

	//--------------------------------------------------------------------------------
	void CSmallObjectHeap::ReportTotalAllocation( Cmp_uint_ptr& uiTotalAlloc )
	{
		uiTotalAlloc = m_uiTotalAlloc;						//Report the total size the heap has grown to
	}

	//--------------------------------------------------------------------------------
	void CSmallObjectHeap::ReportMaxAllocation( Cmp_uint_ptr& uiMaxAlloc )
	{
		uiMaxAlloc = m_uiMaxAlloc;							//Report the maximum size the heap has ever grown to
	}

	//--------------------------------------------------------------------------------
	void CSmallObjectHeap::Analyse( void(*pTrace)( char* ) )
	{
		/*
		unsigned int uiSpace = 2048;
		char Buffer[ 2048 ];
		int iPages = 0;
		int iChains = 0;

		for( iChains = 0; iChains < suiRootBuckets; iChains++ )
		{
			CFPage* pChain = m_Buckets[ iChains ];
			while( pChain )
			{
				iPages++;
				pChain = pChain->Next();
			};
		};
		uiSpace -= sprintf( Buffer, "Tight Heap consists of %d pages in %d chains managing %u bytes", iPages, iChains, m_uiTotalAlloc );
		(pTrace)( Buffer );

		iPages = 0;
		for( iChains = 0; iChains < suiRootBuckets; iChains++ )
		{
			CFPage* pChain = m_Buckets[ iChains ];
			//sprintf( Buffer, "Chain %d:-", iChains );
			//(pTrace)( Buffer );			
			while( pChain )
			{
				iPages++;
				pChain->Analyse( pTrace );
				pChain = pChain->Next();
			};
		};
		*/
	}

}//nsCodeQOR

