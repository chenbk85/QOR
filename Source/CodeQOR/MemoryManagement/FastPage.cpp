//FastPage.cpp

// Copyright Querysoft Limited 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "SystemQOR.h"
#include <string.h>
#include <stdlib.h>
#include "CodeQOR/MemoryManagement/FastPage.h"

//--------------------------------------------------------------------------------
namespace nsCodeQOR
{
	//--------------------------------------------------------------------------------
	CStackPage::CStackPage( Cmp_uint_ptr uiPageUnits ) : m_uiPageUnits( uiPageUnits )
	, m_pNext( 0 )
	, m_pPrev( 0 )
	, m_pMemoryBase( 0 )
	, m_pToS( 0 )
	, m_uiItems( 0 )
	{
	}

	//--------------------------------------------------------------------------------
	CStackPage::CStackPage( CStackPage* pPrev, unsigned char* pMemory, Cmp_uint_ptr uiPageUnits ) : m_uiPageUnits( uiPageUnits )
	, m_pPrev( pPrev )
	, m_pNext( 0 )
	, m_uiItems( 0 )
	{
		m_pMemoryBase = new unsigned char[ m_uiPageUnits * suiPageUnitSize ];
		m_pToS = m_pMemoryBase;
	}

	//--------------------------------------------------------------------------------
	CStackPage::~CStackPage()
	{			
		delete [] m_pMemoryBase;
	}

	//--------------------------------------------------------------------------------
	Cmp_uint_ptr CStackPage::TotalSize( void )
	{
		Cmp_uint_ptr uiTotalSize = m_pMemoryBase ? ( m_uiPageUnits * suiPageUnitSize ) : 0;
		return uiTotalSize;
	}

	//--------------------------------------------------------------------------------
	Cmp_uint_ptr CStackPage::AllocatedSize( void )
	{
		Cmp_uint_ptr uiAllocatedSize = ( m_pToS - m_pMemoryBase );
		return uiAllocatedSize;
	}

	//--------------------------------------------------------------------------------
	Cmp_uint_ptr CStackPage::AllocatedItems( void )
	{
		return m_uiItems;
	}

	//--------------------------------------------------------------------------------
	void CStackPage::SetSize( Cmp_uint_ptr uiPageUnits )
	{
		m_uiPageUnits = uiPageUnits;
	}

	//--------------------------------------------------------------------------------
	CStackPage* CStackPage::Next( void )
	{
		return m_pNext;
	}

	//--------------------------------------------------------------------------------
	CStackPage* CStackPage::Prev( void )
	{
		return m_pPrev;
	}

	//--------------------------------------------------------------------------------
	void CStackPage::SetNext( CStackPage* pNext )
	{
		m_pNext = pNext;
	}

	//--------------------------------------------------------------------------------
	void CStackPage::SetPrev( CStackPage* pPrev )
	{
		m_pPrev = pPrev;
	}

	//--------------------------------------------------------------------------------
	void CStackPage::Initialise()
	{
		if( m_pMemoryBase == 0 && ( m_uiPageUnits > 0 ) )
		{	
			m_pMemoryBase = new unsigned char[ m_uiPageUnits * suiPageUnitSize ];
			m_pToS = m_pMemoryBase;
			m_uiItems = 0;
		}
	}

	//--------------------------------------------------------------------------------
	void* CStackPage::Allocate( Cmp_uint_ptr uiByteCount, unsigned int uiLine, const char* pFile, Cmp_uint_ptr ulAllocIndex )
	{
		void* pMem = 0;
		if( ( m_pMemoryBase + ( m_uiPageUnits * suiPageUnitSize ) ) > ( m_pToS + ( uiByteCount + sizeof( Info ) ) ) )
		{
			Info info = { static_cast< long >( uiByteCount ), uiLine, pFile, ulAllocIndex, this };
			Push/*< Info >*/( info );
			pMem = Push( uiByteCount );
			m_uiItems++;
		}

		return pMem;
	}

	//--------------------------------------------------------------------------------
	bool CStackPage::Free( void* pMemory )
	{
		bool bResult = false;
		if( ( pMemory > m_pMemoryBase ) && ( pMemory <= m_pToS ) )
		{
			Info* pInfo = reinterpret_cast< Info* >( ( reinterpret_cast< unsigned char* >( pMemory ) ) - sizeof( Info ) );
			if( m_pToS == ( ( reinterpret_cast< unsigned char* >( pMemory ) ) + ( pInfo->m_lSize ) ) )
			{
				m_pToS -= pInfo->m_lSize;
				pInfo = Pop/*< Info >*/( pInfo );
				while( pInfo->m_lSize < 0 )
				{
					m_pToS -= ( 0 - pInfo->m_lSize );
					pInfo = Pop/*< Info >*/( pInfo );
				}
			}
			else
			{
				memset( pMemory, 0xDF, pInfo->m_lSize );
				pInfo->m_lSize = 0 - pInfo->m_lSize;
			}
			m_uiItems--;
			if( m_uiItems == 0 )
			{
				m_pToS = m_pMemoryBase;
			}
			bResult = true;
		}
		return bResult;
	}

	//--------------------------------------------------------------------------------
	void CStackPage::Analyse( void(*pTrace)(char*) )
	{
		/*
		char Buffer[ 2048 ];

		unsigned char* pMem = reinterpret_cast< unsigned char* >( m_pMemoryBase );
		Info* pInfo = reinterpret_cast< Info* >( pMem );
		unsigned int uiItem = 0;
		while( pMem < m_pToS )
		{
			if( pInfo->m_lSize > 0 )
			{
				sprintf( Buffer, "Item %u, Index = %u, Size = %d, Line = %u, File = %s", uiItem++, pInfo->m_ulAllocIndex, pInfo->m_lSize, pInfo->m_uiLine, pInfo->m_szFile );		
				(pTrace)( Buffer );
			}
			pMem+= sizeof( Info );
			pMem+= abs( pInfo->m_lSize );
			pInfo = reinterpret_cast< Info* >( pMem );
		}
		*/
	}

	//--------------------------------------------------------------------------------
	void* CStackPage::Push( Cmp_uint_ptr uiBytes )
	{
		void* pMem = m_pToS;
		m_pToS += uiBytes;
		return pMem;
	}

	//--------------------------------------------------------------------------------
	void* CStackPage::Pop( Cmp_uint_ptr uiBytes )
	{
		m_pToS -= uiBytes;
		return m_pToS;
	}

}// nsCodeQOR
