//MemoryManagerPrivate.cpp

// Copyright (c) 2008-2010, Petr Kobalicek <kobalicek.petr@gmail.com>
// Copyright (c) Querysoft Limited 2012, 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "ArchQOR.h"
#include "ArchQOR/Common/Assembler/MemoryManagerPrivate.h"
#include <string.h>
#include <assert.h>

//------------------------------------------------------------------------------
#define M_DIV( x, y ) ( ( x ) / ( y ) )
#define M_MOD( x, y ) ( ( x ) % ( y ) )
#define BITS_PER_ENTITY ( sizeof(Cmp_uint_ptr) * 8 )

//------------------------------------------------------------------------------
namespace nsArch
{
	/*
	//------------------------------------------------------------------------------
	static void _SetBit( Cmp_uint_ptr* buf, Cmp_uint_ptr index ) __QCMP_THROW
	{
		Cmp_uint_ptr i = index / BITS_PER_ENTITY; // Cmp_uint_ptr[]
		Cmp_uint_ptr j = index % BITS_PER_ENTITY; // Cmp_uint_ptr[][] bit index

		buf += i;
		*buf |= (Cmp_uint_ptr)1 << j;
	}

	//------------------------------------------------------------------------------
	static void _ClearBit( Cmp_uint_ptr* buf, Cmp_uint_ptr index ) __QCMP_THROW
	{
		Cmp_uint_ptr i = index / BITS_PER_ENTITY; // Cmp_uint_ptr[]
		Cmp_uint_ptr j = index % BITS_PER_ENTITY; // Cmp_uint_ptr[][] bit index

		buf += i;
		*buf &= ~((Cmp_uint_ptr)1 << j);
	}


	//------------------------------------------------------------------------------
	static void _ClearBits( Cmp_uint_ptr* buf, Cmp_uint_ptr index, Cmp_uint_ptr len ) __QCMP_THROW
	{
		if( len == 0 )
		{
			return;
		}

		Cmp_uint_ptr i = index / BITS_PER_ENTITY; // Cmp_uint_ptr[]
		Cmp_uint_ptr j = index % BITS_PER_ENTITY; // Cmp_uint_ptr[][] bit index

		// How many bytes process in the first group.
		Cmp_uint_ptr c = BITS_PER_ENTITY - j;
		if( c > len )
		{
			c = len;
		}

		// Offset.
		buf += i;

		*buf++ &= ~((((Cmp_uint_ptr)-1) >> (BITS_PER_ENTITY - c)) << j);
		len -= c;

		while( len >= BITS_PER_ENTITY )
		{
			*buf++ = 0;
			len -= BITS_PER_ENTITY;
		}

		if( len )
		{
			*buf &= ((Cmp_uint_ptr)-1) << len;
		}
	}
	*/
	//------------------------------------------------------------------------------
	static void _SetBits( Cmp_uint_ptr* buf, Cmp_uint_ptr index, Cmp_uint_ptr len ) __QCMP_THROW
	{
		if( len == 0 )
		{
			return;
		}

		Cmp_uint_ptr i = index / BITS_PER_ENTITY; // Cmp_uint_ptr[]
		Cmp_uint_ptr j = index % BITS_PER_ENTITY; // Cmp_uint_ptr[][] bit index

		// How many bytes process in the first group.
		Cmp_uint_ptr c = BITS_PER_ENTITY - j;
		if( c > len )
		{
			c = len;
		}

		// Offset.
		buf += i;

		*buf++ |= (((Cmp_uint_ptr)-1) >> (BITS_PER_ENTITY - c)) << j;
		len -= c;

		while (len >= BITS_PER_ENTITY)
		{
			*buf++ = (Cmp_uint_ptr)-1;
			len -= BITS_PER_ENTITY;
		}

		if (len)
		{
			*buf |= (((Cmp_uint_ptr)-1) >> (BITS_PER_ENTITY - len));
		}
	}

	//------------------------------------------------------------------------------
	// Get whether the node is red (NULL or node with red flag).
	template< typename T >
	inline bool isRed( RbNode< T >* node )
	{
		return node != NULL && node->red;
	}

	//------------------------------------------------------------------------------
	static int rbAssert(MemNode* root)
	{
		if( root == 0 )
		{
			return 1;
		}

		MemNode* ln = root->node[0];
		MemNode* rn = root->node[1];

		// Red violation.
		assert( !(isRed(root) && (isRed(ln) || isRed(rn))) );

		int lh = rbAssert(ln);
		int rh = rbAssert(rn);

		// Invalid btree.
		assert(ln == NULL || ln->mem < root->mem);
		assert(rn == NULL || rn->mem > root->mem);

		// Black violation.
		assert( !(lh != 0 && rh != 0 && lh != rh) );

		// Only count black links.
		if( lh != 0 && rh != 0 )
		{
			return isRed( root ) ? lh : lh + 1;
		}
		else
		{
			return 0;
		}
	}

	//------------------------------------------------------------------------------
	static inline MemNode* rbRotateSingle( MemNode* root, int dir )
	{
		MemNode* save = root->node[ !dir ];
		root->node[ !dir ] = save->node[ dir ];
		save->node[ dir ] = root;
		root->red = 1;
		save->red = 0;
		return save;
	}

	//------------------------------------------------------------------------------
	static inline MemNode* rbRotateDouble( MemNode* root, int dir )
	{
		root->node[ !dir ] = rbRotateSingle( root->node[ !dir ], !dir );
		return rbRotateSingle( root, dir );
	}

	//------------------------------------------------------------------------------
	MemoryManagerPrivate::MemoryManagerPrivate( nsCodeQOR::CProcessBase* hProcess ) __QCMP_THROW :
	_hProcess(hProcess),
	_newChunkSize(65536),
	_newChunkDensity(64),
	_allocated(0),
	_used(0),
	_root(0),
	_first(0),
	_last(0),
	_optimal(0),
	_permanent(0),
	_keepVirtualMemory(false)
	{
	}

	//------------------------------------------------------------------------------
	MemoryManagerPrivate::~MemoryManagerPrivate() __QCMP_THROW
	{
		// Freeable memory cleanup - Also frees the virtual memory if configured to.
		freeAll(_keepVirtualMemory);

		// Permanent memory cleanup - Never frees the virtual memory.
		PermanentNode* node = _permanent;
		while (node)
		{
			PermanentNode* prev = node->prev;
			::free(node);
			node = prev;
		}
	}

	//------------------------------------------------------------------------------
	// Allocates virtual memory node and MemNode structure. Returns MemNode* on success, otherwise NULL.
	MemNode* MemoryManagerPrivate::createNode(Cmp_uint_ptr size, Cmp_uint_ptr density) __QCMP_THROW
	{
		Cmp_uint_ptr vsize;
		Cmp_unsigned__int8* vmem = allocVirtualMemory(size, &vsize);

		// Out of memory.
		if( vmem == 0 )
		{
			return 0;
		}

		Cmp_uint_ptr blocks = (vsize / density);
		Cmp_uint_ptr bsize = (((blocks + 7) >> 3) + sizeof(Cmp_uint_ptr) - 1) & ~(Cmp_uint_ptr)(sizeof(Cmp_uint_ptr)-1);

		MemNode* node = reinterpret_cast<MemNode*>(::malloc(sizeof(MemNode)));
		Cmp_unsigned__int8* data = reinterpret_cast<Cmp_unsigned__int8*>(::malloc(bsize * 2));

		// Out of memory.
		if (node == 0 || data == 0 )
		{
			freeVirtualMemory(vmem, vsize);
			if (node) ::free(node);
			if (data) ::free(data);
			return 0;
		}

		// Initialize RbNode data.
		node->node[ 0 ] = 0;
		node->node[ 1 ] = 0;
		node->red = 1;
		node->mem = vmem;

		// Initialize MemNode data.
		node->prev = 0;
		node->next = 0;

		node->size = vsize;
		node->blocks = blocks;
		node->density = density;
		node->used = 0;
		node->largestBlock = vsize;

		memset( data, 0, bsize * 2 );
		node->baUsed = reinterpret_cast<Cmp_uint_ptr*>(data);
		node->baCont = reinterpret_cast<Cmp_uint_ptr*>(data + bsize);

		return node;
	}

	//------------------------------------------------------------------------------
	void* MemoryManagerPrivate::allocPermanent(Cmp_uint_ptr vsize) __QCMP_THROW
	{
		static const Cmp_uint_ptr permanentAlignment = 32;
		static const Cmp_uint_ptr permanentNodeSize  = 32768;

		Cmp_uint_ptr over = vsize % permanentAlignment;
		if( over )
		{
			over = permanentAlignment - over;
		}
		Cmp_uint_ptr alignedSize = vsize + over;

		//AutoLock locked(_lock);

		PermanentNode* node = _permanent;

		// Try to find space in allocated chunks.
		while( node && alignedSize > node->getAvailable() )
		{
			node = node->prev;
		}

		// Or allocate new node.
		if (!node)
		{
			Cmp_uint_ptr nodeSize = permanentNodeSize;
			if( vsize > nodeSize )
			{
				nodeSize = vsize;
			}

			node = (PermanentNode*)(::malloc( sizeof(PermanentNode) ) );
			// Out of memory.
			if( node == 0 )
			{
				return 0;
			}

			node->mem = allocVirtualMemory( nodeSize, &node->size );

			// Out of memory.
			if( node->mem == 0 )
			{
				::free( node );
				return 0;
			}

			node->used = 0;
			node->prev = _permanent;
			_permanent = node;
		}

		// Finally, copy function code to our space we reserved for.
		Cmp_unsigned__int8* result = node->mem + node->used;

		// Update Statistics.
		node->used += alignedSize;
		_used += alignedSize;

		// Code can be null to only reserve space for code.
		return (void*)result;
	}

	//------------------------------------------------------------------------------
	void* MemoryManagerPrivate::allocFreeable( Cmp_uint_ptr vsize ) __QCMP_THROW
	{
		Cmp_uint_ptr i;               // Current index.
		Cmp_uint_ptr need;            // How many we need to be freed.
		Cmp_uint_ptr minVSize;

		// Align to 32 bytes (our default alignment).
		vsize = (vsize + 31) & ~(Cmp_uint_ptr)31;
		if (vsize == 0) return NULL;

		//AutoLock locked(_lock);
		MemNode* node = _optimal;

		minVSize = _newChunkSize;

		// Try to find memory block in existing nodes.
		while (node)
		{
		// Skip this node?
		if ((node->getAvailable() < vsize) ||
		(node->largestBlock < vsize && node->largestBlock != 0))
		{
		MemNode* next = node->next;
		if (node->getAvailable() < minVSize && node == _optimal && next) _optimal = next;
		node = next;
		continue;
		}

		Cmp_uint_ptr* up = node->baUsed;    // Current ubits address.
		Cmp_uint_ptr ubits;                 // Current ubits[0] value.
		Cmp_uint_ptr bit;                   // Current bit mask.
		Cmp_uint_ptr blocks = node->blocks; // Count of blocks in node.
		Cmp_uint_ptr cont = 0;              // How many bits are currently freed in find loop.
		Cmp_uint_ptr maxCont = 0;           // Largest continuous block (bits count).
		Cmp_uint_ptr j;

		need = M_DIV( ( vsize + node->density - 1 ), node->density );
		i = 0;

		// Try to find node that is large enough.
		while (i < blocks)
		{
		ubits = *up++;

		// Fast skip used blocks.
		if (ubits == (Cmp_uint_ptr)-1)
		{
		if (cont > maxCont) maxCont = cont;
		cont = 0;

		i += BITS_PER_ENTITY;
		continue;
		}

		Cmp_uint_ptr max = BITS_PER_ENTITY;
		if (i + max > blocks) max = blocks - i;

		for (j = 0, bit = 1; j < max; bit <<= 1)
		{
		j++;
		if ((ubits & bit) == 0)
		{
			if (++cont == need) { i += j; i -= cont; goto found; }
			continue;
		}

		if (cont > maxCont) maxCont = cont;
		cont = 0;
		}

		i += BITS_PER_ENTITY;
		}

		// Because we traversed entire node, we can set largest node size that
		// will be used to cache next traversing..
		node->largestBlock = maxCont * node->density;

		node = node->next;
		}

		// If we are here, we failed to find existing memory block and we must
		// allocate new.
		{
		Cmp_uint_ptr chunkSize = _newChunkSize;
		if (chunkSize < vsize) chunkSize = vsize;

		node = createNode(chunkSize, _newChunkDensity);
		if (node == NULL) return NULL;

		// Update binary tree.
		insertNode(node);
		assert(checkTree());

		// Alloc first node at start.
		i = 0;
		need = (vsize + node->density - 1) / node->density;

		// Update statistics.
		_allocated += node->size;
		}

		found:
		// Update bits.
		_SetBits(node->baUsed, i, need);
		_SetBits(node->baCont, i, need - 1);

		// Update statistics.
		{
		Cmp_uint_ptr u = need * node->density;
		node->used += u;
		node->largestBlock = 0;
		_used += u;
		}

		// And return pointer to allocated memory.
		Cmp_unsigned__int8* result = node->mem + i * node->density;
		assert(result >= node->mem && result <= node->mem + node->size - vsize);
		return result;
	}

	//------------------------------------------------------------------------------
	bool MemoryManagerPrivate::free(void* address) __QCMP_THROW
	{
		if (address == NULL) return true;

		//AutoLock locked(_lock);

		MemNode* node = findPtr((Cmp_unsigned__int8*)address);
		if (node == NULL)
		return false;

		Cmp_uint_ptr offset = (Cmp_uint_ptr)((Cmp_unsigned__int8*)address - (Cmp_unsigned__int8*)node->mem);
		Cmp_uint_ptr bitpos = M_DIV(offset, node->density);
		Cmp_uint_ptr i = (bitpos / BITS_PER_ENTITY);

		Cmp_uint_ptr* up = node->baUsed + i;  // Current ubits address.
		Cmp_uint_ptr* cp = node->baCont + i;  // Current cbits address.
		Cmp_uint_ptr ubits = *up;             // Current ubits[0] value.
		Cmp_uint_ptr cbits = *cp;             // Current cbits[0] value.
		Cmp_uint_ptr bit = (Cmp_uint_ptr)1 << (bitpos % BITS_PER_ENTITY);

		Cmp_uint_ptr cont = 0;
		bool stop;

		for (;;)
		{
		stop = (cbits & bit) == 0;
		ubits &= ~bit;
		cbits &= ~bit;

		bit <<= 1;
		cont++;

		if (stop || bit == 0)
		{
		*up = ubits;
		*cp = cbits;
		if (stop) break;

		ubits = *++up;
		cbits = *++cp;
		bit = 1;
		}
		}

		// If the freed block is fully allocated node then it's needed to
		// update 'optimal' pointer in memory manager.
		if (node->used == node->size)
		{
		MemNode* cur = _optimal;

		do {
		cur = cur->prev;
		if (cur == node) { _optimal = node; break; }
		} while (cur);
		}

		// Statistics.
		cont *= node->density;
		if (node->largestBlock < cont) node->largestBlock = cont;
		node->used -= cont;
		_used -= cont;

		// If page is empty, we can free it.
		if (node->used == 0)
		{
		// Free memory associated with node (this memory is not accessed
		// anymore so it's safe).
		freeVirtualMemory(node->mem, node->size);
		::free/*ASMJIT_FREE*/(node->baUsed);

		node->baUsed = NULL;
		node->baCont = NULL;

		// Statistics.
		_allocated -= node->size;

		// Remove node. This function can return different node than
		// passed into, but data is copied into previous node if needed.
		::free/*ASMJIT_FREE*/(removeNode(node));
		assert(checkTree());
		}

		return true;
	}

	//------------------------------------------------------------------------------
	bool MemoryManagerPrivate::shrink(void* address, Cmp_uint_ptr used) __QCMP_THROW
	{
		if (address == 0) return false;
		if (used == 0) return free(address);

		//AutoLock locked(_lock);

		MemNode* node = findPtr((Cmp_unsigned__int8*)address);
		if (node == 0)
		return false;

		Cmp_uint_ptr offset = (Cmp_uint_ptr)((Cmp_unsigned__int8*)address - (Cmp_unsigned__int8*)node->mem);
		Cmp_uint_ptr bitpos = M_DIV(offset, node->density);
		Cmp_uint_ptr i = (bitpos / BITS_PER_ENTITY);

		Cmp_uint_ptr* up = node->baUsed + i;  // Current ubits address.
		Cmp_uint_ptr* cp = node->baCont + i;  // Current cbits address.
		Cmp_uint_ptr ubits = *up;             // Current ubits[0] value.
		Cmp_uint_ptr cbits = *cp;             // Current cbits[0] value.
		Cmp_uint_ptr bit = (Cmp_uint_ptr)1 << (bitpos % BITS_PER_ENTITY);

		Cmp_uint_ptr cont = 0;
		Cmp_uint_ptr usedBlocks = (used + node->density - 1) / node->density;

		bool stop;

		// Find the first block we can mark as free.
		for (;;)
		{
		stop = (cbits & bit) == 0;
		if (stop) return true;

		if (++cont == usedBlocks) break;

		bit <<= 1;
		if (bit == 0)
		{
		ubits = *++up;
		cbits = *++cp;
		bit = 1;
		}
		}

		// Free the tail blocks.
		cont = (Cmp_uint_ptr)-1;
		goto enterFreeLoop;

		for (;;)
		{
		stop = (cbits & bit) == 0;
		ubits &= ~bit;
		enterFreeLoop:
		cbits &= ~bit;

		bit <<= 1;
		cont++;

		if (stop || bit == 0)
		{
		*up = ubits;
		*cp = cbits;
		if (stop) break;

		ubits = *++up;
		cbits = *++cp;
		bit = 1;
		}
		}

		// Statistics.
		cont *= node->density;
		if (node->largestBlock < cont) node->largestBlock = cont;
		node->used -= cont;
		_used -= cont;

		return true;
	}

	//------------------------------------------------------------------------------
	void MemoryManagerPrivate::freeAll(bool keepVirtualMemory) __QCMP_THROW
	{
		MemNode* node = _first;

		while (node)
		{
			MemNode* next = node->next;

			if (!keepVirtualMemory) freeVirtualMemory(node->mem, node->size);
			::free/*ASMJIT_FREE*/(node->baUsed);
			::free/*ASMJIT_FREE*/(node);

			node = next;
		}

		_allocated = 0;
		_used = 0;

		_root = NULL;
		_first = NULL;
		_last = NULL;
		_optimal = NULL;
	}

	//------------------------------------------------------------------------------
	bool MemoryManagerPrivate::checkTree() __QCMP_THROW
	{
		return rbAssert( _root ) > 0;
	}

	//------------------------------------------------------------------------------
	void MemoryManagerPrivate::insertNode( MemNode* node ) __QCMP_THROW
	{
		if( _root == 0 )
		{
			// Empty tree case.
			_root = node;
		}
		else
		{
			// False tree root.
			RbNode<MemNode> head = {0};

			// Grandparent & parent.
			MemNode* g = 0;
			MemNode* t = reinterpret_cast<MemNode*>(&head);

			// Iterator & parent.
			MemNode* p = NULL;
			MemNode* q = t->node[1] = _root;

			int dir = 0;
			int last = 0;

			// Search down the tree.
			for (;;)
			{
				if (q == NULL)
				{
					// Insert new node at the bottom.
					q = node;
					p->node[dir] = node;
				}
				else if (isRed(q->node[0]) && isRed(q->node[1]))
				{
					// Color flip.
					q->red = 1;
					q->node[0]->red = 0;
					q->node[1]->red = 0;
				}

				// Fix red violation.
				if( isRed( q ) && isRed( p ) )
				{
					int dir2 = t->node[1] == g;
					t->node[dir2] = ( p && ( q == p->node[last] ) ) ? rbRotateSingle(g, !last) : rbRotateDouble(g, !last);
				}

				// Stop if found.
				if( q == node )
				{
					break;
				}

				last = dir;
				dir = q->mem < node->mem;

				// Update helpers.
				if( g != NULL )
				{
					t = g;
				}
				g = p;
				p = q;
				q = q->node[ dir ];
			}

			// Update root.
			_root = head.node[ 1 ];
		}

		// Make root black.
		_root->red = 0;

		// Link with others.
		node->prev = _last;

		if( _first == 0 )
		{
			_first = node;
			_last = node;
			_optimal = node;
		}
		else
		{
			node->prev = _last;
			_last->next = node;
			_last = node;
		}
	}

	//------------------------------------------------------------------------------
	MemNode* MemoryManagerPrivate::removeNode(MemNode* node) __QCMP_THROW
	{
		// False tree root.
		RbNode<MemNode> head = {0};

		// Helpers.
		MemNode* q = reinterpret_cast<MemNode*>(&head);
		MemNode* p = 0;
		MemNode* g = 0;
		// Found item.
		MemNode* f = 0;
		int dir = 1;

		// Set up.
		q->node[ 1 ] = _root;

		// Search and push a red down.
		while( q->node[ dir ] != 0 )
		{
			int last = dir;

			// Update helpers.
			g = p;
			p = q;
			q = q->node[ dir ];
			dir = q->mem < node->mem;

			// Save found node.
			if( q == node )
			{
				f = q;
			}

			// Push the red node down.
			if( !isRed( q ) && !isRed( q->node[ dir ] ) )
			{
				if( isRed( q->node[ !dir ] ) )
				{
					p = p->node[ last ] = rbRotateSingle( q, dir );
				}
				else if( !isRed( q->node[ !dir ] ) )
				{
					MemNode* s = p->node[ !last ];

					if( s != 0 )
					{
						if( !isRed( s->node[ !last ] ) && !isRed( s->node[ last ] ) )
						{
							// Color flip.
							p->red = 0;
							s->red = 1;
							q->red = 1;
						}
						else
						{
							int dir2 = g->node[ 1 ] == p;

							if( isRed( s->node[ last ] ) )
							{
								g->node[ dir2 ] = rbRotateDouble( p, last );
							}
							else if( isRed( s->node[ !last ] ) )
							{
								g->node[ dir2 ] = rbRotateSingle( p, last );
							}

							// Ensure correct coloring.
							q->red = g->node[ dir2 ]->red = 1;
							g->node[ dir2 ]->node[ 0 ]->red = 0;
							g->node[ dir2 ]->node[ 1 ]->red = 0;
						}
					}
				}
			}
		}

		// Replace and remove.
		assert( f != 0 );
		assert( f != reinterpret_cast< MemNode* >( &head ) );
		assert( q != reinterpret_cast< MemNode* >( &head ) );

		if( f != q )
		{
			f->fillData(q);
		}

		if (p)
		{
			p->node[p->node[1] == q] = q->node[q->node[0] == 0];
		}

		// Update root and make it black.
		if( ( _root = head.node[ 1 ] ) != 0 )
		{
			_root->red = 0;
		}

		// Unlink.
		MemNode* next = q->next;
		MemNode* prev = q->prev;

		if( prev )
		{
			prev->next = next;
		}
		else
		{
			_first = next;
		}

		if( next )
		{
			next->prev = prev;
		}
		else
		{
			_last  = prev;
		}

		if( _optimal == q )
		{
			_optimal = prev ? prev : next;
		}

		return q;
	}

	//------------------------------------------------------------------------------
	MemNode* MemoryManagerPrivate::findPtr( Cmp_unsigned__int8* mem ) __QCMP_THROW
	{
		MemNode* cur = _root;
		while( cur )
		{
			Cmp_unsigned__int8* curMem = cur->mem;
			if( mem < curMem )
			{
				// Go left.
				cur = cur->node[0];
				continue;
			}
			else
			{
				Cmp_unsigned__int8* curEnd = curMem + cur->size;
				if( mem >= curEnd )
				{
					// Go right.
					cur = cur->node[ 1 ];
					continue;
				}
				else
				{
					// Match.
					break;
				}
			}
		}
		return cur;
	}

}//nsArch

