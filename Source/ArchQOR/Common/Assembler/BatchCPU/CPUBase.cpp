//CPUBase.cpp

// Copyright (c) 2008-2010, Petr Kobalicek <kobalicek.petr@gmail.com>
// Copyright (c) Querysoft Limited 2012, 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Implements base virtual CPU

#include "ArchQOR.h"
#include "ArchQOR/Common/Assembler/BatchCPU/CPUBase.h"
#include <string.h>
#include <stdio.h>
#include "CodeQOR/Tracing/FunctionContextBase.h"

//------------------------------------------------------------------------------
namespace nsArch
{
	//------------------------------------------------------------------------------
	__QOR_IMPLEMENT_OCLASS_LUID(CCPUBase);

	//------------------------------------------------------------------------------
	CCPUBase::CCPUBase( CCodeGeneratorBase* pCodeGenerator ) : m_pCodeGenerator( pCodeGenerator != 0 ? pCodeGenerator : CCodeGeneratorBase::getGlobal() )
	, m_Zone( 16384 - sizeof( CZone::Chunk ) - 32 )
	, m_pLogger( 0 )
	, m_uiError( 0 )
	, m_szComment( 0 )
	, m_Buffer( 32 ) // Max instruction length is 15, but we can align up to 32 bytes.
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::CCPUBase");
	}

	//------------------------------------------------------------------------------
	CCPUBase::~CCPUBase()
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::~CCPUBase");
	}

	//------------------------------------------------------------------------------
	//Get code generator.
	inline CCodeGeneratorBase* CCPUBase::getCodeGenerator() const __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::getCodeGenerator");
		return m_pCodeGenerator;
	}

	//------------------------------------------------------------------------------
	//Get zone memory manager.
	inline CZone& CCPUBase::getZone() __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::getZone");
		return m_Zone;
	}

	//------------------------------------------------------------------------------
	//Get logger.
	inline CLogger* CCPUBase::getLogger() const __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::getLogger");
		return m_pLogger;
	}

	//------------------------------------------------------------------------------
	inline void CCPUBase::setLogger(CLogger* pLogger) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::setLogger");
		m_pLogger = pLogger;
	}

	//------------------------------------------------------------------------------
	//Get error code.
	inline Cmp_unsigned__int32 CCPUBase::getError() const __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::getError");
		return m_uiError;
	}
				
	//------------------------------------------------------------------------------
	bool CCPUBase::canEmit() __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::canEmit");
		// If there is an error, we can't emit another instruction until last error
		// is cleared by calling setError( ERROR_NONE ). If something caused an error
		// while generating code it's probably fatal in all cases. You can't use 
		// generated code, because you are not sure about its status.
		if( m_uiError )
		{
			return false;
		}

		// The ensureSpace() method returns true on success and false on failure. We are catching return value and setting error code here.
		if( ensureSpace() )
		{
			return true;
		}

		// If we are here, there is memory allocation error. Note that this is HEAP allocation error, virtual allocation error can be caused only by VirtualMemory class!
		setError( ERROR_NO_HEAP_MEMORY );
		return false;
	}

	//------------------------------------------------------------------------------
	void CCPUBase::embed( const void* data, Cmp_uint_ptr size ) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::embed");
		if( !canEmit() )
		{
			return;
		}

		if( m_pLogger )
		{
			Cmp_uint_ptr i, j;
			Cmp_uint_ptr max;
			char buf[ 128 ];
			char dot[] = ".data ";
			char* p;

			memcpy( buf, dot, __QCS_ARRAY_SIZE( dot ) - 1 );

			for( i = 0; i < size; i += 16 )
			{
				max = ( size - i < 16 ) ? size - i : 16;
				p = buf + __QCS_ARRAY_SIZE( dot ) - 1;

				for( j = 0; j < max; j++ )
				{
					p += sprintf( p, "%0.2X", reinterpret_cast< const Cmp_unsigned__int8* >( data )[ i + j ] );
				}

				*p++ = '\n';
				*p = '\0';

				m_pLogger->logString( buf );
			}
		}

		m_Buffer.emitData( data, size );
	}

	//------------------------------------------------------------------------------
	void CCPUBase::setError( Cmp_unsigned__int32 error ) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::setError");
		m_uiError = error;
		if( m_uiError == ERROR_NONE )
		{
			return;
		}

		if( m_pLogger )
		{
			m_pLogger->logFormat( "*** ASSEMBLER ERROR: %s (%u).\n", getErrorCodeAsString( error ), (unsigned int)error );
		}
	}

	//------------------------------------------------------------------------------
	const char* CCPUBase::getErrorCodeAsString( Cmp_unsigned__int32 error ) __QCMP_THROW
	{
		__QCS_FCONTEXT("CCPUBase::getErrorCodeAsString");

		static const char* errorMessage[] = 
		{
			"No error",
			"No heap memory",
			"No virtual memory",
			"Unknown instruction",
			"Illegal instruction",
			"Illegal addressing",
			"Illegal short jump",
			"No function defined",
			"Incomplete function",
			"Not enough registers",
			"Registers overlap",
			"Incompatible argument",
			"Incompatible return value",
			"Unknown error"
		};

		// Saturate error code to be able to use errorMessage[].
		if( error > _ERROR_COUNT )
		{
			error = _ERROR_COUNT;
		}

		return errorMessage[ error ];
	}

	//------------------------------------------------------------------------------
	inline void CCPUBase::SetComment(const char* szComment) __QCMP_THROW 
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::SetComment");
		m_szComment = szComment;
	}

	//Buffer Getters / Setters

	//------------------------------------------------------------------------------
	//Return start of assembler code buffer.
	// Note that buffer address can change if you emit instruction or something
	// else. Use this pointer only when you finished or make sure you do not
	// use returned pointer after emitting.
	inline Cmp_unsigned__int8* CCPUBase::getCode() const __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::getCode");
		return m_Buffer.getData();
	}

	//------------------------------------------------------------------------------
	//Ensure space for next instruction.
	//Note that this method can return false. It's rare and probably you never
	//get this, but in some situations it's still possible.
	inline bool CCPUBase::ensureSpace() __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::ensureSpace");
		return m_Buffer.ensureSpace();
	}

	//------------------------------------------------------------------------------
	//Return current offset in buffer
	inline Cmp_int_ptr CCPUBase::getOffset() const __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::getOffset");
		return m_Buffer.getOffset();
	}

	//------------------------------------------------------------------------------
	//Set offset to o and returns previous offset.
	//This method can be used to truncate code (previous offset is not
	//recorded) or to overwrite instruction stream at position o.
	//Previous offset value that can be uset to set offset back later.
	inline Cmp_int_ptr CCPUBase::toOffset(Cmp_int_ptr o) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::toOffset");
		return m_Buffer.toOffset(o);
	}

	//------------------------------------------------------------------------------
	//Get capacity of internal code buffer.
	inline Cmp_int_ptr CCPUBase::getCapacity() const __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::getCapacity");
		return m_Buffer.getCapacity();
	}

	//Stream Setters / Getters

	//------------------------------------------------------------------------------
	//Set byte at position pos.
	inline Cmp_unsigned__int8 CCPUBase::getByteAt(Cmp_int_ptr pos) const __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::getByteAt");
		return m_Buffer.getByteAt(pos);
	}

	//------------------------------------------------------------------------------
	//Set word at position pos.
	inline Cmp_unsigned__int16 CCPUBase::getWordAt(Cmp_int_ptr pos) const __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::getWordAt");
		return m_Buffer.getWordAt(pos);
	}

	//------------------------------------------------------------------------------
	//Set word at position pos.
	inline Cmp_unsigned__int32 CCPUBase::getDWordAt(Cmp_int_ptr pos) const __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::getDWordAt");
		return m_Buffer.getDWordAt(pos);
	}

	//------------------------------------------------------------------------------
	//Set word at position pos.
	inline Cmp_unsigned__int64 CCPUBase::getQWordAt(Cmp_int_ptr pos) const __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::getQWordAt");
		return m_Buffer.getQWordAt(pos);
	}

	//------------------------------------------------------------------------------
	//Set byte at position pos.
	inline void CCPUBase::setByteAt(Cmp_int_ptr pos, Cmp_unsigned__int8 x) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::setByteAt");
		m_Buffer.setByteAt(pos, x);
	}

	//------------------------------------------------------------------------------
	//Set word at position pos.
	inline void CCPUBase::setWordAt(Cmp_int_ptr pos, Cmp_unsigned__int16 x) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::setWordAt");
		m_Buffer.setWordAt(pos, x);
	}

	//------------------------------------------------------------------------------
	//Set word at position pos.
	inline void CCPUBase::setDWordAt(Cmp_int_ptr pos, Cmp_unsigned__int32 x) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::setDWordAt");
		m_Buffer.setDWordAt(pos, x);
	}

	//------------------------------------------------------------------------------
	//Set word at position pos.
	inline void CCPUBase::setQWordAt(Cmp_int_ptr pos, Cmp_unsigned__int64 x) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::setQWordAt");
		m_Buffer.setQWordAt(pos, x);
	}

	//------------------------------------------------------------------------------
	//Set word at position pos.
	inline Cmp__int32 CCPUBase::getInt32At(Cmp_int_ptr pos) const __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::getInt32At");
		return (Cmp__int32)m_Buffer.getDWordAt(pos);
	}

	//------------------------------------------------------------------------------
	//Set int32 at position pos.
	inline void CCPUBase::setInt32At(Cmp_int_ptr pos, Cmp__int32 x) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::setInt32At");
		m_Buffer.setDWordAt(pos, (Cmp_unsigned__int32)x);
	}

	//------------------------------------------------------------------------------
	inline void CCPUBase::_emitByte(Cmp_unsigned__int8 x) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::_emitByte");
		m_Buffer.emitByte(x);
	}

	//------------------------------------------------------------------------------
	//Emit Word (2 bytes) to internal buffer.
	inline void CCPUBase::_emitWord(Cmp_unsigned__int16 x) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::_emitWord");
		m_Buffer.emitWord(x);
	}

	//------------------------------------------------------------------------------
	//Emit DWord (4 bytes) to internal buffer.
	inline void CCPUBase::_emitDWord(Cmp_unsigned__int32 x) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::_emitDWord");
		m_Buffer.emitDWord(x);
	}

	//------------------------------------------------------------------------------
	//Emit QWord (8 bytes) to internal buffer.
	inline void CCPUBase::_emitQWord(Cmp_unsigned__int64 x) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::_emitQWord");
		m_Buffer.emitQWord(x);
	}

	//------------------------------------------------------------------------------
	//Emit Int32 (4 bytes) to internal buffer.
	inline void CCPUBase::_emitInt32(Cmp__int32 x) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::_emitInt32");
		m_Buffer.emitDWord((Cmp_unsigned__int32)x);
	}

	//------------------------------------------------------------------------------
	//system signed integer (4 or 8 bytes) to internal buffer.
	inline void CCPUBase::_emitSysInt(Cmp_int_ptr x) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::_emitSysInt");
		m_Buffer.emitSysInt(x);
	}

	//------------------------------------------------------------------------------
	//Emit system unsigned integer (4 or 8 bytes) to internal buffer.
	inline void CCPUBase::_emitSysUInt(Cmp_uint_ptr x) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CCPUBase::_emitSysUInt");
		m_Buffer.emitSysUInt(x);
	}
}//nsArch
