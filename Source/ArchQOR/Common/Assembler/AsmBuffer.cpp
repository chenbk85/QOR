//AsmBuffer.cpp

// Copyright Querysoft Limited 2013, 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//A specialist buffer for the JIT Assembler

#include "SystemQOR.h"
#include "ArchQOR/Common/Assembler/AsmBuffer.h"
#include <string.h>
#include <assert.h>
#include <stdlib.h>
#include "CodeQOR/Tracing/FunctionContextBase.h"

//--------------------------------------------------------------------------------
namespace nsArch
{
	//--------------------------------------------------------------------------------
	__QOR_IMPLEMENT_OCLASS_LUID(CAsmBuffer);

	//--------------------------------------------------------------------------------
	CAsmBuffer::CAsmBuffer( Cmp_int_ptr growThreshold ) __QCMP_THROW :
		m_pData( 0 ),
		m_pCur( 0 ),
		m_pMax( 0 ),
		m_iCapacity( 0 ),
		m_iGrowThreshold( growThreshold )
	{
			__QCS_MEMBER_FCONTEXT("CAsmBuffer::CAsmBuffer");
	}

	//--------------------------------------------------------------------------------
	CAsmBuffer::~CAsmBuffer() __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::~CAsmBuffer");
		if( m_pData )
		{
			::free( m_pData );
		}
	}

	//--------------------------------------------------------------------------------
	CAsmBuffer::CAsmBuffer( const CAsmBuffer& src ) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::CAsmBuffer");
		m_iGrowThreshold = src.m_iGrowThreshold;

		m_iCapacity = src.getCapacity();
		m_pData = reinterpret_cast< Cmp_unsigned__int8* >( ::malloc( m_iCapacity ) );
		
		Cmp_int_ptr iSize = src.getOffset();
		memcpy( m_pData, src.m_pData, iSize );
		m_pCur = m_pData + iSize;
		m_pMax = m_pData + ( src.m_pMax - src.m_pData );		
	}

	//--------------------------------------------------------------------------------
	CAsmBuffer& CAsmBuffer::operator = ( const CAsmBuffer& src ) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::operator =");
		free();

		m_iGrowThreshold = src.m_iGrowThreshold;

		m_iCapacity = src.getCapacity();
		m_pData = reinterpret_cast< Cmp_unsigned__int8* >( ::malloc( m_iCapacity ) );
		
		Cmp_int_ptr iSize = src.getOffset();
		memcpy( m_pData, src.m_pData, iSize );
		m_pCur = m_pData + iSize;
		m_pMax = m_pData + ( src.m_pMax - src.m_pData );
		return *this;
	}

	//--------------------------------------------------------------------------------
	//Sets offset to o and returns previous offset.
	// This method can be used to truncate buffer or it's used to
	// overwrite specific position in buffer by Assembler.
	Cmp_int_ptr CAsmBuffer::toOffset( Cmp_int_ptr o ) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::toOffset");
		assert( o < m_iCapacity );
		Cmp_int_ptr prev = static_cast< Cmp_int_ptr >( m_pCur - m_pData );
		m_pCur = m_pData + o;
		return prev;
	}

	//--------------------------------------------------------------------------------
	void CAsmBuffer::emitData( const void* dataPtr, Cmp_uint_ptr dataLen ) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::emitData");
		Cmp_int_ptr max = getCapacity() - getOffset();
		if( static_cast< Cmp_uint_ptr >( max ) < dataLen )
		{
			if( !realloc( getOffset() + dataLen ) )
			{
				return;
			}
		}

		memcpy( m_pCur, dataPtr, dataLen );
		m_pCur += dataLen;
	}

	//--------------------------------------------------------------------------------
	bool CAsmBuffer::realloc( Cmp_int_ptr to ) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::realloc");
		if( getCapacity() < to )
		{
			Cmp_int_ptr len = getOffset();

			Cmp_unsigned__int8* newdata;
			if( m_pData )
			{
				newdata = reinterpret_cast< Cmp_unsigned__int8* >( ::realloc( m_pData, to ) );
			}
			else
			{
				newdata = reinterpret_cast< Cmp_unsigned__int8* >( ::malloc( to ) );
			}

			if( !newdata )
			{
				return false;
			}

			m_pData = newdata;
			m_pCur = newdata + len;
			m_pMax = newdata + to;
			m_pMax -= ( to >= m_iGrowThreshold ) ? m_iGrowThreshold : to;

			m_iCapacity = to;
		}

		return true;
	}

	//--------------------------------------------------------------------------------
	bool CAsmBuffer::grow() __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::grow");
		Cmp_int_ptr to = m_iCapacity;

		if( to < 512 )
		{
			to = 1024;
		}
		else if( to > 65536 )
		{
			to += 65536;
		}
		else
		{
			to <<= 1;
		}

		return realloc( to );
	}

	//--------------------------------------------------------------------------------
	void CAsmBuffer::clear() __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::clear");
		m_pCur = m_pData;
	}

	//--------------------------------------------------------------------------------
	void CAsmBuffer::free() __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::free");
		if( !m_pData )
		{
			return;
		}

		::free( m_pData );

		m_pData = 0;
		m_pCur = 0;
		m_pMax = 0;
		m_iCapacity = 0;
	}

	//--------------------------------------------------------------------------------
	Cmp_unsigned__int8* CAsmBuffer::take() __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::take");
		Cmp_unsigned__int8* data = m_pData;

		m_pData = 0;
		m_pCur = 0;
		m_pMax = 0;
		m_iCapacity = 0;

		return data;
	}

	//--------------------------------------------------------------------------------
	//Get start of buffer.
	inline Cmp_unsigned__int8* CAsmBuffer::getData() const __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::getData");
		return m_pData;
	}

	//--------------------------------------------------------------------------------
	//Get current pointer in code buffer.
	inline Cmp_unsigned__int8* CAsmBuffer::getCur() const __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::getVur");
		return m_pCur;
	}

	//--------------------------------------------------------------------------------
	//Get maximum pointer in code buffer for growing.
	inline Cmp_unsigned__int8* CAsmBuffer::getMax() const __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::getMax");
		return m_pMax;
	}

	//--------------------------------------------------------------------------------
	//Get current offset in buffer.
	inline Cmp_int_ptr CAsmBuffer::getOffset() const __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::getOffset");
		return (Cmp_int_ptr)(m_pCur - m_pData);
	}

	//--------------------------------------------------------------------------------
	//Get capacity of buffer.
	inline Cmp_int_ptr CAsmBuffer::getCapacity() const __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::getCapacity");
		return m_iCapacity;
	}

	//--------------------------------------------------------------------------------
	//Get grow threshold.
	inline Cmp_int_ptr CAsmBuffer::getGrowThreshold() const __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::getGrowThreshold");
		return m_iGrowThreshold;
	}

	//--------------------------------------------------------------------------------
	//Ensure space for next instruction
	inline bool CAsmBuffer::ensureSpace() __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::ensureSpace");
		return (m_pCur >= m_pMax) ? grow() : true;
	}

	//--------------------------------------------------------------------------------
	//Emit Byte.
	inline void CAsmBuffer::emitByte(Cmp_unsigned__int8 x) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::emitByte");
		*m_pCur++ = x;
	}

	//--------------------------------------------------------------------------------
	//Emit Word (2 bytes).
	inline void CAsmBuffer::emitWord(Cmp_unsigned__int16 x) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::emitWord");
		*(Cmp_unsigned__int16 *)m_pCur = x;
		m_pCur += 2;
	}

	//--------------------------------------------------------------------------------
	//Emit DWord (4 bytes).
	inline void CAsmBuffer::emitDWord(Cmp_unsigned__int32 x) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::emitDWord");
		*(Cmp_unsigned__int32 *)m_pCur = x;
		m_pCur += 4;
	}

	//--------------------------------------------------------------------------------
	//Emit QWord (8 bytes).
	inline void CAsmBuffer::emitQWord(Cmp_unsigned__int64 x) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::emitQWord");
		*(Cmp_unsigned__int64 *)m_pCur = x;
		m_pCur += 8;
	}

	//--------------------------------------------------------------------------------
	//Emit system signed integer (4 or 8 bytes).
	inline void CAsmBuffer::emitSysInt(Cmp_int_ptr x) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::emitSysInt");
		*(Cmp_int_ptr *)m_pCur = x;
		m_pCur += sizeof(Cmp_int_ptr);
	}

	//--------------------------------------------------------------------------------
	//Emit system unsigned integer (4 or 8 bytes).
	inline void CAsmBuffer::emitSysUInt(Cmp_uint_ptr x) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::emitSysUInt");
		*(Cmp_uint_ptr *)m_pCur = x;
		m_pCur += sizeof(Cmp_uint_ptr);
	}

	//--------------------------------------------------------------------------------
	//Set byte at position pos.
	inline Cmp_unsigned__int8 CAsmBuffer::getByteAt(Cmp_int_ptr pos) const __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::getByteAt");
		return *reinterpret_cast< const Cmp_unsigned__int8* >(m_pData + pos);
	}

	//--------------------------------------------------------------------------------
	//Set word at position pos.
	inline Cmp_unsigned__int16 CAsmBuffer::getWordAt(Cmp_int_ptr pos) const __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::getWordAt");
		return *reinterpret_cast< const Cmp_unsigned__int16* >(m_pData + pos);
	}

	//--------------------------------------------------------------------------------
	//Set word at position pos.
	inline Cmp_unsigned__int32 CAsmBuffer::getDWordAt(Cmp_int_ptr pos) const __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::getDWordAt");
		return *reinterpret_cast< const Cmp_unsigned__int32* >(m_pData + pos);
	}

	//--------------------------------------------------------------------------------
	//Set word at position pos.
	inline Cmp_unsigned__int64 CAsmBuffer::getQWordAt(Cmp_int_ptr pos) const __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::getQWordAt");
		return *reinterpret_cast< const Cmp_unsigned__int64* >(m_pData + pos);
	}

	//--------------------------------------------------------------------------------
	//Set byte at position pos.
	inline void CAsmBuffer::setByteAt(Cmp_int_ptr pos, Cmp_unsigned__int8 x) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::setByteAt");
		*reinterpret_cast< Cmp_unsigned__int8* >(m_pData + pos) = x;
	}

	//--------------------------------------------------------------------------------
	//Set word at position pos.
	inline void CAsmBuffer::setWordAt(Cmp_int_ptr pos, Cmp_unsigned__int16 x) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::setWordAt");
		*reinterpret_cast< Cmp_unsigned__int16* >(m_pData + pos) = x;
	}

	//--------------------------------------------------------------------------------
	//Set word at position pos.
	inline void CAsmBuffer::setDWordAt(Cmp_int_ptr pos, Cmp_unsigned__int32 x) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::getDWordAt");
		*reinterpret_cast< Cmp_unsigned__int32* >(m_pData + pos) = x;
	}

	//--------------------------------------------------------------------------------
	//Set word at position pos.
	inline void CAsmBuffer::setQWordAt(Cmp_int_ptr pos, Cmp_unsigned__int64 x) __QCMP_THROW
	{
		__QCS_MEMBER_FCONTEXT("CAsmBuffer::setQWordAt");
		*reinterpret_cast< Cmp_unsigned__int64* >(m_pData + pos) = x;
	}

}//nsArch

