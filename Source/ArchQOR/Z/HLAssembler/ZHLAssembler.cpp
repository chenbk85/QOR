//ZHLAssembler.cpp

// Copyright (c) 2008-2010, Petr Kobalicek <kobalicek.petr@gmail.com>
// Copyright (c) Querysoft Limited 2012, 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "ArchQOR.h"

#if		( QOR_ARCH == QOR_ARCH_Z )

#include "ArchQOR/Common/HLAssembler/Emittables/EComment.h"
#include "ArchQOR/Common/HLAssembler/Emittables/EData.h"
#include "ArchQOR/Common/HLAssembler/Emittables/EAlign.h"
#include "ArchQOR/Zarch/HLAssembler/ZHLAssembler.h"
#include "ArchQOR/Zarch/HLAssembler/Emittables/Z_EFunction.h"
#include "ArchQOR/Zarch/HLAssembler/Emittables/Z_EVariableHint.h"
#include "ArchQOR/Zarch/HLAssembler/Emittables/Z_ECall.h"
#include "ArchQOR/Zarch/HLAssembler/Emittables/Z_ERet.h"
#include "ArchQOR/Zarch/HLAssembler/Z_HLAssembler.h"
#include "ArchQOR/Zarch/HLAssembler/ZHLAContext.h"

#include <new>
#include <assert.h>
#include <stdarg.h>
#include <stdio.h>

//------------------------------------------------------------------------------
namespace nsArch
{
	//------------------------------------------------------------------------------
	namespace nsZ
	{
		//------------------------------------------------------------------------------
		static void delAll( nsArch::CEmittable* first ) __QCMP_THROW
		{
			nsArch::CEmittable* cur = first;

			while( cur )
			{
				nsArch::CEmittable* next = cur->getNext();
				cur->~CEmittable();
				cur = next;
			}
		}

		//------------------------------------------------------------------------------
		CZHLAssembler::CZHLAssembler( nsArch::CCodeGeneratorBase* codeGenerator ) __QCMP_THROW : nsArch::CHighLevelAssemblerBase( codeGenerator ),
		m_uiError( 0 ),
		m_uiProperties( ( 1 << PROPERTY_OPTIMIZE_ALIGN ) ),
		m_uiEmitOptions( 0 ),
		m_uiFinished( false ),
		m_pFunction( 0 ),
		m_iVarNameId( 0 ),
		m_pContext( 0 ),
		m_CPU( codeGenerator )
		{
		}

		//------------------------------------------------------------------------------
		CZHLAssembler::~CZHLAssembler() __QCMP_THROW
		{
			free();
		}

		//------------------------------------------------------------------------------
		void CZHLAssembler::setLogger( CLogger* logger ) __QCMP_THROW
		{
			m_pLogger = logger;
		}

		//------------------------------------------------------------------------------
		void CZHLAssembler::setError( Cmp_unsigned__int32 error ) __QCMP_THROW
		{
			m_uiError = error;
			if( m_uiError == ERROR_NONE )
			{
				return;
			}

			if( m_pLogger )
			{
				m_pLogger->logFormat( "*** COMPILER ERROR: %s (%u).\n", CCPUBase::getErrorCodeAsString( error ), (unsigned int)error );
			}
		}

		//------------------------------------------------------------------------------
		Cmp_unsigned__int32 CZHLAssembler::getProperty( Cmp_unsigned__int32 propertyId )
		{
			return ( m_uiProperties & ( 1 << propertyId ) ) != 0;
		}

		//------------------------------------------------------------------------------
		void CZHLAssembler::setProperty( Cmp_unsigned__int32 propertyId, Cmp_unsigned__int32 value )
		{
			if( value )
			{
				m_uiProperties |= ( 1 << propertyId );
			}
			else
			{
				m_uiProperties &= ~( 1 << propertyId );
			}
		}

		//------------------------------------------------------------------------------
		void CZHLAssembler::clear() __QCMP_THROW
		{
			m_uiFinished = false;

			delAll( m_pFirst );
			m_pFirst = 0;
			m_pLast = 0;
			m_pCurrent = 0;

			m_Zone.freeAll();
			m_TargetData.clear();
			m_VarData.clear();

			m_pContext = 0;

			if( m_uiError )
			{
				setError( ERROR_NONE );
			}
			m_CPU.clear();
		}

		//------------------------------------------------------------------------------
		void CZHLAssembler::free() __QCMP_THROW
		{
			clear();

			m_TargetData.free();
			m_VarData.free();
		}

		//------------------------------------------------------------------------------
		void CZHLAssembler::comment( const char* fmt, ... ) __QCMP_THROW
		{
			char buf[ 128 ];
			char* p = buf;

			if( fmt )
			{
				*p++ = ';';
				*p++ = ' ';

				va_list ap;
				va_start( ap, fmt );
				p += vsnprintf( p, 100, fmt, ap );
				va_end(ap);
			}

			*p++ = '\n';
			*p   = '\0';

			addEmittable( dynamic_cast< nsArch::CEmittable* >( HLA_newObject< nsArch::CEComment >( this, buf ) ) );
		}

		//------------------------------------------------------------------------------
		void CZHLAssembler::_emitInstruction( Cmp_unsigned__int32 code ) __QCMP_THROW
		{
		}

		//------------------------------------------------------------------------------
		void CZHLAssembler::_emitInstruction( Cmp_unsigned__int32 code, const COperand* o0 ) __QCMP_THROW
		{
		}

		//------------------------------------------------------------------------------
		void CZHLAssembler::_emitInstruction( Cmp_unsigned__int32 code, const COperand* o0, const COperand* o1 ) __QCMP_THROW
		{
		}

		//------------------------------------------------------------------------------
		void CZHLAssembler::_emitInstruction( Cmp_unsigned__int32 code, const COperand* o0, const COperand* o1, const COperand* o2 ) __QCMP_THROW
		{
		}

		//------------------------------------------------------------------------------
		void CZHLAssembler::_emitInstruction( Cmp_unsigned__int32 code, const COperand* o0, const COperand* o1, const COperand* o2, const COperand* o3 ) __QCMP_THROW
		{
		}

		//------------------------------------------------------------------------------
		void CZHLAssembler::_emitInstruction( Cmp_unsigned__int32 code, const COperand* o0, const COperand* o1, const COperand* o2, const COperand* o3, const COperand* o4 ) __QCMP_THROW
		{
		}

		//------------------------------------------------------------------------------
		void CZHLAssembler::_emitJcc( Cmp_unsigned__int32 code, const CLabel* label, Cmp_unsigned__int32 hint ) __QCMP_THROW
		{
		}

		//------------------------------------------------------------------------------
		CECall* CZHLAssembler::_emitCall( const COperand* o0 ) __QCMP_THROW
		{
			CEFunction* fn = getFunction();
			if( !fn ) 
			{ 
				setError( ERROR_NO_FUNCTION ); 
				return 0; 
			}

			CECall* eCall = HLA_newObject< CECall >( this, fn, o0 );
			if( !eCall ) 
			{ 
				setError( ERROR_NO_HEAP_MEMORY ); 
				return 0; 
			}

			addEmittable( dynamic_cast< nsArch::CEmittable* >( eCall ) );
			return eCall;
		}

		//------------------------------------------------------------------------------
		void CZHLAssembler::_emitReturn( const COperand* first, const COperand* second ) __QCMP_THROW
		{
			CEFunction* fn = getFunction();
			if( !fn ) 
			{ 
				setError( ERROR_NO_FUNCTION ); 
				return; 
			}

			CERet* eRet = HLA_newObject< CERet >( this, fn, first, second );
			if( !eRet ) 
			{ 
				setError( ERROR_NO_HEAP_MEMORY ); 
				return; 
			}

			addEmittable( eRet );
		}

		//--------------------------------------------------------------------------
		CEInstruction* CZHLAssembler::newInstruction( Cmp_unsigned__int32 code, COperand** paOperandsData, Cmp_unsigned__int32 operandsCount ) __QCMP_THROW
		{
			return 0;
		}

		//--------------------------------------------------------------------------
		CEFunction* CZHLAssembler::newFunction_( Cmp_unsigned__int32 callingConvention, const Cmp_unsigned__int32* arguments, Cmp_unsigned__int32 argumentsCount, Cmp_unsigned__int32 returnValue ) __QCMP_THROW
		{
			return 0;
		}

		//--------------------------------------------------------------------------
		CEFunction* CZHLAssembler::endFunction() __QCMP_THROW
		{
			return 0;
		}

		//--------------------------------------------------------------------------
		void CZHLAssembler::embed( const void* data, Cmp_uint_ptr size ) __QCMP_THROW
		{
			// Align length to 16 bytes.
			Cmp_uint_ptr alignedSize = ( size + 15 ) & ~15;

			nsArch::CEData* e = new( m_Zone.zalloc( sizeof(nsArch::CEData) - sizeof(void*) + alignedSize ) ) nsArch::CEData( this, data, size );
			addEmittable( e );
		}


		//--------------------------------------------------------------------------
		void CZHLAssembler::bind( const CLabel& label ) __QCMP_THROW
		{
		}

		//--------------------------------------------------------------------------
		VarData* CZHLAssembler::_newVarData(const char* name, Cmp_unsigned__int32 type, Cmp_unsigned__int32 size) __QCMP_THROW
		{
			return 0;
		}


		//--------------------------------------------------------------------------------
		void* CZHLAssembler::make() __QCMP_THROW
		{
			return 0;
		}

		//--------------------------------------------------------------------------------
		void CZHLAssembler::serialize() __QCMP_THROW
		{
		}

	}//nsZ
}//nsArch

#endif//( QOR_ARCH == QOR_ARCH_Z )
