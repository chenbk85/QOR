//CPUInfo.cpp

// Copyright (c) 2008-2010, Petr Kobalicek <kobalicek.petr@gmail.com>
// Copyright (c) Querysoft Limited 2012, 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "ArchQOR.h"

#if		( QOR_ARCH == QOR_ARCH_X86_32 || QOR_ARCH == QOR_ARCH_X86_64 )

#include "ArchQOR/x86/CPUInfo.h"
#include <string.h>

//------------------------------------------------------------------------------
namespace nsArch
{
	//------------------------------------------------------------------------------
	namespace nsx86
	{
	//------------------------------------------------------------------------------
	static const CpuInfoStatic::CpuVendorInfo cpuVendorInfo[] =
	{
		{ CpuInfo::CPU_Vendor_INTEL    , { 'G', 'e', 'n', 'u', 'i', 'n', 'e', 'I', 'n', 't', 'e', 'l' } },

		{ CpuInfo::CPU_Vendor_AMD      , { 'A', 'u', 't', 'h', 'e', 'n', 't', 'i', 'c', 'A', 'M', 'D' } },
		{ CpuInfo::CPU_Vendor_AMD      , { 'A', 'M', 'D', 'i', 's', 'b', 'e', 't', 't', 'e', 'r', '!' } },

		{ CpuInfo::CPU_Vendor_NSM      , { 'G', 'e', 'o', 'd', 'e', ' ', 'b', 'y', ' ', 'N', 'S', 'C' } },
		{ CpuInfo::CPU_Vendor_NSM      , { 'C', 'y', 'r', 'i', 'x', 'I', 'n', 's', 't', 'e', 'a', 'd' } },

		{ CpuInfo::CPU_Vendor_TRANSMETA, { 'G', 'e', 'n', 'u', 'i', 'n', 'e', 'T', 'M', 'x', '8', '6' } },
		{ CpuInfo::CPU_Vendor_TRANSMETA, { 'T', 'r', 'a', 'n', 's', 'm', 'e', 't', 'a', 'C', 'P', 'U' } },

		{ CpuInfo::CPU_Vendor_VIA      , { 'V', 'I', 'A',  0 , 'V', 'I', 'A',  0 , 'V', 'I', 'A',  0  } },
		{ CpuInfo::CPU_Vendor_VIA      , { 'C', 'e', 'n', 't', 'a', 'u', 'r', 'H', 'a', 'u', 'l', 's' } }
	};

	//------------------------------------------------------------------------------
	bool CpuInfoStatic::cpuVendorEq( const CpuVendorInfo& info, const char* vendorString )
	{
		const Cmp_unsigned__int32* a = reinterpret_cast< const Cmp_unsigned__int32* >( info.text );
		const Cmp_unsigned__int32* b = reinterpret_cast< const Cmp_unsigned__int32* >( vendorString );

		return( a[ 0 ] == b[ 0 ] ) && ( a[ 1 ] == b[ 1 ] ) && ( a[ 2 ] == b[ 2 ] ) ;
	}

	//------------------------------------------------------------------------------
	void CpuInfoStatic::simplifyBrandString( char* s )
	{
		// Always clear the current character in the buffer. This ensures that there
		// is no garbage after the string NULL terminator.
		char* d = s;

		char prev = 0;
		char curr = s[ 0 ];
		s[ 0 ] = '\0';

		for(;;)
		{
			if( curr == 0 )
			{
				break;
			}

			if( curr == ' ' )
			{
				if( prev == '@' )
				{
					goto _Skip;
				}
				if( s[ 1 ] == ' ' || s[ 1 ] == '@' )
				{
					goto _Skip;
				}
			}

			d[ 0 ] = curr;
			d++;
			prev = curr;

			_Skip:
			curr = *++s;
			s[ 0 ] = '\0';
		}

		d[ 0 ] = '\0';
	}

	//------------------------------------------------------------------------------
	// helpers
	Cmp_unsigned__int32 CpuInfoStatic::detectNumberOfProcessors(void)
	{
#if ( QOR_SYS_OS == QOR_SYS_MSW )
		//TODO:
		//::SYSTEM_INFO info;
		//nsWinQAPI::CKernel32::GetSystemInfo( &info );

		return 1;//info.dwNumberOfProcessors;
#elif defined(ASMJIT_POSIX) && defined(_SC_NPROCESSORS_ONLN)
		// It seems that sysconf returns the number of "logical" processors on both
		// mac and linux.  So we get the number of "online logical" processors.
		long res = sysconf(_SC_NPROCESSORS_ONLN);
		if (res == -1) return 1;

		return static_cast<Cmp_unsigned__int32>(res);
#else
		return 1;
#endif
	}

	// This is messy, I know. cpuid is implemented as intrinsic in VS2005, but
	// we should support other compilers as well. Main problem is that MS compilers
	// in 64-bit mode not allows to use inline assembler, so we need intrinsic and
	// we need also asm version.
#if ( defined(_MSC_VER) && _MSC_VER >= 1400 )
#	pragma intrinsic(__cpuid)
#endif

	// cpuid() and detectCpuInfo() for x86 and x64 platforms begins here.
	void CpuInfoStatic::cpuid( Cmp_unsigned__int32 in, CpuId* out ) __QCMP_THROW
	{
#if defined(_MSC_VER)

	// 2009-02-05: Thanks to Mike Tajmajer for supporting VC7.1 compiler.

#	if _MSC_VER >= 1400
		__cpuid(reinterpret_cast<int*>(out->i), in);			// done by intrinsics
#	else // _MSC_VER < 1400

		Cmp_unsigned__int32 cpuid_in = in;
		Cmp_unsigned__int32* cpuid_out = out->i;

		__asm
		{
			mov     eax, cpuid_in
			mov     edi, cpuid_out
			cpuid
			mov     dword ptr[edi +  0], eax
			mov     dword ptr[edi +  4], ebx
			mov     dword ptr[edi +  8], ecx
			mov     dword ptr[edi + 12], edx
		}
#	endif // _MSC_VER < 1400

#elif defined(__GNUC__)

	// Note, need to preserve ebx/rbx register!
#	if ( QOR_ARCH_WORDSIZE == 32 )
#		define __mycpuid(a, b, c, d, inp) \
		asm ("mov %%ebx, %%edi\n"    \
		   "cpuid\n"               \
		   "xchg %%edi, %%ebx\n"   \
		   : "=a" (a), "=D" (b), "=c" (c), "=d" (d) : "a" (inp))
#	else
#		define __mycpuid(a, b, c, d, inp) \
		asm ("mov %%rbx, %%rdi\n"    \
		   "cpuid\n"               \
		   "xchg %%rdi, %%rbx\n"   \
		   : "=a" (a), "=D" (b), "=c" (c), "=d" (d) : "a" (inp))
#	endif
	  __mycpuid(out->result.eax, out->result.ebx, out->result.ecx, out->result.edx, in);

#endif // compiler
	}

	//------------------------------------------------------------------------------
	void CpuInfoStatic::detectCpuInfo( CpuInfo* i ) __QCMP_THROW
	{
		Cmp_unsigned__int32 a;

		// First clear our struct
		memset( i, 0, sizeof( CpuInfo ) );
		memcpy( i->vendor, "Unknown", 8 );

		i->numberOfProcessors = detectNumberOfProcessors();

#if defined QOR_ARCH_WORDSIZE

		CpuId out;

		// Get vendor string
		cpuid( 0, &out );

		memcpy( i->vendor, &out.result.ebx, 4 );
		memcpy( i->vendor + 4, &out.result.edx, 4 );
		memcpy( i->vendor + 8, &out.result.ecx, 4 );

		for( a = 0; a < 3; a++ )
		{
			if( cpuVendorEq( cpuVendorInfo[ a ], i->vendor ) )
			{
				i->vendorId = cpuVendorInfo[ a ].id;
				break;
			}
		}

		// get feature flags in ecx/edx, and family/model in eax
		cpuid( 1, &out );

		// family and model fields
		i->family   = ( out.result.eax >> 8 ) & 0x0F;
		i->model    = ( out.result.eax >> 4 ) & 0x0F;
		i->stepping = ( out.result.eax      ) & 0x0F;

		// use extended family and model fields
		if( i->family == 0x0F )
		{
			i->family += ( ( out.result.eax >> 20 ) & 0xFF );
			i->model  += ( ( out.result.eax >> 16 ) & 0x0F ) << 4;
		}

		i->x86ExtendedInfo.processorType        = ( ( out.result.eax >> 12 ) & 0x03 );
		i->x86ExtendedInfo.brandIndex           = ( ( out.result.ebx       ) & 0xFF );
		i->x86ExtendedInfo.clFlushCacheLineSize = ( ( out.result.ebx >>  8 ) & 0xFF ) * 8;
		i->x86ExtendedInfo.logicalProcessors	= ( ( out.result.ebx >> 16 ) & 0xFF );
		i->x86ExtendedInfo.apicPhysicalId       = ( ( out.result.ebx >> 24 ) & 0xFF );

		if( out.result.ecx & 0x00000001U ) i->features |= CpuInfo::Feature_SSE3;
		if( out.result.ecx & 0x00000002U ) i->features |= CpuInfo::Feature_PCLMULDQ;
		if( out.result.ecx & 0x00000008U ) i->features |= CpuInfo::Feature_MonitorMWait;
		if( out.result.ecx & 0x00000200U ) i->features |= CpuInfo::Feature_SSSE3;
		if( out.result.ecx & 0x00002000U ) i->features |= CpuInfo::Feature_CMPXCHG16B;
		if( out.result.ecx & 0x00080000U ) i->features |= CpuInfo::Feature_SSE4_1;
		if( out.result.ecx & 0x00100000U ) i->features |= CpuInfo::Feature_SSE4_2;
		if( out.result.ecx & 0x00400000U ) i->features |= CpuInfo::Feature_MOVBE;
		if( out.result.ecx & 0x00800000U ) i->features |= CpuInfo::Feature_POPCNT;
		if( out.result.ecx & 0x10000000U ) i->features |= CpuInfo::Feature_AVX;

		if( out.result.edx & 0x00000010U ) i->features |= CpuInfo::Feature_RDTSC;
		if( out.result.edx & 0x00000100U ) i->features |= CpuInfo::Feature_CMPXCHG8B;
		if( out.result.edx & 0x00008000U ) i->features |= CpuInfo::Feature_CMOV;
		if( out.result.edx & 0x00800000U ) i->features |= CpuInfo::Feature_MMX;
		if( out.result.edx & 0x01000000U ) i->features |= CpuInfo::Feature_FXSR;
		if( out.result.edx & 0x02000000U ) i->features |= CpuInfo::Feature_SSE | CpuInfo::Feature_MMXExt;
		if( out.result.edx & 0x04000000U ) i->features |= CpuInfo::Feature_SSE | CpuInfo::Feature_SSE2;
		if( out.result.edx & 0x10000000U ) i->features |= CpuInfo::Feature_MultiThreading;

		if( i->vendorId == CpuInfo::CPU_Vendor_AMD && ( out.result.edx & 0x10000000U ) )
		{
			// AMD sets Multithreading to ON if it has more cores.
			if( i->numberOfProcessors == 1 )
			{
				i->numberOfProcessors = 2;
			}
		}

		// This comment comes from V8 and I think that its important:
		//
		// Opteron Rev E has a bug in which on very rare occasions a locked
		// instruction doesn't act as a read-acquire barrier if followed by a
		// non-locked read-modify-write instruction.  Rev F has this bug in
		// pre-release versions, but not in versions released to customers,
		// so we test only for Rev E, which is family 15, model 32..63 inclusive.

		if( i->vendorId == CpuInfo::CPU_Vendor_AMD && i->family == 15 && i->model >= 32 && i->model <= 63 )
		{
			i->bugs |= CpuInfo::Bug_AMDLockMB;
		}

		// Calling cpuid with 0x80000000 as the in argument
		// gets the number of valid extended IDs.

		cpuid( 0x80000000, &out );

		Cmp_unsigned__int32 exIds = out.result.eax;
		if( exIds > 0x80000004 )
		{
			exIds = 0x80000004;
		}

		Cmp_unsigned__int32* brand = reinterpret_cast< Cmp_unsigned__int32* >( i->brand );

		for( a = 0x80000001; a <= exIds; a++ )
		{
			cpuid( a, &out );

			switch( a )
			{
			case 0x80000001:
				if ( out.result.ecx & 0x00000001U ) i->features |= CpuInfo::Feature_LAHF_SAHF;
				if ( out.result.ecx & 0x00000020U ) i->features |= CpuInfo::Feature_LZCNT;
				if ( out.result.ecx & 0x00000040U ) i->features |= CpuInfo::Feature_SSE4_A;
				if ( out.result.ecx & 0x00000080U ) i->features |= CpuInfo::Feature_MSSE;
				if ( out.result.ecx & 0x00000100U ) i->features |= CpuInfo::Feature_PREFETCH;

				if ( out.result.edx & 0x00100000U ) i->features |= CpuInfo::Feature_ExecuteDisableBit;
				if ( out.result.edx & 0x00200000U ) i->features |= CpuInfo::Feature_FFXSR;
				if ( out.result.edx & 0x00400000U ) i->features |= CpuInfo::Feature_MMXExt;
				if ( out.result.edx & 0x08000000U ) i->features |= CpuInfo::Feature_RDTSCP;
				if ( out.result.edx & 0x20000000U ) i->features |= CpuInfo::Feature_64Bit;
				if ( out.result.edx & 0x40000000U ) i->features |= CpuInfo::Feature_3dNowExt | CpuInfo::Feature_MMXExt;
				if ( out.result.edx & 0x80000000U ) i->features |= CpuInfo::Feature_3dNow;
				break;

			case 0x80000002:
			case 0x80000003:
			case 0x80000004:
				*brand++ = out.result.eax;
				*brand++ = out.result.ebx;
				*brand++ = out.result.ecx;
				*brand++ = out.result.edx;
				break;

			default:
				// Additional features can be detected in the future.
				break;
			}
		}

		// Simplify the brand string (remove unnecessary spaces to make it printable).
		simplifyBrandString( i->brand );

	}
#else
		memset(i, 0, sizeof(CpuInfo));
	}
#endif // QOR_ARCH_WORDSIZE


}//nsx86
}//nsArch

#endif//( QOR_ARCH == QOR_ARCH_X86_32 || QOR_ARCH == QOR_ARCH_X86_64 )
