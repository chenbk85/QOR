//x86CPUCore.cpp

// Copyright (c) 2008-2010, Petr Kobalicek <kobalicek.petr@gmail.com>
// Copyright (c) Querysoft Limited 2012
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Implement virtual processor for x86PC platform

#include "ArchQOR.h"

#if		( QOR_ARCH == QOR_ARCH_X86_32 || QOR_ARCH == QOR_ARCH_X86_64 )

//#include "ArchQOR/Defs.h"
#include "ArchQOR/x86/Assembler/BatchCPU/x86CPUCore.h"
#include "ArchQOR/x86/Assembler/Operands/Registers/BaseReg.h"
#include "ArchQOR/Common/Assembler/CodeGenerator.h"
#include "ArchQOR/Common/Assembler/Logger.h"
#include "ArchQOR/x86/Assembler/Operands/Mem.h"
#include "ArchQOR/x86/Assembler/Operands/Operand.h"
#include "ArchQOR/x86/Assembler/Operands/Imm.h"
#include "ArchQOR/x86/CPUInfo.h"
#include "ArchQOR/x86/Assembler/BatchCPU/InstEmitter.h"
#include <assert.h>
#include <string.h>
#include <stdio.h>

//------------------------------------------------------------------------------
namespace nsArch
{
	namespace nsx86
	{

		//Registers - 8-bit

		const CGPReg Cx86CPUCore::al( nsCodeQOR::_Initialize(), REG_AL );
		const CGPReg Cx86CPUCore::cl( nsCodeQOR::_Initialize(), REG_CL );
		const CGPReg Cx86CPUCore::dl( nsCodeQOR::_Initialize(), REG_DL );
		const CGPReg Cx86CPUCore::bl( nsCodeQOR::_Initialize(), REG_BL );

		const CGPReg& Cx86CPUCore::reg_cl( void ) const { return cl; }

#if ( QOR_ARCH_WORDSIZE == 64 )
		const CGPReg Cx86CPUCore::spl( nsCodeQOR::_Initialize(), REG_SPL );
		const CGPReg Cx86CPUCore::bpl( nsCodeQOR::_Initialize(), REG_BPL );
		const CGPReg Cx86CPUCore::sil( nsCodeQOR::_Initialize(), REG_SIL );
		const CGPReg Cx86CPUCore::dil( nsCodeQOR::_Initialize(), REG_DIL );

		const CGPReg Cx86CPUCore::r8b( nsCodeQOR::_Initialize(), REG_R8B );
		const CGPReg Cx86CPUCore::r9b( nsCodeQOR::_Initialize(), REG_R9B );
		const CGPReg Cx86CPUCore::r10b( nsCodeQOR::_Initialize(), REG_R10B );
		const CGPReg Cx86CPUCore::r11b( nsCodeQOR::_Initialize(), REG_R11B );
		const CGPReg Cx86CPUCore::r12b( nsCodeQOR::_Initialize(), REG_R12B );
		const CGPReg Cx86CPUCore::r13b( nsCodeQOR::_Initialize(), REG_R13B );
		const CGPReg Cx86CPUCore::r14b( nsCodeQOR::_Initialize(), REG_R14B );
		const CGPReg Cx86CPUCore::r15b( nsCodeQOR::_Initialize(), REG_R15B );
#endif

		const CGPReg Cx86CPUCore::ah( nsCodeQOR::_Initialize(), REG_AH );
		const CGPReg Cx86CPUCore::ch( nsCodeQOR::_Initialize(), REG_CH );
		const CGPReg Cx86CPUCore::dh( nsCodeQOR::_Initialize(), REG_DH );
		const CGPReg Cx86CPUCore::bh( nsCodeQOR::_Initialize(), REG_BH );

		//Registers - 16-bit

		const CGPReg Cx86CPUCore::ax( nsCodeQOR::_Initialize(), REG_AX );
		const CGPReg Cx86CPUCore::cx( nsCodeQOR::_Initialize(), REG_CX );
		const CGPReg Cx86CPUCore::dx( nsCodeQOR::_Initialize(), REG_DX );
		const CGPReg Cx86CPUCore::bx( nsCodeQOR::_Initialize(), REG_BX );
		const CGPReg Cx86CPUCore::sp( nsCodeQOR::_Initialize(), REG_SP );
		const CGPReg Cx86CPUCore::bp( nsCodeQOR::_Initialize(), REG_BP );
		const CGPReg Cx86CPUCore::si( nsCodeQOR::_Initialize(), REG_SI );
		const CGPReg Cx86CPUCore::di( nsCodeQOR::_Initialize(), REG_DI );

#if ( QOR_ARCH_WORDSIZE == 64 )
		const CGPReg Cx86CPUCore::r8w( nsCodeQOR::_Initialize(), REG_R8W );
		const CGPReg Cx86CPUCore::r9w( nsCodeQOR::_Initialize(), REG_R9W );
		const CGPReg Cx86CPUCore::r10w( nsCodeQOR::_Initialize(), REG_R10W );
		const CGPReg Cx86CPUCore::r11w( nsCodeQOR::_Initialize(), REG_R11W );
		const CGPReg Cx86CPUCore::r12w( nsCodeQOR::_Initialize(), REG_R12W );
		const CGPReg Cx86CPUCore::r13w( nsCodeQOR::_Initialize(), REG_R13W );
		const CGPReg Cx86CPUCore::r14w( nsCodeQOR::_Initialize(), REG_R14W );
		const CGPReg Cx86CPUCore::r15w( nsCodeQOR::_Initialize(), REG_R15W );
#endif

		//Registers - 32-bit

		const CGPReg Cx86CPUCore::eax( nsCodeQOR::_Initialize(), REG_EAX );
		const CGPReg Cx86CPUCore::ecx( nsCodeQOR::_Initialize(), REG_ECX );
		const CGPReg Cx86CPUCore::edx( nsCodeQOR::_Initialize(), REG_EDX );
		const CGPReg Cx86CPUCore::ebx( nsCodeQOR::_Initialize(), REG_EBX );
		const CGPReg Cx86CPUCore::esp( nsCodeQOR::_Initialize(), REG_ESP );
		const CGPReg Cx86CPUCore::ebp( nsCodeQOR::_Initialize(), REG_EBP );
		const CGPReg Cx86CPUCore::esi( nsCodeQOR::_Initialize(), REG_ESI );
		const CGPReg Cx86CPUCore::edi( nsCodeQOR::_Initialize(), REG_EDI );

		const CGPReg& Cx86CPUCore::reg_eax( void ) const { return eax; }
		const CGPReg& Cx86CPUCore::reg_ecx( void ) const { return ecx; }
		const CGPReg& Cx86CPUCore::reg_edx( void ) const { return edx; }
		const CGPReg& Cx86CPUCore::reg_ebx( void ) const { return ebx; }
		const CGPReg& Cx86CPUCore::reg_esp( void ) const { return esp; }
		const CGPReg& Cx86CPUCore::reg_ebp( void ) const { return ebp; }
		const CGPReg& Cx86CPUCore::reg_esi( void ) const { return esi; }
		const CGPReg& Cx86CPUCore::reg_edi( void ) const { return edi; }

#if ( QOR_ARCH_WORDSIZE == 64 )
		const CGPReg Cx86CPUCore::r8d( nsCodeQOR::_Initialize(), REG_R8D );
		const CGPReg Cx86CPUCore::r9d( nsCodeQOR::_Initialize(), REG_R9D );
		const CGPReg Cx86CPUCore::r10d( nsCodeQOR::_Initialize(), REG_R10D );
		const CGPReg Cx86CPUCore::r11d( nsCodeQOR::_Initialize(), REG_R11D );
		const CGPReg Cx86CPUCore::r12d( nsCodeQOR::_Initialize(), REG_R12D );
		const CGPReg Cx86CPUCore::r13d( nsCodeQOR::_Initialize(), REG_R13D );
		const CGPReg Cx86CPUCore::r14d( nsCodeQOR::_Initialize(), REG_R14D );
		const CGPReg Cx86CPUCore::r15d( nsCodeQOR::_Initialize(), REG_R15D );
#endif


		//Registers - 64-bit

#if ( QOR_ARCH_WORDSIZE == 64 )
		const CGPReg Cx86CPUCore::rax( nsCodeQOR::_Initialize(), REG_RAX );
		const CGPReg Cx86CPUCore::rcx( nsCodeQOR::_Initialize(), REG_RCX );
		const CGPReg Cx86CPUCore::rdx( nsCodeQOR::_Initialize(), REG_RDX );
		const CGPReg Cx86CPUCore::rbx( nsCodeQOR::_Initialize(), REG_RBX );
		const CGPReg Cx86CPUCore::rsp( nsCodeQOR::_Initialize(), REG_RSP );
		const CGPReg Cx86CPUCore::rbp( nsCodeQOR::_Initialize(), REG_RBP );
		const CGPReg Cx86CPUCore::rsi( nsCodeQOR::_Initialize(), REG_RSI );
		const CGPReg Cx86CPUCore::rdi( nsCodeQOR::_Initialize(), REG_RDI );

		const CGPReg Cx86CPUCore::r8( nsCodeQOR::_Initialize(), REG_R8 );
		const CGPReg Cx86CPUCore::r9( nsCodeQOR::_Initialize(), REG_R9 );
		const CGPReg Cx86CPUCore::r10( nsCodeQOR::_Initialize(), REG_R10 );
		const CGPReg Cx86CPUCore::r11( nsCodeQOR::_Initialize(), REG_R11 );
		const CGPReg Cx86CPUCore::r12( nsCodeQOR::_Initialize(), REG_R12 );
		const CGPReg Cx86CPUCore::r13( nsCodeQOR::_Initialize(), REG_R13 );
		const CGPReg Cx86CPUCore::r14( nsCodeQOR::_Initialize(), REG_R14 );
		const CGPReg Cx86CPUCore::r15( nsCodeQOR::_Initialize(), REG_R15 );
#endif // ASMJIT_X64

		//Registers - Native

		const CGPReg Cx86CPUCore::nax( nsCodeQOR::_Initialize(), REG_NAX );
		const CGPReg Cx86CPUCore::ncx( nsCodeQOR::_Initialize(), REG_NCX );
		const CGPReg Cx86CPUCore::ndx( nsCodeQOR::_Initialize(), REG_NDX );
		const CGPReg Cx86CPUCore::nbx( nsCodeQOR::_Initialize(), REG_NBX );
		const CGPReg Cx86CPUCore::nsp( nsCodeQOR::_Initialize(), REG_NSP );
		const CGPReg Cx86CPUCore::nbp( nsCodeQOR::_Initialize(), REG_NBP );
		const CGPReg Cx86CPUCore::nsi( nsCodeQOR::_Initialize(), REG_NSI );
		const CGPReg Cx86CPUCore::ndi( nsCodeQOR::_Initialize(), REG_NDI );

		const CSegmentReg Cx86CPUCore::cs( nsCodeQOR::_Initialize(), REG_CS );
		const CSegmentReg Cx86CPUCore::ss( nsCodeQOR::_Initialize(), REG_SS );
		const CSegmentReg Cx86CPUCore::ds( nsCodeQOR::_Initialize(), REG_DS );
		const CSegmentReg Cx86CPUCore::es( nsCodeQOR::_Initialize(), REG_ES );
		const CSegmentReg Cx86CPUCore::fs( nsCodeQOR::_Initialize(), REG_FS );
		const CSegmentReg Cx86CPUCore::gs( nsCodeQOR::_Initialize(), REG_GS );

		//------------------------------------------------------------------------------
		//Emit Register / Register - calls _emitMod( 3, opReg, r.code() )
		void Cx86CPUCore::_emitModR( Cmp_unsigned__int8 opReg, const CBaseReg& r ) __QCMP_THROW
		{
			_emitMod( 3, opReg, static_cast< Cmp_unsigned__int8 >( r.getRegCode() ) );
		}

		//------------------------------------------------------------------------------
		Cx86CPUCore::Cx86CPUCore( nsArch::CCodeGeneratorBase* pCodeGenerator ) __QCMP_THROW : CCPUBase( pCodeGenerator ),
		m_uiProperties( ( 1 << PROPERTY_OPTIMIZE_ALIGN ) ),
		m_uiEmitOptions( 0 ),
		m_iTrampolineSize( 0 ),
		m_pUnusedLinks( 0 )
		{
		}

		//------------------------------------------------------------------------------
		Cx86CPUCore::~Cx86CPUCore() __QCMP_THROW
		{
		}

		//------------------------------------------------------------------------------
		Cmp_unsigned__int32 Cx86CPUCore::getProperty( Cmp_unsigned__int32 propertyId )
		{
			return ( m_uiProperties & ( 1 << propertyId ) ) != 0;
		}

		//------------------------------------------------------------------------------
		void Cx86CPUCore::setProperty( Cmp_unsigned__int32 propertyId, Cmp_unsigned__int32 value )
		{
			if( value )
			{
				m_uiProperties |= ( 1 << propertyId );
			}
			else
			{
				m_uiProperties &= ~( 1 << propertyId );
			}
		}

		//------------------------------------------------------------------------------
		void Cx86CPUCore::clear() __QCMP_THROW
		{
			m_Buffer.clear();
			m_LabelData.clear();
			m_RelocData.clear();
			m_Zone.clear();

			if( m_uiError )
			{
				setError( ERROR_NONE );
			}

			m_pUnusedLinks = 0;
		}

		//------------------------------------------------------------------------------
		void Cx86CPUCore::free() __QCMP_THROW
		{
			m_Zone.freeAll();
			m_Buffer.free();
			m_LabelData.free();
			m_RelocData.free();

			if( m_uiError )
			{
				setError( ERROR_NONE );
			}
		}

		//------------------------------------------------------------------------------
		Cmp_unsigned__int8* Cx86CPUCore::takeCode() __QCMP_THROW
		{
			Cmp_unsigned__int8* code = m_Buffer.take();
			m_RelocData.clear();
			m_Zone.clear();

			if( m_uiError )
			{
				setError( ERROR_NONE );
			}
			return code;
		}

		//------------------------------------------------------------------------------
		void Cx86CPUCore::setVarAt( Cmp_int_ptr pos, Cmp_int_ptr i, Cmp_unsigned__int8 isUnsigned, Cmp_unsigned__int32 size ) __QCMP_THROW
		{
			if( size == 1 && !isUnsigned )
			{
				setByteAt( pos, (Cmp__int8  )i );
			}
			else if( size == 1 &&  isUnsigned )
			{
				setByteAt( pos, (Cmp_unsigned__int8 )i );
			}
			else if( size == 2 && !isUnsigned )
			{
				setWordAt( pos, (Cmp__int16 )i );
			}
			else if( size == 2 &&  isUnsigned )
			{
				setWordAt( pos, (Cmp_unsigned__int16)i );
			}
			else if( size == 4 && !isUnsigned )
			{
				setDWordAt( pos, (Cmp__int32 )i );
			}
			else if( size == 4 &&  isUnsigned )
			{
				setDWordAt( pos, (Cmp_unsigned__int32)i );
			}
#if ( QOR_ARCH_WORDSIZE == 64 )
			else if( size == 8 && !isUnsigned )
			{
				setQWordAt( pos, (Cmp__int64 )i );
			}
			else if( size == 8 &&  isUnsigned )
			{
				setQWordAt( pos, (Cmp_unsigned__int64)i );
			}
#endif // ASMJIT_X64
			else
			{
				assert( 0 );
			}
		}

		//------------------------------------------------------------------------------
		void Cx86CPUCore::_emitSegmentPrefix( const COperand* prm ) __QCMP_THROW
		{
			static const Cmp_unsigned__int8 segmentPrefixCodes[ 6 ] =
			{
				0x26,		//ES
				0x2E,		//SS
				0x36,		//SS
				0x3E,		//DS
				0x64,		//FS
				0x65		//GS
			};

			if( prm->isMem() )
			{
				Cmp_uint_ptr segmentPrefix = dynamic_cast< const CMem* >( prm )->getSegmentPrefix();
				if( segmentPrefix < (REG_NUM_SEGMENT-1) )
				{
					_emitByte( segmentPrefixCodes[ segmentPrefix ] );
				}
			}
		}

		//------------------------------------------------------------------------------
		void Cx86CPUCore::_emitModM( Cmp_unsigned__int8 opReg, const CMem* pmem, Cmp_int_ptr immSize ) __QCMP_THROW
		{
			assert( pmem->getType() == EOPERAND_MEM );

			Cmp_unsigned__int8 baseReg = pmem->getBase() & 0x7;
			Cmp_unsigned__int8 indexReg = pmem->getIndex() & 0x7;
			Cmp_int_ptr disp = pmem->getDisplacement();
			Cmp_unsigned__int32 shift = pmem->getShift();

			if( pmem->getMemType() == OPERAND_MEM_NATIVE )
			{
				// [base + displacemnt]
				if( !pmem->hasIndex() )
				{
					// ESP/RSP/R12 == 4
					if( baseReg == 4 )
					{
						Cmp_unsigned__int8 mod = 0;

						if( disp )
						{
							mod = nsCodeQOR::isInt8( disp ) ? 1 : 2;
						}

						_emitMod( mod, opReg, 4 );
						_emitSib( 0, 4, 4 );

						if( disp )
						{
							if( nsCodeQOR::isInt8( disp ) )
							{
								_emitByte( (Cmp__int8)disp );
							}
							else
							{
								_emitInt32( (Cmp__int32)disp );
							}
						}
					}
					// EBP/RBP/R13 == 5
					else if( baseReg != 5 && disp == 0 )
					{
						_emitMod( 0, opReg, baseReg );
					}
					else if( nsCodeQOR::isInt8( disp ) )
					{
						_emitMod( 1, opReg, baseReg );
						_emitByte( (Cmp__int8)disp );
					}
					else
					{
						_emitMod( 2, opReg, baseReg );
						_emitInt32( (Cmp__int32)disp );
					}
				}
				// [base + index * scale + displacemnt]
				else
				{
					// assert(indexReg != RID_ESP);

					// EBP/RBP/R13 == 5
					if( baseReg != 5 && disp == 0 )
					{
						_emitMod( 0, opReg, 4 );
						_emitSib( static_cast< Cmp_unsigned__int8 >( shift ), indexReg, baseReg );
					}
					else if( nsCodeQOR::isInt8( disp ) )
					{
						_emitMod( 1, opReg, 4 );
						_emitSib( static_cast< Cmp_unsigned__int8 >( shift ), indexReg, baseReg );
						_emitByte( (Cmp__int8)disp );
					}
					else
					{
						_emitMod( 2, opReg, 4 );
						_emitSib( static_cast< Cmp_unsigned__int8 >( shift ), indexReg, baseReg );
						_emitInt32( (Cmp__int32)disp );
					}
				}
			}
			// Address                       | 32-bit mode | 64-bit mode
			// ------------------------------+-------------+---------------
			// [displacement]                |   ABSOLUTE  | RELATIVE (RIP)
			// [index * scale + displacemnt] |   ABSOLUTE  | ABSOLUTE (ZERO EXTENDED)
			else
			{
			// - In 32-bit mode the absolute addressing model is used.
			// - In 64-bit mode the relative addressing model is used together with
			//   the absolute addressing. Main problem is that if instruction
			//   contains SIB then relative addressing (RIP) is not possible.

#if ( QOR_ARCH_WORDSIZE == 32 )

				if( pmem->hasIndex() )
				{
					// assert(mem.getMemIndex() != 4); // ESP/RSP == 4
					_emitMod( 0, opReg, 4 );
					_emitSib( static_cast< Cmp_unsigned__int8 >( shift ), indexReg, 5 );
				}
				else
				{
					_emitMod( 0, opReg, 5 );
				}

				// X86 uses absolute addressing model, all relative addresses will be relocated to absolute ones.
				if( pmem->getMemType() == OPERAND_MEM_LABEL )
				{
					LabelData& l_data = m_LabelData[ pmem->getBase() & OPERAND_ID_VALUE_MASK ];
					RelocData r_data;
					Cmp_unsigned__int32 relocId = m_RelocData.getLength();

					// Relative addressing will be relocated to absolute address.
					r_data.type = RelocData::RELATIVE_TO_ABSOLUTE;
					r_data.size = 4;
					r_data.offset = getOffset();
					r_data.destination = disp;

					if( l_data.offset != -1 )
					{
						// Bound label.
						r_data.destination += l_data.offset;

						// Add a dummy DWORD.
						_emitInt32( 0 );
					}
					else
					{
						// Non-bound label.
						_emitDisplacement( l_data, -4 - immSize, 4 )->relocId = relocId;
					}

					m_RelocData.append( r_data );
				}
				else
				{
					// Absolute address
					_emitInt32( (Cmp__int32)( (Cmp_unsigned__int8*)pmem->getTarget() + disp ) );
				}

#else
				// X64 uses relative addressing model
				if( pmem->getMemType() == OPERAND_MEM_LABEL )
				{
					LabelData& l_data = m_LabelData[ pmem->getBase() & OPERAND_ID_VALUE_MASK ];

					if( pmem->hasIndex() )
					{
						// Indexing is not possible.
						setError( ERROR_ILLEGAL_ADDRESING );
						return;
					}

					// Relative address (RIP +/- displacement).
					_emitMod( 0, opReg, 5 );

					disp -= ( 4 + immSize );

					if( l_data.offset != -1 )
					{
						// Bound label.
						disp += getOffset() - l_data.offset;

						// Add a dummy DWORD.
						_emitInt32( (Cmp__int32)disp );
					}
					else
					{
						// Non-bound label.
						_emitDisplacement( l_data, disp, 4 );
					}
				}
				else
				{
					// Absolute address (truncated to 32-bits), this kind of address requires
					// SIB byte (4).
					_emitMod( 0, opReg, 4 );

					if( pmem->hasIndex() )
					{
						// assert(mem.getMemIndex() != 4); // ESP/RSP == 4
						_emitSib( static_cast< Cmp_unsigned__int8 >( shift ), indexReg, 5 );
					}
					else
					{
						_emitSib( 0, 4, 5 );
					}

					// Truncate to 32-bits.
					Cmp_uint_ptr target = ( Cmp_uint_ptr )( (Cmp_unsigned__int8*)pmem->getTarget() + disp );

					if( target > (Cmp_uint_ptr)0xFFFFFFFF )
					{
						if( m_pLogger )
						{
							m_pLogger->logString( "*** ASSEMBER WARNING - Absolute address truncated to 32-bits.\n" );
						}
						target &= 0xFFFFFFFF;
					}

					_emitInt32( (Cmp__int32)( (Cmp_unsigned__int32)target ) );
				}

#endif // ASMJIT_X64

			}
		}

		//------------------------------------------------------------------------------
		//Emit REX prefix (64-bit mode only).
		void Cx86CPUCore::_emitRexRM( Cmp_unsigned__int8 w, Cmp_unsigned__int8 opReg, const COperand& rm, bool forceRexPrefix ) __QCMP_THROW
		{
#if ( QOR_ARCH_WORDSIZE == 64 )
			Cmp_unsigned__int8 r = (opReg & 0x8) != 0;
			Cmp_unsigned__int8 x = 0;
			Cmp_unsigned__int8 b = 0;

			if( rm.isReg() )
			{
				b = ( reinterpret_cast< const CBaseReg& >( rm ).getRegCode() & 0x8 ) != 0;
			}
			else if( rm.isMem() )
			{
				x = ( ( reinterpret_cast<const CMem&>( rm ).getIndex() & 0x8 ) != 0 ) & ( reinterpret_cast< const CMem& >( rm ).getIndex() != INVALID_VALUE );
				b = ( ( reinterpret_cast<const CMem&>( rm ).getBase() & 0x8 ) != 0 ) & ( reinterpret_cast< const CMem& >( rm ).getBase() != INVALID_VALUE );
			}

			// w Default operand size(0=Default, 1=64-bit).
			// r Register field (1=high bit extension of the ModR/M REG field).
			// x Index field (1=high bit extension of the SIB Index field).
			// b Base field (1=high bit extension of the ModR/M or SIB Base field).
			if( w || r || x || b || forceRexPrefix )
			{
				_emitByte( 0x40 | ( w << 3 ) | ( r << 2 ) | ( x << 1 ) | b );
			}
#else
			QOR_PP_UNREF3( w, opReg, rm );
#endif // ASMJIT_X64
		}

		//------------------------------------------------------------------------------
		void Cx86CPUCore::_emitModRM( Cmp_unsigned__int8 opReg, const COperand* pop, Cmp_int_ptr immSize ) __QCMP_THROW
		{
			assert( pop->getType() == EOPERAND_REG || pop->getType() == EOPERAND_MEM );

			if( pop->getType() == EOPERAND_REG )
			{
				_emitModR( opReg, static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CBaseReg* >( pop )->getRegCode() ) );
			}
			else
			{
				_emitModM( opReg, ( dynamic_cast< const CMem* >( pop ) ), immSize );
			}
		}

		//------------------------------------------------------------------------------
		void Cx86CPUCore::_emitX86Inl( Cmp_unsigned__int32 opCode, Cmp_unsigned__int8 i16bit, Cmp_unsigned__int8 rexw, Cmp_unsigned__int8 reg, bool forceRexPrefix ) __QCMP_THROW
		{
			// 16-bit prefix.
			if( i16bit )
			{
				_emitByte( 0x66 );
			}

			// Instruction prefix.
			if( opCode & 0xFF000000 )
			{
				_emitByte( (Cmp_unsigned__int8)( ( opCode & 0xFF000000 ) >> 24 ) );
			}

			// REX prefix.
#if ( QOR_ARCH_WORDSIZE == 64 )
			_emitRexR( rexw, 0, reg, forceRexPrefix );
#endif // ASMJIT_X64

			// Instruction opcodes.
			if( opCode & 0x00FF0000 )
			{
				_emitByte( (Cmp_unsigned__int8)( ( opCode & 0x00FF0000 ) >> 16 ) );
			}
			if( opCode & 0x0000FF00 )
			{
				_emitByte( (Cmp_unsigned__int8)( ( opCode & 0x0000FF00 ) >>  8 ) );
			}

			_emitByte( (Cmp_unsigned__int8)( opCode & 0x000000FF ) + ( reg & 0x7 ) );
		}

		//------------------------------------------------------------------------------
		void Cx86CPUCore::_emitX86RM( Cmp_unsigned__int32 opCode, Cmp_unsigned__int8 i16bit, Cmp_unsigned__int8 rexw, Cmp_unsigned__int8 o, const COperand* op, Cmp_int_ptr immSize, bool forceRexPrefix ) __QCMP_THROW
		{
			if( i16bit )
			{
				_emitByte(0x66);			// 16-bit prefix.
			}

			_emitSegmentPrefix( op );		// Segment prefix.

			if( opCode & 0xFF000000 )		// Instruction prefix.
			{
				_emitByte( (Cmp_unsigned__int8)( ( opCode & 0xFF000000 ) >> 24 ) );
			}

			// REX prefix.
#if ( QOR_ARCH_WORDSIZE == 64 )
			_emitRexRM( rexw, o, *op, forceRexPrefix );
#endif // ASMJIT_X64

			// Instruction opcodes.
			if( opCode & 0x00FF0000 )
			{
				_emitByte( (Cmp_unsigned__int8)( ( opCode & 0x00FF0000 ) >> 16 ) );
			}

			if( opCode & 0x0000FF00 )
			{
				_emitByte( (Cmp_unsigned__int8)( ( opCode & 0x0000FF00 ) >>  8 ) );
			}
			_emitByte( (Cmp_unsigned__int8)( opCode & 0x000000FF ) );

			// Mod R/M.
			_emitModRM( o, op, immSize );
		}

		//------------------------------------------------------------------------------
		void Cx86CPUCore::_emitFpu( Cmp_unsigned__int32 opCode ) __QCMP_THROW
		{
			_emitOpCode( opCode );
		}

		//------------------------------------------------------------------------------
		void Cx86CPUCore::_emitFpuSTI( Cmp_unsigned__int32 opCode, Cmp_unsigned__int32 sti ) __QCMP_THROW
		{
			assert( 0 <= sti && sti < 8 );		// Illegal stack offset.
			_emitOpCode( opCode + sti );
		}

		//------------------------------------------------------------------------------
		void Cx86CPUCore::_emitFpuMEM( Cmp_unsigned__int32 opCode, Cmp_unsigned__int8 opReg, const CMem* pmem ) __QCMP_THROW
		{
			_emitSegmentPrefix( pmem );		// Segment prefix.
			if( opCode & 0xFF000000 )		// Instruction prefix.
			{
				_emitByte( (Cmp_unsigned__int8)( ( opCode & 0xFF000000 ) >> 24 ) );
			}

			// REX prefix.
#if ( QOR_ARCH_WORDSIZE == 64 )
			_emitRexRM( 0, opReg, *pmem, false );
#endif // ASMJIT_X64

			// Instruction opcodes.
			if( opCode & 0x00FF0000 )
			{
				_emitByte( (Cmp_unsigned__int8)( ( opCode & 0x00FF0000 ) >> 16 ) );
			}
			if( opCode & 0x0000FF00 )
			{
				_emitByte( (Cmp_unsigned__int8)( ( opCode & 0x0000FF00 ) >>  8 ) );
			}

			_emitByte( (Cmp_unsigned__int8)( ( opCode & 0x000000FF ) ) );
			_emitModM( opReg, pmem, 0 );
		}

		//------------------------------------------------------------------------------
		void Cx86CPUCore::_emitMmu( Cmp_unsigned__int32 opCode, Cmp_unsigned__int8 rexw, Cmp_unsigned__int8 opReg, const COperand* psrc, Cmp_int_ptr immSize ) __QCMP_THROW
		{
			_emitSegmentPrefix( psrc );		// Segment prefix.
			if( opCode & 0xFF000000 )		// Instruction prefix.
			{
				_emitByte( (Cmp_unsigned__int8)( ( opCode & 0xFF000000 ) >> 24 ) );
			}

#if ( QOR_ARCH_WORDSIZE == 64 )
			_emitRexRM( rexw, opReg, *psrc, false );		// REX prefix.
#endif // ASMJIT_X64

			if( opCode & 0x00FF0000 )		// Instruction opcodes.
			{
				_emitByte( (Cmp_unsigned__int8)( ( opCode & 0x00FF0000 ) >> 16 ) );
			}

			// No checking, MMX/SSE instructions have always two opcodes or more.
			_emitByte( (Cmp_unsigned__int8)( ( opCode & 0x0000FF00 ) >> 8 ) );
			_emitByte( (Cmp_unsigned__int8)( ( opCode & 0x000000FF ) ) );

			if( psrc->isReg() )
			{
				_emitModR( opReg, static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CBaseReg* >( psrc )->getRegCode() ) );
			}
			else
			{
				_emitModM( opReg, dynamic_cast< const CMem* >( psrc ), immSize );
			}
		}

		//------------------------------------------------------------------------------
		LabelLink* Cx86CPUCore::_emitDisplacement( LabelData& l_data, Cmp_int_ptr inlinedDisplacement, int size ) __QCMP_THROW
		{
			assert( l_data.offset == -1 );
			assert( size == 1 || size == 4 );

			// Chain with label.
			LabelLink* link = _newLabelLink();
			link->prev = l_data.links;
			link->offset = getOffset();
			link->displacement = inlinedDisplacement;

			l_data.links = link;

			// Emit label size as dummy data.
			if( size == 1 )
			{
				_emitByte( 0x01 );
			}
			else // if (size == 4)
			{
				_emitDWord(0x04040404);
			}

			return link;
		}

		//------------------------------------------------------------------------------
		void Cx86CPUCore::_emitJmpOrCallReloc( Cmp_unsigned__int32 instruction, void* target ) __QCMP_THROW
		{
			RelocData rd;

			rd.type = RelocData::ABSOLUTE_TO_RELATIVE_TRAMPOLINE;

#if ( QOR_ARCH_WORDSIZE == 64 )
			// If we are compiling in 64-bit mode, we can use trampoline if relative jump is not possible.
			m_iTrampolineSize += TrampolineWriter::TRAMPOLINE_SIZE;
#endif // ARCHITECTURE_SPECIFIC

			rd.size = 4;
			rd.offset = getOffset();
			rd.address = target;
			m_RelocData.append( rd );
			_emitInt32( 0 );		// Emit dummy 32-bit integer (will be overwritten by relocCode()).
		}

		//------------------------------------------------------------------------------
		void Cx86CPUCore::_emitJcc( Cmp_unsigned__int32 code, const CLabel* label, Cmp_unsigned__int32 hint ) __QCMP_THROW
		{
			if( !hint )
			{
				//TODO:
				_emitInstruction( code, label, 0, 0 );
			}
			else
			{
				CImm imm( hint );
				//TODO:
				//_emitInstruction(code, label, &imm, 0);
			}
		}

		//------------------------------------------------------------------------------
		Cmp_uint_ptr Cx86CPUCore::relocCode( void* _dst, Cmp_uint_ptr addressBase ) const __QCMP_THROW
		{
			// Copy code to virtual memory ( this is a given _dst pointer ).
			Cmp_unsigned__int8* dst = reinterpret_cast< Cmp_unsigned__int8* >( _dst );

			Cmp_int_ptr coff = m_Buffer.getOffset();
			Cmp_int_ptr csize = getCodeSize();

			// We are copying the exact size of the generated code. Extra code for trampolines
			// is generated on-the-fly by relocator (this code doesn't exist at the moment).
			memcpy( dst, m_Buffer.getData(), coff );

#if ( QOR_ARCH_WORDSIZE == 64 )
			// Trampoline pointer.
			Cmp_unsigned__int8* tramp = dst + coff;
#endif // ASMJIT_X64

			// Relocate all recorded locations.
			Cmp_int_ptr i;
			Cmp_int_ptr len = m_RelocData.getLength();

			for( i = 0; i < len; i++ )
			{
				const RelocData& r = m_RelocData[ i ];
				Cmp_int_ptr val = 0;

#if ( QOR_ARCH_WORDSIZE == 64 )
				// Whether to use trampoline, can be only used if relocation type is
				// ABSOLUTE_TO_RELATIVE_TRAMPOLINE.
				bool useTrampoline = false;
#endif // ASMJIT_X64

				// Be sure that reloc data structure is correct.
				assert( (Cmp_int_ptr)( r.offset + r.size ) <= csize );

				switch( r.type )
				{
				case RelocData::ABSOLUTE_TO_ABSOLUTE:
					val = (Cmp_int_ptr)( r.address );
					break;

				case RelocData::RELATIVE_TO_ABSOLUTE:
					val = (Cmp_int_ptr)( addressBase + r.destination );
					break;

				case RelocData::ABSOLUTE_TO_RELATIVE:
				case RelocData::ABSOLUTE_TO_RELATIVE_TRAMPOLINE:
					val = (Cmp_int_ptr)( (Cmp_uint_ptr)r.address - ( addressBase + (Cmp_uint_ptr)r.offset + 4 ) );

#if ( QOR_ARCH_WORDSIZE == 64 )
					if( r.type == RelocData::ABSOLUTE_TO_RELATIVE_TRAMPOLINE && !nsCodeQOR::isInt32( val ) )
					{
						val = (Cmp_int_ptr)( (Cmp_uint_ptr)tramp - ( (Cmp_uint_ptr)_dst + (Cmp_uint_ptr)r.offset + 4 ) );
						useTrampoline = true;
					}
#endif // ASMJIT_X64
					break;

				default:
					assert( 0 );
				}

				switch( r.size )
				{
				case 4:
					*reinterpret_cast< Cmp__int32* >( dst + r.offset ) = (Cmp__int32)val;
					break;

				case 8:
					*reinterpret_cast< Cmp__int64* >( dst + r.offset ) = (Cmp__int64)val;
					break;

				default:
					assert( 0 );
				}

#if ( QOR_ARCH_WORDSIZE == 64 )
				if( useTrampoline )
				{
					if( getLogger() )
					{
						getLogger()->logFormat( "; Trampoline from %p -> %p\n", (Cmp__int8*)addressBase + r.offset, r.address );
					}

					TrampolineWriter::writeTrampoline( tramp, r.address );
					tramp += TrampolineWriter::TRAMPOLINE_SIZE;
				}
#endif // ASMJIT_X64
			}

#if ( QOR_ARCH_WORDSIZE == 64 )
			return (Cmp_uint_ptr)( tramp - dst );
#else
			return (Cmp_uint_ptr)coff;
#endif // ASMJIT_X64
		}

		//------------------------------------------------------------------------------
		void* Cx86CPUCore::make() __QCMP_THROW
		{
			// Do nothing on error state or when no instruction was emitted.
			if( m_uiError || getCodeSize() == 0 )
			{
				return 0;
			}

			void* p;
			m_uiError = m_pCodeGenerator->generate( &p, reinterpret_cast< CAbstractAssembler* >( this ) );
			return p;
		}

		//------------------------------------------------------------------------------
		LabelLink* Cx86CPUCore::_newLabelLink() __QCMP_THROW
		{
			LabelLink* link = m_pUnusedLinks;

			if( link )
			{
				m_pUnusedLinks = link->prev;
			}
			else
			{
				link = (LabelLink*)m_Zone.zalloc( sizeof( LabelLink ) );
				if( link == 0 )
				{
					return 0;
				}
			}

			// clean link
			link->prev = 0;
			link->offset = 0;
			link->displacement = 0;
			link->relocId = -1;

			return link;
		}

		//------------------------------------------------------------------------------
		static const char* operandSize[] =
		{
			0,
			"byte ptr ",
			"word ptr ",
			0,
			"dword ptr ",
			0,
			0,
			0,
			"qword ptr ",
			0,
			"tword ptr ",
			0,
			0,
			0,
			0,
			0,
			"dqword ptr "
		};

		//------------------------------------------------------------------------------
		static const char segmentPrefixName[] =
		"es:\0"
		"cs:\0"
		"ss:\0"
		"ds:\0"
		"fs:\0"
		"gs:\0"
		"\0\0\0\0";

		//------------------------------------------------------------------------------
		__QCMP_LOCAL char* dumpRegister( char* buf, Cmp_unsigned__int32 type, Cmp_unsigned__int32 index) __QCMP_THROW
		{
			// NE == Not-Encodable.
			const char reg8l[] = "al\0\0" "cl\0\0" "dl\0\0" "bl\0\0" "spl\0"  "bpl\0"  "sil\0"  "dil\0" ;
			const char reg8h[] = "ah\0\0" "ch\0\0" "dh\0\0" "bh\0\0" "NE\0\0" "NE\0\0" "NE\0\0" "NE\0\0";
			const char reg16[] = "ax\0\0" "cx\0\0" "dx\0\0" "bx\0\0" "sp\0\0" "bp\0\0" "si\0\0" "di\0\0";

			switch( type )
			{
			case REG_TYPE_GPB_LO:
				if( index < 8 )
				{
					return nsCodeQOR::mycpy( buf, &reg8l[ index * 4 ] );
				}

				*buf++ = 'r';
				goto _EmitID;

			case REG_TYPE_GPB_HI:
				if( index < 4 )
				{
					return nsCodeQOR::mycpy( buf, &reg8h[ index * 4 ] );
				}

_EmitNE:
				return nsCodeQOR::mycpy( buf, "NE" );

			case REG_TYPE_GPW:
				if( index < 8 )
				{
					return nsCodeQOR::mycpy( buf, &reg16[ index * 4 ] );
				}

				*buf++ = 'r';
				buf = nsCodeQOR::myutoa( buf, index );
				*buf++ = 'w';
				return buf;

			case REG_TYPE_GPD:
				if( index < 8 )
				{
					*buf++ = 'e';
					return nsCodeQOR::mycpy( buf, &reg16[ index * 4] );
				}

				*buf++ = 'r';
				buf = nsCodeQOR::myutoa( buf, index );
				*buf++ = 'd';
				return buf;

			case REG_TYPE_GPQ:
				*buf++ = 'r';

				if( index < 8 )
				{
					return nsCodeQOR::mycpy( buf, &reg16[ index * 4 ] );
				}
_EmitID:
				return nsCodeQOR::myutoa( buf, index );

			case REG_TYPE_X87:
				*buf++ = 's';
				*buf++ = 't';
				goto _EmitID;

			case REG_TYPE_MM:
				*buf++ = 'm';
				*buf++ = 'm';
				goto _EmitID;

			case REG_TYPE_XMM:
				*buf++ = 'x';
				*buf++ = 'm';
				*buf++ = 'm';
				goto _EmitID;

			case REG_TYPE_YMM:
				*buf++ = 'y';
				*buf++ = 'm';
				*buf++ = 'm';
				goto _EmitID;

			case REG_TYPE_SEGMENT:
				if( index < REG_NUM_SEGMENT )
				{
					return nsCodeQOR::mycpy( buf, &segmentPrefixName[ index * 4 ], 2 );
				}
				goto _EmitNE;

			default:
				return buf;
			}
		}
/*
		//------------------------------------------------------------------------------
		__QCMP_LOCAL char* dumpRegister( char* buf, Cmp_unsigned__int32 type, Cmp_unsigned__int32 index ) __QCMP_THROW
		{
			// NE == Not-Encodable.
			const char reg8l[] = "al\0\0" "cl\0\0" "dl\0\0" "bl\0\0" "spl\0"  "bpl\0"  "sil\0"  "dil\0" ;
			const char reg8h[] = "ah\0\0" "ch\0\0" "dh\0\0" "bh\0\0" "NE\0\0" "NE\0\0" "NE\0\0" "NE\0\0";
			const char reg16[] = "ax\0\0" "cx\0\0" "dx\0\0" "bx\0\0" "sp\0\0" "bp\0\0" "si\0\0" "di\0\0";

			switch( type )
			{
			case REG_TYPE_GPB_LO:
				{
					if( index < 8 )
					{
						return buf + sprintf( buf, "%s", &reg8l[ index * 4 ] );
					}
					else
					{
						return buf + sprintf( buf, "r%ub", (Cmp_unsigned__int32)index );
					}
				}
			case REG_TYPE_GPB_HI:
				{
					if( index < 4 )
					{
						return buf + sprintf( buf, "%s", &reg8h[ index * 4 ] );
					}
					else
					{
						return buf + sprintf( buf, "%s", "INVALID" );
					}
				}
			case REG_TYPE_GPW:
				{
					if( index < 8 )
					{
						return buf + sprintf( buf, "%s", &reg16[ index * 4 ] );
					}
					else
					{
						return buf + sprintf( buf, "r%uw", (Cmp_unsigned__int32)index );
					}
				}
			case REG_TYPE_GPD:
			{
				if( index < 8 )
				{
					return buf + sprintf( buf, "e%s", &reg16[ index * 4 ] );
				}
				else
				{
					return buf + sprintf( buf, "r%ud", (Cmp_unsigned__int32)index );
				}
			}
			case REG_TYPE_GPQ:
				{
					if( index < 8 )
					{
						return buf + sprintf( buf, "r%s", &reg16[ index * 4 ] );
					}
					else
					{
						return buf + sprintf( buf, "r%u", (Cmp_unsigned__int32)index );
					}
				}
			case REG_TYPE_X87:
				return buf + sprintf( buf, "st%u", (Cmp_unsigned__int32)index );
			case REG_TYPE_MM:
				return buf + sprintf( buf, "mm%u", (Cmp_unsigned__int32)index );
			case REG_TYPE_XMM:
				return buf + sprintf( buf, "xmm%u", (Cmp_unsigned__int32)index );
			default:
				return buf;
			}
		}
*/
		//------------------------------------------------------------------------------
		__QCMP_LOCAL char* dumpOperand( char* buf, const COperand* op, Cmp_unsigned__int32 memRegType ) __QCMP_THROW
		{
			if( op->isReg() )
			{
				const CBaseReg& reg = reinterpret_cast< const CBaseReg& >( *op );
				return dumpRegister( buf, reg.getRegType(), reg.getRegIndex() );
			}
			else if( op->isMem() )
			{
				bool isAbsolute = false;
				const CMem& mem = reinterpret_cast< const CMem& >( *op );
				Cmp_unsigned__int32 segmentPrefix = mem.getSegmentPrefix();

				//bool bisAbsolute = false;

				if( op->getSize() <= 16 )
				{
					buf = nsCodeQOR::mycpy( buf, operandSize[ op->getSize() ] );
				}

				if( segmentPrefix < REG_NUM_SEGMENT )
				{
					buf = nsCodeQOR::mycpy( buf, &segmentPrefixName[ segmentPrefix * 4 ] );
				}

				*buf++ = '[';

				switch( mem.getMemType() )
				{
				case OPERAND_MEM_NATIVE:
					{
						// [base + index*scale + displacement]
						buf = dumpRegister( buf, memRegType, mem.getBase() );
						break;
					}
				case OPERAND_MEM_LABEL:
					{
						// [label + index*scale + displacement]
						buf += sprintf( buf, "L.%u", mem.getBase() & OPERAND_ID_VALUE_MASK );
						break;
					}
				case OPERAND_MEM_ABSOLUTE:
					{
						// [absolute]
						isAbsolute = true;
						buf = nsCodeQOR::myutoa( buf, (Cmp_uint_ptr)mem.getTarget() + mem.getDisplacement(), 16 );
						break;
					}
				}

				if( mem.hasIndex() )
				{
					buf = nsCodeQOR::mycpy( buf, " + " );
					buf = dumpRegister( buf, memRegType, mem.getIndex() );

					if( mem.getShift() )
					{
						buf = nsCodeQOR::mycpy( buf, " * " );
						*buf++ = "1248"[ mem.getShift() & 3 ];
					}
				}

				if( mem.getDisplacement() && !isAbsolute )
				{
					Cmp_int_ptr d = mem.getDisplacement();
					*buf++ = ' ';
					*buf++ = (d < 0) ? '-' : '+';
					*buf++ = ' ';
					buf = nsCodeQOR::myutoa( buf, d < 0 ? -d : d );
				}

				*buf++ = ']';
				return buf;
			}
			else if( op->isImm() )
			{
				const CImm& i = reinterpret_cast< const CImm& >( *op );
				return nsCodeQOR::myitoa( buf, (Cmp_int_ptr)i.getValue() );
			}
			else if( op->isLabel() )
			{
				return buf + sprintf( buf, "L.%u", op->getId() & OPERAND_ID_VALUE_MASK );
			}
			else
			{
				return nsCodeQOR::mycpy( buf, "None" );
			}
		}

		//------------------------------------------------------------------------------
		void Cx86CPUCore::embedLabel( const CLabel& label ) __QCMP_THROW
		{
			assert( label.getId() != INVALID_VALUE );
			if( !canEmit() )
			{
				return;
			}

			LabelData& l_data = m_LabelData[ label.getId() & OPERAND_ID_VALUE_MASK ];
			RelocData r_data;

			if( m_pLogger )
			{
				m_pLogger->logFormat( sizeof( Cmp_int_ptr ) == 4 ? ".dd L.%u\n" : ".dq L.%u\n", (Cmp_unsigned__int32)label.getId() & OPERAND_ID_VALUE_MASK );
			}

			r_data.type = RelocData::RELATIVE_TO_ABSOLUTE;
			r_data.size = sizeof( Cmp_int_ptr );
			r_data.offset = getOffset();
			r_data.destination = 0;

			if( l_data.offset != -1 )
			{
				// Bound label.
				r_data.destination = l_data.offset;
			}
			else
			{
				// Non-bound label. Need to chain.
				LabelLink* link = _newLabelLink();

				link->prev = (LabelLink*)l_data.links;
				link->offset = getOffset();
				link->displacement = 0;
				link->relocId = m_RelocData.getLength();

				l_data.links = link;
			}

			m_RelocData.append( r_data );

			// Emit dummy sysint (4 or 8 bytes that depends on address size).
			_emitSysInt( 0 );
		}

		//------------------------------------------------------------------------------
		void Cx86CPUCore::align( Cmp_unsigned__int32 m ) __QCMP_THROW
		{
			if( !canEmit() )
			{
				return;
			}

			if( m_pLogger )
			{
				m_pLogger->logFormat( ".align %u", (Cmp_unsigned_int)m );
			}

			if( !m )
			{
				return;
			}

			if( m > 64 )
			{
				assert( 0 );
				return;
			}

			Cmp_uint_ptr i = m - ( getOffset() % m );
			if( i == m )
			{
				return;
			}

			if( m_uiProperties & ( 1 << PROPERTY_OPTIMIZE_ALIGN ) )
			{
				nsArch::nsx86::CpuInfo cpuinfo;
				nsArch::nsx86::CpuInfo* ci = &cpuinfo;
				nsArch::nsx86::CpuInfoStatic info;
				info.detectCpuInfo( ci );//= cpuInfo();

				// NOPs optimized for Intel:
				//   Intel 64 and IA-32 Architectures Software Developer's Manual
				//   - Volume 2B
				//   - Instruction Set Reference N-Z
				//     - NOP

				// NOPs optimized for AMD:
				//   Software Optimization Guide for AMD Family 10h Processors (Quad-Core)
				//   - 4.13 - Code Padding with Operand-Size Override and Multibyte NOP

				// Intel and AMD.
				static const Cmp_unsigned__int8 nop1[] = { 0x90 };
				static const Cmp_unsigned__int8 nop2[] = { 0x66, 0x90 };
				static const Cmp_unsigned__int8 nop3[] = { 0x0F, 0x1F, 0x00 };
				static const Cmp_unsigned__int8 nop4[] = { 0x0F, 0x1F, 0x40, 0x00 };
				static const Cmp_unsigned__int8 nop5[] = { 0x0F, 0x1F, 0x44, 0x00, 0x00 };
				static const Cmp_unsigned__int8 nop6[] = { 0x66, 0x0F, 0x1F, 0x44, 0x00, 0x00 };
				static const Cmp_unsigned__int8 nop7[] = { 0x0F, 0x1F, 0x80, 0x00, 0x00, 0x00, 0x00 };
				static const Cmp_unsigned__int8 nop8[] = { 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00 };
				static const Cmp_unsigned__int8 nop9[] = { 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00 };

				// AMD.
				static const Cmp_unsigned__int8 nop10[] = { 0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00 };
				static const Cmp_unsigned__int8 nop11[] = { 0x66, 0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00 };

				const Cmp_unsigned__int8* p;
				Cmp_int_ptr n;

				if( ci->vendorId == QOR_ARCH_X86_VENDOR_INTEL &&  ( (ci->family & 0x0F ) == 6 ||  ( ci->family & 0x0F ) == 15 ) )
				{
					do
					{
						switch( i )
						{
						case  1: p = nop1; n = 1; break;
						case  2: p = nop2; n = 2; break;
						case  3: p = nop3; n = 3; break;
						case  4: p = nop4; n = 4; break;
						case  5: p = nop5; n = 5; break;
						case  6: p = nop6; n = 6; break;
						case  7: p = nop7; n = 7; break;
						case  8: p = nop8; n = 8; break;
						default: p = nop9; n = 9; break;
						}

						i -= n;
						do
						{
							_emitByte( *p++ );
						}while( --n );
					} while( i );

					return;
				}

				if( ci->vendorId == QOR_ARCH_X86_VENDOR_AMD && ci->family >= 0x0F )
				{
					do
					{
						switch( i )
						{
						case  1: p = nop1 ; n =  1; break;
						case  2: p = nop2 ; n =  2; break;
						case  3: p = nop3 ; n =  3; break;
						case  4: p = nop4 ; n =  4; break;
						case  5: p = nop5 ; n =  5; break;
						case  6: p = nop6 ; n =  6; break;
						case  7: p = nop7 ; n =  7; break;
						case  8: p = nop8 ; n =  8; break;
						case  9: p = nop9 ; n =  9; break;
						case 10: p = nop10; n = 10; break;
						default: p = nop11; n = 11; break;
						}

						i -= n;
						do
						{
							_emitByte( *p++ );
						}while( --n );
					} while( i );

					return;
				}
#	if ( QOR_ARCH_WORDSIZE == 32 )
				// legacy NOPs, 0x90 with 0x66 prefix.
				do
				{
					switch( i )
					{
					default:
						_emitByte( 0x66 );
						i--;
					case  3:
						_emitByte( 0x66 );
						i--;
					case  2:
						_emitByte( 0x66 );
						i--;
					case  1:
						_emitByte( 0x90 );
						i--;
					}
				}while( i );
#	endif
			}

			// legacy NOPs, only 0x90
			// In 64-bit mode, we can't use 0x66 prefix
			do
			{
				_emitByte( 0x90 );
			} while( --i );
		}

		//------------------------------------------------------------------------------
		CLabel Cx86CPUCore::newLabel() __QCMP_THROW
		{
			CLabel label;
			label.setId( (Cmp_unsigned__int32)m_LabelData.getLength() | OPERAND_ID_TYPE_LABEL );

			LabelData l_data;
			l_data.offset = -1;
			l_data.links = 0;
			m_LabelData.append( l_data );

			return label;
		}

		//------------------------------------------------------------------------------
		void Cx86CPUCore::registerLabels( Cmp_uint_ptr count ) __QCMP_THROW
		{
			// Duplicated newLabel() code, but we are not creating Label instances.
			LabelData l_data;
			l_data.offset = -1;
			l_data.links = 0;

			for( Cmp_uint_ptr i = 0; i < count; i++ )
			{
				m_LabelData.append( l_data );
			}
		}

		//------------------------------------------------------------------------------
		void Cx86CPUCore::bind( const CLabel& label ) __QCMP_THROW
		{
			assert( label.getId() != INVALID_VALUE );											// Only labels created by newLabel() can be used by Assembler.
			assert( ( label.getId() & OPERAND_ID_VALUE_MASK ) < m_LabelData.getLength() );		// Never go out of bounds.
			LabelData& l_data = m_LabelData[ label.getId() & OPERAND_ID_VALUE_MASK ];			// Get label data based on label id.
			assert( l_data.offset == -1 );														// Label can be bound only once.

			if( m_pLogger )																		// Log.
			{
				m_pLogger->logFormat( "L.%u:\n", (Cmp_unsigned__int32)label.getId() & OPERAND_ID_VALUE_MASK );
			}

			Cmp_int_ptr pos = getOffset();

			LabelLink* link = l_data.links;
			LabelLink* prev = 0;

			while( link )
			{
				Cmp_int_ptr offset = link->offset;

				if( link->relocId != -1 )
				{
					// If linked label points to RelocData then instead of writing relative
					// displacement to assembler stream, we will write it to RelocData.
					m_RelocData[ link->relocId ].destination += pos;
				}
				else
				{
					// Not using relocId, this means that we overwriting real displacement in assembler stream.
					Cmp__int32 patchedValue = (Cmp__int32)( pos - offset + link->displacement );
					Cmp_unsigned__int32 size = getByteAt( offset );

					// Only these size specifiers are allowed.
					//assert( size == 1 || size == 4 );

					if( size == 4 )
					{
						setInt32At( offset, patchedValue );
					}
					else // if (size == 1)
					{
						if( nsCodeQOR::isInt8( patchedValue ) )
						{
							setByteAt( offset, (Cmp_unsigned__int8)(Cmp__int8)patchedValue );
						}
						else
						{
							// Fatal error.
							setError( ERROR_ILLEGAL_SHORT_JUMP );
						}
					}
				}

				prev = link->prev;

				if( link != prev )
				{
					link = prev;
				}
				else
				{
					link = 0;
				}
			}

			// Chain unused links.
			link = l_data.links;
			if( link )
			{
				if( prev == 0 )
				{
					prev = link;
				}

				prev->prev = m_pUnusedLinks;
				m_pUnusedLinks = link;
			}

			// Unlink label if it was linked.
			l_data.offset = pos;
			l_data.links = 0;
		}

		//------------------------------------------------------------------------------
		void Cx86CPUCore::_emitInstruction( Cmp_unsigned__int32 code ) __QCMP_THROW
		{
			_emitInstruction( code, 0, 0, 0 );
		}

		//------------------------------------------------------------------------------
		void Cx86CPUCore::_emitInstruction( Cmp_unsigned__int32 code, const COperand* o0 ) __QCMP_THROW
		{
			_emitInstruction( code, o0, 0, 0 );
		}

		//------------------------------------------------------------------------------
		void Cx86CPUCore::_emitInstruction( Cmp_unsigned__int32 code, const COperand* o0, const COperand* o1 ) __QCMP_THROW
		{
			_emitInstruction( code, o0, o1, 0 );
		}

		//------------------------------------------------------------------------------
		void Cx86CPUCore::_emitInstruction( Cmp_unsigned__int32 code, const COperand* o0, const COperand* o1, const COperand* o2 ) __QCMP_THROW
		{
			const InstructionDescription* id = &instructionDescription[ code ];

			CInstEmitter Emitter( *this, code, o0, o1, o2 );

			if( Emitter.BeginInstruction() && Emitter.PrepareInstruction() && Emitter.LockInstruction() )
			{
				switch( id->group )
				{
				case InstructionDescription::G_EMIT:
					Emitter.InstructionG_EMIT();
					break;

				case InstructionDescription::G_ALU:
					Emitter.InstructionG_ALU();
					break;

				case InstructionDescription::G_BSWAP:
					Emitter.InstructionG_BSWAP();
					break;

				case InstructionDescription::G_BT:
					Emitter.InstructionG_BT();
					break;

				case InstructionDescription::G_CALL:
					Emitter.InstructionG_CALL();
					break;

				case InstructionDescription::G_CRC32:
					Emitter.InstructionG_CRC32();
					break;

				case InstructionDescription::G_ENTER:
					Emitter.InstructionG_ENTER();
					break;

				case InstructionDescription::G_IMUL:
					Emitter.InstructionG_IMUL();
					break;

				case InstructionDescription::G_INC_DEC:
					Emitter.InstructionG_INC_DEC();
					break;

				case InstructionDescription::G_J:
					Emitter.InstructionG_J();
					break;

				case InstructionDescription::G_JMP:
					Emitter.InstructionG_JMP();
					break;

				case InstructionDescription::G_LEA:
					Emitter.InstructionG_LEA();
					break;

				case InstructionDescription::G_M:
					Emitter.InstructionG_M();
					break;

				case InstructionDescription::G_MOV:
					Emitter.InstructionG_MOV();
					break;

				case InstructionDescription::G_MOV_PTR:
					Emitter.InstructionG_MOV_PTR();
					break;

				case InstructionDescription::G_MOVSX_MOVZX:
					Emitter.InstructionG_MOVSX_MOVZX();
					break;

#		if ( QOR_ARCH_WORDSIZE == 64 )
				case InstructionDescription::G_MOVSXD:
					Emitter.InstructionG_MOVSXD();
					break;
#		endif // ASMJIT_X64

				case InstructionDescription::G_PUSH:
					Emitter.InstructionG_PUSH();
					// ... goto G_POP ...

				case InstructionDescription::G_POP:
					Emitter.InstructionG_POP();
					break;

				case InstructionDescription::G_R_RM:
					Emitter.InstructionG_R_RM();
					break;

				case InstructionDescription::G_RM_B:
					Emitter.InstructionG_RM_B();
					break;

				case InstructionDescription::G_RM:
					Emitter.InstructionG_RM();
					break;

				case InstructionDescription::G_RM_R:
					Emitter.InstructionG_RM_R();
					break;

				case InstructionDescription::G_REP:
					Emitter.InstructionG_REP();
					return;

				case InstructionDescription::G_RET:
					Emitter.InstructionG_RET();
					break;

				case InstructionDescription::G_ROT:
					Emitter.InstructionG_ROT();
					break;

				case InstructionDescription::G_SHLD_SHRD:
					Emitter.InstructionG_SHLD_SHRD();
					break;

				case InstructionDescription::G_TEST:
					Emitter.InstructionG_TEST();
					break;

				case InstructionDescription::G_XCHG:
					Emitter.InstructionG_XCHG();
					break;

				case InstructionDescription::G_MOVBE:
					Emitter.InstructionG_MOVBE();
					break;

				case InstructionDescription::G_X87_FPU:
					Emitter.InstructionG_X87_FPU();
					break;

				case InstructionDescription::G_X87_STI:
					Emitter.InstructionG_X87_STI();
					break;

				case InstructionDescription::G_X87_FSTSW:
					Emitter.InstructionG_X87_FSTSW();
					break;

				case InstructionDescription::G_X87_MEM_STI:
					Emitter.InstructionG_X87_MEM_STI();

					// ... fall through to G_X87_MEM ...

				case InstructionDescription::G_X87_MEM:
					Emitter.InstructionG_X87_MEM();
					break;

				case InstructionDescription::G_MMU_MOV:
					Emitter.InstructionG_MMU_MOV();
					break;

				case InstructionDescription::G_MMU_MOVD:
					Emitter.InstructionG_MMU_MOVD();
					break;

				case InstructionDescription::G_MMU_MOVQ:
					Emitter.InstructionG_MMU_MOVQ();
					break;

				case InstructionDescription::G_MMU_PREFETCH:
					Emitter.InstructionG_MMU_PREFETCH();
					break;

				case InstructionDescription::G_MMU_PEXTR:
					Emitter.InstructionG_MMU_PEXTR();
					break;

				case InstructionDescription::G_MMU_RMI:
					Emitter.InstructionG_MMU_RMI();
					break;

				case InstructionDescription::G_MMU_RM_IMM8:
					Emitter.InstructionG_MMU_RM_IMM8();
					break;

				case InstructionDescription::G_MMU_RM_3DNOW:
					Emitter.InstructionG_MMU_RM_3DNOW();
					break;

				}
			}

			Emitter.CleanupInstruction();
			return;
		}

		//------------------------------------------------------------------------------
		char* dumpInstruction( char* buf, Cmp_unsigned__int32 code, Cmp_unsigned__int32 emitOptions, const COperand* o0, const COperand* o1, const COperand* o2, Cmp_unsigned__int32 memRegType ) __QCMP_THROW
		{
			if( emitOptions & EMIT_OPTION_REX_PREFIX )
			{
				buf = nsCodeQOR::mycpy( buf, "rex ", 4 );
			}
			if( emitOptions & EMIT_OPTION_LOCK_PREFIX )
			{
				buf = nsCodeQOR::mycpy( buf, "lock ", 5 );
			}
			if( emitOptions & EMIT_OPTION_SHORT_JUMP )
			{
				buf = nsCodeQOR::mycpy( buf, "short ", 6 );
			}

			// Dump instruction.
			buf = dumpInstructionName( buf, code );

			// Dump operands.
			if( !o0->isNone() )
			{
				*buf++ = ' ';
				buf = dumpOperand( buf, o0, memRegType );
			}

			if( !o1->isNone() )
			{
				*buf++ = ',';
				*buf++ = ' ';
				buf = dumpOperand(buf, o1, memRegType );
			}

			if( !o2->isNone() )
			{
				*buf++ = ',';
				*buf++ = ' ';
				buf = dumpOperand( buf, o2, memRegType );
			}

			return buf;
		}

		//------------------------------------------------------------------------------
		char* dumpComment( char* buf, Cmp_uint_ptr len, const Cmp_unsigned__int8* binaryData, Cmp_uint_ptr binaryLen, const char* comment )
		{
			Cmp_uint_ptr currentLength = len;
			Cmp_uint_ptr commentLength = comment ? strlen(comment) : 0;

			if( binaryLen || commentLength )
			{
				Cmp_uint_ptr align = 32;
				char sep = ';';

				// Truncate if comment is too long (it shouldn't be, larger than 80 seems to
				// be an exploit).
				if( commentLength > 80 )
				{
					commentLength = 80;
				}

				for( Cmp_uint_ptr i = ( binaryLen == 0 ); i < 2; i++ )
				{
					char* bufBegin = buf;

					// Append align.
					if( currentLength < align )
					{
						buf = nsCodeQOR::myfill( buf, ' ', align - currentLength );
					}

					// Append separator.
					if( sep )
					{
						*buf++ = sep;
						*buf++ = ' ';
					}

					// Append binary data or comment.
					if( i == 0 )
					{
						buf = nsCodeQOR::myhex( buf, binaryData, binaryLen );
						if( commentLength == 0 )
						{
							break;
						}
					}
					else
					{
						buf = nsCodeQOR::mycpy( buf, comment, commentLength );
					}

					currentLength += (Cmp_uint_ptr)( buf - bufBegin );
					align += 18;
					sep = '|';
				}
			}

			*buf++ = '\n';
			return buf;
		}

		//------------------------------------------------------------------------------
		char* dumpInstructionName( char* buf, Cmp_unsigned__int32 code) __QCMP_THROW
		{
			assert( code < _INST_COUNT );
			return nsCodeQOR::mycpy( buf, instructionDescription[ code ].getName() );
		}

	}//nsx86
}//nsArch

#endif//( QOR_ARCH == QOR_ARCH_X86_32 || QOR_ARCH == QOR_ARCH_X86_64 )
