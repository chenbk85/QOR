//InstEmitter.cpp

// Copyright (c) 2008-2010, Petr Kobalicek <kobalicek.petr@gmail.com>
// Copyright (c) Querysoft Limited 2012
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Implements low level instruction emitter for x86 virtual processor

#include "ArchQOR.h"

#if		( QOR_ARCH == QOR_ARCH_X86_32 || QOR_ARCH == QOR_ARCH_X86_64 )

//#include "ArchQOR/Defs.h"
#include "ArchQOR/x86/Assembler/BatchCPU/x86CPUCore.h"
#include "ArchQOR/x86/Assembler/Operands/Registers/BaseReg.h"
#include "ArchQOR/Common/Assembler/CodeGenerator.h"
#include "ArchQOR/Common/Assembler/Logger.h"
#include "ArchQOR/x86/Assembler/Operands/Mem.h"
#include "ArchQOR/x86/Assembler/Operands/Operand.h"
#include "ArchQOR/x86/Assembler/Operands/Imm.h"
#include "ArchQOR/x86/CPUInfo.h"
#include "ArchQOR/x86/Assembler/BatchCPU/InstEmitter.h"
#include <assert.h>
#include <string.h>
#include <stdio.h>

//------------------------------------------------------------------------------
namespace nsArch
{
	//------------------------------------------------------------------------------
	namespace nsx86
	{
		//------------------------------------------------------------------------------
		// Used for NULL operands to translate them to OPERAND_NONE.
		static const Cmp_unsigned__int8 _none[ sizeof( COperand ) ] =
		{
			0
		};

		//------------------------------------------------------------------------------
		static const CBaseReg __patchedHiReg0( REG_TYPE_GPB_LO | 4, 1 );
		static const CBaseReg __patchedHiReg1( REG_TYPE_GPB_LO | 5, 1 );
		static const CBaseReg __patchedHiReg2( REG_TYPE_GPB_LO | 6, 1 );
		static const CBaseReg __patchedHiReg3( REG_TYPE_GPB_LO | 7, 1 );

		static const CBaseReg* _patchedHiRegs[ 4 ] = {&__patchedHiReg0, &__patchedHiReg1, &__patchedHiReg2, &__patchedHiReg3 };

		//------------------------------------------------------------------------------
		CInstEmitter::CInstEmitter( Cx86CPUCore& CPUParam, Cmp_unsigned__int32 codeParam, const COperand* o0Param, const COperand* o1Param, const COperand* o2Param ) __QCMP_THROW :
		m_CPU( CPUParam )
		,m_uiCode( codeParam )
		, m_pO0( o0Param )
		, m_pO1( o1Param )
		, m_pO2( o2Param )
		, m_bLoHiUsed( 0 )
		, m_bAssertIllegal( false )
		, m_pImmOperand( 0 )
		, m_uiImmSize( 0 )
		, m_uiBeginOffset( m_CPU.getOffset() )
		, m_pId( &instructionDescription[ m_uiCode ] )
		, m_uiForceRexPrefix( ( QOR_ARCH_WORDSIZE == 32 ) ? false : m_CPU.m_uiEmitOptions & EMIT_OPTION_REX_PREFIX )
		, m_uiMemRegType( REG_TYPE_GPN )
		{
		}

		//------------------------------------------------------------------------------
		bool CInstEmitter::BeginInstruction( void ) __QCMP_THROW
		{
			bool bResult = true;

			if( m_uiCode >= _INST_COUNT )
			{
				m_CPU.setError( ERROR_UNKNOWN_INSTRUCTION );
				bResult = false;
			}
			else
			{
				// Convert operands to OPERAND_NONE if needed.
				if( m_pO0 == 0 ) 
				{ 
					m_pO0 = reinterpret_cast< const COperand* >( _none );
				} 
				else if( m_pO0->isReg() ) 
				{ 
					m_bLoHiUsed |= ( dynamic_cast< const CBaseReg* >( m_pO0 ) )->getRegCode() & ( REG_TYPE_GPB_LO | REG_TYPE_GPB_HI ); 
				}

				if( m_pO1 == 0 ) 
				{ 
					m_pO1 = reinterpret_cast< const COperand* >( _none ); 
				} 
				else if( m_pO1->isReg() ) 
				{ 
					m_bLoHiUsed |= ( dynamic_cast< const CBaseReg* >( m_pO1 ) )->getRegCode() & ( REG_TYPE_GPB_LO | REG_TYPE_GPB_HI ); 
				}

				if( m_pO2 == 0 ) 
				{ 
					m_pO2 = reinterpret_cast< const COperand* >( _none ); 
				} 
				else if( m_pO2->isReg() ) 
				{ 
					m_bLoHiUsed |= ( dynamic_cast< const CBaseReg* >( m_pO2 ) )->getRegCode() & ( REG_TYPE_GPB_LO | REG_TYPE_GPB_HI ); 
				}
			}
			return bResult;
		}

		//------------------------------------------------------------------------------
		bool CInstEmitter::PrepareInstruction( void ) __QCMP_THROW
		{
			// Check if register operand is BPL, SPL, SIL, DIL and do action that depends
			// to current mode:
			//   - 64-bit: - Force REX prefix.
			//
			// Check if register operand is AH, BH, CH or DH and do action that depends
			// to current mode:
			//   - 32-bit: - Patch operand index (index += 4), because we are using
			//               different index what is used in opcode.
			//   - 64-bit: - Check whether there is REX prefix and raise error if it is.
			//             - Do the same as in 32-bit mode - patch register index.
			//
			// NOTE: This is a hit hacky, but I added this to older code-base and I have
			// no energy to rewrite it. Maybe in future all of this can be cleaned up!
			if( m_bLoHiUsed | m_uiForceRexPrefix )
			{
				m_aLoggerOperands[ 0 ] = m_pO0;
				m_aLoggerOperands[ 1 ] = m_pO1;
				m_aLoggerOperands[ 2 ] = m_pO2;

#	if ( QOR_ARCH_WORDSIZE == 64 )
				// Check if there is register that makes this instruction un-encodable.

				m_uiForceRexPrefix |= (Cmp_unsigned__int32)m_pO0->isExtendedRegisterUsed();
				m_uiForceRexPrefix |= (Cmp_unsigned__int32)m_pO1->isExtendedRegisterUsed();
				m_uiForceRexPrefix |= (Cmp_unsigned__int32)m_pO2->isExtendedRegisterUsed();

				if( m_pO0->isRegType( REG_TYPE_GPB_LO ) && ( reinterpret_cast< const CBaseReg* >( m_pO0 )->getRegCode() & REG_INDEX_MASK ) >= 4 ) 
				{
					m_uiForceRexPrefix = true;
				}
				else if( m_pO1->isRegType( REG_TYPE_GPB_LO ) && ( reinterpret_cast< const CBaseReg* >( m_pO1 )->getRegCode() & REG_INDEX_MASK ) >= 4 )
				{
					m_uiForceRexPrefix = true;
				}
				else if( m_pO2->isRegType( REG_TYPE_GPB_LO ) && ( reinterpret_cast< const CBaseReg* >( m_pO2 )->getRegCode() & REG_INDEX_MASK ) >= 4 )
				{
					m_uiForceRexPrefix = true;
				}

				if( ( m_bLoHiUsed & REG_TYPE_GPB_HI ) != 0 && m_uiForceRexPrefix )
				{
					m_CPU.setError( ERROR_ILLEGAL_INSTRUCTION );
					m_bAssertIllegal= true;
					EndInstruction();
					return false;
				}
#	endif // ASMJIT_X64

				// Patch GPB.HI operand index.
				if( ( m_bLoHiUsed & REG_TYPE_GPB_HI ) != 0 )
				{
					if( m_pO0->isRegType( REG_TYPE_GPB_HI ) )
					{
						m_pO0 = _patchedHiRegs[ (reinterpret_cast< const CBaseReg* >( m_pO0 ) )->getRegCode() & REG_INDEX_MASK ];
					}
					if( m_pO1->isRegType( REG_TYPE_GPB_HI ) )
					{
						m_pO1 = _patchedHiRegs[ (reinterpret_cast< const CBaseReg* >( m_pO1 ) )->getRegCode() & REG_INDEX_MASK ];
					}
					if( m_pO2->isRegType( REG_TYPE_GPB_HI ) )
					{
						if (((reinterpret_cast<const CBaseReg*>(m_pO2))->getRegCode() & REG_INDEX_MASK) < 4)
						{
							m_pO2 = _patchedHiRegs[(reinterpret_cast<const CBaseReg*>(m_pO2))->getRegCode() & REG_INDEX_MASK];
						}
						else
						{
							//TOOD: raise a range error
						}
					}
				}
			}

			// Check for buffer space (and grow if needed).
			return m_CPU.canEmit();
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::FinishImmediate( const COperand* pOperand, Cmp_unsigned__int32 Size ) __QCMP_THROW
		{
			m_pImmOperand = dynamic_cast< const CImm* >( pOperand );
			m_uiImmSize = Size;
			InstructionImmediate();
			CleanupInstruction();
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::EndInstruction( void ) __QCMP_THROW
		{
			if( m_CPU.m_pLogger || m_bAssertIllegal )
			{
				char bufStorage[ 512 ];
				char* buf = bufStorage;

				// Detect truncated operand.
				CImm immTemporary( 0 );

				// Use the original operands, because BYTE some of them were replaced.
				if( m_bLoHiUsed )
				{
					m_pO0 = m_aLoggerOperands[ 0 ];
					m_pO1 = m_aLoggerOperands[ 1 ];
					m_pO2 = m_aLoggerOperands[ 2 ];
				}

				if( m_pImmOperand )
				{
					Cmp_int_ptr value = m_pImmOperand->getValue();
					bool isUnsigned = m_pImmOperand->isUnsigned();

					switch( m_uiImmSize )
					{
					case 1: 
						if( isUnsigned && !nsCodeQOR::isUInt8( value ) ) 
						{ 
							immTemporary.setValue( (Cmp_unsigned__int8)(Cmp_uint_ptr)value, true );
							break;
						}
						if( !isUnsigned && !nsCodeQOR::isInt8( value ) ) 
						{ 
							immTemporary.setValue( (Cmp_unsigned__int8)(Cmp_uint_ptr)value, false );
							break; 
						}
						break;
					case 2: 
						if( isUnsigned && !nsCodeQOR::isUInt16( value ) ) 
						{ 
							immTemporary.setValue( (Cmp_unsigned__int16)(Cmp_uint_ptr)value, true );
							break; 
						}
						if( !isUnsigned && !nsCodeQOR::isInt16( value ) ) 
						{ 
							immTemporary.setValue( (Cmp_unsigned__int16)(Cmp_uint_ptr)value, false );
							break; 
						}
						break;
					case 4: 
						if( isUnsigned && !nsCodeQOR::isUInt32( value ) ) 
						{ 
							immTemporary.setValue( (Cmp_unsigned__int32)(Cmp_uint_ptr)value, true );
							break;
						}
						if( !isUnsigned && !nsCodeQOR::isInt32( value ) ) 
						{ 
							immTemporary.setValue( (Cmp_unsigned__int32)(Cmp_uint_ptr)value, false ); 
							break; 
						}
						break;
					}

					if( immTemporary.getValue() != 0 )
					{
						if( m_pO0 == m_pImmOperand )
						{
							m_pO0 = &immTemporary;
						}
						if( m_pO1 == m_pImmOperand )
						{
							m_pO1 = &immTemporary;
						}
						if( m_pO2 == m_pImmOperand )
						{
							m_pO2 = &immTemporary;
						}
					}
				}

				buf = dumpInstruction( buf, m_uiCode, m_CPU.m_uiEmitOptions, m_pO0, m_pO1, m_pO2, m_uiMemRegType );

				if (m_CPU.m_pLogger && m_CPU.m_pLogger->getLogBinary())
				{
					buf = dumpComment( buf, (Cmp_uint_ptr)( buf - bufStorage ), m_CPU.getCode() + m_uiBeginOffset, m_CPU.getOffset() - m_uiBeginOffset, m_CPU.m_szComment );
				}
				else
				{
					buf = dumpComment( buf, (Cmp_uint_ptr)( buf - bufStorage ), 0, 0, m_CPU.m_szComment );
				}

				// We don't need to 0 terminate the resulting string.
#		if defined(ASMJIT_DEBUG)
				if( _logger )
#		endif // ASMJIT_DEBUG
				{
					m_CPU.m_pLogger->logString( bufStorage, (Cmp_uint_ptr)( buf - bufStorage ) );
				}

#		if defined(ASMJIT_DEBUG)
				if( assertIllegal )
				{
					// Here we need to 0 terminate.
					buf[ 0 ] = '\0';

					// Raise an assertion failure, because this situation shouldn't happen.
					assertionFailure( __FILE__, __LINE__, bufStorage );
				}
#		endif // ASMJIT_DEBUG
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::CleanupInstruction( void ) __QCMP_THROW
		{
			m_CPU.m_szComment = 0;
			m_CPU.m_uiEmitOptions = 0;
		}

		//------------------------------------------------------------------------------
		bool CInstEmitter::LockInstruction( void ) __QCMP_THROW
		{
			bool bResult = true;

			if( m_CPU.m_uiEmitOptions & EMIT_OPTION_LOCK_PREFIX )
			{
				if( !m_pId->isLockable() )
				{
					m_CPU.setError( ERROR_ILLEGAL_INSTRUCTION );
					m_bAssertIllegal = true;
					EndInstruction();
					bResult = false;
				}
				else
				{
					m_CPU._emitByte( 0xF0 );
				}
			}
			return bResult;
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionImmediate( void ) __QCMP_THROW
		{
			Cmp_int_ptr value = m_pImmOperand->getValue();
			switch( m_uiImmSize )
			{
			case 1: 
				m_CPU._emitByte( (Cmp_unsigned__int8 )(Cmp_uint_ptr)value );
				break;
			case 2: 
				m_CPU._emitWord( (Cmp_unsigned__int16)(Cmp_uint_ptr)value ); 
				break;
			case 4: 
				m_CPU._emitDWord( (Cmp_unsigned__int32)(Cmp_uint_ptr)value );
				break;
#		if ( QOR_ARCH_WORDSIZE == 64 )
			case 8: 
				m_CPU._emitQWord( (Cmp_unsigned__int64)(Cmp_uint_ptr)value );
				break;
#		endif // ASMJIT_X64
			default: 
				assert( 0 );
			}

			EndInstruction();
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionIllegal( void ) __QCMP_THROW
		{
			// Set an error. If we run in release mode assertion will be not used, so we
			// must inform about invalid state.
			m_CPU.setError( ERROR_ILLEGAL_INSTRUCTION );
			m_bAssertIllegal = true;
			EndInstruction();
			CleanupInstruction();
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_EMIT( void ) __QCMP_THROW
		{
			m_CPU._emitOpCode( m_pId->opCode[ 0 ] );
			EndInstruction();
			CleanupInstruction();
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_ALU( void ) __QCMP_THROW
		{
			Cmp_unsigned__int32 opCode = m_pId->opCode[0];
			Cmp_unsigned__int8 opReg = (Cmp_unsigned__int8)m_pId->opCodeR;

			// Mem <- Reg
			if( m_pO0->isMem() && m_pO1->isReg() )
			{
				m_CPU._emitX86RM( opCode + ( m_pO1->getSize() != 1 ), ( m_pO1->getSize() == 2 ), ( m_pO1->getSize() == 8 ),
					static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CGPReg* >(m_pO1)->getRegCode() ), m_pO0, 0, m_uiForceRexPrefix ? true : false );
				EndInstruction();
				CleanupInstruction();
				return;
			}

			// Reg <- Reg|Mem
			if( m_pO0->isReg() && m_pO1->isRegMem() )
			{
				m_CPU._emitX86RM( opCode + 2 + ( m_pO0->getSize() != 1 ), m_pO0->getSize() == 2, m_pO0->getSize() == 8, 
					static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CBaseReg* >(m_pO0)->getRegCode() ), m_pO1, 0, m_uiForceRexPrefix ? true : false );
				EndInstruction();
				CleanupInstruction();
				return;
			}

			// AL, AX, EAX, RAX register shortcuts
			if( m_pO0->isRegIndex( 0 ) && m_pO1->isImm() )
			{
				if( m_pO0->getSize() == 2 )
				{
					m_CPU._emitByte( 0x66 ); // 16-bit.
				}
				else if( m_pO0->getSize() == 8 )
				{
					m_CPU._emitByte( 0x48 ); // REX.W.
				}

				m_CPU._emitByte( ( opReg << 3 ) | ( 0x04 + ( m_pO0->getSize() != 1 ) ) );
				FinishImmediate( m_pO1, m_pO0->getSize() <= 4 ? m_pO0->getSize() : 4 );
			}

			if( m_pO0->isRegMem() && m_pO1->isImm() )
			{
				const CImm* pimm = dynamic_cast< const CImm* >( m_pO1 );
				m_uiImmSize = nsCodeQOR::isInt8( pimm->getValue() ) ? 1 : ( m_pO0->getSize() <= 4 ? m_pO0->getSize() : 4 );

				m_CPU._emitX86RM( m_pId->opCode[ 1 ] + ( m_pO0->getSize() != 1 ? ( m_uiImmSize != 1 ? 1 : 3 ) : 0 ), m_pO0->getSize() == 2, m_pO0->getSize() == 8, opReg, m_pO0, m_uiImmSize, m_uiForceRexPrefix ? true : false );
				FinishImmediate( pimm, m_uiImmSize );
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_BSWAP( void ) __QCMP_THROW
		{
			if( m_pO0->isReg() )
			{
				const CGPReg* pdst = dynamic_cast< const CGPReg* >( m_pO0 );

#		if ( QOR_ARCH_WORDSIZE == 64 )
				m_CPU._emitRexR( pdst->getRegType() == REG_TYPE_GPQ, 1, pdst->getRegCode(), m_uiForceRexPrefix );
#		endif // ASMJIT_X64
				m_CPU._emitByte( 0x0F );
				m_CPU._emitModR( 1, static_cast< Cmp_unsigned__int8 >( pdst->getRegCode() ) );
				EndInstruction();
				CleanupInstruction();
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_BT( void ) __QCMP_THROW
		{
			if( m_pO0->isRegMem() && m_pO1->isReg() )
			{
				const COperand* pdst = m_pO0;
				const CGPReg* psrc = dynamic_cast< const CGPReg* >( m_pO1 );

				m_CPU._emitX86RM( m_pId->opCode[ 0 ], psrc->isRegType( REG_TYPE_GPW ), psrc->isRegType( REG_TYPE_GPQ ), static_cast< Cmp_unsigned__int8 >( psrc->getRegCode() ), pdst, 0, m_uiForceRexPrefix ? true : false );
				EndInstruction();
				CleanupInstruction();
				return;
			}

			if( m_pO0->isRegMem() && m_pO1->isImm() )
			{
				const COperand* pdst = m_pO0;
				//TODO: Should this be used?
				//const Imm& src = reinterpret_cast< const Imm& >( *m_pO1 );

				m_CPU._emitX86RM( m_pId->opCode[ 1 ], pdst->getSize() == 2, pdst->getSize() == 8, (Cmp_unsigned__int8)m_pId->opCodeR, pdst, 1, m_uiForceRexPrefix ? true : false );
				FinishImmediate( m_pO1, 1 );
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_CALL( void ) __QCMP_THROW
		{
			if( m_pO0->isRegTypeMem( REG_TYPE_GPN ) )
			{
				m_CPU._emitX86RM( 0xFF, 0, 0, 2, m_pO0, 0, m_uiForceRexPrefix ? true : false );
				EndInstruction();
				CleanupInstruction();
				return;
			}

			if( m_pO0->isImm() )
			{
				const CImm* pImm = dynamic_cast< const CImm* >( m_pO0 );
				m_CPU._emitByte( 0xE8 );
				m_CPU._emitJmpOrCallReloc( InstructionDescription::G_CALL, (void*)pImm->getValue() );
				EndInstruction();
				CleanupInstruction();
				return;
			}

			if( m_pO0->isLabel() )
			{
				LabelData& l_data = m_CPU.m_LabelData[ reinterpret_cast< const CLabel* >( m_pO0 )->getId() & OPERAND_ID_VALUE_MASK ];

				if( l_data.offset != -1 )
				{
					// Bound label.
					static const Cmp_int_ptr rel32_size = 5;
					Cmp_int_ptr offs = l_data.offset - m_CPU.getOffset();

					assert( offs <= 0 );

					m_CPU._emitByte( 0xE8 );
					m_CPU._emitInt32( (Cmp__int32)( offs - rel32_size ) );
				}
				else
				{
					// Non-bound label.
					m_CPU._emitByte( 0xE8 );
					m_CPU._emitDisplacement( l_data, -4, 4 );
				}
				EndInstruction();
				CleanupInstruction();
				return;
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_CRC32( void ) __QCMP_THROW
		{
			if( m_pO0->isReg() && m_pO1->isRegMem() )
			{
				const CGPReg* pdst = dynamic_cast< const CGPReg* >( m_pO0 );
				assert( pdst->getRegType() == REG_TYPE_GPD || pdst->getRegType() == REG_TYPE_GPQ );

				m_CPU._emitX86RM( m_pId->opCode[ 0 ] + ( m_pO1->getSize() != 1 ), m_pO1->getSize() == 2, pdst->getRegType() == 8, static_cast< Cmp_unsigned__int8 >( pdst->getRegCode() ), m_pO1, 0, m_uiForceRexPrefix ? true : false );
				EndInstruction();
				CleanupInstruction();
				return;
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_ENTER( void ) __QCMP_THROW
		{
			if( m_pO0->isImm() && m_pO1->isImm() )
			{
				m_CPU._emitByte( 0xC8 );
				m_CPU._emitWord( (Cmp_unsigned__int16)(Cmp_uint_ptr)dynamic_cast< const CImm* >( m_pO2 )->getValue() );
				m_CPU._emitByte( (Cmp_unsigned__int8 )(Cmp_uint_ptr)dynamic_cast< const CImm* >( m_pO1 )->getValue() );
				EndInstruction();
				CleanupInstruction();
				return;
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_IMUL( void ) __QCMP_THROW
		{
			// 1 operand
			if( m_pO0->isRegMem() && m_pO1->isNone() && m_pO2->isNone() )
			{
				m_CPU._emitX86RM( 0xF6 + ( m_pO0->getSize() != 1 ), m_pO0->getSize() == 2, m_pO0->getSize() == 8, 5, m_pO0, 0, m_uiForceRexPrefix ? true : false );
				EndInstruction();
				CleanupInstruction();
				return;
			}
			// 2 operands
			else if( m_pO0->isReg() && !m_pO1->isNone() && m_pO2->isNone() )
			{
				const CGPReg* pdst = dynamic_cast< const CGPReg* >( m_pO0 );
				assert( !pdst->isRegType( REG_TYPE_GPW ) );

				if( m_pO1->isRegMem() )
				{
					m_CPU._emitX86RM( 0x0FAF, pdst->isRegType( REG_TYPE_GPW ), pdst->isRegType( REG_TYPE_GPQ ), static_cast< Cmp_unsigned__int8 >( pdst->getRegCode() ), m_pO1, 0, m_uiForceRexPrefix ? true : false );
					EndInstruction();
					CleanupInstruction();
					return;
				}
				else if( m_pO1->isImm() )
				{
					const CImm* pimm = dynamic_cast< const CImm* >( m_pO1 );

					if( nsCodeQOR::isInt8( pimm->getValue() ) )
					{
						m_CPU._emitX86RM( 0x6B, pdst->isRegType( REG_TYPE_GPW ), pdst->isRegType( REG_TYPE_GPQ ), static_cast< Cmp_unsigned__int8 >( pdst->getRegCode() ), pdst, 1, m_uiForceRexPrefix ? true : false );
						FinishImmediate( pimm, 1 );
					}
					else
					{
						m_uiImmSize = pdst->isRegType( REG_TYPE_GPW ) ? 2 : 4;
						m_CPU._emitX86RM( 0x69, pdst->isRegType( REG_TYPE_GPW ), pdst->isRegType( REG_TYPE_GPQ ), static_cast< Cmp_unsigned__int8 >( pdst->getRegCode() ), pdst, m_uiImmSize, m_uiForceRexPrefix ? true : false );
						FinishImmediate( pimm, m_uiImmSize );
					}
				}
			}
			// 3 operands
			else if( m_pO0->isReg() && m_pO1->isRegMem() && m_pO2->isImm() )
			{
				const CGPReg* pdst = dynamic_cast< const CGPReg* >( m_pO0 );
				const CImm* pimm = dynamic_cast< const CImm* >( m_pO2 );

				if( nsCodeQOR::isInt8( pimm->getValue() ) )
				{
					m_CPU._emitX86RM( 0x6B, pdst->isRegType( REG_TYPE_GPW ), pdst->isRegType( REG_TYPE_GPQ ), static_cast< Cmp_unsigned__int8 >( pdst->getRegCode() ), m_pO1, 1, m_uiForceRexPrefix ? true : false );
					FinishImmediate( pimm, 1 );
				}
				else
				{
					m_uiImmSize = pdst->isRegType( REG_TYPE_GPW ) ? 2 : 4;
					m_CPU._emitX86RM( 0x69, pdst->isRegType( REG_TYPE_GPW ), pdst->isRegType( REG_TYPE_GPQ ), static_cast< Cmp_unsigned__int8 >( pdst->getRegCode() ), m_pO1, m_uiImmSize, m_uiForceRexPrefix ? true : false );
					FinishImmediate( pimm, m_uiImmSize );
				}
			}

		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_INC_DEC( void ) __QCMP_THROW
		{
			if( m_pO0->isRegMem() )
			{
				// INC [r16|r32] in 64-bit mode is not encodable.
#		if ( QOR_ARCH_WORDSIZE == 32 )
				if( ( m_pO0->isReg() ) && ( m_pO0->isRegType( REG_TYPE_GPW ) || m_pO0->isRegType( REG_TYPE_GPD ) ) )
				{
					m_CPU._emitX86Inl( m_pId->opCode[ 0 ], m_pO0->isRegType( REG_TYPE_GPW ), 0, static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CBaseReg* >( m_pO0 )->getRegCode() ), false );
					EndInstruction();
					CleanupInstruction();
					return;
				}
#		endif // ( QOR_ARCH_WORDSIZE == 32 )

				m_CPU._emitX86RM( m_pId->opCode[ 1 ] + ( m_pO0->getSize() != 1 ), m_pO0->getSize() == 2, m_pO0->getSize() == 8, (Cmp_unsigned__int8)m_pId->opCodeR, m_pO0, 0, m_uiForceRexPrefix ? true : false );
				EndInstruction();
				CleanupInstruction();
				return;
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_J( void ) __QCMP_THROW
		{
			if( m_pO0->isLabel() )
			{
				LabelData& l_data = m_CPU.m_LabelData[ dynamic_cast< const CLabel* >( m_pO0 )->getId() & OPERAND_ID_VALUE_MASK ];

				Cmp_unsigned__int32 hint = (Cmp_unsigned__int32)( m_pO1->isImm() ? dynamic_cast< const CImm* >( m_pO1 )->getValue() : 0 );
				bool isShortJump = ( m_CPU.m_uiEmitOptions & EMIT_OPTION_SHORT_JUMP ) != 0;

				// Emit jump hint if configured for that.
				if( ( hint & ( HINT_TAKEN | HINT_NOT_TAKEN ) ) && ( m_CPU.m_uiProperties & ( 1 << PROPERTY_JUMP_HINTS ) ) )
				{
					if( hint & HINT_TAKEN )
					{
						m_CPU._emitByte( HINT_BYTE_VALUE_TAKEN );
					}
					else if( hint & HINT_NOT_TAKEN )
					{
						m_CPU._emitByte( HINT_BYTE_VALUE_NOT_TAKEN );
					}
				}

				if( l_data.offset != -1 )
				{
					// Bound label.
					static const Cmp_int_ptr rel8_size = 2;
					static const Cmp_int_ptr rel32_size = 6;
					Cmp_int_ptr offs = l_data.offset - m_CPU.getOffset();

					assert( offs <= 0 );

					if( nsCodeQOR::isInt8( offs - rel8_size ) )
					{
						m_CPU._emitByte( 0x70 | (Cmp_unsigned__int8)m_pId->opCode[ 0 ] );
						m_CPU._emitByte( (Cmp_unsigned__int8)(Cmp__int8)( offs - rel8_size ) );

						// Change the emit options so logger can log instruction correctly.
						m_CPU.m_uiEmitOptions |= EMIT_OPTION_SHORT_JUMP;
					}
					else
					{
						if( isShortJump && m_CPU.m_pLogger )
						{
							m_CPU.m_pLogger->logString( "*** ASSEMBLER WARNING: Emitting long conditional jump, but short jump instruction forced!\n" );
							m_CPU.m_uiEmitOptions &= ~EMIT_OPTION_SHORT_JUMP;
						}

						m_CPU._emitByte( 0x0F );
						m_CPU._emitByte( 0x80 | (Cmp_unsigned__int8)m_pId->opCode[ 0 ] );
						m_CPU._emitInt32( (Cmp__int32)( offs - rel32_size ) );
					}
				}
				else
				{
					// Non-bound label.
					if( isShortJump )
					{
						m_CPU._emitByte( 0x70 | (Cmp_unsigned__int8)m_pId->opCode[ 0 ] );
						m_CPU._emitDisplacement( l_data, -1, 1 );
					}
					else
					{
						m_CPU._emitByte( 0x0F );
						m_CPU._emitByte( 0x80 | (Cmp_unsigned__int8)m_pId->opCode[ 0 ] );
						m_CPU._emitDisplacement( l_data, -4, 4 );
					}
				}
				EndInstruction();
				CleanupInstruction();
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_JMP( void ) __QCMP_THROW
		{
			if( m_pO0->isRegMem() )
			{
				m_CPU._emitX86RM( 0xFF, 0, 0, 4, m_pO0, 0, m_uiForceRexPrefix ? true : false );
				EndInstruction();
				CleanupInstruction();
				return;
			}

			if( m_pO0->isImm() )
			{
				const CImm* pimm = dynamic_cast< const CImm* >( m_pO0 );
				m_CPU._emitByte( 0xE9 );
				m_CPU._emitJmpOrCallReloc( InstructionDescription::G_JMP, (void*)pimm->getValue() );
				EndInstruction();
				CleanupInstruction();
				return;
			}

			if( m_pO0->isLabel() )
			{
				LabelData& l_data = m_CPU.m_LabelData[ reinterpret_cast< const CLabel* >( m_pO0 )->getId() & OPERAND_ID_VALUE_MASK ];
				bool isShortJump = ( m_CPU.m_uiEmitOptions & EMIT_OPTION_SHORT_JUMP ) != 0;

				if( l_data.offset != -1 )
				{
					// Bound label.
					const Cmp_int_ptr rel8_size = 2;
					const Cmp_int_ptr rel32_size = 5;
					Cmp_int_ptr offs = l_data.offset - m_CPU.getOffset();

					if( nsCodeQOR::isInt8( offs - rel8_size ) )
					{
						m_CPU._emitByte( 0xEB );
						m_CPU._emitByte( (Cmp_unsigned__int8)(Cmp__int8)( offs - rel8_size ) );

						// Change the emit options so logger can log instruction correctly.
						m_CPU.m_uiEmitOptions |= EMIT_OPTION_SHORT_JUMP;
					}
					else
					{
						if( isShortJump )
						{
							if( m_CPU.m_pLogger )
							{
								m_CPU.m_pLogger->logString( "*** ASSEMBLER WARNING: Emitting long jump, but short jump instruction forced!\n" );
								m_CPU.m_uiEmitOptions &= ~EMIT_OPTION_SHORT_JUMP;
							}
						}

						m_CPU._emitByte( 0xE9 );
						m_CPU._emitInt32( (Cmp__int32)( offs - rel32_size ) );
					}
				}
				else
				{
					// Non-bound label.
					if( isShortJump )
					{
						m_CPU._emitByte( 0xEB );
						m_CPU._emitDisplacement( l_data, -1, 1 );
					}
					else
					{
						m_CPU._emitByte( 0xE9 );
						m_CPU._emitDisplacement( l_data, -4, 4 );
					}
				}
				EndInstruction();
				CleanupInstruction();
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_LEA( void ) __QCMP_THROW
		{
			if( m_pO0->isReg() && m_pO1->isMem() )
			{
				const CGPReg* pdst = dynamic_cast< const CGPReg* >( m_pO0 );
				const CMem* psrc = dynamic_cast< const CMem* >( m_pO1 );

				//Size override prefix support
				if( psrc->getSizePrefix() )
				{
					m_CPU._emitByte( 0x67 );
#if ( QOR_ARCH_WORDSIZE == 32 )
					m_uiMemRegType = REG_TYPE_GPW;
#else
					m_uiMemRegType = REG_TYPE_GPD;
#endif
				}

				m_CPU._emitX86RM( 0x8D, pdst->isRegType( REG_TYPE_GPW ), pdst->isRegType( REG_TYPE_GPQ ), static_cast< Cmp_unsigned__int8 >( pdst->getRegCode() ), psrc, 0, m_uiForceRexPrefix ? true : false );
				EndInstruction();
				CleanupInstruction();
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_M( void ) __QCMP_THROW
		{
			if( m_pO0->isMem() )
			{
				m_CPU._emitX86RM( m_pId->opCode[ 0 ], 0, (Cmp_unsigned__int8)m_pId->opCode[ 1 ], (Cmp_unsigned__int8)m_pId->opCodeR, dynamic_cast< const CMem* >( m_pO0 ), 0, m_uiForceRexPrefix ? true : false );
				EndInstruction();
				CleanupInstruction();
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_MOV( void ) __QCMP_THROW
		{
			const COperand* pdst = m_pO0;
			const COperand* psrc = m_pO1;

			switch( pdst->getType() << 4 | psrc->getType() )
			{
				// Reg <- Reg/Mem
			case( EOPERAND_REG << 4 ) | EOPERAND_REG:
				{
					// Reg <- Sreg
					if( psrc->isRegType( REG_TYPE_SEGMENT ) )
					{
						assert( pdst->isRegType( REG_TYPE_GPW ) || pdst->isRegType( REG_TYPE_GPD ) || pdst->isRegType( REG_TYPE_GPQ ) );

						m_CPU._emitX86RM( 0x8C, pdst->getSize() == 2, pdst->getSize() == 8, static_cast< Cmp_unsigned__int8 >( reinterpret_cast< const CSegmentReg* >( psrc )->getRegCode() ), pdst, 0, m_uiForceRexPrefix ? true : false );
						EndInstruction();
						CleanupInstruction();
						return;
					}

					// Sreg <- Reg/Mem
					if( pdst->isRegType( REG_TYPE_SEGMENT ) )
					{
						assert( psrc->isRegType( REG_TYPE_GPW ) || psrc->isRegType( REG_TYPE_GPD ) || psrc->isRegType( REG_TYPE_GPQ ) );

//_Emit_Mov_Sreg_RM:
						m_CPU._emitX86RM( 0x8E, psrc->getSize() == 2, psrc->getSize() == 8, static_cast< Cmp_unsigned__int8 >( reinterpret_cast< const CSegmentReg* >( pdst )->getRegCode() ), psrc, 0, m_uiForceRexPrefix ? true : false );
						EndInstruction();
						CleanupInstruction();
						return;
					}

					assert( psrc->isRegType( REG_TYPE_GPB_LO ) || psrc->isRegType( REG_TYPE_GPB_HI) || psrc->isRegType( REG_TYPE_GPW ) || psrc->isRegType( REG_TYPE_GPD ) || psrc->isRegType( REG_TYPE_GPQ ) );
					// ... fall through ...
				}
			case( EOPERAND_REG << 4 ) | EOPERAND_MEM:
				{
					//SReg <- Mem
					if( pdst->isRegType( REG_TYPE_SEGMENT ) )
					{
						m_CPU._emitX86RM( 0x8E, psrc->getSize() == 2, psrc->getSize() == 8, static_cast< Cmp_unsigned__int8 >( reinterpret_cast< const CSegmentReg* >( pdst )->getRegCode() ), psrc, 0, m_uiForceRexPrefix ? true : false );
						EndInstruction();
						CleanupInstruction();
						return;
					}

					assert( pdst->isRegType( REG_TYPE_GPB_LO ) || pdst->isRegType( REG_TYPE_GPB_HI ) || pdst->isRegType( REG_TYPE_GPW ) || pdst->isRegType( REG_TYPE_GPD ) || pdst->isRegType( REG_TYPE_GPQ ) );

					m_CPU._emitX86RM( 0x0000008A + ( pdst->getSize() != 1 ), pdst->isRegType( REG_TYPE_GPW ), pdst->isRegType( REG_TYPE_GPQ ), static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CBaseReg* >( pdst )->getRegCode() ), psrc, 0, m_uiForceRexPrefix ? true : false );
					EndInstruction();
					CleanupInstruction();
					return;
				}
				// Reg <- Imm
			case( EOPERAND_REG << 4 ) | EOPERAND_IMM:
				{
					const CGPReg* pdst = dynamic_cast< const CGPReg* >( m_pO0 );
					const CImm* psrc = dynamic_cast< const CImm* >( m_pO1 );

					// In 64-bit mode the immediate can be 64-bits long if the
					// destination operand type is register (otherwise 32-bits).
					m_uiImmSize = pdst->getSize();

#		if ( QOR_ARCH_WORDSIZE == 64 )
					// Optimize instruction size by using 32-bit immediate if value can
					// fit into it.
					if( m_uiImmSize == 8 && nsCodeQOR::isInt32( psrc->getValue() ) )
					{
						m_CPU._emitX86RM( 0xC7,
						0, // 16BIT
						1, // REX.W
						0, // O
						pdst, 0, m_uiForceRexPrefix );
						m_uiImmSize = 4;
					}
					else
					{
#		endif // ASMJIT_X64
						m_CPU._emitX86Inl( ( pdst->getSize() == 1 ? 0xB0 : 0xB8 ), pdst->isRegType( REG_TYPE_GPW ), pdst->isRegType( REG_TYPE_GPQ ), static_cast< Cmp_unsigned__int8 >( pdst->getRegCode() ), m_uiForceRexPrefix ? true : false );
#		if ( QOR_ARCH_WORDSIZE == 64 )
					}
#		endif // ASMJIT_X64

					FinishImmediate( psrc, m_uiImmSize );
				}

				// Mem <- Reg
			case( EOPERAND_MEM << 4 ) | EOPERAND_REG:
				{
					if( psrc->isRegType( REG_TYPE_SEGMENT ) )
					{
						// Mem <- Sreg
						m_CPU._emitX86RM( 0x8C, pdst->getSize() == 2, pdst->getSize() == 8, static_cast< Cmp_unsigned__int8 >( reinterpret_cast< const CSegmentReg* >( psrc )->getRegCode() ), pdst, 0, m_uiForceRexPrefix ? true : false );
						EndInstruction();
						CleanupInstruction();
						return;
					}
					else
					{
						assert( psrc->isRegType( REG_TYPE_GPB_LO ) || psrc->isRegType( REG_TYPE_GPB_HI ) || psrc->isRegType( REG_TYPE_GPW ) || psrc->isRegType( REG_TYPE_GPD ) || psrc->isRegType( REG_TYPE_GPQ ) );

						m_CPU._emitX86RM( 0x88 + ( psrc->getSize() != 1 ), psrc->isRegType( REG_TYPE_GPW ), psrc->isRegType( REG_TYPE_GPQ ),
							static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CBaseReg* >( psrc )->getRegCode() ), pdst, 0, m_uiForceRexPrefix ? true : false );
						EndInstruction();
						CleanupInstruction();
						return;
					}
				}
				// Mem <- Imm
			case( EOPERAND_MEM << 4) | EOPERAND_IMM:
				{
					m_uiImmSize = pdst->getSize() <= 4 ? pdst->getSize() : 4;
					m_CPU._emitX86RM( 0xC6 + ( pdst->getSize() != 1 ), pdst->getSize() == 2, pdst->getSize() == 8, 0, pdst, m_uiImmSize, m_uiForceRexPrefix ? true : false );
					FinishImmediate( psrc, m_uiImmSize );
				}
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_MOV_PTR( void ) __QCMP_THROW
		{
			if( ( m_pO0->isReg() && m_pO1->isImm() ) || ( m_pO0->isImm() && m_pO1->isReg() ) )
			{
				bool reverse = m_pO1->getType() == EOPERAND_REG;
				Cmp_unsigned__int8 opCode = !reverse ? 0xA0 : 0xA2;
				const CGPReg* preg = dynamic_cast< const CGPReg* >( !reverse ? m_pO0 : m_pO1 );
				const CImm* pimm = dynamic_cast< const CImm* >( !reverse ? m_pO1 : m_pO0 );

				if( preg->getRegIndex() != 0 )
				{
					InstructionIllegal();
					return;
				}

				if( preg->isRegType( REG_TYPE_GPW ) )
				{
					m_CPU._emitByte( 0x66 );
				}
#		if ( QOR_ARCH_WORDSIZE == 64 )
				m_CPU._emitRexR( preg->getSize() == 8, 0, 0, m_uiForceRexPrefix );
#		endif // ASMJIT_X64
				m_CPU._emitByte( opCode + ( preg->getSize() != 1 ) );
				FinishImmediate( pimm, sizeof( Cmp_int_ptr ) );
			}

		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_MOVSX_MOVZX( void ) __QCMP_THROW
		{
			if( m_pO0->isReg() && m_pO1->isRegMem() )
			{
				const CGPReg* pdst = dynamic_cast< const CGPReg* >( m_pO0 );
				const COperand* psrc = dynamic_cast< const COperand* >( m_pO1 );

				if( pdst->getSize() == 1 )
				{
					InstructionIllegal();
					return;
				}
				if( psrc->getSize() != 1 && psrc->getSize() != 2 )
				{
					InstructionIllegal();
					return;
				}
				if( psrc->getSize() == 2 && pdst->getSize() == 2 )
				{
					InstructionIllegal();
					return;
				}

				m_CPU._emitX86RM( m_pId->opCode[ 0 ] + ( psrc->getSize() != 1 ), pdst->isRegType( REG_TYPE_GPW ), pdst->isRegType( REG_TYPE_GPQ ), static_cast< Cmp_unsigned__int8 >( pdst->getRegCode() ), psrc, 0, m_uiForceRexPrefix ? true : false );
				EndInstruction();
				CleanupInstruction();
			}
		}

		//------------------------------------------------------------------------------
#		if ( QOR_ARCH_WORDSIZE == 64 )
		void CInstEmitter::InstructionG_MOVSXD( void ) __QCMP_THROW
		{
			if( m_pO0->isReg() && m_pO1->isRegMem() )
			{
				const CGPReg* pdst = dynamic_cast< const CGPReg* >( m_pO0 );
				m_CPU._emitX86RM( 0x00000063, 0, 1, pdst->getRegCode(), m_pO1, 0, m_uiForceRexPrefix );
				EndInstruction();
				CleanupInstruction();
				return;
			}
		}

		//------------------------------------------------------------------------------
#		endif
		void CInstEmitter::InstructionG_PUSH( void ) __QCMP_THROW
		{
			// This section is only for immediates, memory/register operands are handled in G_POP.
			if( m_pO0->isImm() )
			{
				const CImm* pimm = dynamic_cast< const CImm* >( m_pO0 );

				if( nsCodeQOR::isInt8( pimm->getValue() ) )
				{
					m_CPU._emitByte( 0x6A );
					FinishImmediate( pimm, 1 );
				}
				else
				{
					m_CPU._emitByte( 0x68 );
					FinishImmediate( pimm, 4 );
				}
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_POP( void ) __QCMP_THROW
		{
			if( m_pO0->isReg() )
			{
				assert( m_pO0->isRegType( REG_TYPE_GPW ) || m_pO0->isRegType( REG_TYPE_GPN ) );
				m_CPU._emitX86Inl( m_pId->opCode[ 0 ], m_pO0->isRegType( REG_TYPE_GPW ), 0, static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CBaseReg* >( m_pO0 )->getRegCode() ), m_uiForceRexPrefix ? true : false );
				EndInstruction();
				CleanupInstruction();
				return;
			}

			if( m_pO0->isMem() )
			{
				m_CPU._emitX86RM( m_pId->opCode[ 1 ], m_pO0->getSize() == 2, 0, (Cmp_unsigned__int8)m_pId->opCodeR, m_pO0, 0, m_uiForceRexPrefix ? true : false );
				EndInstruction();
				CleanupInstruction();
				return;
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_R_RM( void ) __QCMP_THROW
		{
			if( m_pO0->isReg() && m_pO1->isRegMem() )
			{
				const CGPReg* pdst = dynamic_cast< const CGPReg* >( m_pO0 );
				const COperand* psrc = dynamic_cast< const COperand* >( m_pO1 );
				assert( pdst->getSize() != 1 );

				m_CPU._emitX86RM( m_pId->opCode[ 0 ], pdst->getRegType() == REG_TYPE_GPW, pdst->getRegType() == REG_TYPE_GPQ, static_cast< Cmp_unsigned__int8 >( pdst->getRegCode() ), psrc, 0, m_uiForceRexPrefix ? true : false );
				EndInstruction();
				CleanupInstruction();
				return;
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_RM_B( void ) __QCMP_THROW
		{
			if( m_pO0->isRegMem() )
			{
				// Only BYTE register or BYTE/TYPELESS memory location can be used.
				assert( m_pO0->getSize() <= 1 );
        
				m_CPU._emitX86RM( m_pId->opCode[ 0 ], false, false, 0, m_pO0, 0, m_uiForceRexPrefix ? true : false );
				EndInstruction();
				CleanupInstruction();
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_RM( void ) __QCMP_THROW
		{
			if( m_pO0->isRegMem() )
			{
				m_CPU._emitX86RM( m_pId->opCode[ 0 ] + ( m_pO0->getSize() != 1 ), m_pO0->getSize() == 2, m_pO0->getSize() == 8, (Cmp_unsigned__int8)m_pId->opCodeR, m_pO0, 0, m_uiForceRexPrefix ? true : false );
				EndInstruction();
				CleanupInstruction();
				return;
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_RM_R( void ) __QCMP_THROW
		{
			if( m_pO0->isRegMem() && m_pO1->isReg() )
			{
				const COperand* pdst = m_pO0;
				const CGPReg* psrc = dynamic_cast< const CGPReg* >( m_pO1 );
				m_CPU._emitX86RM( m_pId->opCode[ 0 ] + ( psrc->getSize() != 1 ), psrc->getRegType() == REG_TYPE_GPW, psrc->getRegType() == REG_TYPE_GPQ, static_cast< Cmp_unsigned__int8 >( psrc->getRegCode() ), pdst, 0, m_uiForceRexPrefix ? true : false );
				EndInstruction();
				CleanupInstruction();
				return;
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_REP( void ) __QCMP_THROW
		{
			Cmp_unsigned__int32 opCode = m_pId->opCode[ 0 ];
			Cmp_unsigned__int32 opSize = m_pId->opCode[ 1 ];

			// Emit REP prefix (1 BYTE).
			m_CPU._emitByte( opCode >> 24 );

			if( opSize != 1 )
			{
				opCode++; // D, Q and W form.
			}
			if( opSize == 2 )
			{
				m_CPU._emitByte( 0x66 ); // 16-bit prefix.
			}
#		if ( QOR_ARCH_WORDSIZE == 64 )
			else if( opSize == 8 )
			{
				m_CPU._emitByte( 0x48 ); // REX.W prefix.
			}
#		endif // ASMJIT_X64

			// Emit opcode (1 BYTE).
			m_CPU._emitByte( opCode & 0xFF );
			EndInstruction();
			CleanupInstruction();
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_RET( void ) __QCMP_THROW
		{
			if( m_pO0->isNone() )
			{
				m_CPU._emitByte( 0xC3 );
				EndInstruction();
				CleanupInstruction();
				return;
			}
			else if( m_pO0->isImm() )
			{
				const CImm* pimm = dynamic_cast< const CImm* >( m_pO0 );
				assert( nsCodeQOR::isUInt16( pimm->getValue() ) );

				if( pimm->getValue() == 0 )
				{
					m_CPU._emitByte( 0xC3 );
					EndInstruction();
					CleanupInstruction();
					return;
				}
				else
				{
					m_CPU._emitByte( 0xC2 );
					FinishImmediate( pimm, 2 );
				}
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_ROT( void ) __QCMP_THROW
		{
			if( m_pO0->isRegMem() && ( m_pO1->isRegCode( REG_CL ) || m_pO1->isImm() ) )
			{
				// generate opcode. For these operations is base 0xC0 or 0xD0.
				bool useImm8 = m_pO1->isImm() && dynamic_cast< const CImm* >( m_pO1 )->getValue() != 1;
				Cmp_unsigned__int32 opCode = useImm8 ? 0xC0 : 0xD0;

				// size and operand type modifies the opcode
				if( m_pO0->getSize() != 1 )
				{
					opCode |= 0x01;
				}
				if( m_pO1->getType() == EOPERAND_REG )
				{
					opCode |= 0x02;
				}

				m_CPU._emitX86RM( opCode, m_pO0->getSize() == 2, m_pO0->getSize() == 8, (Cmp_unsigned__int8)m_pId->opCodeR, m_pO0, useImm8 ? 1 : 0, m_uiForceRexPrefix ? true : false );

				if( useImm8 )
				{
					FinishImmediate( m_pO1, 1 );
				}
				else
				{
					EndInstruction();
					CleanupInstruction();
					return;
				}
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_SHLD_SHRD( void ) __QCMP_THROW
		{
			if( m_pO0->isRegMem() && m_pO1->isReg() && ( m_pO2->isImm() || ( m_pO2->isReg() && m_pO2->isRegCode( REG_CL ) ) ) )
			{
				const COperand* pdst = m_pO0;
				const CGPReg* psrc1 = dynamic_cast< const CGPReg* >( m_pO1 );
				const COperand* psrc2 = m_pO2;

				assert( pdst->getSize() == psrc1->getSize() );

				m_CPU._emitX86RM( m_pId->opCode[ 0 ] + psrc2->isReg(), psrc1->isRegType( REG_TYPE_GPW ), psrc1->isRegType( REG_TYPE_GPQ ), static_cast< Cmp_unsigned__int8 >( psrc1->getRegCode() ), pdst, psrc2->isImm() ? 1 : 0, m_uiForceRexPrefix ? true : false );
				if( psrc2->isImm() )
				{
					FinishImmediate( psrc2, 1 );
				}
				else
				{
					EndInstruction();
					CleanupInstruction();
				}
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_TEST( void ) __QCMP_THROW
		{
			if( m_pO0->isRegMem() && m_pO1->isReg() )
			{
				//TODO: Check - assert( m_pO0->getSize() == m_pO1->getSize() );
				m_CPU._emitX86RM( 0x84 + ( m_pO1->getSize() != 1 ), m_pO1->getSize() == 2, m_pO1->getSize() == 8, static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CBaseReg* >( m_pO1 )->getRegCode() ), m_pO0, 0, m_uiForceRexPrefix ? true : false );
				EndInstruction();
				CleanupInstruction();
				return;
			}

			if( m_pO0->isRegIndex( 0 ) && m_pO1->isImm() )
			{
				m_uiImmSize = m_pO0->getSize() <= 4 ? m_pO0->getSize() : 4;

				if( m_pO0->getSize() == 2 )
				{
					m_CPU._emitByte( 0x66 ); // 16-bit.
				}
#		if ( QOR_ARCH_WORDSIZE == 64 )
				m_CPU._emitRexRM( m_pO0->getSize() == 8, 0, *m_pO0, m_uiForceRexPrefix );
#		endif // ASMJIT_X64
				m_CPU._emitByte( 0xA8 + ( m_pO0->getSize() != 1 ) );
				FinishImmediate( m_pO1, m_uiImmSize );
			}

			if( m_pO0->isRegMem() && m_pO1->isImm() )
			{
				m_uiImmSize = m_pO0->getSize() <= 4 ? m_pO0->getSize() : 4;

				if( m_pO0->getSize() == 2 )
				{
					m_CPU._emitByte( 0x66 ); // 16-bit.
				}
				m_CPU._emitSegmentPrefix( m_pO0 ); // Segment prefix.
#		if ( QOR_ARCH_WORDSIZE == 64 )
				m_CPU._emitRexRM( m_pO0->getSize() == 8, 0, *m_pO0, m_uiForceRexPrefix );
#		endif // ASMJIT_X64
				m_CPU._emitByte( 0xF6 + ( m_pO0->getSize() != 1 ) );
				m_CPU._emitModRM( 0, m_pO0, m_uiImmSize );
				FinishImmediate( m_pO1, m_uiImmSize );
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_XCHG( void ) __QCMP_THROW
		{
			if( m_pO0->isRegMem() && m_pO1->isReg() )
			{
				const COperand* pdst = m_pO0;
				const CGPReg* psrc = dynamic_cast< const CGPReg* >( m_pO1 );

				if( psrc->isRegType( REG_TYPE_GPW ) )
				{
					m_CPU._emitByte( 0x66 ); // 16-bit.
				}
				m_CPU._emitSegmentPrefix( pdst ); // segment prefix
#		if ( QOR_ARCH_WORDSIZE == 64 )
				m_CPU._emitRexRM( psrc->isRegType( REG_TYPE_GPQ ), psrc->getRegCode(), *pdst, m_uiForceRexPrefix );
#		endif // ASMJIT_X64

				// Special opcode for index 0 registers (AX, EAX, RAX vs register).
				if( ( pdst->getType() == EOPERAND_REG && pdst->getSize() > 1 ) && ( ( dynamic_cast< const CGPReg* >( pdst ) )->getRegCode() == 0 || dynamic_cast< const CGPReg* >( psrc )->getRegCode() == 0 ) )
				{
					Cmp_unsigned__int8 index = static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CGPReg* >( pdst )->getRegCode() | psrc->getRegCode() );
					m_CPU._emitByte( 0x90 + index );
					EndInstruction();
					CleanupInstruction();
					return;
				}

				m_CPU._emitByte( 0x86 + ( psrc->getSize() != 1 ) );
				m_CPU._emitModRM( static_cast< Cmp_unsigned__int8 >( psrc->getRegCode() ), pdst, 0 );
				EndInstruction();
				CleanupInstruction();
				return;
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_MOVBE( void ) __QCMP_THROW
		{
			if( m_pO0->isReg() && m_pO1->isMem() )
			{
				m_CPU._emitX86RM( 0x000F38F0, m_pO0->isRegType( REG_TYPE_GPW ), m_pO0->isRegType( REG_TYPE_GPQ ), static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CGPReg* >( m_pO0 )->getRegCode() ), dynamic_cast< const CMem* >( m_pO1 ), 0, m_uiForceRexPrefix ? true : false );
				EndInstruction();
				CleanupInstruction();
				return;
			}

			if( m_pO0->isMem() && m_pO1->isReg() )
			{
				m_CPU._emitX86RM( 0x000F38F1, m_pO1->isRegType( REG_TYPE_GPW ), m_pO1->isRegType( REG_TYPE_GPQ ), static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CGPReg* >( m_pO1 )->getRegCode() ), dynamic_cast< const CMem* >( m_pO0 ), 0, m_uiForceRexPrefix ? true : false );
				EndInstruction();
				CleanupInstruction();
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_X87_FPU( void ) __QCMP_THROW
		{
			if( m_pO0->isRegType( REG_TYPE_X87 ) )
			{
				Cmp_unsigned__int8 i1 = static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CX87Reg* >( m_pO0 )->getRegIndex() );
				Cmp_unsigned__int8 i2 = 0;

				if( m_uiCode != INST_FCOM && m_uiCode != INST_FCOMP )
				{
					if( !m_pO1->isRegType( REG_TYPE_X87 ) )
					{
						InstructionIllegal();
						return;
					}
					i2 = static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CX87Reg* >( m_pO1 )->getRegIndex() );
				}
				else if( i1 != 0 && i2 != 0 )
				{
					InstructionIllegal();
					return;
				}

				m_CPU._emitByte( static_cast< Cmp_unsigned__int8 >( i1 == 0 ? ( ( m_pId->opCode[ 0 ] & 0xFF000000 ) >> 24 ) : ( ( m_pId->opCode[ 0 ] & 0x00FF0000 ) >> 16 ) ) );
				m_CPU._emitByte( i1 == 0 ? ( ( m_pId->opCode[ 0 ] & 0x0000FF00 ) >>  8 ) + i2 : ( ( m_pId->opCode[ 0 ] & 0x000000FF ) ) + i1 );
				EndInstruction();
				CleanupInstruction();
				return;
			}

			if( m_pO0->isMem() && ( m_pO0->getSize() == 4 || m_pO0->getSize() == 8 ) && m_pO1->isNone() )
			{
				const CMem* pm = dynamic_cast< const CMem* >( m_pO0 );

				// segment prefix
				m_CPU._emitSegmentPrefix( pm );

				m_CPU._emitByte( static_cast< Cmp_unsigned__int8 >( m_pO0->getSize() == 4 ? ( ( m_pId->opCode[ 0 ] & 0xFF000000 ) >> 24 ) : ( ( m_pId->opCode[ 0 ] & 0x00FF0000 ) >> 16 ) ) );
				m_CPU._emitModM( (Cmp_unsigned__int8)m_pId->opCodeR, pm, 0 );
				EndInstruction();
				CleanupInstruction();
				return;
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_X87_STI( void ) __QCMP_THROW
		{
			if( m_pO0->isRegType( REG_TYPE_X87 ) )
			{
				Cmp_unsigned__int8 i = static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CX87Reg* >( m_pO0 )->getRegIndex() );
				m_CPU._emitByte( (Cmp_unsigned__int8)( ( m_pId->opCode[ 0 ] & 0x0000FF00 ) >> 8 ) );
				m_CPU._emitByte( (Cmp_unsigned__int8)( ( m_pId->opCode[ 0 ] & 0x000000FF ) + i ) );
				EndInstruction();
				CleanupInstruction();
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_X87_FSTSW( void ) __QCMP_THROW
		{
			if( m_pO0->isReg() && dynamic_cast< const CBaseReg* >( m_pO0 )->getRegType() <= REG_TYPE_GPQ && dynamic_cast< const CBaseReg* >( m_pO0 )->getRegIndex() == 0 )
			{
				m_CPU._emitOpCode( m_pId->opCode[ 1 ] );
				EndInstruction();
				CleanupInstruction();
				return;
			}

			if( m_pO0->isMem() )
			{
				m_CPU._emitX86RM( m_pId->opCode[ 0 ], 0, 0, (Cmp_unsigned__int8)m_pId->opCodeR, dynamic_cast< const CMem* >( m_pO0 ), 0, m_uiForceRexPrefix ? true : false );
				EndInstruction();
				CleanupInstruction();
				return;
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_X87_MEM_STI( void ) __QCMP_THROW
		{
			if( m_pO0->isRegType( REG_TYPE_X87 ) )
			{
				m_CPU._emitByte( (Cmp_unsigned__int8)( ( m_pId->opCode[ 1 ] & 0xFF000000 ) >> 24 ) );
				m_CPU._emitByte( (Cmp_unsigned__int8)( ( m_pId->opCode[ 1 ] & 0x00FF0000 ) >> 16 ) + static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CX87Reg* >( m_pO0 )->getRegIndex() ) );
				EndInstruction();
				CleanupInstruction();
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_X87_MEM( void ) __QCMP_THROW
		{
			if( !m_pO0->isMem() )
			{
				InstructionIllegal();
				return;
			}
			const CMem* pm = dynamic_cast< const CMem* >( m_pO0 );

			Cmp_unsigned__int8 opCode = 0x00, mod = 0;

			if( m_pO0->getSize() == 2 && ( m_pId->oflags[ 0 ] & InstructionDescription::O_FM_2 ) )
			{
				opCode = (Cmp_unsigned__int8)( ( m_pId->opCode[ 0 ] & 0xFF000000 ) >> 24 );
				mod    = (Cmp_unsigned__int8)m_pId->opCodeR;
			}

			if( m_pO0->getSize() == 4 && ( m_pId->oflags[ 0 ] & InstructionDescription::O_FM_4 ) )
			{
				opCode = (Cmp_unsigned__int8)( ( m_pId->opCode[ 0 ] & 0x00FF0000 ) >> 16 );
				mod    = (Cmp_unsigned__int8)m_pId->opCodeR;
			}

			if( m_pO0->getSize() == 8 && ( m_pId->oflags[ 0 ] & InstructionDescription::O_FM_8 ) )
			{
				opCode = (Cmp_unsigned__int8)( ( m_pId->opCode[ 0 ] & 0x0000FF00 ) >>  8 );
				mod    = (Cmp_unsigned__int8)( ( m_pId->opCode[ 0 ] & 0x000000FF )       );
			}

			if( opCode )
			{
				m_CPU._emitSegmentPrefix( pm );
				m_CPU._emitByte( opCode );
				m_CPU._emitModM( mod, pm, 0 );
				EndInstruction();
				CleanupInstruction();
				return;
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_MMU_MOV( void ) __QCMP_THROW
		{
			assert( m_pId->oflags[ 0 ] != 0 );
			assert( m_pId->oflags[ 1 ] != 0 );

			// Check parameters (X)MM|GP32_64 <- (X)MM|GP32_64|Mem|Imm
			if( ( m_pO0->isMem() && ( m_pId->oflags[ 0 ] & InstructionDescription::O_MEM ) == 0 ) ||
				( m_pO0->isRegType( REG_TYPE_MM ) && ( m_pId->oflags[ 0 ] & InstructionDescription::O_MM ) == 0 ) ||
				( m_pO0->isRegType( REG_TYPE_XMM ) && ( m_pId->oflags[ 0 ] & InstructionDescription::O_XMM ) == 0 ) ||
				( m_pO0->isRegType( REG_TYPE_GPD ) && ( m_pId->oflags[ 0 ] & InstructionDescription::O_GD ) == 0 ) ||
				( m_pO0->isRegType( REG_TYPE_GPQ ) && ( m_pId->oflags[ 0 ] & InstructionDescription::O_GQ ) == 0 ) ||
				( m_pO1->isRegType( REG_TYPE_MM ) && ( m_pId->oflags[ 1 ] & InstructionDescription::O_MM ) == 0 ) ||
				( m_pO1->isRegType( REG_TYPE_XMM ) && ( m_pId->oflags[ 1 ] & InstructionDescription::O_XMM ) == 0 ) ||
				( m_pO1->isRegType( REG_TYPE_GPD ) && ( m_pId->oflags[ 1 ] & InstructionDescription::O_GD ) == 0 ) ||
				( m_pO1->isRegType( REG_TYPE_GPQ ) && ( m_pId->oflags[ 1 ] & InstructionDescription::O_GQ ) == 0 ) ||
				( m_pO1->isMem()                 && ( m_pId->oflags[ 1 ] & InstructionDescription::O_MEM ) == 0 ) )
			{
				InstructionIllegal();
				return;
			}

			// Illegal.
			if( m_pO0->isMem() && m_pO1->isMem() )
			{
				InstructionIllegal();
				return;
			}

			Cmp_unsigned__int8 rexw = ( ( m_pId->oflags[ 0 ] | m_pId->oflags[ 1 ] ) & InstructionDescription::O_NOREX ) ? 0 : m_pO0->isRegType( REG_TYPE_GPQ ) | m_pO1->isRegType( REG_TYPE_GPQ );

			// (X)MM|Reg <- (X)MM|Reg
			if( m_pO0->isReg() && m_pO1->isReg() )
			{
				m_CPU._emitMmu( m_pId->opCode[ 0 ], rexw, static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CBaseReg* >( m_pO0 )->getRegCode() ), dynamic_cast< const CBaseReg* >( m_pO1 ), 0 );
				EndInstruction();
				CleanupInstruction();
				return;
			}

			// (X)MM|Reg <- Mem
			if (m_pO0->isReg() && m_pO1->isMem())
			{
				m_CPU._emitMmu( m_pId->opCode[ 0 ], rexw, static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CBaseReg* >( m_pO0 )->getRegCode() ), dynamic_cast< const CMem* >( m_pO1 ), 0 );
				EndInstruction();
				CleanupInstruction();
				return;
			}

			// Mem <- (X)MM|Reg
			if( m_pO0->isMem() && m_pO1->isReg() )
			{
				m_CPU._emitMmu( m_pId->opCode[ 1 ], rexw, static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CBaseReg* >( m_pO1 )->getRegCode() ), dynamic_cast< const CMem* >( m_pO0 ), 0 );
				EndInstruction();
				CleanupInstruction();
				return;
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_MMU_MOVD( void ) __QCMP_THROW
		{
			if( ( m_pO0->isRegType( REG_TYPE_MM ) || m_pO0->isRegType( REG_TYPE_XMM ) ) && ( m_pO1->isRegType( REG_TYPE_GPD ) || m_pO1->isMem() ) )
			{
				m_CPU._emitMmu( m_pO0->isRegType( REG_TYPE_XMM ) ? 0x66000F6E : 0x00000F6E, 0, static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CBaseReg* >( m_pO0 )->getRegCode() ), m_pO1, 0 );
				EndInstruction();
				CleanupInstruction();
				return;
			}

			if( ( m_pO0->isRegType( REG_TYPE_GPD ) || m_pO0->isMem() ) && ( m_pO1->isRegType( REG_TYPE_MM ) || m_pO1->isRegType( REG_TYPE_XMM ) ) )
			{
				m_CPU._emitMmu( m_pO1->isRegType( REG_TYPE_XMM ) ? 0x66000F7E : 0x00000F7E, 0, static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CBaseReg* >( m_pO1 )->getRegCode() ), m_pO0, 0 );
				EndInstruction();
				CleanupInstruction();
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_MMU_MOVQ( void ) __QCMP_THROW
		{
			if( m_pO0->isRegType( REG_TYPE_MM ) && m_pO1->isRegType( REG_TYPE_MM ) )
			{
				m_CPU._emitMmu( 0x00000F6F, 0, static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CMMReg* >( m_pO0 )->getRegCode() ), dynamic_cast< const CMMReg* >( m_pO1 ), 0 );
				EndInstruction();
				CleanupInstruction();
				return;
			}

			if( m_pO0->isRegType( REG_TYPE_XMM ) && m_pO1->isRegType( REG_TYPE_XMM ) )
			{
				m_CPU._emitMmu( 0xF3000F7E, 0, static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CXMMReg* >( m_pO0 )->getRegCode() ), dynamic_cast< const CXMMReg* >( m_pO1 ), 0 );
				EndInstruction();
				CleanupInstruction();
				return;
			}

			// Convenience - movdq2q
			if( m_pO0->isRegType( REG_TYPE_MM ) && m_pO1->isRegType( REG_TYPE_XMM ) )
			{
				m_CPU._emitMmu( 0xF2000FD6, 0, static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CMMReg* >( m_pO0 )->getRegCode() ), dynamic_cast< const CXMMReg* >( m_pO1 ), 0 );
				EndInstruction();
				CleanupInstruction();
				return;
			}

			// Convenience - movq2dq
			if( m_pO0->isRegType( REG_TYPE_XMM ) && m_pO1->isRegType( REG_TYPE_MM ) )
			{
				m_CPU._emitMmu( 0xF3000FD6, 0, static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CXMMReg* >( m_pO0 )->getRegCode() ), dynamic_cast< const CMMReg* >( m_pO1 ), 0 );
				EndInstruction();
				CleanupInstruction();
				return;
			}

			if( m_pO0->isRegType(REG_TYPE_MM) && m_pO1->isMem() )
			{
				m_CPU._emitMmu( 0x00000F6F, 0, static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CMMReg* >( m_pO0 )->getRegCode() ), dynamic_cast< const CMem* >( m_pO1 ), 0 );
				EndInstruction();
				CleanupInstruction();
				return;
			}

			if( m_pO0->isRegType( REG_TYPE_XMM ) && m_pO1->isMem() )
			{
				m_CPU._emitMmu( 0xF3000F7E, 0, static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CXMMReg* >( m_pO0 )->getRegCode() ), dynamic_cast< const CMem* >( m_pO1 ), 0 );
				EndInstruction();
				CleanupInstruction();
				return;
			}

			if( m_pO0->isMem() && m_pO1->isRegType( REG_TYPE_MM ) )
			{
				m_CPU._emitMmu( 0x00000F7F, 0, static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CMMReg* >( m_pO1 )->getRegCode() ), dynamic_cast< const CMem* >( m_pO0 ), 0 );
				EndInstruction();
				CleanupInstruction();
				return;
			}

			if( m_pO0->isMem() && m_pO1->isRegType( REG_TYPE_XMM ) )
			{
				m_CPU._emitMmu( 0x66000FD6, 0, static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CXMMReg* >( m_pO1 )->getRegCode() ), dynamic_cast< const CMem* >( m_pO0 ), 0 );
				EndInstruction();
				CleanupInstruction();
				return;
			}

#		if ( QOR_ARCH_WORDSIZE == 64 )
			if( ( m_pO0->isRegType( REG_TYPE_MM ) || m_pO0->isRegType( REG_TYPE_XMM ) ) && ( m_pO1->isRegType( REG_TYPE_GPQ ) || m_pO1->isMem() ) )
			{
				m_CPU._emitMmu( m_pO0->isRegType( REG_TYPE_XMM ) ? 0x66000F6E : 0x00000F6E, 1, dynamic_cast< const CBaseReg* >( m_pO0 )->getRegCode(), m_pO1, 0 );
				EndInstruction();
				CleanupInstruction();
				return;
			}

			if( ( m_pO0->isRegType( REG_TYPE_GPQ ) || m_pO0->isMem() ) && ( m_pO1->isRegType( REG_TYPE_MM ) || m_pO1->isRegType( REG_TYPE_XMM ) ) )
			{
				m_CPU._emitMmu( m_pO1->isRegType( REG_TYPE_XMM ) ? 0x66000F7E : 0x00000F7E, 1, dynamic_cast< const CBaseReg* >( m_pO1 )->getRegCode(), m_pO0, 0 );
				EndInstruction();
				CleanupInstruction();
			}
#		endif
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_MMU_PREFETCH( void ) __QCMP_THROW
		{
			if( m_pO0->isMem() && m_pO1->isImm() )
			{
				const CMem* pmem = dynamic_cast< const CMem* >( m_pO0 );
				const CImm* phint = dynamic_cast< const CImm* >( m_pO1 );

				m_CPU._emitMmu( 0x00000F18, 0, (Cmp_unsigned__int8)phint->getValue(), pmem, 0 );
				EndInstruction();
				CleanupInstruction();
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_MMU_PEXTR( void ) __QCMP_THROW
		{
			if( !( m_pO0->isRegMem() && ( m_pO1->isRegType( REG_TYPE_XMM ) || ( m_uiCode == INST_PEXTRW && m_pO1->isRegType( REG_TYPE_MM ) ) ) && m_pO2->isImm() ) )
			{
				InstructionIllegal();
				return;
			}

			Cmp_unsigned__int32 opCode = m_pId->opCode[ 0 ];
			Cmp_unsigned__int8 isGpdGpq = m_pO0->isRegType( REG_TYPE_GPD ) | m_pO0->isRegType( REG_TYPE_GPQ );

			if( m_uiCode == INST_PEXTRB && ( m_pO0->getSize() != 0 && m_pO0->getSize() != 1 ) && !isGpdGpq ) 
			{ 
				InstructionIllegal();
				return;
			}
			if( m_uiCode == INST_PEXTRW && ( m_pO0->getSize() != 0 && m_pO0->getSize() != 2 ) && !isGpdGpq ) 
			{ 
				InstructionIllegal();
				return;
			}
			if( m_uiCode == INST_PEXTRD && ( m_pO0->getSize() != 0 && m_pO0->getSize() != 4 ) && !isGpdGpq ) 
			{ 
				InstructionIllegal();
				return;
			}
			if( m_uiCode == INST_PEXTRQ && ( m_pO0->getSize() != 0 && m_pO0->getSize() != 8 ) && !isGpdGpq ) 
			{ 
				InstructionIllegal();
				return;
			}

			if( m_pO1->isRegType( REG_TYPE_XMM ) )
			{
				opCode |= 0x66000000;
			}

			if( m_pO0->isReg() )
			{
				m_CPU._emitMmu( opCode, static_cast< Cmp_unsigned__int8 >( m_pId->opCodeR | static_cast< Cmp_unsigned__int8 >( m_pO0->isRegType( REG_TYPE_GPQ ) ) ), static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CBaseReg* >( m_pO1 )->getRegCode() ), dynamic_cast< const CBaseReg* >( m_pO0 ), 1 );
				FinishImmediate( m_pO2, 1 );
			}

			if( m_pO0->isMem() )
			{
				m_CPU._emitMmu( opCode, (Cmp_unsigned__int8)m_pId->opCodeR, static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CBaseReg* >( m_pO1 )->getRegCode() ), dynamic_cast< const CMem* >( m_pO0 ), 1 );
				FinishImmediate( m_pO2, 1 );
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_MMU_RMI( void ) __QCMP_THROW
		{
			assert( m_pId->oflags[ 0 ] != 0 );
			assert( m_pId->oflags[ 1 ] != 0 );

			// Check parameters (X)MM|GP32_64 <- (X)MM|GP32_64|Mem|Imm
			if( !m_pO0->isReg() ||
				( m_pO0->isRegType( REG_TYPE_MM ) && ( m_pId->oflags[ 0 ] & InstructionDescription::O_MM ) == 0 ) ||
				( m_pO0->isRegType( REG_TYPE_XMM ) && ( m_pId->oflags[ 0 ] & InstructionDescription::O_XMM ) == 0 ) ||
				( m_pO0->isRegType( REG_TYPE_GPD ) && ( m_pId->oflags[ 0 ] & InstructionDescription::O_GD ) == 0 ) ||
				( m_pO0->isRegType( REG_TYPE_GPQ ) && ( m_pId->oflags[ 0 ] & InstructionDescription::O_GQ ) == 0 ) ||
				( m_pO1->isRegType( REG_TYPE_MM ) && ( m_pId->oflags[ 1 ] & InstructionDescription::O_MM ) == 0 ) ||
				( m_pO1->isRegType( REG_TYPE_XMM ) && ( m_pId->oflags[ 1 ] & InstructionDescription::O_XMM ) == 0 ) ||
				( m_pO1->isRegType( REG_TYPE_GPD ) && ( m_pId->oflags[ 1 ] & InstructionDescription::O_GD ) == 0 ) ||
				( m_pO1->isRegType( REG_TYPE_GPQ ) && ( m_pId->oflags[ 1 ] & InstructionDescription::O_GQ ) == 0 ) ||
				( m_pO1->isMem()                 && ( m_pId->oflags[ 1 ] & InstructionDescription::O_MEM ) == 0 ) ||
				( m_pO1->isImm()                 && ( m_pId->oflags[ 1 ] & InstructionDescription::O_IMM ) == 0 ) )
			{
				InstructionIllegal();
				return;
			}

			Cmp_unsigned__int32 prefix = ( ( m_pId->oflags[ 0 ] & InstructionDescription::O_MM_XMM ) == InstructionDescription::O_MM_XMM && m_pO0->isRegType( REG_TYPE_XMM ) ) || ( ( m_pId->oflags[ 1 ] & InstructionDescription::O_MM_XMM ) == InstructionDescription::O_MM_XMM && m_pO1->isRegType( REG_TYPE_XMM ) ) ? 0x66000000 : 0x00000000;
			Cmp_unsigned__int8 rexw = ( ( m_pId->oflags[ 0 ] | m_pId->oflags[ 1 ] ) & InstructionDescription::O_NOREX ) ? 0 : m_pO0->isRegType( REG_TYPE_GPQ ) | m_pO1->isRegType( REG_TYPE_GPQ );

			// (X)MM <- (X)MM (opcode0)
			if( m_pO1->isReg() )
			{
				if( ( m_pId->oflags[ 1 ] & ( InstructionDescription::O_MM_XMM | InstructionDescription::O_GQD ) ) == 0 )
				{
					InstructionIllegal();
					return;
				}
				m_CPU._emitMmu( m_pId->opCode[ 0 ] | prefix, rexw, static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CBaseReg* >( m_pO0 )->getRegCode() ), dynamic_cast< const CBaseReg* >( m_pO1 ), 0 );
				EndInstruction();
				CleanupInstruction();
				return;
			}
			// (X)MM <- Mem (opcode0)
			if( m_pO1->isMem() )
			{
				if( ( m_pId->oflags[ 1 ] & InstructionDescription::O_MEM ) == 0 )
				{
					InstructionIllegal();
					return;
				}
				m_CPU._emitMmu( m_pId->opCode[ 0 ] | prefix, rexw, static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CBaseReg* >( m_pO0 )->getRegCode() ), dynamic_cast< const CMem* >( m_pO1 ), 0 );
				EndInstruction();
				CleanupInstruction();
				return;
			}
			// (X)MM <- Imm (opcode1+opcodeR)
			if( m_pO1->isImm() )
			{
				if( ( m_pId->oflags[ 1 ] & InstructionDescription::O_IMM ) == 0 )
				{
					InstructionIllegal();
					return;
				}
				m_CPU._emitMmu( m_pId->opCode[ 1 ] | prefix, rexw, (Cmp_unsigned__int8)m_pId->opCodeR, dynamic_cast< const CBaseReg* >( m_pO0 ), 1 );
				FinishImmediate( m_pO1, 1 );
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_MMU_RM_IMM8( void ) __QCMP_THROW
		{
			assert( m_pId->oflags[ 0 ] != 0 );
			assert( m_pId->oflags[ 1 ] != 0 );

			// Check parameters (X)MM|GP32_64 <- (X)MM|GP32_64|Mem|Imm
			if( !m_pO0->isReg() || ( m_pO0->isRegType( REG_TYPE_MM ) && ( m_pId->oflags[ 0 ] & InstructionDescription::O_MM ) == 0 ) ||
				( m_pO0->isRegType( REG_TYPE_XMM ) && ( m_pId->oflags[ 0 ] & InstructionDescription::O_XMM ) == 0 ) ||
				( m_pO0->isRegType( REG_TYPE_GPD ) && ( m_pId->oflags[ 0 ] & InstructionDescription::O_GD ) == 0 ) ||
				( m_pO0->isRegType( REG_TYPE_GPQ ) && ( m_pId->oflags[ 0 ] & InstructionDescription::O_GQ ) == 0 ) ||
				( m_pO1->isRegType( REG_TYPE_MM ) && ( m_pId->oflags[ 1 ] & InstructionDescription::O_MM ) == 0 ) ||
				( m_pO1->isRegType( REG_TYPE_XMM ) && ( m_pId->oflags[ 1 ] & InstructionDescription::O_XMM ) == 0 ) ||
				( m_pO1->isRegType( REG_TYPE_GPD ) && ( m_pId->oflags[ 1 ] & InstructionDescription::O_GD ) == 0 ) ||
				( m_pO1->isRegType( REG_TYPE_GPQ ) && ( m_pId->oflags[ 1 ] & InstructionDescription::O_GQ ) == 0 ) ||
				( m_pO1->isMem()                 && ( m_pId->oflags[ 1 ] & InstructionDescription::O_MEM ) == 0 ) ||
				!m_pO2->isImm() )
			{
				InstructionIllegal();
				return;
			}

			Cmp_unsigned__int32 prefix = ( ( m_pId->oflags[ 0 ] & InstructionDescription::O_MM_XMM ) == InstructionDescription::O_MM_XMM && m_pO0->isRegType( REG_TYPE_XMM ) ) 
				|| ( ( m_pId->oflags[ 1 ] & InstructionDescription::O_MM_XMM ) == InstructionDescription::O_MM_XMM && m_pO1->isRegType( REG_TYPE_XMM ) ) ? 0x66000000 : 0x00000000;

			Cmp_unsigned__int8 rexw = ( ( m_pId->oflags[ 0 ] | m_pId->oflags[ 1 ] ) & InstructionDescription::O_NOREX ) ? 0 : m_pO0->isRegType( REG_TYPE_GPQ ) | m_pO1->isRegType( REG_TYPE_GPQ );

			// (X)MM <- (X)MM (opcode0)
			if( m_pO1->isReg() )
			{
				if( ( m_pId->oflags[ 1 ] & ( InstructionDescription::O_MM_XMM | InstructionDescription::O_GQD ) ) == 0 )
				{
					InstructionIllegal();
					return;
				}
				m_CPU._emitMmu( m_pId->opCode[ 0 ] | prefix, rexw, static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CBaseReg* >( m_pO0 )->getRegCode() ), dynamic_cast< const CBaseReg* >( m_pO1 ), 1 );
				FinishImmediate( m_pO2, 1 );
			}
			// (X)MM <- Mem (opcode0)
			if( m_pO1->isMem() )
			{
				if( ( m_pId->oflags[ 1 ] & InstructionDescription::O_MEM ) == 0 )
				{
					InstructionIllegal();
					return;
				}
				m_CPU._emitMmu( m_pId->opCode[ 0 ] | prefix, rexw, static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CBaseReg* >( m_pO0 )->getRegCode() ), dynamic_cast< const CMem* >( m_pO1 ), 1 );
				FinishImmediate( m_pO2, 1 );
			}
		}

		//------------------------------------------------------------------------------
		void CInstEmitter::InstructionG_MMU_RM_3DNOW( void ) __QCMP_THROW
		{
			if( m_pO0->isRegType( REG_TYPE_MM ) && ( m_pO1->isRegType( REG_TYPE_MM ) || m_pO1->isMem() ) )
			{
				m_CPU._emitMmu( m_pId->opCode[ 0 ], 0, static_cast< Cmp_unsigned__int8 >( dynamic_cast< const CBaseReg* >( m_pO0 )->getRegCode() ), dynamic_cast< const CMem* >( m_pO1 ), 1 );
				m_CPU._emitByte( (Cmp_unsigned__int8)m_pId->opCode[ 1 ] );
				EndInstruction();
				CleanupInstruction();
			}
		}

	}//nsx86
}//nsArch

#endif//( QOR_ARCH == QOR_ARCH_X86_32 || QOR_ARCH == QOR_ARCH_X86_64 )
