//Cx86HLAIntrinsics.cpp

// Copyright (c) 2008-2010, Petr Kobalicek <kobalicek.petr@gmail.com>
// Copyright (c) Querysoft Limited 2012, 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "ArchQOR.h"

#if		( QOR_ARCH == QOR_ARCH_X86_32 )

#include "ArchQOR/x86/HLAssembler/x86HLAIntrinsics.h"

//------------------------------------------------------------------------------
namespace nsArch
{
	namespace nsx86
	{
		//------------------------------------------------------------------------------
		// Add 8-bit integer data to the instuction stream.
		inline void Cx86HLAIntrinsics::db( Cmp_unsigned__int8 x ) __QCMP_THROW 
		{ 
			embed( &x, 1 ); 
		}

		//------------------------------------------------------------------------------
		// Add 16-bit integer data to the instuction stream.
		inline void Cx86HLAIntrinsics::dw( Cmp_unsigned__int16 x ) __QCMP_THROW 
		{ 
			embed( &x, 2 ); 
		}

		//------------------------------------------------------------------------------
		// Add 32-bit integer data to the instuction stream.
		inline void Cx86HLAIntrinsics::dd( Cmp_unsigned__int32 x ) __QCMP_THROW 
		{ 
			embed( &x, 4 ); 
		}

		//------------------------------------------------------------------------------
		// Add 64-bit integer data to the instuction stream.
		inline void Cx86HLAIntrinsics::dq( Cmp_unsigned__int64 x ) __QCMP_THROW 
		{ 
			embed( &x, 8 ); 
		}

		//------------------------------------------------------------------------------
		// Add 8-bit integer data to the instuction stream.
		inline void Cx86HLAIntrinsics::dint8( Cmp__int8 x ) __QCMP_THROW 
		{ 
			embed( &x, sizeof(Cmp__int8) ); 
		}

		//------------------------------------------------------------------------------
		// Add 8-bit integer data to the instuction stream.
		inline void Cx86HLAIntrinsics::duint8( Cmp_unsigned__int8 x ) __QCMP_THROW 
		{ 
			embed( &x, sizeof(Cmp_unsigned__int8) ); 
		}

		//------------------------------------------------------------------------------
		// Add 16-bit integer data to the instuction stream.
		inline void Cx86HLAIntrinsics::dint16( Cmp__int16 x ) __QCMP_THROW 
		{ 
			embed( &x, sizeof(Cmp__int16) ); 
		}

		//------------------------------------------------------------------------------
		// Add 16-bit integer data to the instuction stream.
		inline void Cx86HLAIntrinsics::duint16( Cmp_unsigned__int16 x ) __QCMP_THROW 
		{ 
			embed( &x, sizeof(Cmp_unsigned__int16) ); 
		}

		//------------------------------------------------------------------------------
		// Add 32-bit integer data to the instuction stream.
		inline void Cx86HLAIntrinsics::dint32( Cmp__int32 x ) __QCMP_THROW 
		{ 
			embed( &x, sizeof(Cmp__int32) ); 
		}

		//------------------------------------------------------------------------------
		// Add 32-bit integer data to the instuction stream.
		inline void Cx86HLAIntrinsics::duint32( Cmp_unsigned__int32 x ) __QCMP_THROW 
		{ 
			embed( &x, sizeof( Cmp_unsigned__int32 ) ); 
		}

		//------------------------------------------------------------------------------
		// Add 64-bit integer data to the instuction stream.
		inline void Cx86HLAIntrinsics::dint64( Cmp__int64 x ) __QCMP_THROW 
		{ 
			embed( &x, sizeof(Cmp__int64) ); 
		}

		//------------------------------------------------------------------------------
		// Add 64-bit integer data to the instuction stream.
		inline void Cx86HLAIntrinsics::duint64( Cmp_unsigned__int64 x ) __QCMP_THROW 
		{ 
			embed( &x, sizeof(Cmp_unsigned__int64) ); 
		}

		//------------------------------------------------------------------------------
		// Add system-integer data to the instuction stream.
		inline void Cx86HLAIntrinsics::dsysint( Cmp_int_ptr x ) __QCMP_THROW 
		{ 
			embed( &x, sizeof(Cmp_int_ptr) ); 
		}

		//------------------------------------------------------------------------------
		// Add system-integer data to the instuction stream.
		inline void Cx86HLAIntrinsics::dsysuint( Cmp_uint_ptr x ) __QCMP_THROW 
		{ 
			embed( &x, sizeof(Cmp_uint_ptr) ); 
		}

		//------------------------------------------------------------------------------
		// Add float data to the instuction stream.
		inline void Cx86HLAIntrinsics::dfloat( float x ) __QCMP_THROW 
		{ 
			embed( &x, sizeof(float) ); 
		}

		//------------------------------------------------------------------------------
		// Add double data to the instuction stream.
		inline void Cx86HLAIntrinsics::ddouble( double x ) __QCMP_THROW 
		{ 
			embed( &x, sizeof(double) ); 
		}

		//------------------------------------------------------------------------------
		// Add pointer data to the instuction stream.
		inline void Cx86HLAIntrinsics::dptr( void* x ) __QCMP_THROW 
		{ 
			embed( &x, sizeof(void*) ); 
		}

		//------------------------------------------------------------------------------
		// Add MM data to the instuction stream.
		inline void Cx86HLAIntrinsics::dmm( const MMData& x ) __QCMP_THROW 
		{ 
			embed( &x, sizeof(MMData) ); 
		}

		//------------------------------------------------------------------------------
		// Add XMM data to the instuction stream.
		inline void Cx86HLAIntrinsics::dxmm( const XMMData& x ) __QCMP_THROW 
		{ 
			embed( &x, sizeof(XMMData) ); 
		}

		//------------------------------------------------------------------------------
		// Add data to the instuction stream.
		inline void Cx86HLAIntrinsics::data( const void* data, Cmp_uint_ptr size ) __QCMP_THROW 
		{ 
			embed( data, size ); 
		}

		// These emitters are used by custom HLA code (register alloc / spill, prolog / epilog generator, ...).

		//------------------------------------------------------------------------------
		inline void Cx86HLAIntrinsics::emit( Cmp_unsigned__int32 code ) __QCMP_THROW
		{
			_emitInstruction( code );
		}

		//------------------------------------------------------------------------------
		inline void Cx86HLAIntrinsics::emit( Cmp_unsigned__int32 code, const COperand* po0 ) __QCMP_THROW
		{
			_emitInstruction( code, po0 );
		}

		//------------------------------------------------------------------------------
		inline void Cx86HLAIntrinsics::emit( Cmp_unsigned__int32 code, const COperand* po0, const COperand* po1 ) __QCMP_THROW
		{
			_emitInstruction( code, po0, po1 );
		}

		//------------------------------------------------------------------------------
		inline void Cx86HLAIntrinsics::emit( Cmp_unsigned__int32 code, const COperand* po0, const COperand* po1, const COperand* po2 ) __QCMP_THROW
		{
			_emitInstruction( code, po0, po1, po2 );
		}

		// X86 Instructions

		//------------------------------------------------------------------------------
		// Add with Carry.
		inline void Cx86HLAIntrinsics::adc( const CGPVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_ADC, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Add with Carry.
		inline void Cx86HLAIntrinsics::adc( const CGPVar& dst, const CMem& src )
		{
			_emitInstruction( INST_ADC, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Add with Carry.
		inline void Cx86HLAIntrinsics::adc( const CGPVar& dst, const CImm& src )
		{
			_emitInstruction( INST_ADC, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Add with Carry.
		inline void Cx86HLAIntrinsics::adc( const CMem& dst, const CGPVar& src )
		{
			_emitInstruction( INST_ADC, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Add with Carry.
		inline void Cx86HLAIntrinsics::adc( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_ADC, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Add.
		inline void Cx86HLAIntrinsics::add( const CGPVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_ADD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Add.
		inline void Cx86HLAIntrinsics::add( const CGPVar& dst, const CMem& src )
		{
			_emitInstruction( INST_ADD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Add.
		inline void Cx86HLAIntrinsics::add( const CGPVar& dst, const CImm& src )
		{
			_emitInstruction( INST_ADD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Add.
		inline void Cx86HLAIntrinsics::add( const CMem& dst, const CGPVar& src )
		{
			_emitInstruction( INST_ADD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Add.
		inline void Cx86HLAIntrinsics::add( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_ADD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Logical And.
		inline void Cx86HLAIntrinsics::and_(const CGPVar& dst, const CGPVar& src)
		{
			_emitInstruction(INST_AND, &dst, &src);
		}

		//------------------------------------------------------------------------------
		// Logical And.
		inline void Cx86HLAIntrinsics::and_(const CGPVar& dst, const CMem& src)
		{
			_emitInstruction(INST_AND, &dst, &src);
		}
	
		//------------------------------------------------------------------------------
		// Logical And.
		inline void Cx86HLAIntrinsics::and_( const CGPVar& dst, const CImm& src )
		{
			_emitInstruction( INST_AND, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Logical And.
		inline void Cx86HLAIntrinsics::and_( const CMem& dst, const CGPVar& src )
		{
			_emitInstruction( INST_AND, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Logical And.
		inline void Cx86HLAIntrinsics::and_( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_AND, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Bit Scan Forward.
		inline void Cx86HLAIntrinsics::bsf( const CGPVar& dst, const CGPVar& src )
		{
			//assert(!dst.isGPB());
			_emitInstruction( INST_BSF, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Bit Scan Forward.
		inline void Cx86HLAIntrinsics::bsf( const CGPVar& dst, const CMem& src )
		{
			//assert(!dst.isGPB());
			_emitInstruction( INST_BSF, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Bit Scan Reverse.
		inline void Cx86HLAIntrinsics::bsr( const CGPVar& dst, const CGPVar& src )
		{
			//assert(!dst.isGPB());
			_emitInstruction( INST_BSR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Bit Scan Reverse.
		inline void Cx86HLAIntrinsics::bsr( const CGPVar& dst, const CMem& src )
		{
			//assert(!dst.isGPB());
			_emitInstruction( INST_BSR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Byte swap (32-bit or 64-bit registers only) (i486).
		inline void Cx86HLAIntrinsics::bswap( const CGPVar& dst )
		{
			// //assert(dst.getRegType() == REG_GPD || dst.getRegType() == REG_GPQ);
			_emitInstruction( INST_BSWAP, &dst );
		}

		//------------------------------------------------------------------------------
		// Bit test.
		inline void Cx86HLAIntrinsics::bt( const CGPVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_BT, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Bit test.
		inline void Cx86HLAIntrinsics::bt( const CGPVar& dst, const CImm& src )
		{
			_emitInstruction( INST_BT, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Bit test.
		inline void Cx86HLAIntrinsics::bt( const CMem& dst, const CGPVar& src )
		{
			_emitInstruction( INST_BT, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Bit test.
		inline void Cx86HLAIntrinsics::bt( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_BT, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Bit test and complement.
		inline void Cx86HLAIntrinsics::btc( const CGPVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_BTC, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Bit test and complement.
		inline void Cx86HLAIntrinsics::btc( const CGPVar& dst, const CImm& src )
		{
			_emitInstruction( INST_BTC, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Bit test and complement.
		inline void Cx86HLAIntrinsics::btc( const CMem& dst, const CGPVar& src )
		{
			_emitInstruction( INST_BTC, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Bit test and complement.
		inline void Cx86HLAIntrinsics::btc( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_BTC, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Bit test and reset.
		inline void Cx86HLAIntrinsics::btr( const CGPVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_BTR, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Bit test and reset.
		inline void Cx86HLAIntrinsics::btr( const CGPVar& dst, const CImm& src )
		{
			_emitInstruction( INST_BTR, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Bit test and reset.
		inline void Cx86HLAIntrinsics::btr( const CMem& dst, const CGPVar& src )
		{
			_emitInstruction( INST_BTR, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Bit test and reset.
		inline void Cx86HLAIntrinsics::btr( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_BTR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Bit test and set.
		inline void Cx86HLAIntrinsics::bts( const CGPVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_BTS, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Bit test and set.
		inline void Cx86HLAIntrinsics::bts( const CGPVar& dst, const CImm& src )
		{
			_emitInstruction( INST_BTS, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Bit test and set.
		inline void Cx86HLAIntrinsics::bts( const CMem& dst, const CGPVar& src )
		{
			_emitInstruction( INST_BTS, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Bit test and set.
		inline void Cx86HLAIntrinsics::bts( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_BTS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Call Procedure.
		inline CECall* Cx86HLAIntrinsics::call( const CGPVar& dst )
		{
			return _emitCall( &dst );
		}
	
		//------------------------------------------------------------------------------
		// Call Procedure.
		inline CECall* Cx86HLAIntrinsics::call( const CMem& dst )
		{
			return _emitCall( &dst );
		}
	
		//------------------------------------------------------------------------------
		// Call Procedure.
		inline CECall* Cx86HLAIntrinsics::call( const CImm& dst )
		{
			return _emitCall( &dst );
		}
	
		//------------------------------------------------------------------------------
		// Call Procedure.
		// overload
		inline CECall* Cx86HLAIntrinsics::call( void* dst )
		{
			CImm imm( (Cmp_int_ptr)dst );
			return _emitCall( &imm );
		}

		//------------------------------------------------------------------------------
		// Call Procedure.
		inline CECall* Cx86HLAIntrinsics::call( const CLabel& label )
		{
			return _emitCall( &label );
		}

		//------------------------------------------------------------------------------
		// Convert Byte to Word (Sign Extend).
		inline void Cx86HLAIntrinsics::cbw( const CGPVar& dst )
		{
			_emitInstruction( INST_CBW, &dst );
		}

		//------------------------------------------------------------------------------
		// Convert Word to DWord (Sign Extend).
		inline void Cx86HLAIntrinsics::cwde( const CGPVar& dst )
		{
			_emitInstruction( INST_CWDE, &dst );
		}

		//------------------------------------------------------------------------------
#if ( QOR_ARCH_WORDSIZE == 64 )
		// Convert DWord to QWord (Sign Extend).
		inline void Cx86HLAIntrinsics::cdqe( const CGPVar& dst )
		{
			_emitInstruction( INST_CDQE, &dst );
		}
#endif

		//------------------------------------------------------------------------------
		// Clear Carry flag
		// This instruction clears the CF flag in the EFLAGS register.
		inline void Cx86HLAIntrinsics::clc()
		{
			_emitInstruction( INST_CLC );
		}

		//------------------------------------------------------------------------------
		// Clear Direction flag
		// This instruction clears the DF flag in the EFLAGS register.
		inline void Cx86HLAIntrinsics::cld()
		{
			_emitInstruction( INST_CLD );
		}

		//------------------------------------------------------------------------------
		// Complement Carry Flag.
		// This instruction complements the CF flag in the EFLAGS register.
		// (CF = NOT CF)
		inline void Cx86HLAIntrinsics::cmc()
		{
			_emitInstruction( INST_CMC );
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmov( CONDITION cc, const CGPVar& dst, const CGPVar& src )
		{
			_emitInstruction( ConditionToInstruction::toCMovCC( cc ), &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmov( CONDITION cc, const CGPVar& dst, const CMem& src )
		{
			_emitInstruction( ConditionToInstruction::toCMovCC( cc ), &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmova( const CGPVar& dst, const CGPVar& src ) 
		{ 
			_emitInstruction( INST_CMOVA, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmova( const CGPVar& dst, const CMem& src )   
		{ 
			_emitInstruction( INST_CMOVA, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovae( const CGPVar& dst, const CGPVar& src ) 
		{ 
			_emitInstruction( INST_CMOVAE, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovae( const CGPVar& dst, const CMem& src )   
		{ 
			_emitInstruction( INST_CMOVAE, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovb( const CGPVar& dst, const CGPVar& src ) 
		{ 
			_emitInstruction( INST_CMOVB, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovb( const CGPVar& dst, const CMem& src )   
		{ 
			_emitInstruction( INST_CMOVB, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovbe( const CGPVar& dst, const CGPVar& src ) 
		{ 
			_emitInstruction( INST_CMOVBE, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovbe( const CGPVar& dst, const CMem& src )   
		{ 
			_emitInstruction( INST_CMOVBE, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovc( const CGPVar& dst, const CGPVar& src ) 
		{ 
			_emitInstruction( INST_CMOVC, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovc( const CGPVar& dst, const CMem& src )   
		{ 
			_emitInstruction( INST_CMOVC, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmove( const CGPVar& dst, const CGPVar& src ) 
		{ 
			_emitInstruction( INST_CMOVE, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmove( const CGPVar& dst, const CMem& src )   
		{ 
			_emitInstruction( INST_CMOVE, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovg( const CGPVar& dst, const CGPVar& src ) 
		{ 
			_emitInstruction( INST_CMOVG, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovg( const CGPVar& dst, const CMem& src )   
		{ 
			_emitInstruction( INST_CMOVG, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovge( const CGPVar& dst, const CGPVar& src ) 
		{ 
			_emitInstruction( INST_CMOVGE, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovge( const CGPVar& dst, const CMem& src )   
		{ 
			_emitInstruction( INST_CMOVGE, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovl( const CGPVar& dst, const CGPVar& src ) 
		{ 
			_emitInstruction( INST_CMOVL, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovl( const CGPVar& dst, const CMem& src )   
		{ 
			_emitInstruction( INST_CMOVL, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovle( const CGPVar& dst, const CGPVar& src ) 
		{ 
			_emitInstruction( INST_CMOVLE, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovle( const CGPVar& dst, const CMem& src )   
		{ 
			_emitInstruction( INST_CMOVLE, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovna( const CGPVar& dst, const CGPVar& src ) 
		{ 
			_emitInstruction( INST_CMOVNA, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovna( const CGPVar& dst, const CMem& src )   
		{ 
			_emitInstruction( INST_CMOVNA, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovnae( const CGPVar& dst, const CGPVar& src ) 
		{ 
			_emitInstruction( INST_CMOVNAE, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovnae( const CGPVar& dst, const CMem& src )   
		{ 
			_emitInstruction( INST_CMOVNAE, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovnb( const CGPVar& dst, const CGPVar& src ) 
		{ 
			_emitInstruction( INST_CMOVNB, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovnb( const CGPVar& dst, const CMem& src )   
		{ 
			_emitInstruction( INST_CMOVNB, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovnbe( const CGPVar& dst, const CGPVar& src ) 
 		{ 
			_emitInstruction( INST_CMOVNBE, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovnbe( const CGPVar& dst, const CMem& src )   
		{ 
			_emitInstruction( INST_CMOVNBE, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovnc( const CGPVar& dst, const CGPVar& src ) 
		{ 
			_emitInstruction( INST_CMOVNC, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovnc( const CGPVar& dst, const CMem& src )   
		{ 
			_emitInstruction( INST_CMOVNC, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovne( const CGPVar& dst, const CGPVar& src ) 
		{ 
			_emitInstruction( INST_CMOVNE, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovne( const CGPVar& dst, const CMem& src )   
		{ 
			_emitInstruction( INST_CMOVNE, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovng( const CGPVar& dst, const CGPVar& src ) 
		{ 
			_emitInstruction( INST_CMOVNG, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovng( const CGPVar& dst, const CMem& src )   
		{ 
			_emitInstruction( INST_CMOVNG, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovnge( const CGPVar& dst, const CGPVar& src ) 
		{ 
			_emitInstruction( INST_CMOVNGE, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovnge( const CGPVar& dst, const CMem& src )   
		{ 
			_emitInstruction( INST_CMOVNGE, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovnl( const CGPVar& dst, const CGPVar& src ) 
		{ 
			_emitInstruction( INST_CMOVNL, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovnl( const CGPVar& dst, const CMem& src )   
		{ 
			_emitInstruction( INST_CMOVNL, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovnle( const CGPVar& dst, const CGPVar& src ) 
		{ 
			_emitInstruction( INST_CMOVNLE, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovnle( const CGPVar& dst, const CMem& src )   
		{ 
			_emitInstruction( INST_CMOVNLE, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovno( const CGPVar& dst, const CGPVar& src ) 
		{ 
			_emitInstruction( INST_CMOVNO, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovno( const CGPVar& dst, const CMem& src )   
		{ 
			_emitInstruction( INST_CMOVNO, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovnp( const CGPVar& dst, const CGPVar& src ) 
		{ 
			_emitInstruction( INST_CMOVNP, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovnp( const CGPVar& dst, const CMem& src )   
		{ 
			_emitInstruction( INST_CMOVNP, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovns( const CGPVar& dst, const CGPVar& src ) 
		{ 
			_emitInstruction( INST_CMOVNS, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovns( const CGPVar& dst, const CMem& src )   
		{ 
			_emitInstruction( INST_CMOVNS, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovnz( const CGPVar& dst, const CGPVar& src ) 
		{ 
			_emitInstruction( INST_CMOVNZ, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovnz( const CGPVar& dst, const CMem& src )   
		{ 
			_emitInstruction( INST_CMOVNZ, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovo( const CGPVar& dst, const CGPVar& src ) 
		{ 
			_emitInstruction( INST_CMOVO, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovo( const CGPVar& dst, const CMem& src )   
		{ 
			_emitInstruction( INST_CMOVO, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovp( const CGPVar& dst, const CGPVar& src ) 
		{ 
			_emitInstruction( INST_CMOVP, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovp( const CGPVar& dst, const CMem& src )   
		{ 
			_emitInstruction( INST_CMOVP, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovpe( const CGPVar& dst, const CGPVar& src ) 
		{ 
			_emitInstruction( INST_CMOVPE, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovpe( const CGPVar& dst, const CMem& src )   
		{ 
			_emitInstruction( INST_CMOVPE, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovpo( const CGPVar& dst, const CGPVar& src ) 
		{ 
			_emitInstruction( INST_CMOVPO, &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovpo( const CGPVar& dst, const CMem& src )   
		{ 
			_emitInstruction( INST_CMOVPO , &dst, &src ); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovs( const CGPVar& dst, const CGPVar& src) 
		{ 
			_emitInstruction(INST_CMOVS  , &dst, &src); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovs( const CGPVar& dst, const CMem& src )  
		{ 
			_emitInstruction(INST_CMOVS  , &dst, &src); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovz( const CGPVar& dst, const CGPVar& src ) 
		{ 
			_emitInstruction(INST_CMOVZ  , &dst, &src); 
		}

		//------------------------------------------------------------------------------
		// Conditional Move.
		inline void Cx86HLAIntrinsics::cmovz( const CGPVar& dst, const CMem& src )   
		{ 
			_emitInstruction(INST_CMOVZ  , &dst, &src); 
		}

		//------------------------------------------------------------------------------
		// Compare Two Operands.
		inline void Cx86HLAIntrinsics::cmp( const CGPVar& dst, const CGPVar& src )
		{
			_emitInstruction(INST_CMP, &dst, &src);
		}

		//------------------------------------------------------------------------------
		// Compare Two Operands.
		inline void Cx86HLAIntrinsics::cmp( const CGPVar& dst, const CMem& src )
		{
			_emitInstruction(INST_CMP, &dst, &src);
		}
		//------------------------------------------------------------------------------
		// Compare Two Operands.
		inline void Cx86HLAIntrinsics::cmp( const CGPVar& dst, const CImm& src )
		{
			_emitInstruction(INST_CMP, &dst, &src);
		}

		//------------------------------------------------------------------------------
		// Compare Two Operands.
		inline void Cx86HLAIntrinsics::cmp( const CMem& dst, const CGPVar& src )
		{
			_emitInstruction(INST_CMP, &dst, &src);
		}

		//------------------------------------------------------------------------------
		// Compare Two Operands.
		inline void Cx86HLAIntrinsics::cmp(const CMem& dst, const CImm& src )
		{
			_emitInstruction(INST_CMP, &dst, &src);
		}

		//------------------------------------------------------------------------------
		// Compare and Exchange (i486).
		inline void Cx86HLAIntrinsics::cmpxchg( const CGPVar cmp_1_eax, const CGPVar& cmp_2, const CGPVar& src )
		{
			//assert(cmp_1_eax.getId() != src.getId());
			_emitInstruction(INST_CMPXCHG, &cmp_1_eax, &cmp_2, &src);
		}

		//------------------------------------------------------------------------------
		// Compare and Exchange (i486).
		inline void Cx86HLAIntrinsics::cmpxchg( const CGPVar cmp_1_eax, const CMem& cmp_2, const CGPVar& src )
		{
			//assert(cmp_1_eax.getId() != src.getId());
			_emitInstruction( INST_CMPXCHG, &cmp_1_eax, &cmp_2, &src );
		}

		//------------------------------------------------------------------------------
		// Compares the 64-bit value in EDX:EAX with the memory operand (Pentium).
		// If the values are equal, then this instruction stores the 64-bit value
		// in ECX:EBX into the memory operand and sets the zero flag. Otherwise,
		// this instruction copies the 64-bit memory operand into the EDX:EAX
		// registers and clears the zero flag.
		inline void Cx86HLAIntrinsics::cmpxchg8b( const CGPVar& cmp_edx, const CGPVar& cmp_eax, const CGPVar& cmp_ecx, const CGPVar& cmp_ebx, const CMem& dst )
		{
			//assert(cmp_edx.getId() != cmp_eax.getId() && cmp_eax.getId() != cmp_ecx.getId() && cmp_ecx.getId() != cmp_ebx.getId());
			_emitInstruction( INST_CMPXCHG8B, &cmp_edx, &cmp_eax, &cmp_ecx, &cmp_ebx, &dst );
		}

#if ( QOR_ARCH_WORDSIZE == 64 )
		// Compares the 128-bit value in RDX:RAX with the memory operand (X64).
		//
		// If the values are equal, then this instruction stores the 128-bit value
		// in RCX:RBX into the memory operand and sets the zero flag. Otherwise,
		// this instruction copies the 128-bit memory operand into the RDX:RAX
		// registers and clears the zero flag.
		inline void Cx86HLAIntrinsics::cmpxchg16b( const CGPVar& cmp_edx, const CGPVar& cmp_eax, const CGPVar& cmp_ecx, const CGPVar& cmp_ebx, const CMem& dst )
		{
			//assert(cmp_edx.getId() != cmp_eax.getId() && cmp_eax.getId() != cmp_ecx.getId() && cmp_ecx.getId() != cmp_ebx.getId());
			_emitInstruction( INST_CMPXCHG16B, &cmp_edx, &cmp_eax, &cmp_ecx, &cmp_ebx, &dst );
		}
#endif // ASMJIT_X64

		//------------------------------------------------------------------------------
		// CPU Identification (i486).
		inline void Cx86HLAIntrinsics::cpuid( const CGPVar& inout_eax, const CGPVar& out_ebx, const CGPVar& out_ecx, const CGPVar& out_edx)
		{
			// Destination variables must be different.
			//assert( inout_eax.getId() != out_ebx.getId() && out_ebx.getId() != out_ecx.getId() && out_ecx.getId() != out_edx.getId() );
			_emitInstruction( INST_CPUID, &inout_eax, &out_ebx, &out_ecx, &out_edx );
		}

#if	( QOR_ARCH_WORDSIZE == 32 )
		//------------------------------------------------------------------------------
		inline void Cx86HLAIntrinsics::daa( const CGPVar& dst )
		{
			_emitInstruction( INST_DAA, &dst );
		}
#endif

#if	( QOR_ARCH_WORDSIZE == 32 )
		//------------------------------------------------------------------------------
		inline void Cx86HLAIntrinsics::das( const CGPVar& dst )
		{
			_emitInstruction( INST_DAS, &dst );
		}
#endif // ( QOR_ARCH_WORDSIZE == 32 )

		//------------------------------------------------------------------------------
		// Decrement by 1. Note This instruction can be slower than sub(dst, 1)
		inline void Cx86HLAIntrinsics::dec( const CGPVar& dst )
		{
			_emitInstruction( INST_DEC, &dst );
		}

		//------------------------------------------------------------------------------
		// Decrement by 1. Note This instruction can be slower than sub(dst, 1)
		inline void Cx86HLAIntrinsics::dec( const CMem& dst )
		{
			_emitInstruction( INST_DEC, &dst );
		}

		//------------------------------------------------------------------------------
		// Unsigned divide.
		// This instruction divides (unsigned) the value in the AL, AX, or EAX
		// register by the source operand and stores the result in the AX,
		// DX:AX, or EDX:EAX registers.
		inline void Cx86HLAIntrinsics::div( const CGPVar& dst_rem, const CGPVar& dst_quot, const CGPVar& src )
		{
			// Destination variables must be different.
			//assert( dst_rem.getId() != dst_quot.getId() );

			_emitInstruction( INST_DIV, &dst_rem, &dst_quot, &src );
		}

		//------------------------------------------------------------------------------
		//Unsigned divide.
		inline void Cx86HLAIntrinsics::div( const CGPVar& dst_rem, const CGPVar& dst_quot, const CMem& src )
		{
			// Destination variables must be different.
			//assert( dst_rem.getId() != dst_quot.getId() );

			_emitInstruction( INST_DIV, &dst_rem, &dst_quot, &src );
		}

#if ASMJIT_NOT_SUPPORTED_BY_COMPILER
		//------------------------------------------------------------------------------
		// Make Stack Frame for Procedure Parameters.
		inline void Cx86HLAIntrinsics::enter( const CImm& imm16, const CImm& imm8 )
		{
			_emitInstruction( INST_ENTER, &imm16, &imm8 );
		}
#endif // ASMJIT_NOT_SUPPORTED_BY_COMPILER

		//------------------------------------------------------------------------------
		// Signed divide.
		// This instruction divides (signed) the value in the AL, AX, or EAX
		// register by the source operand and stores the result in the AX,
		// DX:AX, or EDX:EAX registers.
		inline void Cx86HLAIntrinsics::idiv( const CGPVar& dst_rem, const CGPVar& dst_quot, const CGPVar& src )
		{
			// Destination variables must be different.
			//assert( dst_rem.getId() != dst_quot.getId() );

			_emitInstruction( INST_IDIV, &dst_rem, &dst_quot, &src );
		}

		//------------------------------------------------------------------------------
		//Signed divide.
		inline void Cx86HLAIntrinsics::idiv( const CGPVar& dst_rem, const CGPVar& dst_quot, const CMem& src )
		{
			// Destination variables must be different.
			//assert( dst_rem.getId() != dst_quot.getId() );

			_emitInstruction( INST_IDIV, &dst_rem, &dst_quot, &src );
		}

		//------------------------------------------------------------------------------
		//Signed multiply.
		//[dst_lo:dst_hi] = dst_hi * src.
		inline void Cx86HLAIntrinsics::imul( const CGPVar& dst_hi, const CGPVar& dst_lo, const CGPVar& src )
		{
			// Destination variables must be different.
			//assert( dst_hi.getId() != dst_lo.getId() );

			_emitInstruction( INST_IMUL, &dst_hi, &dst_lo, &src );
		}

		//------------------------------------------------------------------------------
		inline void Cx86HLAIntrinsics::imul( const CGPVar& dst_hi, const CGPVar& dst_lo, const CMem& src )
		{
			// Destination variables must be different.
			//assert( dst_hi.getId() != dst_lo.getId() );

			_emitInstruction( INST_IMUL, &dst_hi, &dst_lo, &src );
		}

		//------------------------------------------------------------------------------
		// Signed multiply.
		// Destination operand (the first operand) is multiplied by the source
		// operand (second operand). The destination operand is a general-purpose
		// register and the source operand is an immediate value, a general-purpose
		// register, or a memory location. The product is then stored in the
		// destination operand location.
		inline void Cx86HLAIntrinsics::imul(const CGPVar& dst, const CGPVar& src)
		{
			_emitInstruction(INST_IMUL, &dst, &src);
		}

		//------------------------------------------------------------------------------
		// Signed multiply.
		inline void Cx86HLAIntrinsics::imul(const CGPVar& dst, const CMem& src)
		{
			_emitInstruction(INST_IMUL, &dst, &src);
		}

		//------------------------------------------------------------------------------
		// Signed multiply.
		inline void Cx86HLAIntrinsics::imul(const CGPVar& dst, const CImm& src)
		{
			_emitInstruction(INST_IMUL, &dst, &src);
		}

		//------------------------------------------------------------------------------
		// Signed multiply.
		// source operand (which can be a general-purpose register or a memory
		// location) is multiplied by the second source operand (an immediate
		// value). The product is then stored in the destination operand
		// (a general-purpose register).
		inline void Cx86HLAIntrinsics::imul(const CGPVar& dst, const CGPVar& src, const CImm& imm)
		{
			_emitInstruction(INST_IMUL, &dst, &src, &imm);
		}

		//------------------------------------------------------------------------------
		inline void Cx86HLAIntrinsics::imul(const CGPVar& dst, const CMem& src, const CImm& imm)
		{
			_emitInstruction(INST_IMUL, &dst, &src, &imm);
		}

		//------------------------------------------------------------------------------
		// Increment by 1. Note This instruction can be slower than add(dst, 1)
		inline void Cx86HLAIntrinsics::inc(const CGPVar& dst)
		{
			_emitInstruction(INST_INC, &dst);
		}

		//------------------------------------------------------------------------------
		// Increment by 1. Note This instruction can be slower than add(dst, 1)
		inline void Cx86HLAIntrinsics::inc(const CMem& dst)
		{
			_emitInstruction(INST_INC, &dst);
		}

		//------------------------------------------------------------------------------
		// Interrupt 3 - trap to debugger.
		inline void Cx86HLAIntrinsics::int3()
		{
			_emitInstruction(INST_INT3);
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition cc is met.
		// This instruction checks the state of one or more of the status flags in
		// the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the
		// specified state (condition), performs a jump to the target instruction
		// specified by the destination operand. A condition code (cc) is associated
		// with each instruction to indicate the condition being tested for. If the
		// condition is not satisfied, the jump is not performed and execution
		// continues with the instruction following the Jcc instruction.
		inline void Cx86HLAIntrinsics::j( CONDITION cc, const CLabel& label, Cmp_unsigned__int32 hint )
		{
			_emitJcc( ConditionToInstruction::toJCC( cc ), &label, hint );
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::ja( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{ 
			_emitJcc( INST_JA, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::jae( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{ 
			_emitJcc( INST_JAE, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::jb( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{ 
			_emitJcc( INST_JB, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::jbe( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{ 
			_emitJcc( INST_JBE, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::jc( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{ 
			_emitJcc( INST_JC, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::je( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{ 
			_emitJcc( INST_JE, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::jg( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{ 
			_emitJcc( INST_JG, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::jge( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{ 
			_emitJcc( INST_JGE, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::jl( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{ 
			_emitJcc( INST_JL, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::jle( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{ 
			_emitJcc( INST_JLE, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::jna( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{ 
			_emitJcc( INST_JNA, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::jnae( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{ 
			_emitJcc( INST_JNAE, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::jnb( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{ 
			_emitJcc( INST_JNB, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::jnbe( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{ 
			_emitJcc( INST_JNBE, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::jnc( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{ 
			_emitJcc( INST_JNC, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::jne( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{ 
			_emitJcc( INST_JNE, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::jng( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{ 
			_emitJcc( INST_JNG, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::jnge( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{ 
			_emitJcc( INST_JNGE, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::jnl( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{ 
			_emitJcc( INST_JNL, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::jnle( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{ 
			_emitJcc( INST_JNLE, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::jno( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{ 
			_emitJcc( INST_JNO, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::jnp( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{ 
			_emitJcc( INST_JNP, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::jns( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{ 
			_emitJcc( INST_JNS, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::jnz( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{ 
			_emitJcc( INST_JNZ, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::jo( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{
			_emitJcc( INST_JO, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::jp( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{ 
			_emitJcc( INST_JP, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::jpe( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{ 
			_emitJcc( INST_JPE, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::jpo( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{ 
			_emitJcc( INST_JPO, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::js( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{ 
			_emitJcc( INST_JS, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump to label label if condition is met.
		inline void Cx86HLAIntrinsics::jz( const CLabel& label, Cmp_unsigned__int32 hint ) 
		{ 
			_emitJcc( INST_JZ, &label, hint ); 
		}

		//------------------------------------------------------------------------------
		// Jump.
		inline void Cx86HLAIntrinsics::jmp( const CGPVar& dst )
		{
			_emitInstruction( INST_JMP, &dst );
		}

		//------------------------------------------------------------------------------
		// Jump.
		inline void Cx86HLAIntrinsics::jmp( const CMem& dst )
		{
			_emitInstruction( INST_JMP, &dst );
		}

		//------------------------------------------------------------------------------
		// Jump.
		inline void Cx86HLAIntrinsics::jmp( const CImm& dst )
		{
			_emitInstruction( INST_JMP, &dst );
		}

		//------------------------------------------------------------------------------
		// Jump.
		inline void Cx86HLAIntrinsics::jmp( void* dst )
		{
			CImm imm( (Cmp_int_ptr)dst );
			_emitInstruction( INST_JMP, &imm );
		}

		//------------------------------------------------------------------------------
		// Jump.
		// This instruction transfers program control to a different point
		// in the instruction stream without recording return information.
		// The destination (target) operand specifies the label of the
		// instruction being jumped to.
		inline void Cx86HLAIntrinsics::jmp( const CLabel& label )
		{
			_emitInstruction( INST_JMP, &label );
		}

		//------------------------------------------------------------------------------
		// Load Effective Address
		// This instruction computes the effective address of the second
		// operand (the source operand) and stores it in the first operand
		// (destination operand). The source operand is a memory address
		// (offset part) specified with one of the processors addressing modes.
		// The destination operand is a general-purpose register.
		inline void Cx86HLAIntrinsics::lea( const CGPVar& dst, const CMem& src )
		{
			_emitInstruction( INST_LEA, &dst, &src );
		}

//#if ASMJIT_NOT_SUPPORTED_BY_COMPILER
		//------------------------------------------------------------------------------
		// High Level Procedure Exit.
		inline void Cx86HLAIntrinsics::leave()
		{
			_emitInstruction( INST_LEAVE );
		}
//#endif // ASMJIT_NOT_SUPPORTED_BY_COMPILER

		//------------------------------------------------------------------------------
		// Move.
		// This instruction copies the second operand (source operand) to the first
		// operand (destination operand). The source operand can be an immediate
		// value, general-purpose register, segment register, or memory location.
		// The destination register can be a general-purpose register, segment
		// register, or memory location. Both operands must be the same size, which
		// can be a byte, a word, or a DWORD.Note To move MMX or SSE registers to/from GP registers or memory, use
		// corresponding functions: movd(), movq(), etc. Passing MMX or SSE registers to mov() is illegal.
		inline void Cx86HLAIntrinsics::mov( const CGPVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_MOV, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move.
		inline void Cx86HLAIntrinsics::mov( const CGPVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MOV, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move.
		inline void Cx86HLAIntrinsics::mov( const CGPVar& dst, const CImm& src )
		{
			_emitInstruction( INST_MOV, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move.
		inline void Cx86HLAIntrinsics::mov( const CMem& dst, const CGPVar& src )
		{
			_emitInstruction( INST_MOV, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move.
		inline void Cx86HLAIntrinsics::mov( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_MOV, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Move from segment register.
		inline void Cx86HLAIntrinsics::mov( const CGPVar& dst, const CSegmentReg& src )
		{
			_emitInstruction( INST_MOV, &dst, &src );
		}
  
		//------------------------------------------------------------------------------
		//Move from segment register.
		inline void Cx86HLAIntrinsics::mov( const CMem& dst, const CSegmentReg& src )
		{
			_emitInstruction( INST_MOV, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Move to segment register.
		inline void Cx86HLAIntrinsics::mov( const CSegmentReg& dst, const CGPVar& src )
		{
			_emitInstruction( INST_MOV, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Move to segment register.
		inline void Cx86HLAIntrinsics::mov( const CSegmentReg& dst, const CMem& src )
		{
			_emitInstruction( INST_MOV, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move byte, word, dword or qword from absolute address src to
		// AL, AX, EAX or RAX register.
		inline void Cx86HLAIntrinsics::mov_ptr( const CGPVar& dst, void* src )
		{
			CImm imm( (Cmp_int_ptr)src );
			_emitInstruction( INST_MOV_PTR, &dst, &imm );
		}

		//------------------------------------------------------------------------------
		// Move byte, word, dword or qword from AL, AX, EAX or RAX register
		// to absolute address dst.
		inline void Cx86HLAIntrinsics::mov_ptr( void* dst, const CGPVar& src )
		{
			CImm imm( (Cmp_int_ptr)dst );
			_emitInstruction( INST_MOV_PTR, &imm, &src );
		}

		//------------------------------------------------------------------------------
		// Move with Sign-Extension.
		// This instruction copies the contents of the source operand (register
		// or memory location) to the destination operand (register) and sign
		// extends the value to 16, 32 or 64-bits.
		void Cx86HLAIntrinsics::movsx( const CGPVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_MOVSX, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move with Sign-Extension.
		void Cx86HLAIntrinsics::movsx( const CGPVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MOVSX, &dst, &src );
		}

#if ( QOR_ARCH_WORDSIZE == 64 )
		//------------------------------------------------------------------------------
		// Move DWord to QWord with sign-extension.
		inline void Cx86HLAIntrinsics::movsxd( const CGPVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_MOVSXD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move DWord to QWord with sign-extension.
		inline void movsxd( const CGPVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MOVSXD, &dst, &src );
		}
#endif // ASMJIT_X64

		//------------------------------------------------------------------------------
		// Move with Zero-Extend.
		// This instruction copies the contents of the source operand (register
		// or memory location) to the destination operand (register) and zero
		// extends the value to 16 or 32-bits. The size of the converted value
		// depends on the operand-size attribute.
		inline void Cx86HLAIntrinsics::movzx( const CGPVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_MOVZX, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move with Zero-Extend.
		inline void Cx86HLAIntrinsics::movzx( const CGPVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MOVZX, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unsigned multiply.
		// Source operand (in a general-purpose register or memory location)
		// is multiplied by the value in the AL, AX, or EAX register (depending
		// on the operand size) and the product is stored in the AX, DX:AX, or
		// EDX:EAX registers, respectively.
		inline void Cx86HLAIntrinsics::mul( const CGPVar& dst_hi, const CGPVar& dst_lo, const CGPVar& src )
		{
			// Destination variables must be different.
			//assert( dst_hi.getId() != dst_lo.getId() );

			_emitInstruction( INST_MUL, &dst_hi, &dst_lo, &src );
		}

		//------------------------------------------------------------------------------
		//Unsigned multiply.
		inline void Cx86HLAIntrinsics::mul( const CGPVar& dst_hi, const CGPVar& dst_lo, const CMem& src )
		{
			// Destination variables must be different.
			//assert( dst_hi.getId() != dst_lo.getId() );

			_emitInstruction( INST_MUL, &dst_hi, &dst_lo, &src );
		}

		//------------------------------------------------------------------------------
		// Two's Complement Negation.
		inline void Cx86HLAIntrinsics::neg( const CGPVar& dst )
		{
			_emitInstruction( INST_NEG, &dst );
		}

		//------------------------------------------------------------------------------
		// Two's Complement Negation.
		inline void Cx86HLAIntrinsics::neg( const CMem& dst )
		{
			_emitInstruction( INST_NEG, &dst );
		}

		//------------------------------------------------------------------------------
		// No Operation.
		// This instruction performs no operation. This instruction is a one-byte
		// instruction that takes up space in the instruction stream but does not
		// affect the machine context, except the EIP register. The NOP instruction
		// is an alias mnemonic for the XCHG (E)AX, (E)AX instruction.
		inline void Cx86HLAIntrinsics::nop()
		{
			_emitInstruction( INST_NOP );
		}

		//------------------------------------------------------------------------------
		// One's Complement Negation.
		inline void Cx86HLAIntrinsics::not_( const CGPVar& dst )
		{
			_emitInstruction( INST_NOT, &dst );
		}

		//------------------------------------------------------------------------------
		// One's Complement Negation.
		inline void Cx86HLAIntrinsics::not_( const CMem& dst )
		{
			_emitInstruction( INST_NOT, &dst );
		}

		//------------------------------------------------------------------------------
		// Logical Inclusive OR.
		inline void Cx86HLAIntrinsics::or_( const CGPVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_OR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Logical Inclusive OR.
		inline void Cx86HLAIntrinsics::or_( const CGPVar& dst, const CMem& src )
		{
			_emitInstruction( INST_OR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Logical Inclusive OR.
		inline void Cx86HLAIntrinsics::or_( const CGPVar& dst, const CImm& src )
		{
			_emitInstruction( INST_OR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Logical Inclusive OR.
		inline void Cx86HLAIntrinsics::or_( const CMem& dst, const CGPVar& src )
		{
			_emitInstruction( INST_OR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Logical Inclusive OR.
		inline void Cx86HLAIntrinsics::or_( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_OR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Pop a Value from the Stack.
		// This instruction loads the value from the top of the stack to the location
		// specified with the destination operand and then increments the stack pointer.
		// The destination operand can be a general purpose register, memory location,
		// or segment register.
		inline void Cx86HLAIntrinsics::pop( const CGPVar& dst )
		{
			_emitInstruction( INST_POP, &dst );
		}

		//------------------------------------------------------------------------------
		inline void Cx86HLAIntrinsics::pop( const CMem& dst )
		{
			//assert(dst.getSize() == 2 || dst.getSize() == sizeof(Cmp_int_ptr));
			_emitInstruction( INST_POP, &dst );
		}

#if	( QOR_ARCH_WORDSIZE == 32 )
		//------------------------------------------------------------------------------
		// Pop All General-Purpose Registers.
		// Pop EDI, ESI, EBP, EBX, EDX, ECX, and EAX.
		inline void Cx86HLAIntrinsics::popad()
		{
			_emitInstruction( INST_POPAD );
		}
#endif // ( QOR_ARCH_WORDSIZE == 32 )

		//------------------------------------------------------------------------------
		// Pop Stack into EFLAGS Register (32-bit or 64-bit).
		inline void Cx86HLAIntrinsics::popf()
		{
#	if	( QOR_ARCH_WORDSIZE == 32 )
			popfd();
#	else
			popfq();
#	endif
		}
		
#	if	( QOR_ARCH_WORDSIZE == 32 )
		//------------------------------------------------------------------------------
		// Pop Stack into EFLAGS Register (32-bit).
		inline void Cx86HLAIntrinsics::popfd() 
		{ 
			_emitInstruction( INST_POPFD ); 
		}
#	else
		//------------------------------------------------------------------------------
		// Pop Stack into EFLAGS Register (64-bit).
		inline void Cx86HLAIntrinsics::popfq() 
		{ 
			_emitInstruction( INST_POPFQ ); 
		}
#	endif

		//------------------------------------------------------------------------------
		// Push WORD/DWORD/QWORD Onto the Stack.
		// Note 32-bit architecture pushed DWORD while 64-bit
		// pushes QWORD. 64-bit mode not provides instruction to
		// push 32-bit register/memory.
		inline void Cx86HLAIntrinsics::push( const CGPVar& src )
		{
			_emitInstruction( INST_PUSH, &src );
		}

		//------------------------------------------------------------------------------
		// Push WORD/DWORD/QWORD Onto the Stack.
		inline void Cx86HLAIntrinsics::push( const CMem& src )
		{
			//assert(src.getSize() == 2 || src.getSize() == sizeof(Cmp_int_ptr));
			_emitInstruction( INST_PUSH, &src );
		}

		//------------------------------------------------------------------------------
		// Push WORD/DWORD/QWORD Onto the Stack.
		inline void Cx86HLAIntrinsics::push( const CImm& src )
		{
			_emitInstruction( INST_PUSH, &src );
		}

#	if	( QOR_ARCH_WORDSIZE == 32 )
		//------------------------------------------------------------------------------
		// Push All General-Purpose Registers.
		// Push EAX, ECX, EDX, EBX, original ESP, EBP, ESI, and EDI.
		inline void Cx86HLAIntrinsics::pushad()
		{
			_emitInstruction( INST_PUSHAD );
		}
#	endif // ( QOR_ARCH_WORDSIZE == 32 )

		//------------------------------------------------------------------------------
		// Push EFLAGS Register (32-bit or 64-bit) onto the Stack.
		inline void Cx86HLAIntrinsics::pushf()
		{
#	if	( QOR_ARCH_WORDSIZE == 32 )
			pushfd();
#	else
			pushfq();
#	endif
		}

#	if	( QOR_ARCH_WORDSIZE == 32 )
		//------------------------------------------------------------------------------
		// Push EFLAGS Register (32-bit) onto the Stack.
		inline void Cx86HLAIntrinsics::pushfd() 
		{ 
			_emitInstruction( INST_PUSHFD ); 
		}
#	else
		//------------------------------------------------------------------------------
		// Push EFLAGS Register (64-bit) onto the Stack.
		inline void Cx86HLAIntrinsics::pushfq() 
		{ 
			_emitInstruction( INST_PUSHFQ ); 
		}
#	endif // ( QOR_ARCH_WORDSIZE == 32 )

		//------------------------------------------------------------------------------
		// Rotate Bits Left. Note src register can be only cl.
		inline void Cx86HLAIntrinsics::rcl( const CGPVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_RCL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Rotate Bits Left.
		inline void Cx86HLAIntrinsics::rcl( const CGPVar& dst, const CImm& src )
		{
			_emitInstruction( INST_RCL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Rotate Bits Left.
		// Note src register can be only cl.
		inline void Cx86HLAIntrinsics::rcl( const CMem& dst, const CGPVar& src )
		{
			_emitInstruction( INST_RCL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Rotate Bits Left.
		inline void Cx86HLAIntrinsics::rcl( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_RCL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Rotate Bits Right.
		// Note src register can be only cl.
		inline void Cx86HLAIntrinsics::rcr( const CGPVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_RCR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Rotate Bits Right.
		inline void Cx86HLAIntrinsics::rcr( const CGPVar& dst, const CImm& src )
		{
			_emitInstruction( INST_RCR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Rotate Bits Right.
		// Note src register can be only cl.
		inline void Cx86HLAIntrinsics::rcr( const CMem& dst, const CGPVar& src )
		{
			_emitInstruction( INST_RCR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Rotate Bits Right.
		inline void Cx86HLAIntrinsics::rcr( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_RCR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Read Time-Stamp Counter (Pentium).
		inline void Cx86HLAIntrinsics::rdtsc( const CGPVar& dst_edx, const CGPVar& dst_eax )
		{
			// Destination registers must be different.
			//assert(dst_edx.getId() != dst_eax.getId());
			_emitInstruction( INST_RDTSC, &dst_edx, &dst_eax );
		}

		//------------------------------------------------------------------------------
		// Read Time-Stamp Counter and Processor ID (New).
		inline void Cx86HLAIntrinsics::rdtscp( const CGPVar& dst_edx, const CGPVar& dst_eax, const CGPVar& dst_ecx )
		{
			// Destination registers must be different.
			//assert(dst_edx.getId() != dst_eax.getId() && dst_eax.getId() != dst_ecx.getId());
			_emitInstruction( INST_RDTSCP, &dst_edx, &dst_eax, &dst_ecx );
		}

		//------------------------------------------------------------------------------
		// Load ECX/RCX BYTEs from DS:[ESI/RSI] to AL.
		inline void Cx86HLAIntrinsics::rep_lodsb( const CGPVar& dst_val, const CGPVar& src_addr, const CGPVar& cnt_ecx )
		{
			// All registers must be unique, they will be reallocated to dst=EAX,RAX, src=DS:ESI/RSI, cnt=ECX/RCX.
			//assert(dst_val.getId() != src_addr.getId() && src_addr.getId() != cnt_ecx.getId());
			_emitInstruction( INST_REP_LODSB, &dst_val, &src_addr, &cnt_ecx );
		}

		//------------------------------------------------------------------------------
		// Load ECX/RCX DWORDs from DS:[ESI/RSI] to EAX.
		inline void Cx86HLAIntrinsics::rep_lodsd( const CGPVar& dst_val, const CGPVar& src_addr, const CGPVar& cnt_ecx )
		{
			// All registers must be unique, they will be reallocated to dst=EAX,RAX, src=DS:ESI/RSI, cnt=ECX/RCX.
			//assert(dst_val.getId() != src_addr.getId() && src_addr.getId() != cnt_ecx.getId());
			_emitInstruction( INST_REP_LODSD, &dst_val, &src_addr, &cnt_ecx );
		}
		
#if ( QOR_ARCH_WORDSIZE == 64 )
		//------------------------------------------------------------------------------
		// Load ECX/RCX QWORDs from DS:[ESI/RSI] to RAX.
		inline void Cx86HLAIntrinsics::rep_lodsq( const CGPVar& dst_val, const CGPVar& src_addr, const CGPVar& cnt_ecx )
		{
			// All registers must be unique, they will be reallocated to dst=EAX,RAX, src=DS:ESI/RSI, cnt=ECX/RCX.
			//assert(dst_val.getId() != src_addr.getId() && src_addr.getId() != cnt_ecx.getId());
			_emitInstruction( INST_REP_LODSQ, &dst_val, &src_addr, &cnt_ecx );
		}
#endif // ASMJIT_X64

		//------------------------------------------------------------------------------
		// Load ECX/RCX WORDs from DS:[ESI/RSI] to AX.
		inline void Cx86HLAIntrinsics::rep_lodsw( const CGPVar& dst_val, const CGPVar& src_addr, const CGPVar& cnt_ecx )
		{
			// All registers must be unique, they will be reallocated to dst=EAX,RAX, src=DS:ESI/RSI, cnt=ECX/RCX.
			//assert(dst_val.getId() != src_addr.getId() && src_addr.getId() != cnt_ecx.getId());
			_emitInstruction( INST_REP_LODSW, &dst_val, &src_addr, &cnt_ecx );
		}

		//------------------------------------------------------------------------------
		// Move ECX/RCX BYTEs from DS:[ESI/RSI] to ES:[EDI/RDI].
		inline void Cx86HLAIntrinsics::rep_movsb( const CGPVar& dst_addr, const CGPVar& src_addr, const CGPVar& cnt_ecx )
		{
			// All registers must be unique, they will be reallocated to dst=ES:EDI,RDI, src=DS:ESI/RSI, cnt=ECX/RCX.
			//assert(dst_addr.getId() != src_addr.getId() && src_addr.getId() != cnt_ecx.getId());
			_emitInstruction( INST_REP_MOVSB, &dst_addr, &src_addr, &cnt_ecx );
		}

		//------------------------------------------------------------------------------
		// Move ECX/RCX DWORDs from DS:[ESI/RSI] to ES:[EDI/RDI].
		inline void Cx86HLAIntrinsics::rep_movsd( const CGPVar& dst_addr, const CGPVar& src_addr, const CGPVar& cnt_ecx )
		{
			// All registers must be unique, they will be reallocated to dst=ES:EDI,RDI, src=DS:ESI/RSI, cnt=ECX/RCX.
			//assert(dst_addr.getId() != src_addr.getId() && src_addr.getId() != cnt_ecx.getId());
			_emitInstruction( INST_REP_MOVSD, &dst_addr, &src_addr, &cnt_ecx );
		}

#if ( QOR_ARCH_WORDSIZE == 64 )
		//------------------------------------------------------------------------------
		// Move ECX/RCX QWORDs from DS:[ESI/RSI] to ES:[EDI/RDI].
		inline void Cx86HLAIntrinsics::rep_movsq( const CGPVar& dst_addr, const CGPVar& src_addr, const CGPVar& cnt_ecx )
		{
			// All registers must be unique, they will be reallocated to dst=ES:EDI,RDI, src=DS:ESI/RSI, cnt=ECX/RCX.
			//assert(dst_addr.getId() != src_addr.getId() && src_addr.getId() != cnt_ecx.getId());
			_emitInstruction( INST_REP_MOVSQ, &dst_addr, &src_addr, &cnt_ecx );
		}
#endif // ASMJIT_X64

		//------------------------------------------------------------------------------
		// Move ECX/RCX WORDs from DS:[ESI/RSI] to ES:[EDI/RDI].
		inline void Cx86HLAIntrinsics::rep_movsw( const CGPVar& dst_addr, const CGPVar& src_addr, const CGPVar& cnt_ecx )
		{
			// All registers must be unique, they will be reallocated to dst=ES:EDI,RDI, src=DS:ESI/RSI, cnt=ECX/RCX.
			//assert(dst_addr.getId() != src_addr.getId() && src_addr.getId() != cnt_ecx.getId());
			_emitInstruction( INST_REP_MOVSW, &dst_addr, &src_addr, &cnt_ecx );
		}

		//------------------------------------------------------------------------------
		// Fill ECX/RCX BYTEs at ES:[EDI/RDI] with AL.
		inline void Cx86HLAIntrinsics::rep_stosb( const CGPVar& dst_addr, const CGPVar& src_val, const CGPVar& cnt_ecx )
		{
			// All registers must be unique, they will be reallocated to dst=ES:EDI,RDI, src=EAX/RAX, cnt=ECX/RCX.
			//assert(dst_addr.getId() != src_val.getId() && src_val.getId() != cnt_ecx.getId());
			_emitInstruction( INST_REP_STOSB, &dst_addr, &src_val, &cnt_ecx );
		}

		//------------------------------------------------------------------------------
		// Fill ECX/RCX DWORDs at ES:[EDI/RDI] with EAX.
		inline void Cx86HLAIntrinsics::rep_stosd( const CGPVar& dst_addr, const CGPVar& src_val, const CGPVar& cnt_ecx )
		{
			// All registers must be unique, they will be reallocated to dst=ES:EDI,RDI, src=EAX/RAX, cnt=ECX/RCX.
			//assert(dst_addr.getId() != src_val.getId() && src_val.getId() != cnt_ecx.getId());
			_emitInstruction( INST_REP_STOSD, &dst_addr, &src_val, &cnt_ecx );
		}

#if ( QOR_ARCH_WORDSIZE == 64 )
		//------------------------------------------------------------------------------
		// Fill ECX/RCX QWORDs at ES:[EDI/RDI] with RAX.
		inline void Cx86HLAIntrinsics::rep_stosq( const CGPVar& dst_addr, const CGPVar& src_val, const CGPVar& cnt_ecx )
		{
			// All registers must be unique, they will be reallocated to dst=ES:EDI,RDI, src=EAX/RAX, cnt=ECX/RCX.
			//assert(dst_addr.getId() != src_val.getId() && src_val.getId() != cnt_ecx.getId());
			_emitInstruction( INST_REP_STOSQ, &dst_addr, &src_val, &cnt_ecx );
		}
#endif // ASMJIT_X64

		//------------------------------------------------------------------------------
		// Fill ECX/RCX WORDs at ES:[EDI/RDI] with AX.
		inline void Cx86HLAIntrinsics::rep_stosw( const CGPVar& dst_addr, const CGPVar& src_val, const CGPVar& cnt_ecx )
		{
			// All registers must be unique, they will be reallocated to dst=ES:EDI,RDI, src=EAX/RAX, cnt=ECX/RCX.
			//assert(dst_addr.getId() != src_val.getId() && src_val.getId() != cnt_ecx.getId());
			_emitInstruction( INST_REP_STOSW, &dst_addr, &src_val, &cnt_ecx );
		}

		//------------------------------------------------------------------------------
		// Repeated find nonmatching BYTEs in ES:[EDI/RDI] and DS:[ESI/RDI].
		inline void Cx86HLAIntrinsics::repe_cmpsb( const CGPVar& cmp1_addr, const CGPVar& cmp2_addr, const CGPVar& cnt_ecx )
		{
			// All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, cmp2=ES:[EDI/RDI], cnt=ECX/RCX.
			//assert(cmp1_addr.getId() != cmp2_addr.getId() && cmp2_addr.getId() != cnt_ecx.getId());
			_emitInstruction( INST_REPE_CMPSB, &cmp1_addr, &cmp2_addr, &cnt_ecx );
		}

		//------------------------------------------------------------------------------
		// Repeated find nonmatching DWORDs in ES:[EDI/RDI] and DS:[ESI/RDI].
		inline void Cx86HLAIntrinsics::repe_cmpsd( const CGPVar& cmp1_addr, const CGPVar& cmp2_addr, const CGPVar& cnt_ecx )
		{
			// All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, cmp2=ES:[EDI/RDI], cnt=ECX/RCX.
			//assert(cmp1_addr.getId() != cmp2_addr.getId() && cmp2_addr.getId() != cnt_ecx.getId());
			_emitInstruction( INST_REPE_CMPSD, &cmp1_addr, &cmp2_addr, &cnt_ecx );
		}

#if ( QOR_ARCH_WORDSIZE == 64 )
		//------------------------------------------------------------------------------
		// Repeated find nonmatching QWORDs in ES:[EDI/RDI] and DS:[ESI/RDI].
		inline void Cx86HLAIntrinsics::repe_cmpsq( const CGPVar& cmp1_addr, const CGPVar& cmp2_addr, const CGPVar& cnt_ecx )
		{
			// All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, cmp2=ES:[EDI/RDI], cnt=ECX/RCX.
			//assert(cmp1_addr.getId() != cmp2_addr.getId() && cmp2_addr.getId() != cnt_ecx.getId());
			_emitInstruction( INST_REPE_CMPSQ, &cmp1_addr, &cmp2_addr, &cnt_ecx );
		}
#endif // ASMJIT_X64

		//------------------------------------------------------------------------------
		// Repeated find nonmatching WORDs in ES:[EDI/RDI] and DS:[ESI/RDI].
		inline void Cx86HLAIntrinsics::repe_cmpsw( const CGPVar& cmp1_addr, const CGPVar& cmp2_addr, const CGPVar& cnt_ecx )
		{
			// All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, cmp2=ES:[EDI/RDI], cnt=ECX/RCX.
			//assert(cmp1_addr.getId() != cmp2_addr.getId() && cmp2_addr.getId() != cnt_ecx.getId());
			_emitInstruction( INST_REPE_CMPSW, &cmp1_addr, &cmp2_addr, &cnt_ecx );
		}

		//------------------------------------------------------------------------------
		// Find non-AL BYTE starting at ES:[EDI/RDI].
		inline void Cx86HLAIntrinsics::repe_scasb( const CGPVar& cmp1_addr, const CGPVar& cmp2_val, const CGPVar& cnt_ecx )
		{
			// All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, src=AL, cnt=ECX/RCX.
			//assert(cmp1_addr.getId() != cmp2_val.getId() && cmp2_val.getId() != cnt_ecx.getId());
			_emitInstruction( INST_REPE_SCASB, &cmp1_addr, &cmp2_val, &cnt_ecx );
		}

		//------------------------------------------------------------------------------
		// Find non-EAX DWORD starting at ES:[EDI/RDI].
		inline void Cx86HLAIntrinsics::repe_scasd( const CGPVar& cmp1_addr, const CGPVar& cmp2_val, const CGPVar& cnt_ecx )
		{
			// All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, src=EAX, cnt=ECX/RCX.
			//assert(cmp1_addr.getId() != cmp2_val.getId() && cmp2_val.getId() != cnt_ecx.getId());
			_emitInstruction( INST_REPE_SCASD, &cmp1_addr, &cmp2_val, &cnt_ecx );
		}

#if ( QOR_ARCH_WORDSIZE == 64 )
		//------------------------------------------------------------------------------
		// Find non-RAX QWORD starting at ES:[EDI/RDI].
		inline void Cx86HLAIntrinsics::repe_scasq( const CGPVar& cmp1_addr, const CGPVar& cmp2_val, const CGPVar& cnt_ecx )
		{
			// All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, src=RAX, cnt=ECX/RCX.
			//assert(cmp1_addr.getId() != cmp2_val.getId() && cmp2_val.getId() != cnt_ecx.getId());
			_emitInstruction( INST_REPE_SCASQ, &cmp1_addr, &cmp2_val, &cnt_ecx );
		}
#endif // ASMJIT_X64

		//------------------------------------------------------------------------------
		// Find non-AX WORD starting at ES:[EDI/RDI].
		inline void Cx86HLAIntrinsics::repe_scasw( const CGPVar& cmp1_addr, const CGPVar& cmp2_val, const CGPVar& cnt_ecx )
		{
			// All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, src=AX, cnt=ECX/RCX.
			//assert(cmp1_addr.getId() != cmp2_val.getId() && cmp2_val.getId() != cnt_ecx.getId());
			_emitInstruction( INST_REPE_SCASW, &cmp1_addr, &cmp2_val, &cnt_ecx );
		}

		//------------------------------------------------------------------------------
		// Find matching BYTEs in [RDI] and [RSI].
		inline void Cx86HLAIntrinsics::repne_cmpsb( const CGPVar& cmp1_addr, const CGPVar& cmp2_addr, const CGPVar& cnt_ecx )
		{
			// All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, cmp2=ES:[EDI/RDI], cnt=ECX/RCX.
			//assert(cmp1_addr.getId() != cmp2_addr.getId() && cmp2_addr.getId() != cnt_ecx.getId());
			_emitInstruction( INST_REPNE_CMPSB, &cmp1_addr, &cmp2_addr, &cnt_ecx );
		}

		//------------------------------------------------------------------------------
		// Find matching DWORDs in [RDI] and [RSI].
		inline void Cx86HLAIntrinsics::repne_cmpsd( const CGPVar& cmp1_addr, const CGPVar& cmp2_addr, const CGPVar& cnt_ecx )
		{
			// All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, cmp2=ES:[EDI/RDI], cnt=ECX/RCX.
			//assert(cmp1_addr.getId() != cmp2_addr.getId() && cmp2_addr.getId() != cnt_ecx.getId());
			_emitInstruction( INST_REPNE_CMPSD, &cmp1_addr, &cmp2_addr, &cnt_ecx );
		}

#if ( QOR_ARCH_WORDSIZE == 64 )
		//------------------------------------------------------------------------------
		// Find matching QWORDs in [RDI] and [RSI].
		inline void Cx86HLAIntrinsics::repne_cmpsq( const CGPVar& cmp1_addr, const CGPVar& cmp2_addr, const CGPVar& cnt_ecx )
		{
			// All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, cmp2=ES:[EDI/RDI], cnt=ECX/RCX.
			//assert(cmp1_addr.getId() != cmp2_addr.getId() && cmp2_addr.getId() != cnt_ecx.getId());
			_emitInstruction( INST_REPNE_CMPSQ, &cmp1_addr, &cmp2_addr, &cnt_ecx );
		}
#endif // ASMJIT_X64

		//------------------------------------------------------------------------------
		// Find matching WORDs in [RDI] and [RSI].
		inline void Cx86HLAIntrinsics::repne_cmpsw( const CGPVar& cmp1_addr, const CGPVar& cmp2_addr, const CGPVar& cnt_ecx )
		{
			// All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, cmp2=ES:[EDI/RDI], cnt=ECX/RCX.
			//assert(cmp1_addr.getId() != cmp2_addr.getId() && cmp2_addr.getId() != cnt_ecx.getId());
			_emitInstruction( INST_REPNE_CMPSW, &cmp1_addr, &cmp2_addr, &cnt_ecx );
		}

		//------------------------------------------------------------------------------
		// Find AL, starting at ES:[EDI/RDI].
		inline void Cx86HLAIntrinsics::repne_scasb( const CGPVar& cmp1_addr, const CGPVar& cmp2_val, const CGPVar& cnt_ecx )
		{
			// All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, src=AL, cnt=ECX/RCX.
			//assert(cmp1_addr.getId() != cmp2_val.getId() && cmp2_val.getId() != cnt_ecx.getId());
			_emitInstruction( INST_REPNE_SCASB, &cmp1_addr, &cmp2_val, &cnt_ecx );
		}

		//------------------------------------------------------------------------------
		// Find EAX, starting at ES:[EDI/RDI].
		inline void Cx86HLAIntrinsics::repne_scasd( const CGPVar& cmp1_addr, const CGPVar& cmp2_val, const CGPVar& cnt_ecx )
		{
			// All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, src=EAX, cnt=ECX/RCX.
			//assert(cmp1_addr.getId() != cmp2_val.getId() && cmp2_val.getId() != cnt_ecx.getId());
			_emitInstruction( INST_REPNE_SCASD, &cmp1_addr, &cmp2_val, &cnt_ecx );
		}

#if ( QOR_ARCH_WORDSIZE == 64 )
		//------------------------------------------------------------------------------
		// Find RAX, starting at ES:[EDI/RDI].
		inline void Cx86HLAIntrinsics::repne_scasq( const CGPVar& cmp1_addr, const CGPVar& cmp2_val, const CGPVar& cnt_ecx )
		{
			// All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, src=RAX, cnt=ECX/RCX.
			//assert(cmp1_addr.getId() != cmp2_val.getId() && cmp2_val.getId() != cnt_ecx.getId());
			_emitInstruction( INST_REPNE_SCASQ, &cmp1_addr, &cmp2_val, &cnt_ecx );
		}
#endif // ASMJIT_X64

		//------------------------------------------------------------------------------
		// Find AX, starting at ES:[EDI/RDI].
		inline void Cx86HLAIntrinsics::repne_scasw( const CGPVar& cmp1_addr, const CGPVar& cmp2_val, const CGPVar& cnt_ecx )
		{
			// All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, src=AX, cnt=ECX/RCX.
			//assert(cmp1_addr.getId() != cmp2_val.getId() && cmp2_val.getId() != cnt_ecx.getId());
			_emitInstruction( INST_REPNE_SCASW, &cmp1_addr, &cmp2_val, &cnt_ecx );
		}

		//------------------------------------------------------------------------------
		// Return from Procedure.
		inline void Cx86HLAIntrinsics::ret()
		{
			_emitReturn( 0, 0 );
		}

		//------------------------------------------------------------------------------
		// Return from Procedure.
		inline void Cx86HLAIntrinsics::ret( const CGPVar& first )
		{
			_emitReturn( &first, 0 );
		}

		//------------------------------------------------------------------------------
		// Return from Procedure.
		inline void Cx86HLAIntrinsics::ret( const CGPVar& first, const CGPVar& second )
		{
			_emitReturn( &first, &second );
		}

		//------------------------------------------------------------------------------
		// Return from Procedure.
		inline void Cx86HLAIntrinsics::ret( const CXMMVar& first )
		{
			_emitReturn( &first, 0 );
		}

		//------------------------------------------------------------------------------
		// Return from Procedure.
		inline void Cx86HLAIntrinsics::ret( const CXMMVar& first, const CXMMVar& second )
		{
			_emitReturn( &first, &second );
		}

		//------------------------------------------------------------------------------
		// Rotate Bits Left. Note src register can be only cl.
		inline void Cx86HLAIntrinsics::rol( const CGPVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_ROL, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Rotate Bits Left.
		inline void Cx86HLAIntrinsics::rol( const CGPVar& dst, const CImm& src )
		{
			_emitInstruction( INST_ROL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Rotate Bits Left. Note @a src register can be only cl.
		inline void Cx86HLAIntrinsics::rol( const CMem& dst, const CGPVar& src )
		{
			_emitInstruction( INST_ROL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Rotate Bits Left.
		inline void Cx86HLAIntrinsics::rol( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_ROL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Rotate Bits Right. Note src register can be only cl.
		inline void Cx86HLAIntrinsics::ror( const CGPVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_ROR, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Rotate Bits Right.
		inline void Cx86HLAIntrinsics::ror( const CGPVar& dst, const CImm& src )
		{
			_emitInstruction( INST_ROR, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Rotate Bits Right. Note src register can be only cl.
		inline void Cx86HLAIntrinsics::ror( const CMem& dst, const CGPVar& src )
		{
			_emitInstruction( INST_ROR, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Rotate Bits Right.
		inline void Cx86HLAIntrinsics::ror( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_ROR, &dst, &src );
		}

#if ( QOR_ARCH_WORDSIZE == 32 )
		//------------------------------------------------------------------------------
		// Store var (allocated to AH/AX/EAX/RAX) into Flags.
		inline void Cx86HLAIntrinsics::sahf( const CGPVar& var )
		{
			_emitInstruction( INST_SAHF, &var );
		}
#endif // ( QOR_ARCH_WORDSIZE == 32 )

		//------------------------------------------------------------------------------
		// Integer subtraction with borrow.
		inline void Cx86HLAIntrinsics::sbb( const CGPVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_SBB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Integer subtraction with borrow.
		inline void Cx86HLAIntrinsics::sbb( const CGPVar& dst, const CMem& src )
		{
			_emitInstruction( INST_SBB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Integer subtraction with borrow.
		inline void Cx86HLAIntrinsics::sbb( const CGPVar& dst, const CImm& src )
		{
			_emitInstruction( INST_SBB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Integer subtraction with borrow.
		inline void Cx86HLAIntrinsics::sbb( const CMem& dst, const CGPVar& src )
		{
			_emitInstruction( INST_SBB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Integer subtraction with borrow.
		inline void Cx86HLAIntrinsics::sbb( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_SBB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Shift Bits Left. Note src register can be only cl.
		inline void Cx86HLAIntrinsics::sal( const CGPVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_SAL, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Shift Bits Left.
		inline void Cx86HLAIntrinsics::sal( const CGPVar& dst, const CImm& src )
		{
			_emitInstruction( INST_SAL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Shift Bits Left. Note src register can be only cl.
		inline void Cx86HLAIntrinsics::sal( const CMem& dst, const CGPVar& src )
		{
			_emitInstruction( INST_SAL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Shift Bits Left.
		inline void Cx86HLAIntrinsics::sal( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_SAL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Shift Bits Right. Note src register can be only cl.
		inline void Cx86HLAIntrinsics::sar( const CGPVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_SAR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Shift Bits Right.
		inline void Cx86HLAIntrinsics::sar( const CGPVar& dst, const CImm& src )
		{
			_emitInstruction( INST_SAR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Shift Bits Right. Note src register can be only cl.
		inline void Cx86HLAIntrinsics::sar( const CMem& dst, const CGPVar& src )
		{
			_emitInstruction( INST_SAR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Shift Bits Right.
		inline void Cx86HLAIntrinsics::sar( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_SAR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::set( CONDITION cc, const CGPVar& dst )
		{
			//assert(dst.getSize() == 1);
			_emitInstruction( ConditionToInstruction::toSetCC( cc ), &dst );
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::set( CONDITION cc, const CMem& dst )
		{
			//assert(dst.getSize() <= 1);
			_emitInstruction( ConditionToInstruction::toSetCC( cc ), &dst );
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::seta( const CGPVar& dst ) 
		{ 
			//assert(dst.getSize() == 1); 
			_emitInstruction( INST_SETA, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::seta( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1); 
			_emitInstruction( INST_SETA, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setae( const CGPVar& dst ) 
		{ 
			//assert(dst.getSize() == 1); 
			_emitInstruction( INST_SETAE, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setae( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1); 
			_emitInstruction( INST_SETAE, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setb( const CGPVar& dst ) 
		{ 
			//assert(dst.getSize() == 1); 
			_emitInstruction( INST_SETB, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setb( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1); 
			_emitInstruction( INST_SETB, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setbe( const CGPVar& dst ) 
		{ 
			//assert(dst.getSize() == 1);
			_emitInstruction( INST_SETBE, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setbe( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1); 
			_emitInstruction( INST_SETBE, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setc( const CGPVar& dst ) 
		{ 
			//assert(dst.getSize() == 1); 
			_emitInstruction( INST_SETC, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setc( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1); 
			_emitInstruction( INST_SETC, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::sete( const CGPVar& dst ) 
		{ 
			//assert(dst.getSize() == 1); 
			_emitInstruction( INST_SETE, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::sete( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1); 
			_emitInstruction( INST_SETE, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setg( const CGPVar& dst ) 
		{ 
			//assert(dst.getSize() == 1); 
			_emitInstruction( INST_SETG, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setg( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1); 
			_emitInstruction( INST_SETG, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setge( const CGPVar& dst ) 
		{ 
			//assert(dst.getSize() == 1); 
			_emitInstruction( INST_SETGE, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setge( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1); 
			_emitInstruction( INST_SETGE, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setl( const CGPVar& dst ) 
		{ 
			//assert(dst.getSize() == 1); 
			_emitInstruction( INST_SETL, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setl( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1); 
			_emitInstruction( INST_SETL, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setle( const CGPVar& dst ) 
		{ 
			//assert(dst.getSize() == 1); 
			_emitInstruction( INST_SETLE, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setle( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1); 
			_emitInstruction( INST_SETLE, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setna( const CGPVar& dst ) 
		{ 
			//assert(dst.getSize() == 1); 
			_emitInstruction( INST_SETNA, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setna( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1); 
			_emitInstruction( INST_SETNA, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setnae( const CGPVar& dst ) 
		{ 
			//assert(dst.getSize() == 1); 
			_emitInstruction( INST_SETNAE, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setnae( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1); 
			_emitInstruction( INST_SETNAE, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setnb( const CGPVar& dst ) 
		{ 
			//assert(dst.getSize() == 1); 
			_emitInstruction( INST_SETNB, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setnb( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1); 
			_emitInstruction( INST_SETNB, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setnbe( const CGPVar& dst ) 
		{ 
			//assert(dst.getSize() == 1); 
			_emitInstruction( INST_SETNBE, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setnbe( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1); 
			_emitInstruction( INST_SETNBE, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setnc( const CGPVar& dst ) 
		{ 
			//assert(dst.getSize() == 1); 
			_emitInstruction( INST_SETNC, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setnc( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1); 
			_emitInstruction( INST_SETNC, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setne( const CGPVar& dst ) 
		{ 
			//assert(dst.getSize() == 1); 
			_emitInstruction( INST_SETNE, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setne( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1); 
			_emitInstruction( INST_SETNE, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setng( const CGPVar& dst ) 
		{ 
			//assert(dst.getSize() == 1);
			_emitInstruction( INST_SETNG, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setng( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1);
			_emitInstruction( INST_SETNG, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setnge( const CGPVar& dst ) 
		{ 
			//assert(dst.getSize() == 1); 
			_emitInstruction( INST_SETNGE, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setnge( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1); 
			_emitInstruction( INST_SETNGE, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setnl( const CGPVar& dst ) 
		{ 
			//assert(dst.getSize() == 1); 
			_emitInstruction( INST_SETNL, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setnl( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1); 
			_emitInstruction( INST_SETNL, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setnle( const CGPVar& dst ) 
		{ 
			//assert(dst.getSize() == 1); 
			_emitInstruction( INST_SETNLE, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setnle( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1); 
			_emitInstruction( INST_SETNLE, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setno( const CGPVar& dst ) 
		{ 
			//assert(dst.getSize() == 1); 
			_emitInstruction( INST_SETNO, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setno( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1);
			_emitInstruction( INST_SETNO, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setnp( const CGPVar& dst ) 
		{ 
			//assert(dst.getSize() == 1);
			_emitInstruction( INST_SETNP, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setnp( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1);
			_emitInstruction( INST_SETNP, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setns( const CGPVar& dst ) 
		{ 
			//assert(dst.getSize() == 1);
			_emitInstruction( INST_SETNS, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setns( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1);
			_emitInstruction( INST_SETNS, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setnz( const CGPVar& dst ) 
		{ 
			////assert(dst.getSize() == 1);
			_emitInstruction( INST_SETNZ, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setnz( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1);
			_emitInstruction( INST_SETNZ, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::seto( const CGPVar& dst ) 
		{ 
			//assert(dst.getSize() == 1);
			_emitInstruction( INST_SETO, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::seto( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1);
			_emitInstruction( INST_SETO, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setp( const CGPVar& dst ) 
		{ 
			//assert(dst.getSize() == 1);
			_emitInstruction( INST_SETP, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setp( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1);
			_emitInstruction( INST_SETP, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setpe( const CGPVar& dst ) 
		{ 
			//assert(dst.getSize() == 1);
			_emitInstruction( INST_SETPE, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setpe( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1);
			_emitInstruction( INST_SETPE, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setpo( const CGPVar& dst ) 
		{ 
			//assert(dst.getSize() == 1);
			_emitInstruction( INST_SETPO, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setpo( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1); 
			_emitInstruction( INST_SETPO, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::sets( const CGPVar& dst ) 
		{ 
			//assert(dst.getSize() == 1); 
			_emitInstruction( INST_SETS, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::sets( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1); 
			_emitInstruction( INST_SETS, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setz( const CGPVar& dst ) 
		{ 
			//assert(dst.getSize() == 1); 
			_emitInstruction( INST_SETZ, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Set Byte on Condition.
		inline void Cx86HLAIntrinsics::setz( const CMem& dst )   
		{ 
			//assert(dst.getSize() <= 1); 
			_emitInstruction( INST_SETZ, &dst ); 
		}

		//------------------------------------------------------------------------------
		// Shift Bits Left.
		// Note src register can be only cl.
		inline void Cx86HLAIntrinsics::shl( const CGPVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_SHL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Shift Bits Left.
		inline void Cx86HLAIntrinsics::shl( const CGPVar& dst, const CImm& src )
		{
			_emitInstruction( INST_SHL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Shift Bits Left. Note src register can be only cl.
		inline void Cx86HLAIntrinsics::shl( const CMem& dst, const CGPVar& src )
		{
			_emitInstruction( INST_SHL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Shift Bits Left.
		inline void Cx86HLAIntrinsics::shl( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_SHL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Shift Bits Right. Note src register can be only cl.
		inline void Cx86HLAIntrinsics::shr( const CGPVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_SHR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Shift Bits Right.
		inline void Cx86HLAIntrinsics::shr( const CGPVar& dst, const CImm& src )
		{
			_emitInstruction( INST_SHR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Shift Bits Right. Note src register can be only cl.
		inline void Cx86HLAIntrinsics::shr( const CMem& dst, const CGPVar& src )
		{
			_emitInstruction( INST_SHR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Shift Bits Right.
		inline void Cx86HLAIntrinsics::shr( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_SHR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Double Precision Shift Left. Note src2 register can be only cl register.
		inline void Cx86HLAIntrinsics::shld( const CGPVar& dst, const CGPVar& src1, const CGPVar& src2 )
		{
			_emitInstruction( INST_SHLD, &dst, &src1, &src2 );
		}

		//------------------------------------------------------------------------------
		// Double Precision Shift Left.
		inline void Cx86HLAIntrinsics::shld( const CGPVar& dst, const CGPVar& src1, const CImm& src2 )
		{
			_emitInstruction( INST_SHLD, &dst, &src1, &src2 );
		}

		//------------------------------------------------------------------------------
		// Double Precision Shift Left. Note src2 register can be only cl register.
		inline void Cx86HLAIntrinsics::shld( const CMem& dst, const CGPVar& src1, const CGPVar& src2 )
		{
			_emitInstruction( INST_SHLD, &dst, &src1, &src2 );
		}

		//------------------------------------------------------------------------------
		// Double Precision Shift Left.
		inline void Cx86HLAIntrinsics::shld( const CMem& dst, const CGPVar& src1, const CImm& src2 )
		{
			_emitInstruction( INST_SHLD, &dst, &src1, &src2 );
		}

		//------------------------------------------------------------------------------
		// Double Precision Shift Right. Note src2 register can be only cl register.
		inline void Cx86HLAIntrinsics::shrd( const CGPVar& dst, const CGPVar& src1, const CGPVar& src2 )
		{
			_emitInstruction( INST_SHRD, &dst, &src1, &src2 );
		}

		//------------------------------------------------------------------------------
		// Double Precision Shift Right.
		inline void Cx86HLAIntrinsics::shrd( const CGPVar& dst, const CGPVar& src1, const CImm& src2 )
		{
			_emitInstruction( INST_SHRD, &dst, &src1, &src2 );
		}

		//------------------------------------------------------------------------------
		// Double Precision Shift Right. Note src2 register can be only cl register.
		inline void Cx86HLAIntrinsics::shrd( const CMem& dst, const CGPVar& src1, const CGPVar& src2 )
		{
			_emitInstruction( INST_SHRD, &dst, &src1, &src2 );
		}

		//------------------------------------------------------------------------------
		// Double Precision Shift Right.
		inline void Cx86HLAIntrinsics::shrd( const CMem& dst, const CGPVar& src1, const CImm& src2 )
		{
			_emitInstruction( INST_SHRD, &dst, &src1, &src2 );
		}

		//------------------------------------------------------------------------------
		// Set Carry Flag to 1.
		inline void Cx86HLAIntrinsics::stc()
		{
			_emitInstruction( INST_STC );
		}

		//------------------------------------------------------------------------------
		// Set Direction Flag to 1.
		inline void Cx86HLAIntrinsics::std()
		{
			_emitInstruction( INST_STD );
		}

		//------------------------------------------------------------------------------
		// Subtract.
		inline void Cx86HLAIntrinsics::sub( const CGPVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_SUB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Subtract.
		inline void Cx86HLAIntrinsics::sub( const CGPVar& dst, const CMem& src )
		{
			_emitInstruction( INST_SUB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Subtract.
		inline void Cx86HLAIntrinsics::sub( const CGPVar& dst, const CImm& src )
		{
			_emitInstruction( INST_SUB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Subtract.
		inline void Cx86HLAIntrinsics::sub( const CMem& dst, const CGPVar& src )
		{
			_emitInstruction( INST_SUB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Subtract.
		inline void Cx86HLAIntrinsics::sub( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_SUB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Logical Compare.
		inline void Cx86HLAIntrinsics::test( const CGPVar& op1, const CGPVar& op2 )
		{
			_emitInstruction( INST_TEST, &op1, &op2 );
		}

		//------------------------------------------------------------------------------
		// Logical Compare.
		inline void Cx86HLAIntrinsics::test( const CGPVar& op1, const CImm& op2 )
		{
			_emitInstruction( INST_TEST, &op1, &op2 );
		}

		//------------------------------------------------------------------------------
		// Logical Compare.
		inline void Cx86HLAIntrinsics::test( const CMem& op1, const CGPVar& op2 )
		{
			_emitInstruction( INST_TEST, &op1, &op2 );
		}

		//------------------------------------------------------------------------------
		// Logical Compare.
		inline void Cx86HLAIntrinsics::test( const CMem& op1, const CImm& op2 )
		{
			_emitInstruction( INST_TEST, &op1, &op2 );
		}

		//------------------------------------------------------------------------------
		// Undefined instruction - Raise invalid opcode exception.
		inline void Cx86HLAIntrinsics::ud2()
		{
			_emitInstruction( INST_UD2 );
		}

		//------------------------------------------------------------------------------
		// Exchange and Add.
		inline void Cx86HLAIntrinsics::xadd( const CGPVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_XADD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Exchange and Add.
		inline void Cx86HLAIntrinsics::xadd( const CMem& dst, const CGPVar& src )
		{
			_emitInstruction( INST_XADD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Exchange Register/Memory with Register.
		inline void Cx86HLAIntrinsics::xchg( const CGPVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_XCHG, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Exchange Register/Memory with Register.
		inline void Cx86HLAIntrinsics::xchg( const CMem& dst, const CGPVar& src )
		{
			_emitInstruction( INST_XCHG, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Exchange Register/Memory with Register.
		inline void Cx86HLAIntrinsics::xchg( const CGPVar& dst, const CMem& src )
		{
			_emitInstruction( INST_XCHG, &src, &dst );
		}

		//------------------------------------------------------------------------------
		// Exchange Register/Memory with Register.
		inline void Cx86HLAIntrinsics::xor_( const CGPVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_XOR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Exchange Register/Memory with Register.
		inline void Cx86HLAIntrinsics::xor_( const CGPVar& dst, const CMem& src )
		{
			_emitInstruction( INST_XOR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Exchange Register/Memory with Register.
		inline void Cx86HLAIntrinsics::xor_( const CGPVar& dst, const CImm& src )
		{
			_emitInstruction( INST_XOR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Exchange Register/Memory with Register.
		inline void Cx86HLAIntrinsics::xor_( const CMem& dst, const CGPVar& src )
		{
			_emitInstruction( INST_XOR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Exchange Register/Memory with Register.
		inline void Cx86HLAIntrinsics::xor_( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_XOR, &dst, &src );
		}

		// [MMX]

		//------------------------------------------------------------------------------
		// Empty MMX state.
		inline void Cx86HLAIntrinsics::emms()
		{
			_emitInstruction( INST_EMMS );
		}

		//------------------------------------------------------------------------------
		// Move DWord (MMX).
		inline void Cx86HLAIntrinsics::movd( const CMem& dst, const CMMVar& src )
		{
			_emitInstruction( INST_MOVD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Move DWord (MMX).
		inline void Cx86HLAIntrinsics::movd( const CGPVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_MOVD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Move DWord (MMX).
		inline void Cx86HLAIntrinsics::movd( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MOVD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Move DWord (MMX).
		inline void Cx86HLAIntrinsics::movd( const CMMVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_MOVD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move QWord (MMX).
		inline void Cx86HLAIntrinsics::movq( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_MOVQ, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Move QWord (MMX).
		inline void Cx86HLAIntrinsics::movq( const CMem& dst, const CMMVar& src )
		{
			_emitInstruction( INST_MOVQ, &dst, &src );
		}

#if ( QOR_ARCH_WORDSIZE == 64 )
		//------------------------------------------------------------------------------
		// Move QWord (MMX).
		inline void Cx86HLAIntrinsics::movq( const CGPVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_MOVQ, &dst, &src );
		}
#endif

		//------------------------------------------------------------------------------
		// Move QWord (MMX).
		inline void Cx86HLAIntrinsics::movq( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MOVQ, &dst, &src );
		}

#if ( QOR_ARCH_WORDSIZE == 64 )
		//------------------------------------------------------------------------------
		// Move QWord (MMX).
		inline void Cx86HLAIntrinsics::movq( const CMMVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_MOVQ, &dst, &src );
		}
#endif

		//------------------------------------------------------------------------------
		//Pack with Signed Saturation (MMX).
		inline void Cx86HLAIntrinsics::packsswb( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PACKSSWB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Pack with Signed Saturation (MMX).
		inline void Cx86HLAIntrinsics::packsswb( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PACKSSWB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Pack with Signed Saturation (MMX).
		inline void Cx86HLAIntrinsics::packssdw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PACKSSDW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Pack with Signed Saturation (MMX).
		inline void Cx86HLAIntrinsics::packssdw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PACKSSDW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Pack with Unsigned Saturation (MMX).
		inline void Cx86HLAIntrinsics::packuswb( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PACKUSWB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Pack with Unsigned Saturation (MMX).
		inline void Cx86HLAIntrinsics::packuswb( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PACKUSWB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed BYTE Add (MMX).
		inline void Cx86HLAIntrinsics::paddb( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PADDB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed BYTE Add (MMX).
		inline void Cx86HLAIntrinsics::paddb( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PADDB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed WORD Add (MMX).
		inline void Cx86HLAIntrinsics::paddw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PADDW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed WORD Add (MMX).
		inline void Cx86HLAIntrinsics::paddw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PADDW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed DWORD Add (MMX).
		inline void Cx86HLAIntrinsics::paddd( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PADDD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed DWORD Add (MMX).
		inline void Cx86HLAIntrinsics::paddd( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PADDD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Add with Saturation (MMX).
		inline void Cx86HLAIntrinsics::paddsb( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PADDSB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Add with Saturation (MMX).
		inline void Cx86HLAIntrinsics::paddsb( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PADDSB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Add with Saturation (MMX).
		inline void Cx86HLAIntrinsics::paddsw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PADDSW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Add with Saturation (MMX).
		inline void Cx86HLAIntrinsics::paddsw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PADDSW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Add Unsigned with Saturation (MMX).
		inline void Cx86HLAIntrinsics::paddusb( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PADDUSB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Add Unsigned with Saturation (MMX).
		inline void Cx86HLAIntrinsics::paddusb( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PADDUSB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Add Unsigned with Saturation (MMX).
		inline void Cx86HLAIntrinsics::paddusw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PADDUSW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Add Unsigned with Saturation (MMX).
		inline void Cx86HLAIntrinsics::paddusw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PADDUSW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Logical AND (MMX).
		inline void Cx86HLAIntrinsics::pand( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PAND, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Logical AND (MMX).
		inline void Cx86HLAIntrinsics::pand( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PAND, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Logical AND Not (MMX).
		inline void Cx86HLAIntrinsics::pandn( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PANDN, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Logical AND Not (MMX).
		inline void Cx86HLAIntrinsics::pandn( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PANDN, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Compare for Equal (BYTES) (MMX).
		inline void Cx86HLAIntrinsics::pcmpeqb( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PCMPEQB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Compare for Equal (BYTES) (MMX).
		inline void Cx86HLAIntrinsics::pcmpeqb( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PCMPEQB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Compare for Equal (WORDS) (MMX).
		inline void Cx86HLAIntrinsics::pcmpeqw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PCMPEQW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Compare for Equal (WORDS) (MMX).
		inline void Cx86HLAIntrinsics::pcmpeqw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PCMPEQW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Compare for Equal (DWORDS) (MMX).
		inline void Cx86HLAIntrinsics::pcmpeqd( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PCMPEQD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Compare for Equal (DWORDS) (MMX).
		inline void Cx86HLAIntrinsics::pcmpeqd( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PCMPEQD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Compare for Greater Than (BYTES) (MMX).
		inline void Cx86HLAIntrinsics::pcmpgtb( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PCMPGTB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Compare for Greater Than (BYTES) (MMX).
		inline void Cx86HLAIntrinsics::pcmpgtb( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PCMPGTB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Compare for Greater Than (WORDS) (MMX).
		inline void Cx86HLAIntrinsics::pcmpgtw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PCMPGTW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Compare for Greater Than (WORDS) (MMX).
		inline void Cx86HLAIntrinsics::pcmpgtw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PCMPGTW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Compare for Greater Than (DWORDS) (MMX).
		inline void Cx86HLAIntrinsics::pcmpgtd( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PCMPGTD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Compare for Greater Than (DWORDS) (MMX).
		inline void Cx86HLAIntrinsics::pcmpgtd( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PCMPGTD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Multiply High (MMX).
		inline void Cx86HLAIntrinsics::pmulhw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PMULHW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Multiply High (MMX).
		inline void Cx86HLAIntrinsics::pmulhw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMULHW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Multiply Low (MMX).
		inline void Cx86HLAIntrinsics::pmullw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PMULLW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Multiply Low (MMX).
		inline void Cx86HLAIntrinsics::pmullw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMULLW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Bitwise Logical OR (MMX).
		inline void Cx86HLAIntrinsics::por( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_POR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Bitwise Logical OR (MMX).
		inline void Cx86HLAIntrinsics::por( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_POR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Multiply and Add (MMX).
		inline void Cx86HLAIntrinsics::pmaddwd( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PMADDWD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Multiply and Add (MMX).
		inline void Cx86HLAIntrinsics::pmaddwd( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMADDWD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Left Logical (MMX).
		inline void Cx86HLAIntrinsics::pslld( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PSLLD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Left Logical (MMX).
		inline void Cx86HLAIntrinsics::pslld( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSLLD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Left Logical (MMX).
		inline void Cx86HLAIntrinsics::pslld( const CMMVar& dst, const CImm& src )
		{
			_emitInstruction( INST_PSLLD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Left Logical (MMX).
		inline void Cx86HLAIntrinsics::psllq( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PSLLQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Left Logical (MMX).
		inline void Cx86HLAIntrinsics::psllq( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSLLQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Left Logical (MMX).
		inline void Cx86HLAIntrinsics::psllq( const CMMVar& dst, const CImm& src )
		{
			_emitInstruction( INST_PSLLQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Left Logical (MMX).
		inline void Cx86HLAIntrinsics::psllw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PSLLW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Left Logical (MMX).
		inline void Cx86HLAIntrinsics::psllw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSLLW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Left Logical (MMX).
		inline void Cx86HLAIntrinsics::psllw( const CMMVar& dst, const CImm& src )
		{
			_emitInstruction( INST_PSLLW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Right Arithmetic (MMX).
		inline void Cx86HLAIntrinsics::psrad( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PSRAD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Right Arithmetic (MMX).
		inline void Cx86HLAIntrinsics::psrad( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSRAD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Right Arithmetic (MMX).
		inline void Cx86HLAIntrinsics::psrad( const CMMVar& dst, const CImm& src )
		{
			_emitInstruction( INST_PSRAD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Right Arithmetic (MMX).
		inline void Cx86HLAIntrinsics::psraw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PSRAW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Right Arithmetic (MMX).
		inline void Cx86HLAIntrinsics::psraw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSRAW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Right Arithmetic (MMX).
		inline void Cx86HLAIntrinsics::psraw( const CMMVar& dst, const CImm& src )
		{
			_emitInstruction( INST_PSRAW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Right Logical (MMX).
		inline void Cx86HLAIntrinsics::psrld( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PSRLD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Right Logical (MMX).
		inline void Cx86HLAIntrinsics::psrld( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSRLD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Right Logical (MMX).
		inline void Cx86HLAIntrinsics::psrld( const CMMVar& dst, const CImm& src )
		{
			_emitInstruction( INST_PSRLD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Right Logical (MMX).
		inline void Cx86HLAIntrinsics::psrlq( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PSRLQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Right Logical (MMX).
		inline void Cx86HLAIntrinsics::psrlq( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSRLQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Right Logical (MMX).
		inline void Cx86HLAIntrinsics::psrlq( const CMMVar& dst, const CImm& src )
		{
			_emitInstruction( INST_PSRLQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Right Logical (MMX).
		inline void Cx86HLAIntrinsics::psrlw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PSRLW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Right Logical (MMX).
		inline void Cx86HLAIntrinsics::psrlw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSRLW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Right Logical (MMX).
		inline void Cx86HLAIntrinsics::psrlw( const CMMVar& dst, const CImm& src )
		{
			_emitInstruction( INST_PSRLW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Subtract (MMX).
		inline void Cx86HLAIntrinsics::psubb( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PSUBB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Subtract (MMX).
		inline void Cx86HLAIntrinsics::psubb( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSUBB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Subtract (MMX).
		inline void Cx86HLAIntrinsics::psubw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PSUBW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Subtract (MMX).
		inline void Cx86HLAIntrinsics::psubw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSUBW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Subtract (MMX).
		inline void Cx86HLAIntrinsics::psubd( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PSUBD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Subtract (MMX).
		inline void Cx86HLAIntrinsics::psubd( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSUBD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Subtract with Saturation (MMX).
		inline void Cx86HLAIntrinsics::psubsb( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PSUBSB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Subtract with Saturation (MMX).
		inline void Cx86HLAIntrinsics::psubsb( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSUBSB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Subtract with Saturation (MMX).
		inline void Cx86HLAIntrinsics::psubsw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PSUBSW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Subtract with Saturation (MMX).
		inline void Cx86HLAIntrinsics::psubsw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSUBSW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Subtract with Unsigned Saturation (MMX).
		inline void Cx86HLAIntrinsics::psubusb( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PSUBUSB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Subtract with Unsigned Saturation (MMX).
		inline void Cx86HLAIntrinsics::psubusb( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSUBUSB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Subtract with Unsigned Saturation (MMX).
		inline void Cx86HLAIntrinsics::psubusw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PSUBUSW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Subtract with Unsigned Saturation (MMX).
		inline void Cx86HLAIntrinsics::psubusw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSUBUSW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unpack High Packed Data (MMX).
		inline void Cx86HLAIntrinsics::punpckhbw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PUNPCKHBW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unpack High Packed Data (MMX).
		inline void Cx86HLAIntrinsics::punpckhbw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PUNPCKHBW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unpack High Packed Data (MMX).
		inline void Cx86HLAIntrinsics::punpckhwd( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PUNPCKHWD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unpack High Packed Data (MMX).
		inline void Cx86HLAIntrinsics::punpckhwd( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PUNPCKHWD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unpack High Packed Data (MMX).
		inline void Cx86HLAIntrinsics::punpckhdq( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PUNPCKHDQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unpack High Packed Data (MMX).
		inline void Cx86HLAIntrinsics::punpckhdq( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PUNPCKHDQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unpack High Packed Data (MMX).
		inline void Cx86HLAIntrinsics::punpcklbw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PUNPCKLBW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unpack High Packed Data (MMX).
		inline void Cx86HLAIntrinsics::punpcklbw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PUNPCKLBW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unpack High Packed Data (MMX).
		inline void Cx86HLAIntrinsics::punpcklwd( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PUNPCKLWD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unpack High Packed Data (MMX).
		inline void Cx86HLAIntrinsics::punpcklwd( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PUNPCKLWD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unpack High Packed Data (MMX).
		inline void Cx86HLAIntrinsics::punpckldq( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PUNPCKLDQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unpack High Packed Data (MMX).
		inline void Cx86HLAIntrinsics::punpckldq( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PUNPCKLDQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Bitwise Exclusive OR (MMX).
		inline void Cx86HLAIntrinsics::pxor( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PXOR, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Bitwise Exclusive OR (MMX).
		inline void Cx86HLAIntrinsics::pxor( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PXOR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// 3dNow
		// Faster EMMS (3dNow!).
		// Note Use only for early AMD processors where is only 3dNow! or SSE. If
		// CPU contains SSE2, it's better to use emms() ( femms() is mapped to emms() ).
		inline void Cx86HLAIntrinsics::femms()
		{
			_emitInstruction( INST_FEMMS );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP to Integer Convert (3dNow!).
		inline void Cx86HLAIntrinsics::pf2id( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PF2ID, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP to Integer Convert (3dNow!).
		inline void Cx86HLAIntrinsics::pf2id( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PF2ID, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//  Packed SP-FP to Integer Word Convert (3dNow!).
		inline void Cx86HLAIntrinsics::pf2iw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PF2IW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//  Packed SP-FP to Integer Word Convert (3dNow!).
		inline void Cx86HLAIntrinsics::pf2iw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PF2IW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Accumulate (3dNow!).
		inline void Cx86HLAIntrinsics::pfacc( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PFACC, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Accumulate (3dNow!).
		inline void Cx86HLAIntrinsics::pfacc( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PFACC, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Addition (3dNow!).
		inline void Cx86HLAIntrinsics::pfadd( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PFADD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Addition (3dNow!).
		inline void Cx86HLAIntrinsics::pfadd( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PFADD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Compare - dst == src (3dNow!).
		inline void Cx86HLAIntrinsics::pfcmpeq( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PFCMPEQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Compare - dst == src (3dNow!).
		inline void Cx86HLAIntrinsics::pfcmpeq( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PFCMPEQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Compare - dst >= src (3dNow!).
		inline void Cx86HLAIntrinsics::pfcmpge( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PFCMPGE, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Compare - dst >= src (3dNow!).
		inline void Cx86HLAIntrinsics::pfcmpge( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PFCMPGE, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Compare - dst > src (3dNow!).
		inline void Cx86HLAIntrinsics::pfcmpgt( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PFCMPGT, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Compare - dst > src (3dNow!).
		inline void Cx86HLAIntrinsics::pfcmpgt( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PFCMPGT, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Maximum (3dNow!).
		inline void Cx86HLAIntrinsics::pfmax( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PFMAX, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Maximum (3dNow!).
		inline void Cx86HLAIntrinsics::pfmax( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PFMAX, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Minimum (3dNow!).
		inline void Cx86HLAIntrinsics::pfmin( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PFMIN, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Minimum (3dNow!).
		inline void Cx86HLAIntrinsics::pfmin( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PFMIN, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Multiply (3dNow!).
		inline void Cx86HLAIntrinsics::pfmul( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PFMUL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Multiply (3dNow!).
		inline void Cx86HLAIntrinsics::pfmul( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PFMUL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Negative Accumulate (3dNow!).
		inline void Cx86HLAIntrinsics::pfnacc( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PFNACC, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed SP-FP Negative Accumulate (3dNow!).
		inline void Cx86HLAIntrinsics::pfnacc( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PFNACC, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Mixed Accumulate (3dNow!).
		inline void Cx86HLAIntrinsics::pfpnaxx( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PFPNACC, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed SP-FP Mixed Accumulate (3dNow!).
		inline void Cx86HLAIntrinsics::pfpnacc( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PFPNACC, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Reciprocal Approximation (3dNow!).
		inline void Cx86HLAIntrinsics::pfrcp( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PFRCP, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed SP-FP Reciprocal Approximation (3dNow!).
		inline void Cx86HLAIntrinsics::pfrcp( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PFRCP, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Reciprocal, First Iteration Step (3dNow!).
		inline void Cx86HLAIntrinsics::pfrcpit1( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PFRCPIT1, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed SP-FP Reciprocal, First Iteration Step (3dNow!).
		inline void Cx86HLAIntrinsics::pfrcpit1( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PFRCPIT1, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Reciprocal, Second Iteration Step (3dNow!).
		inline void Cx86HLAIntrinsics::pfrcpit2( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PFRCPIT2, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Reciprocal, Second Iteration Step (3dNow!).
		inline void Cx86HLAIntrinsics::pfrcpit2( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PFRCPIT2, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Reciprocal Square Root, First Iteration Step (3dNow!).
		inline void Cx86HLAIntrinsics::pfrsqit1( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PFRSQIT1, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Reciprocal Square Root, First Iteration Step (3dNow!).
		inline void Cx86HLAIntrinsics::pfrsqit1( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PFRSQIT1, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Reciprocal Square Root Approximation (3dNow!).
		inline void Cx86HLAIntrinsics::pfrsqrt( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PFRSQRT, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Reciprocal Square Root Approximation (3dNow!).
		inline void Cx86HLAIntrinsics::pfrsqrt( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PFRSQRT, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Subtract (3dNow!).
		inline void Cx86HLAIntrinsics::pfsub( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PFSUB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Subtract (3dNow!).
		inline void Cx86HLAIntrinsics::pfsub( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PFSUB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Reverse Subtract (3dNow!).
		inline void Cx86HLAIntrinsics::pfsubr( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PFSUBR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Reverse Subtract (3dNow!).
		inline void Cx86HLAIntrinsics::pfsubr( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PFSUBR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed DWords to SP-FP (3dNow!).
		inline void Cx86HLAIntrinsics::pi2fd( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PI2FD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed DWords to SP-FP (3dNow!).
		inline void Cx86HLAIntrinsics::pi2fd( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PI2FD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Words to SP-FP (3dNow!).
		inline void Cx86HLAIntrinsics::pi2fw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PI2FW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Words to SP-FP (3dNow!).
		inline void Cx86HLAIntrinsics::pi2fw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PI2FW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed swap DWord (3dNow!)
		inline void Cx86HLAIntrinsics::pswapd( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PSWAPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed swap DWord (3dNow!)
		inline void Cx86HLAIntrinsics::pswapd( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSWAPD, &dst, &src );
		}

		// SSE

		//------------------------------------------------------------------------------
		// Packed SP-FP Add (SSE).
		inline void Cx86HLAIntrinsics::addps( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_ADDPS, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed SP-FP Add (SSE).
		inline void Cx86HLAIntrinsics::addps( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_ADDPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar SP-FP Add (SSE).
		inline void Cx86HLAIntrinsics::addss( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_ADDSS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar SP-FP Add (SSE).
		inline void Cx86HLAIntrinsics::addss( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_ADDSS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Bit-wise Logical And Not For SP-FP (SSE).
		inline void Cx86HLAIntrinsics::andnps( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_ANDNPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Bit-wise Logical And Not For SP-FP (SSE).
		inline void Cx86HLAIntrinsics::andnps( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_ANDNPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Bit-wise Logical And For SP-FP (SSE).
		inline void Cx86HLAIntrinsics::andps( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_ANDPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Bit-wise Logical And For SP-FP (SSE).
		inline void Cx86HLAIntrinsics::andps( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_ANDPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Compare (SSE).
		inline void Cx86HLAIntrinsics::cmpps( const CXMMVar& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_CMPPS, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Compare (SSE).
		inline void Cx86HLAIntrinsics::cmpps( const CXMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_CMPPS, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Compare Scalar SP-FP Values (SSE).
		inline void Cx86HLAIntrinsics::cmpss( const CXMMVar& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_CMPSS, &dst, &src, &imm8 );
		}
	
		//------------------------------------------------------------------------------
		// Compare Scalar SP-FP Values (SSE).
		inline void Cx86HLAIntrinsics::cmpss( const CXMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_CMPSS, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Scalar Ordered SP-FP Compare and Set EFLAGS (SSE).
		inline void Cx86HLAIntrinsics::comiss( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_COMISS, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Scalar Ordered SP-FP Compare and Set EFLAGS (SSE).
		inline void Cx86HLAIntrinsics::comiss( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_COMISS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Signed INT32 to Packed SP-FP Conversion (SSE).
		inline void Cx86HLAIntrinsics::cvtpi2ps( const CXMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_CVTPI2PS, &dst, &src );
		}
		
		//------------------------------------------------------------------------------
		// Packed Signed INT32 to Packed SP-FP Conversion (SSE).
		inline void Cx86HLAIntrinsics::cvtpi2ps( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_CVTPI2PS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP to Packed INT32 Conversion (SSE).
		inline void Cx86HLAIntrinsics::cvtps2pi( const CMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_CVTPS2PI, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP to Packed INT32 Conversion (SSE).
		inline void Cx86HLAIntrinsics::cvtps2pi( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_CVTPS2PI, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar Signed INT32 to SP-FP Conversion (SSE).
		inline void Cx86HLAIntrinsics::cvtsi2ss( const CXMMVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_CVTSI2SS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar Signed INT32 to SP-FP Conversion (SSE).
		inline void Cx86HLAIntrinsics::cvtsi2ss( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_CVTSI2SS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar SP-FP to Signed INT32 Conversion (SSE).
		inline void Cx86HLAIntrinsics::cvtss2si( const CGPVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_CVTSS2SI, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar SP-FP to Signed INT32 Conversion (SSE).
		inline void Cx86HLAIntrinsics::cvtss2si( const CGPVar& dst, const CMem& src )
		{
			_emitInstruction( INST_CVTSS2SI, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP to Packed INT32 Conversion (truncate) (SSE).
		inline void Cx86HLAIntrinsics::cvttps2pi( const CMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_CVTTPS2PI, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP to Packed INT32 Conversion (truncate) (SSE).
		inline void Cx86HLAIntrinsics::cvttps2pi( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_CVTTPS2PI, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar SP-FP to Signed INT32 Conversion (truncate) (SSE).
		inline void Cx86HLAIntrinsics::cvttss2si( const CGPVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_CVTTSS2SI, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar SP-FP to Signed INT32 Conversion (truncate) (SSE).
		inline void Cx86HLAIntrinsics::cvttss2si( const CGPVar& dst, const CMem& src )
		{
			_emitInstruction( INST_CVTTSS2SI, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Divide (SSE).
		inline void Cx86HLAIntrinsics::divps( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_DIVPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Divide (SSE).
		inline void Cx86HLAIntrinsics::divps( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_DIVPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar SP-FP Divide (SSE).
		inline void Cx86HLAIntrinsics::divss( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_DIVSS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar SP-FP Divide (SSE).
		inline void Cx86HLAIntrinsics::divss( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_DIVSS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Load Streaming SIMD Extension Control/Status (SSE).
		inline void Cx86HLAIntrinsics::ldmxcsr( const CMem& src )
		{
			_emitInstruction( INST_LDMXCSR, &src );
		}

		//------------------------------------------------------------------------------
		// Byte Mask Write (SSE). Note The default memory location is specified by DS:EDI.
		inline void Cx86HLAIntrinsics::maskmovq( const CGPVar& dst_ptr, const CMMVar& data, const CMMVar& mask )
		{
			_emitInstruction( INST_MASKMOVQ, &dst_ptr, &data, &mask );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Maximum (SSE).
		inline void Cx86HLAIntrinsics::maxps( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MAXPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Maximum (SSE).
		inline void Cx86HLAIntrinsics::maxps( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MAXPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar SP-FP Maximum (SSE).
		inline void Cx86HLAIntrinsics::maxss( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MAXSS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar SP-FP Maximum (SSE).
		inline void Cx86HLAIntrinsics::maxss( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MAXSS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Minimum (SSE).
		inline void Cx86HLAIntrinsics::minps( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MINPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Minimum (SSE).
		inline void Cx86HLAIntrinsics::minps( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MINPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar SP-FP Minimum (SSE).
		inline void Cx86HLAIntrinsics::minss( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MINSS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar SP-FP Minimum (SSE).
		inline void Cx86HLAIntrinsics::minss( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MINSS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Aligned Packed SP-FP Values (SSE).
		inline void Cx86HLAIntrinsics::movaps( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVAPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Aligned Packed SP-FP Values (SSE).
		inline void Cx86HLAIntrinsics::movaps( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MOVAPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Aligned Packed SP-FP Values (SSE).
		inline void Cx86HLAIntrinsics::movaps( const CMem& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVAPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move DWord.
		inline void Cx86HLAIntrinsics::movd( const CMem& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move DWord.
		inline void Cx86HLAIntrinsics::movd( const CGPVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move DWord.
		inline void Cx86HLAIntrinsics::movd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MOVD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move DWord.
		inline void Cx86HLAIntrinsics::movd( const CXMMVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_MOVD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move QWord (SSE).
		inline void Cx86HLAIntrinsics::movq( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVQ, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Move QWord (SSE).
		inline void Cx86HLAIntrinsics::movq( const CMem& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVQ, &dst, &src );
		}

#if ( QOR_ARCH_WORDSIZE == 64 )
		//------------------------------------------------------------------------------
		// Move QWord (SSE).
		inline void Cx86HLAIntrinsics::movq( const CGPVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVQ, &dst, &src );
		}
#endif // ASMJIT_X64

		//------------------------------------------------------------------------------
		// Move QWord (SSE).
		inline void Cx86HLAIntrinsics::movq( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MOVQ, &dst, &src );
		}

#if ( QOR_ARCH_WORDSIZE == 64 )
		//------------------------------------------------------------------------------
		// Move QWord (SSE).
		inline void Cx86HLAIntrinsics::movq( const CXMMVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_MOVQ, &dst, &src );
		}
#endif // ASMJIT_X64

		//------------------------------------------------------------------------------
		// Move 64 Bits Non Temporal (SSE).
		inline void Cx86HLAIntrinsics::movntq( const CMem& dst, const CMMVar& src )
		{
			_emitInstruction( INST_MOVNTQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// High to Low Packed SP-FP (SSE).
		inline void Cx86HLAIntrinsics::movhlps( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVHLPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move High Packed SP-FP (SSE).
		inline void Cx86HLAIntrinsics::movhps( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MOVHPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move High Packed SP-FP (SSE).
		inline void Cx86HLAIntrinsics::movhps( const CMem& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVHPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Low to High Packed SP-FP (SSE).
		inline void Cx86HLAIntrinsics::movlhps( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVLHPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Low Packed SP-FP (SSE).
		inline void Cx86HLAIntrinsics::movlps( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MOVLPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Low Packed SP-FP (SSE).
		inline void Cx86HLAIntrinsics::movlps( const CMem& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVLPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Aligned Four Packed SP-FP Non Temporal (SSE).
		inline void Cx86HLAIntrinsics::movntps( const CMem& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVNTPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Scalar SP-FP (SSE).
		inline void Cx86HLAIntrinsics::movss( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVSS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Scalar SP-FP (SSE).
		inline void Cx86HLAIntrinsics::movss( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MOVSS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Scalar SP-FP (SSE).
		inline void Cx86HLAIntrinsics::movss( const CMem& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVSS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Unaligned Packed SP-FP Values (SSE).
		inline void Cx86HLAIntrinsics::movups( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVUPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Unaligned Packed SP-FP Values (SSE).
		inline void Cx86HLAIntrinsics::movups( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MOVUPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Unaligned Packed SP-FP Values (SSE).
		inline void Cx86HLAIntrinsics::movups( const CMem& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVUPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Multiply (SSE).
		inline void Cx86HLAIntrinsics::mulps( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MULPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Multiply (SSE).
		inline void Cx86HLAIntrinsics::mulps( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MULPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar SP-FP Multiply (SSE).
		inline void Cx86HLAIntrinsics::mulss( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MULSS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar SP-FP Multiply (SSE).
		inline void Cx86HLAIntrinsics::mulss( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MULSS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Bit-wise Logical OR for SP-FP Data (SSE).
		inline void Cx86HLAIntrinsics::orps( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_ORPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Bit-wise Logical OR for SP-FP Data (SSE).
		inline void Cx86HLAIntrinsics::orps( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_ORPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Average (SSE).
		inline void Cx86HLAIntrinsics::pavgb( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PAVGB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Average (SSE).
		inline void Cx86HLAIntrinsics::pavgb( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PAVGB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Average (SSE).
		inline void Cx86HLAIntrinsics::pavgw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PAVGW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Average (SSE).
		inline void Cx86HLAIntrinsics::pavgw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PAVGW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Extract Word (SSE).
		inline void Cx86HLAIntrinsics::pextrw( const CGPVar& dst, const CMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PEXTRW, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Insert Word (SSE).
		inline void Cx86HLAIntrinsics::pinsrw( const CMMVar& dst, const CGPVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PINSRW, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Insert Word (SSE).
		inline void Cx86HLAIntrinsics::pinsrw( const CMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PINSRW, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Packed Signed Integer Word Maximum (SSE).
		inline void Cx86HLAIntrinsics::pmaxsw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PMAXSW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Signed Integer Word Maximum (SSE).
		inline void Cx86HLAIntrinsics::pmaxsw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMAXSW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Unsigned Integer Byte Maximum (SSE).
		inline void Cx86HLAIntrinsics::pmaxub( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PMAXUB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Unsigned Integer Byte Maximum (SSE).
		inline void Cx86HLAIntrinsics::pmaxub( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMAXUB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Signed Integer Word Minimum (SSE).
		inline void Cx86HLAIntrinsics::pminsw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PMINSW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Signed Integer Word Minimum (SSE).
		inline void Cx86HLAIntrinsics::pminsw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMINSW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Unsigned Integer Byte Minimum (SSE).
		inline void Cx86HLAIntrinsics::pminub( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PMINUB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Unsigned Integer Byte Minimum (SSE).
		inline void Cx86HLAIntrinsics::pminub( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMINUB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Byte Mask To Integer (SSE).
		inline void Cx86HLAIntrinsics::pmovmskb( const CGPVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PMOVMSKB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Multiply High Unsigned (SSE).
		inline void Cx86HLAIntrinsics::pmulhuw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PMULHUW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Multiply High Unsigned (SSE).
		inline void Cx86HLAIntrinsics::pmulhuw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMULHUW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Sum of Absolute Differences (SSE).
		inline void Cx86HLAIntrinsics::psadbw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PSADBW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Sum of Absolute Differences (SSE).
		inline void Cx86HLAIntrinsics::psadbw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSADBW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shuffle word (SSE).
		inline void Cx86HLAIntrinsics::pshufw( const CMMVar& dst, const CMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PSHUFW, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Packed Shuffle word (SSE).
		inline void Cx86HLAIntrinsics::pshufw( const CMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PSHUFW, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Reciprocal (SSE).
		inline void Cx86HLAIntrinsics::rcpps( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_RCPPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Reciprocal (SSE).
		inline void Cx86HLAIntrinsics::rcpps( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_RCPPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar SP-FP Reciprocal (SSE).
		inline void Cx86HLAIntrinsics::rcpss( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_RCPSS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar SP-FP Reciprocal (SSE).
		inline void Cx86HLAIntrinsics::rcpss( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_RCPSS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Prefetch (SSE).
		inline void Cx86HLAIntrinsics::prefetch( const CMem& mem, const CImm& hint )
		{
			_emitInstruction( INST_PREFETCH, &mem, &hint );
		}

		//------------------------------------------------------------------------------
		// Compute Sum of Absolute Differences (SSE).
		inline void Cx86HLAIntrinsics::psadbw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PSADBW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Compute Sum of Absolute Differences (SSE).
		inline void Cx86HLAIntrinsics::psadbw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSADBW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Square Root Reciprocal (SSE).
		inline void Cx86HLAIntrinsics::rsqrtps( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_RSQRTPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Square Root Reciprocal (SSE).
		inline void Cx86HLAIntrinsics::rsqrtps( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_RSQRTPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar SP-FP Square Root Reciprocal (SSE).
		inline void Cx86HLAIntrinsics::rsqrtss( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_RSQRTSS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar SP-FP Square Root Reciprocal (SSE).
		inline void Cx86HLAIntrinsics::rsqrtss( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_RSQRTSS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Store fence (SSE).
		inline void Cx86HLAIntrinsics::sfence()
		{
			_emitInstruction( INST_SFENCE );
		}

		//------------------------------------------------------------------------------
		// Shuffle SP-FP (SSE).
		inline void Cx86HLAIntrinsics::shufps( const CXMMVar& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_SHUFPS, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Shuffle SP-FP (SSE).
		inline void Cx86HLAIntrinsics::shufps( const CXMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_SHUFPS, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Square Root (SSE).
		inline void Cx86HLAIntrinsics::sqrtps( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_SQRTPS, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed SP-FP Square Root (SSE).
		inline void Cx86HLAIntrinsics::sqrtps( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_SQRTPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar SP-FP Square Root (SSE).
		inline void Cx86HLAIntrinsics::sqrtss( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_SQRTSS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar SP-FP Square Root (SSE).
		inline void Cx86HLAIntrinsics::sqrtss( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_SQRTSS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Store Streaming SIMD Extension Control/Status (SSE).
		inline void Cx86HLAIntrinsics::stmxcsr( const CMem& dst )
		{
			_emitInstruction( INST_STMXCSR, &dst );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Subtract (SSE).
		inline void Cx86HLAIntrinsics::subps( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_SUBPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Subtract (SSE).
		inline void Cx86HLAIntrinsics::subps( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_SUBPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar SP-FP Subtract (SSE).
		inline void Cx86HLAIntrinsics::subss( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_SUBSS, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Scalar SP-FP Subtract (SSE).
		inline void Cx86HLAIntrinsics::subss( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_SUBSS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unordered Scalar SP-FP compare and set EFLAGS (SSE).
		inline void Cx86HLAIntrinsics::ucomiss( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_UCOMISS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unordered Scalar SP-FP compare and set EFLAGS (SSE).
		inline void Cx86HLAIntrinsics::ucomiss( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_UCOMISS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unpack High Packed SP-FP Data (SSE).
		inline void Cx86HLAIntrinsics::unpckhps( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_UNPCKHPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unpack High Packed SP-FP Data (SSE).
		inline void Cx86HLAIntrinsics::unpckhps( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_UNPCKHPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unpack Low Packed SP-FP Data (SSE).
		inline void Cx86HLAIntrinsics::unpcklps( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_UNPCKLPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unpack Low Packed SP-FP Data (SSE).
		inline void Cx86HLAIntrinsics::unpcklps( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_UNPCKLPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Bit-wise Logical Xor for SP-FP Data (SSE).
		inline void Cx86HLAIntrinsics::xorps( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_XORPS, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Bit-wise Logical Xor for SP-FP Data (SSE).
		inline void Cx86HLAIntrinsics::xorps( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_XORPS, &dst, &src );
		}

		// SSE2

		//------------------------------------------------------------------------------
		// Packed DP-FP Add (SSE2).
		inline void Cx86HLAIntrinsics::addpd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_ADDPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed DP-FP Add (SSE2).
		inline void Cx86HLAIntrinsics::addpd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_ADDPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar DP-FP Add (SSE2).
		inline void Cx86HLAIntrinsics::addsd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_ADDSD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar DP-FP Add (SSE2).
		inline void Cx86HLAIntrinsics::addsd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_ADDSD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Bit-wise Logical And Not For DP-FP (SSE2).
		inline void Cx86HLAIntrinsics::andnpd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_ANDNPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Bit-wise Logical And Not For DP-FP (SSE2).
		inline void Cx86HLAIntrinsics::andnpd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_ANDNPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Bit-wise Logical And For DP-FP (SSE2).
		inline void Cx86HLAIntrinsics::andpd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_ANDPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Bit-wise Logical And For DP-FP (SSE2).
		inline void Cx86HLAIntrinsics::andpd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_ANDPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Flush Cache Line (SSE2).
		inline void Cx86HLAIntrinsics::clflush( const CMem& mem )
		{
			_emitInstruction( INST_CLFLUSH, &mem );
		}

		//------------------------------------------------------------------------------
		// Packed DP-FP Compare (SSE2).
		inline void Cx86HLAIntrinsics::cmppd( const CXMMVar& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_CMPPD, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Packed DP-FP Compare (SSE2).
		inline void Cx86HLAIntrinsics::cmppd( const CXMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_CMPPD, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Compare Scalar SP-FP Values (SSE2).
		inline void Cx86HLAIntrinsics::cmpsd( const CXMMVar& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_CMPSD, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Compare Scalar SP-FP Values (SSE2).
		inline void Cx86HLAIntrinsics::cmpsd( const CXMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_CMPSD, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Scalar Ordered DP-FP Compare and Set EFLAGS (SSE2).
		inline void Cx86HLAIntrinsics::comisd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_COMISD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar Ordered DP-FP Compare and Set EFLAGS (SSE2).
		inline void Cx86HLAIntrinsics::comisd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_COMISD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert Packed Dword Integers to Packed DP-FP Values (SSE2).
		inline void Cx86HLAIntrinsics::cvtdq2pd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_CVTDQ2PD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert Packed Dword Integers to Packed DP-FP Values (SSE2).
		inline void Cx86HLAIntrinsics::cvtdq2pd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_CVTDQ2PD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert Packed Dword Integers to Packed SP-FP Values (SSE2).
		inline void Cx86HLAIntrinsics::cvtdq2ps( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_CVTDQ2PS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert Packed Dword Integers to Packed SP-FP Values (SSE2).
		inline void Cx86HLAIntrinsics::cvtdq2ps( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_CVTDQ2PS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert Packed DP-FP Values to Packed Dword Integers (SSE2).
		inline void Cx86HLAIntrinsics::cvtpd2dq( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_CVTPD2DQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert Packed DP-FP Values to Packed Dword Integers (SSE2).
		inline void Cx86HLAIntrinsics::cvtpd2dq( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_CVTPD2DQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert Packed DP-FP Values to Packed Dword Integers (SSE2).
		inline void Cx86HLAIntrinsics::cvtpd2pi( const CMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_CVTPD2PI, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert Packed DP-FP Values to Packed Dword Integers (SSE2).
		inline void Cx86HLAIntrinsics::cvtpd2pi( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_CVTPD2PI, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert Packed DP-FP Values to Packed SP-FP Values (SSE2).
		inline void Cx86HLAIntrinsics::cvtpd2ps( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_CVTPD2PS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert Packed DP-FP Values to Packed SP-FP Values (SSE2).
		inline void Cx86HLAIntrinsics::cvtpd2ps( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_CVTPD2PS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert Packed Dword Integers to Packed DP-FP Values (SSE2).
		inline void Cx86HLAIntrinsics::cvtpi2pd( const CXMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_CVTPI2PD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert Packed Dword Integers to Packed DP-FP Values (SSE2).
		inline void Cx86HLAIntrinsics::cvtpi2pd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_CVTPI2PD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert Packed SP-FP Values to Packed Dword Integers (SSE2).
		inline void Cx86HLAIntrinsics::cvtps2dq( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_CVTPS2DQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert Packed SP-FP Values to Packed Dword Integers (SSE2).
		inline void Cx86HLAIntrinsics::cvtps2dq( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_CVTPS2DQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert Packed SP-FP Values to Packed DP-FP Values (SSE2).
		inline void Cx86HLAIntrinsics::cvtps2pd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_CVTPS2PD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert Packed SP-FP Values to Packed DP-FP Values (SSE2).
		inline void Cx86HLAIntrinsics::cvtps2pd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_CVTPS2PD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert Scalar DP-FP Value to Dword Integer (SSE2).
		inline void Cx86HLAIntrinsics::cvtsd2si( const CGPVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_CVTSD2SI, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert Scalar DP-FP Value to Dword Integer (SSE2).
		inline void Cx86HLAIntrinsics::cvtsd2si( const CGPVar& dst, const CMem& src )
		{
			_emitInstruction( INST_CVTSD2SI, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert Scalar DP-FP Value to Scalar SP-FP Value (SSE2).
		inline void Cx86HLAIntrinsics::cvtsd2ss( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_CVTSD2SS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert Scalar DP-FP Value to Scalar SP-FP Value (SSE2).
		inline void Cx86HLAIntrinsics::cvtsd2ss( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_CVTSD2SS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert Dword Integer to Scalar DP-FP Value (SSE2).
		inline void Cx86HLAIntrinsics::cvtsi2sd( const CXMMVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_CVTSI2SD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Convert Dword Integer to Scalar DP-FP Value (SSE2).
		inline void Cx86HLAIntrinsics::cvtsi2sd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_CVTSI2SD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert Scalar SP-FP Value to Scalar DP-FP Value (SSE2).
		inline void Cx86HLAIntrinsics::cvtss2sd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_CVTSS2SD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Convert Scalar SP-FP Value to Scalar DP-FP Value (SSE2).
		inline void Cx86HLAIntrinsics::cvtss2sd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_CVTSS2SD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert with Truncation Packed DP-FP Values to Packed Dword Integers (SSE2).
		inline void Cx86HLAIntrinsics::cvttpd2pi( const CMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_CVTTPD2PI, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert with Truncation Packed DP-FP Values to Packed Dword Integers (SSE2).
		inline void Cx86HLAIntrinsics::cvttpd2pi( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_CVTTPD2PI, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert with Truncation Packed DP-FP Values to Packed Dword Integers (SSE2).
		inline void Cx86HLAIntrinsics::cvttpd2dq( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_CVTTPD2DQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert with Truncation Packed DP-FP Values to Packed Dword Integers (SSE2).
		inline void Cx86HLAIntrinsics::cvttpd2dq( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_CVTTPD2DQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert with Truncation Packed SP-FP Values to Packed Dword Integers (SSE2).
		inline void Cx86HLAIntrinsics::cvttps2dq( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_CVTTPS2DQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert with Truncation Packed SP-FP Values to Packed Dword Integers (SSE2).
		inline void Cx86HLAIntrinsics::cvttps2dq( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_CVTTPS2DQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert with Truncation Scalar DP-FP Value to Signed Dword Integer (SSE2).
		inline void Cx86HLAIntrinsics::cvttsd2si( const CGPVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_CVTTSD2SI, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Convert with Truncation Scalar DP-FP Value to Signed Dword Integer (SSE2).
		inline void Cx86HLAIntrinsics::cvttsd2si( const CGPVar& dst, const CMem& src )
		{
			_emitInstruction( INST_CVTTSD2SI, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed DP-FP Divide (SSE2).
		inline void Cx86HLAIntrinsics::divpd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_DIVPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed DP-FP Divide (SSE2).
		inline void Cx86HLAIntrinsics::divpd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_DIVPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar DP-FP Divide (SSE2).
		inline void Cx86HLAIntrinsics::divsd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_DIVSD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar DP-FP Divide (SSE2).
		inline void Cx86HLAIntrinsics::divsd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_DIVSD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Load Fence (SSE2).
		inline void Cx86HLAIntrinsics::lfence()
		{
			_emitInstruction( INST_LFENCE );
		}

		//------------------------------------------------------------------------------
		// Store Selected Bytes of Double Quadword (SSE2). Note Target is DS:EDI.
		inline void Cx86HLAIntrinsics::maskmovdqu( const CGPVar& dst_ptr, const CXMMVar& src, const CXMMVar& mask )
		{
			_emitInstruction( INST_MASKMOVDQU, &dst_ptr, &src, &mask );
		}

		//------------------------------------------------------------------------------
		// Return Maximum Packed Double-Precision FP Values (SSE2).
		inline void Cx86HLAIntrinsics::maxpd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MAXPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Return Maximum Packed Double-Precision FP Values (SSE2).
		inline void Cx86HLAIntrinsics::maxpd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MAXPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Return Maximum Scalar Double-Precision FP Value (SSE2).
		inline void Cx86HLAIntrinsics::maxsd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MAXSD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Return Maximum Scalar Double-Precision FP Value (SSE2).
		inline void Cx86HLAIntrinsics::maxsd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MAXSD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Memory Fence (SSE2).
		inline void Cx86HLAIntrinsics::mfence()
		{
			_emitInstruction( INST_MFENCE );
		}

		//------------------------------------------------------------------------------
		// Return Minimum Packed DP-FP Values (SSE2).
		inline void Cx86HLAIntrinsics::minpd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MINPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Return Minimum Packed DP-FP Values (SSE2).
		inline void Cx86HLAIntrinsics::minpd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MINPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Return Minimum Scalar DP-FP Value (SSE2).
		inline void Cx86HLAIntrinsics::minsd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MINSD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Return Minimum Scalar DP-FP Value (SSE2).
		inline void Cx86HLAIntrinsics::minsd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MINSD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Aligned DQWord (SSE2).
		inline void Cx86HLAIntrinsics::movdqa( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVDQA, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Aligned DQWord (SSE2).
		inline void Cx86HLAIntrinsics::movdqa( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MOVDQA, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Aligned DQWord (SSE2).
		inline void Cx86HLAIntrinsics::movdqa( const CMem& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVDQA, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Unaligned Double Quadword (SSE2).
		inline void Cx86HLAIntrinsics::movdqu( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVDQU, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Unaligned Double Quadword (SSE2).
		inline void Cx86HLAIntrinsics::movdqu( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MOVDQU, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Unaligned Double Quadword (SSE2).
		inline void Cx86HLAIntrinsics::movdqu( const CMem& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVDQU, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Extract Packed SP-FP Sign Mask (SSE2).
		inline void Cx86HLAIntrinsics::movmskps( const CGPVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVMSKPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Extract Packed DP-FP Sign Mask (SSE2).
		inline void Cx86HLAIntrinsics::movmskpd( const CGPVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVMSKPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Scalar Double-Precision FP Value (SSE2).
		inline void Cx86HLAIntrinsics::movsd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVSD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Move Scalar Double-Precision FP Value (SSE2).
		inline void Cx86HLAIntrinsics::movsd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MOVSD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Scalar Double-Precision FP Value (SSE2).
		inline void Cx86HLAIntrinsics::movsd( const CMem& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVSD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Aligned Packed Double-Precision FP Values (SSE2).
		inline void Cx86HLAIntrinsics::movapd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVAPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Aligned Packed Double-Precision FP Values (SSE2).
		inline void Cx86HLAIntrinsics::movapd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MOVAPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Aligned Packed Double-Precision FP Values (SSE2).
		inline void Cx86HLAIntrinsics::movapd( const CMem& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVAPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Quadword from XMM to MMX Technology Register (SSE2).
		inline void Cx86HLAIntrinsics::movdq2q( const CMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVDQ2Q, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Quadword from MMX Technology to XMM Register (SSE2).
		inline void Cx86HLAIntrinsics::movq2dq( const CXMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_MOVQ2DQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move High Packed Double-Precision FP Value (SSE2).
		inline void Cx86HLAIntrinsics::movhpd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MOVHPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move High Packed Double-Precision FP Value (SSE2).
		inline void Cx86HLAIntrinsics::movhpd( const CMem& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVHPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Low Packed Double-Precision FP Value (SSE2).
		inline void Cx86HLAIntrinsics::movlpd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MOVLPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Low Packed Double-Precision FP Value (SSE2).
		inline void Cx86HLAIntrinsics::movlpd( const CMem& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVLPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Store Double Quadword Using Non-Temporal Hint (SSE2).
		inline void Cx86HLAIntrinsics::movntdq( const CMem& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVNTDQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Store Store DWORD Using Non-Temporal Hint (SSE2).
		inline void Cx86HLAIntrinsics::movnti( const CMem& dst, const CGPVar& src )
		{
			_emitInstruction( INST_MOVNTI, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Store Packed Double-Precision FP Values Using Non-Temporal Hint (SSE2).
		inline void Cx86HLAIntrinsics::movntpd( const CMem& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVNTPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Move Unaligned Packed Double-Precision FP Values (SSE2).
		inline void Cx86HLAIntrinsics::movupd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVUPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Unaligned Packed Double-Precision FP Values (SSE2).
		inline void Cx86HLAIntrinsics::movupd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MOVUPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Unaligned Packed Double-Precision FP Values (SSE2).
		inline void Cx86HLAIntrinsics::movupd( const CMem& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVUPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed DP-FP Multiply (SSE2).
		inline void Cx86HLAIntrinsics::mulpd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MULPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed DP-FP Multiply (SSE2).
		inline void Cx86HLAIntrinsics::mulpd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MULPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar DP-FP Multiply (SSE2).
		inline void Cx86HLAIntrinsics::mulsd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MULSD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Scalar DP-FP Multiply (SSE2).
		inline void Cx86HLAIntrinsics::mulsd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MULSD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Bit-wise Logical OR for DP-FP Data (SSE2).
		inline void Cx86HLAIntrinsics::orpd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_ORPD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Bit-wise Logical OR for DP-FP Data (SSE2).
		inline void Cx86HLAIntrinsics::orpd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_ORPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Pack with Signed Saturation (SSE2).
		inline void Cx86HLAIntrinsics::packsswb( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PACKSSWB, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Pack with Signed Saturation (SSE2).
		inline void Cx86HLAIntrinsics::packsswb( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PACKSSWB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Pack with Signed Saturation (SSE2).
		inline void Cx86HLAIntrinsics::packssdw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PACKSSDW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Pack with Signed Saturation (SSE2).
		inline void Cx86HLAIntrinsics::packssdw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PACKSSDW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Pack with Unsigned Saturation (SSE2).
		inline void Cx86HLAIntrinsics::packuswb( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PACKUSWB, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Pack with Unsigned Saturation (SSE2).
		inline void Cx86HLAIntrinsics::packuswb( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PACKUSWB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed BYTE Add (SSE2).
		inline void Cx86HLAIntrinsics::paddb( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PADDB, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed BYTE Add (SSE2).
		inline void Cx86HLAIntrinsics::paddb( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PADDB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed WORD Add (SSE2).
		inline void Cx86HLAIntrinsics::paddw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PADDW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed WORD Add (SSE2).
		inline void Cx86HLAIntrinsics::paddw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PADDW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed DWORD Add (SSE2).
		inline void Cx86HLAIntrinsics::paddd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PADDD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed DWORD Add (SSE2).
		inline void Cx86HLAIntrinsics::paddd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PADDD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed QWORD Add (SSE2).
		inline void Cx86HLAIntrinsics::paddq( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PADDQ, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed QWORD Add (SSE2).
		inline void Cx86HLAIntrinsics::paddq( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PADDQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed QWORD Add (SSE2).
		inline void Cx86HLAIntrinsics::paddq( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PADDQ, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed QWORD Add (SSE2).
		inline void Cx86HLAIntrinsics::paddq( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PADDQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Add with Saturation (SSE2).
		inline void Cx86HLAIntrinsics::paddsb( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PADDSB, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Add with Saturation (SSE2).
		inline void Cx86HLAIntrinsics::paddsb( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PADDSB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Add with Saturation (SSE2).
		inline void Cx86HLAIntrinsics::paddsw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PADDSW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Add with Saturation (SSE2).
		inline void Cx86HLAIntrinsics::paddsw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PADDSW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Add Unsigned with Saturation (SSE2).
		inline void Cx86HLAIntrinsics::paddusb( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PADDUSB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Add Unsigned with Saturation (SSE2).
		inline void Cx86HLAIntrinsics::paddusb( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PADDUSB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Add Unsigned with Saturation (SSE2).
		inline void Cx86HLAIntrinsics::paddusw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PADDUSW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Add Unsigned with Saturation (SSE2).
		inline void Cx86HLAIntrinsics::paddusw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PADDUSW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Logical AND (SSE2).
		inline void Cx86HLAIntrinsics::pand( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PAND, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Logical AND (SSE2).
		inline void Cx86HLAIntrinsics::pand( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PAND, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Logical AND Not (SSE2).
		inline void Cx86HLAIntrinsics::pandn( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PANDN, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Logical AND Not (SSE2).
		inline void Cx86HLAIntrinsics::pandn( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PANDN, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Spin Loop Hint (SSE2).
		inline void Cx86HLAIntrinsics::pause()
		{
			_emitInstruction( INST_PAUSE );
		}

		//------------------------------------------------------------------------------
		// Packed Average (SSE2).
		inline void Cx86HLAIntrinsics::pavgb( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PAVGB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Average (SSE2).
		inline void Cx86HLAIntrinsics::pavgb( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PAVGB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Average (SSE2).
		inline void Cx86HLAIntrinsics::pavgw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PAVGW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Average (SSE2).
		inline void Cx86HLAIntrinsics::pavgw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PAVGW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Compare for Equal (BYTES) (SSE2).
		inline void Cx86HLAIntrinsics::pcmpeqb( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PCMPEQB, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Compare for Equal (BYTES) (SSE2).
		inline void Cx86HLAIntrinsics::pcmpeqb( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PCMPEQB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Compare for Equal (WORDS) (SSE2).
		inline void Cx86HLAIntrinsics::pcmpeqw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PCMPEQW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Compare for Equal (WORDS) (SSE2).
		inline void Cx86HLAIntrinsics::pcmpeqw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PCMPEQW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Compare for Equal (DWORDS) (SSE2).
		inline void Cx86HLAIntrinsics::pcmpeqd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PCMPEQD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Compare for Equal (DWORDS) (SSE2).
		inline void Cx86HLAIntrinsics::pcmpeqd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PCMPEQD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Compare for Greater Than (BYTES) (SSE2).
		inline void Cx86HLAIntrinsics::pcmpgtb( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PCMPGTB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Compare for Greater Than (BYTES) (SSE2).
		inline void Cx86HLAIntrinsics::pcmpgtb( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PCMPGTB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Compare for Greater Than (WORDS) (SSE2).
		inline void Cx86HLAIntrinsics::pcmpgtw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PCMPGTW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Compare for Greater Than (WORDS) (SSE2).
		inline void Cx86HLAIntrinsics::pcmpgtw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PCMPGTW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Compare for Greater Than (DWORDS) (SSE2).
		inline void Cx86HLAIntrinsics::pcmpgtd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PCMPGTD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Compare for Greater Than (DWORDS) (SSE2).
		inline void Cx86HLAIntrinsics::pcmpgtd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PCMPGTD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Extract Word (SSE2).
		inline void Cx86HLAIntrinsics::pextrw( const CGPVar& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PEXTRW, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		//Extract Word (SSE2).
		inline void Cx86HLAIntrinsics::pextrw( const CMem& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PEXTRW, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Packed Signed Integer Word Maximum (SSE2).
		inline void Cx86HLAIntrinsics::pmaxsw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMAXSW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Signed Integer Word Maximum (SSE2).
		inline void Cx86HLAIntrinsics::pmaxsw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMAXSW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Unsigned Integer Byte Maximum (SSE2).
		inline void Cx86HLAIntrinsics::pmaxub( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMAXUB, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Unsigned Integer Byte Maximum (SSE2).
		inline void Cx86HLAIntrinsics::pmaxub( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMAXUB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Signed Integer Word Minimum (SSE2).
		inline void Cx86HLAIntrinsics::pminsw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMINSW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Signed Integer Word Minimum (SSE2).
		inline void Cx86HLAIntrinsics::pminsw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMINSW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Unsigned Integer Byte Minimum (SSE2).
		inline void Cx86HLAIntrinsics::pminub( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMINUB, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Unsigned Integer Byte Minimum (SSE2).
		inline void Cx86HLAIntrinsics::pminub( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMINUB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Byte Mask (SSE2).
		inline void Cx86HLAIntrinsics::pmovmskb( const CGPVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMOVMSKB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Multiply High (SSE2).
		inline void Cx86HLAIntrinsics::pmulhw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMULHW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Multiply High (SSE2).
		inline void Cx86HLAIntrinsics::pmulhw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMULHW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Multiply High Unsigned (SSE2).
		inline void Cx86HLAIntrinsics::pmulhuw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMULHUW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Multiply High Unsigned (SSE2).
		inline void Cx86HLAIntrinsics::pmulhuw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMULHUW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Multiply Low (SSE2).
		inline void Cx86HLAIntrinsics::pmullw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMULLW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Multiply Low (SSE2).
		inline void Cx86HLAIntrinsics::pmullw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMULLW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Multiply to QWORD (SSE2).
		inline void Cx86HLAIntrinsics::pmuludq( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PMULUDQ, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Multiply to QWORD (SSE2).
		inline void Cx86HLAIntrinsics::pmuludq( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMULUDQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Multiply to QWORD (SSE2).
		inline void Cx86HLAIntrinsics::pmuludq( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMULUDQ, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Multiply to QWORD (SSE2).
		inline void Cx86HLAIntrinsics::pmuludq( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMULUDQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Bitwise Logical OR (SSE2).
		inline void Cx86HLAIntrinsics::por( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_POR, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Bitwise Logical OR (SSE2).
		inline void Cx86HLAIntrinsics::por( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_POR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Left Logical (SSE2).
		inline void Cx86HLAIntrinsics::pslld( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PSLLD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Shift Left Logical (SSE2).
		inline void Cx86HLAIntrinsics::pslld( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSLLD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Left Logical (SSE2).
		inline void Cx86HLAIntrinsics::pslld( const CXMMVar& dst, const CImm& src )
		{
			_emitInstruction( INST_PSLLD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Left Logical (SSE2).
		inline void Cx86HLAIntrinsics::psllq( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PSLLQ, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Shift Left Logical (SSE2).
		inline void Cx86HLAIntrinsics::psllq( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSLLQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Left Logical (SSE2).
		inline void Cx86HLAIntrinsics::psllq( const CXMMVar& dst, const CImm& src )
		{
			_emitInstruction( INST_PSLLQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Left Logical (SSE2).
		inline void Cx86HLAIntrinsics::psllw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PSLLW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Shift Left Logical (SSE2).
		inline void Cx86HLAIntrinsics::psllw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSLLW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Left Logical (SSE2).
		inline void Cx86HLAIntrinsics::psllw( const CXMMVar& dst, const CImm& src )
		{
			_emitInstruction( INST_PSLLW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Left Logical (SSE2).
		inline void Cx86HLAIntrinsics::pslldq( const CXMMVar& dst, const CImm& src )
		{
			_emitInstruction( INST_PSLLDQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Right Arithmetic (SSE2).
		inline void Cx86HLAIntrinsics::psrad( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PSRAD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Shift Right Arithmetic (SSE2).
		inline void Cx86HLAIntrinsics::psrad( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSRAD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Right Arithmetic (SSE2).
		inline void Cx86HLAIntrinsics::psrad( const CXMMVar& dst, const CImm& src )
		{
			_emitInstruction( INST_PSRAD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Right Arithmetic (SSE2).
		inline void Cx86HLAIntrinsics::psraw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PSRAW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Shift Right Arithmetic (SSE2).
		inline void Cx86HLAIntrinsics::psraw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSRAW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Right Arithmetic (SSE2).
		inline void Cx86HLAIntrinsics::psraw( const CXMMVar& dst, const CImm& src )
		{
			_emitInstruction( INST_PSRAW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Subtract (SSE2).
		inline void Cx86HLAIntrinsics::psubb( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PSUBB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Subtract (SSE2).
		inline void Cx86HLAIntrinsics::psubb( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSUBB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Subtract (SSE2).
		inline void Cx86HLAIntrinsics::psubw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PSUBW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Subtract (SSE2).
		inline void Cx86HLAIntrinsics::psubw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSUBW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Subtract (SSE2).
		inline void Cx86HLAIntrinsics::psubd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PSUBD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Subtract (SSE2).
		inline void Cx86HLAIntrinsics::psubd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSUBD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Subtract (SSE2).
		inline void Cx86HLAIntrinsics::psubq( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PSUBQ, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Subtract (SSE2).
		inline void Cx86HLAIntrinsics::psubq( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSUBQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Subtract (SSE2).
		inline void Cx86HLAIntrinsics::psubq( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PSUBQ, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Subtract (SSE2).
		inline void Cx86HLAIntrinsics::psubq( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSUBQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Multiply and Add (SSE2).
		inline void Cx86HLAIntrinsics::pmaddwd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMADDWD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Multiply and Add (SSE2).
		inline void Cx86HLAIntrinsics::pmaddwd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMADDWD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Shuffle Packed DWORDs (SSE2).
		inline void Cx86HLAIntrinsics::pshufd( const CXMMVar& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction(INST_PSHUFD, &dst, &src, &imm8 );
		}
	
		//------------------------------------------------------------------------------
		// Shuffle Packed DWORDs (SSE2).
		inline void Cx86HLAIntrinsics::pshufd( const CXMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PSHUFD, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Shuffle Packed High Words (SSE2).
		inline void Cx86HLAIntrinsics::pshufhw( const CXMMVar& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PSHUFHW, &dst, &src, &imm8 );
		}
	
		//------------------------------------------------------------------------------
		// Shuffle Packed High Words (SSE2).
		inline void Cx86HLAIntrinsics::pshufhw( const CXMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PSHUFHW, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Shuffle Packed Low Words (SSE2).
		inline void Cx86HLAIntrinsics::pshuflw( const CXMMVar& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PSHUFLW, &dst, &src, &imm8 );
		}
	
		//------------------------------------------------------------------------------
		// Shuffle Packed Low Words (SSE2).
		inline void Cx86HLAIntrinsics::pshuflw( const CXMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PSHUFLW, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Right Logical (SSE2).
		inline void Cx86HLAIntrinsics::psrld( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PSRLD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Shift Right Logical (SSE2).
		inline void Cx86HLAIntrinsics::psrld( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSRLD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Right Logical (SSE2).
		inline void Cx86HLAIntrinsics::psrld( const CXMMVar& dst, const CImm& src )
		{
			_emitInstruction( INST_PSRLD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Right Logical (SSE2).
		inline void Cx86HLAIntrinsics::psrlq( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PSRLQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Right Logical (SSE2).
		inline void Cx86HLAIntrinsics::psrlq( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSRLQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Right Logical (SSE2).
		inline void Cx86HLAIntrinsics::psrlq( const CXMMVar& dst, const CImm& src )
		{
			_emitInstruction( INST_PSRLQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// DQWord Shift Right Logical (MMX).
		inline void Cx86HLAIntrinsics::psrldq( const CXMMVar& dst, const CImm& src )
		{
			_emitInstruction( INST_PSRLDQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Right Logical (SSE2).
		inline void Cx86HLAIntrinsics::psrlw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PSRLW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Right Logical (SSE2).
		inline void Cx86HLAIntrinsics::psrlw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction(INST_PSRLW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shift Right Logical (SSE2).
		inline void Cx86HLAIntrinsics::psrlw( const CXMMVar& dst, const CImm& src )
		{
			_emitInstruction( INST_PSRLW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Subtract with Saturation (SSE2).
		inline void Cx86HLAIntrinsics::psubsb( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PSUBSB, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Subtract with Saturation (SSE2).
		inline void Cx86HLAIntrinsics::psubsb( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSUBSB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Subtract with Saturation (SSE2).
		inline void Cx86HLAIntrinsics::psubsw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PSUBSW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Subtract with Saturation (SSE2).
		inline void Cx86HLAIntrinsics::psubsw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSUBSW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Subtract with Unsigned Saturation (SSE2).
		inline void Cx86HLAIntrinsics::psubusb( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PSUBUSB, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Subtract with Unsigned Saturation (SSE2).
		inline void Cx86HLAIntrinsics::psubusb( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSUBUSB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Subtract with Unsigned Saturation (SSE2).
		inline void Cx86HLAIntrinsics::psubusw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PSUBUSW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Subtract with Unsigned Saturation (SSE2).
		inline void Cx86HLAIntrinsics::psubusw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSUBUSW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unpack High Data (SSE2).
		inline void Cx86HLAIntrinsics::punpckhbw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PUNPCKHBW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Unpack High Data (SSE2).
		inline void Cx86HLAIntrinsics::punpckhbw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PUNPCKHBW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unpack High Data (SSE2).
		inline void Cx86HLAIntrinsics::punpckhwd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PUNPCKHWD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unpack High Data (SSE2).
		inline void Cx86HLAIntrinsics::punpckhwd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PUNPCKHWD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unpack High Data (SSE2).
		inline void Cx86HLAIntrinsics::punpckhdq( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PUNPCKHDQ, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Unpack High Data (SSE2).
		inline void Cx86HLAIntrinsics::punpckhdq( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PUNPCKHDQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unpack High Data (SSE2).
		inline void Cx86HLAIntrinsics::punpckhqdq( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PUNPCKHQDQ, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Unpack High Data (SSE2).
		inline void Cx86HLAIntrinsics::punpckhqdq( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PUNPCKHQDQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unpack Low Data (SSE2).
		inline void Cx86HLAIntrinsics::punpcklbw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PUNPCKLBW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Unpack Low Data (SSE2).
		inline void Cx86HLAIntrinsics::punpcklbw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PUNPCKLBW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unpack Low Data (SSE2).
		inline void Cx86HLAIntrinsics::punpcklwd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PUNPCKLWD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Unpack Low Data (SSE2).
		inline void Cx86HLAIntrinsics::punpcklwd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PUNPCKLWD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unpack Low Data (SSE2).
		inline void Cx86HLAIntrinsics::punpckldq( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PUNPCKLDQ, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Unpack Low Data (SSE2).
		inline void Cx86HLAIntrinsics::punpckldq( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PUNPCKLDQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unpack Low Data (SSE2).
		inline void Cx86HLAIntrinsics::punpcklqdq( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PUNPCKLQDQ, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Unpack Low Data (SSE2).
		inline void Cx86HLAIntrinsics::punpcklqdq( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PUNPCKLQDQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Bitwise Exclusive OR (SSE2).
		inline void Cx86HLAIntrinsics::pxor( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PXOR, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Bitwise Exclusive OR (SSE2).
		inline void Cx86HLAIntrinsics::pxor( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PXOR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Shuffle DP-FP (SSE2).
		inline void Cx86HLAIntrinsics::shufpd( const CXMMVar& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_SHUFPD, &dst, &src, &imm8 );
		}
	
		//------------------------------------------------------------------------------
		// Shuffle DP-FP (SSE2).
		inline void Cx86HLAIntrinsics::shufpd( const CXMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_SHUFPD, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Compute Square Roots of Packed DP-FP Values (SSE2).
		inline void Cx86HLAIntrinsics::sqrtpd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_SQRTPD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Compute Square Roots of Packed DP-FP Values (SSE2).
		inline void Cx86HLAIntrinsics::sqrtpd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_SQRTPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Compute Square Root of Scalar DP-FP Value (SSE2).
		inline void Cx86HLAIntrinsics::sqrtsd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_SQRTSD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Compute Square Root of Scalar DP-FP Value (SSE2).
		inline void Cx86HLAIntrinsics::sqrtsd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_SQRTSD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed DP-FP Subtract (SSE2).
		inline void Cx86HLAIntrinsics::subpd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_SUBPD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed DP-FP Subtract (SSE2).
		inline void Cx86HLAIntrinsics::subpd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_SUBPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar DP-FP Subtract (SSE2).
		inline void Cx86HLAIntrinsics::subsd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_SUBSD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Scalar DP-FP Subtract (SSE2).
		inline void Cx86HLAIntrinsics::subsd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_SUBSD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Scalar Unordered DP-FP Compare and Set EFLAGS (SSE2).
		inline void Cx86HLAIntrinsics::ucomisd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_UCOMISD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Scalar Unordered DP-FP Compare and Set EFLAGS (SSE2).
		inline void Cx86HLAIntrinsics::ucomisd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_UCOMISD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unpack and Interleave High Packed Double-Precision FP Values (SSE2).
		inline void Cx86HLAIntrinsics::unpckhpd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_UNPCKHPD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Unpack and Interleave High Packed Double-Precision FP Values (SSE2).
		inline void Cx86HLAIntrinsics::unpckhpd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_UNPCKHPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Unpack and Interleave Low Packed Double-Precision FP Values (SSE2).
		inline void Cx86HLAIntrinsics::unpcklpd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_UNPCKLPD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Unpack and Interleave Low Packed Double-Precision FP Values (SSE2).
		inline void Cx86HLAIntrinsics::unpcklpd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_UNPCKLPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Bit-wise Logical OR for DP-FP Data (SSE2).
		inline void Cx86HLAIntrinsics::xorpd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_XORPD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Bit-wise Logical OR for DP-FP Data (SSE2).
		inline void Cx86HLAIntrinsics::xorpd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_XORPD, &dst, &src );
		}

		//--------------------------------------------------------------------------
		// [SSE3]

		//------------------------------------------------------------------------------
		// Packed DP-FP Add/Subtract (SSE3).
		inline void Cx86HLAIntrinsics::addsubpd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_ADDSUBPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed DP-FP Add/Subtract (SSE3).
		inline void Cx86HLAIntrinsics::addsubpd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_ADDSUBPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Add/Subtract (SSE3).
		inline void Cx86HLAIntrinsics::addsubps( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_ADDSUBPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Add/Subtract (SSE3).
		inline void Cx86HLAIntrinsics::addsubps( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_ADDSUBPS, &dst, &src );
		}

#if ASMJIT_NOT_SUPPORTED_BY_COMPILER
		//------------------------------------------------------------------------------
		// TODO: NOT IMPLEMENTED BY THE COMPILER.
		// Store Integer with Truncation (SSE3).
		inline void Cx86HLAIntrinsics::fisttp(const CMem& dst)
		{
			_emitInstruction(INST_FISTTP, &dst);
		}
#endif // ASMJIT_NOT_SUPPORTED_BY_COMPILER

		//------------------------------------------------------------------------------
		// Packed DP-FP Horizontal Add (SSE3).
		inline void Cx86HLAIntrinsics::haddpd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_HADDPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed DP-FP Horizontal Add (SSE3).
		inline void Cx86HLAIntrinsics::haddpd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_HADDPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Horizontal Add (SSE3).
		inline void Cx86HLAIntrinsics::haddps( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_HADDPS, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed SP-FP Horizontal Add (SSE3).
		inline void Cx86HLAIntrinsics::haddps( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_HADDPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed DP-FP Horizontal Subtract (SSE3).
		inline void Cx86HLAIntrinsics::hsubpd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_HSUBPD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed DP-FP Horizontal Subtract (SSE3).
		inline void Cx86HLAIntrinsics::hsubpd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_HSUBPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SP-FP Horizontal Subtract (SSE3).
		inline void Cx86HLAIntrinsics::hsubps( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_HSUBPS, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed SP-FP Horizontal Subtract (SSE3).
		inline void Cx86HLAIntrinsics::hsubps( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_HSUBPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Load Unaligned Integer 128 Bits (SSE3).
		inline void Cx86HLAIntrinsics::lddqu( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_LDDQU, &dst, &src );
		}

#if ASMJIT_NOT_SUPPORTED_BY_COMPILER
		//------------------------------------------------------------------------------
		// Set Up Monitor Address (SSE3).
		inline void Cx86HLAIntrinsics::monitor()
		{
			_emitInstruction( INST_MONITOR );
		}
#endif // ASMJIT_NOT_SUPPORTED_BY_COMPILER

		//------------------------------------------------------------------------------
		// Move One DP-FP and Duplicate (SSE3).
		inline void Cx86HLAIntrinsics::movddup( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVDDUP, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Move One DP-FP and Duplicate (SSE3).
		inline void Cx86HLAIntrinsics::movddup( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MOVDDUP, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Packed SP-FP High and Duplicate (SSE3).
		inline void Cx86HLAIntrinsics::movshdup( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVSHDUP, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Move Packed SP-FP High and Duplicate (SSE3).
		inline void Cx86HLAIntrinsics::movshdup( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MOVSHDUP, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Packed SP-FP Low and Duplicate (SSE3).
		inline void Cx86HLAIntrinsics::movsldup( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_MOVSLDUP, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Move Packed SP-FP Low and Duplicate (SSE3).
		inline void Cx86HLAIntrinsics::movsldup( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MOVSLDUP, &dst, &src );
		}

#if ASMJIT_NOT_SUPPORTED_BY_COMPILER
		//------------------------------------------------------------------------------
		// Monitor Wait (SSE3).
		inline void Cx86HLAIntrinsics::mwait()
		{
			_emitInstruction( INST_MWAIT );
		}
#endif // ASMJIT_NOT_SUPPORTED_BY_COMPILER

		//------------------------------------------------------------------------------
		// [SSSE3]

		//------------------------------------------------------------------------------
		// Packed SIGN (SSSE3).
		inline void Cx86HLAIntrinsics::psignb( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PSIGNB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SIGN (SSSE3).
		inline void Cx86HLAIntrinsics::psignb( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSIGNB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SIGN (SSSE3).
		inline void Cx86HLAIntrinsics::psignb( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PSIGNB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SIGN (SSSE3).
		inline void Cx86HLAIntrinsics::psignb( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSIGNB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SIGN (SSSE3).
		inline void Cx86HLAIntrinsics::psignw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PSIGNW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed SIGN (SSSE3).
		inline void Cx86HLAIntrinsics::psignw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSIGNW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SIGN (SSSE3).
		inline void Cx86HLAIntrinsics::psignw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PSIGNW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SIGN (SSSE3).
		inline void Cx86HLAIntrinsics::psignw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSIGNW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SIGN (SSSE3).
		inline void Cx86HLAIntrinsics::psignd( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PSIGND, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SIGN (SSSE3).
		inline void Cx86HLAIntrinsics::psignd( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSIGND, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed SIGN (SSSE3).
		inline void Cx86HLAIntrinsics::psignd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PSIGND, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed SIGN (SSSE3).
		inline void Cx86HLAIntrinsics::psignd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSIGND, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Horizontal Add (SSSE3).
		inline void Cx86HLAIntrinsics::phaddw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PHADDW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Horizontal Add (SSSE3).
		inline void Cx86HLAIntrinsics::phaddw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PHADDW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Horizontal Add (SSSE3).
		inline void Cx86HLAIntrinsics::phaddw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PHADDW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Horizontal Add (SSSE3).
		inline void Cx86HLAIntrinsics::phaddw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PHADDW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Horizontal Add (SSSE3).
		inline void Cx86HLAIntrinsics::phaddd( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PHADDD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Horizontal Add (SSSE3).
		inline void Cx86HLAIntrinsics::phaddd( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PHADDD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Horizontal Add (SSSE3).
		inline void Cx86HLAIntrinsics::phaddd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PHADDD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Horizontal Add (SSSE3).
		inline void Cx86HLAIntrinsics::phaddd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PHADDD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Horizontal Add and Saturate (SSSE3).
		inline void Cx86HLAIntrinsics::phaddsw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PHADDSW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Horizontal Add and Saturate (SSSE3).
		inline void Cx86HLAIntrinsics::phaddsw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PHADDSW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Horizontal Add and Saturate (SSSE3).
		inline void Cx86HLAIntrinsics::phaddsw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PHADDSW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Horizontal Add and Saturate (SSSE3).
		inline void Cx86HLAIntrinsics::phaddsw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PHADDSW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Horizontal Subtract (SSSE3).
		inline void Cx86HLAIntrinsics::phsubw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PHSUBW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Horizontal Subtract (SSSE3).
		inline void Cx86HLAIntrinsics::phsubw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PHSUBW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Horizontal Subtract (SSSE3).
		inline void Cx86HLAIntrinsics::phsubw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PHSUBW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Horizontal Subtract (SSSE3).
		inline void Cx86HLAIntrinsics::phsubw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PHSUBW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Horizontal Subtract (SSSE3).
		inline void Cx86HLAIntrinsics::phsubd( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PHSUBD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Horizontal Subtract (SSSE3).
		inline void Cx86HLAIntrinsics::phsubd( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PHSUBD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Horizontal Subtract (SSSE3).
		inline void Cx86HLAIntrinsics::phsubd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PHSUBD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Horizontal Subtract (SSSE3).
		inline void Cx86HLAIntrinsics::phsubd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PHSUBD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Horizontal Subtract and Saturate (SSSE3).
		inline void Cx86HLAIntrinsics::phsubsw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PHSUBSW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Horizontal Subtract and Saturate (SSSE3).
		inline void Cx86HLAIntrinsics::phsubsw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PHSUBSW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Horizontal Subtract and Saturate (SSSE3).
		inline void Cx86HLAIntrinsics::phsubsw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PHSUBSW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Horizontal Subtract and Saturate (SSSE3).
		inline void Cx86HLAIntrinsics::phsubsw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PHSUBSW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Multiply and Add Packed Signed and Unsigned Bytes (SSSE3).
		inline void Cx86HLAIntrinsics::pmaddubsw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PMADDUBSW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Multiply and Add Packed Signed and Unsigned Bytes (SSSE3).
		inline void Cx86HLAIntrinsics::pmaddubsw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMADDUBSW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Multiply and Add Packed Signed and Unsigned Bytes (SSSE3).
		inline void Cx86HLAIntrinsics::pmaddubsw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMADDUBSW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Multiply and Add Packed Signed and Unsigned Bytes (SSSE3).
		inline void Cx86HLAIntrinsics::pmaddubsw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMADDUBSW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Absolute Value (SSSE3).
		inline void Cx86HLAIntrinsics::pabsb( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PABSB, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Absolute Value (SSSE3).
		inline void Cx86HLAIntrinsics::pabsb( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PABSB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Absolute Value (SSSE3).
		inline void Cx86HLAIntrinsics::pabsb( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PABSB, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Absolute Value (SSSE3).
		inline void Cx86HLAIntrinsics::pabsb( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PABSB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Absolute Value (SSSE3).
		inline void Cx86HLAIntrinsics::pabsw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PABSW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Absolute Value (SSSE3).
		inline void Cx86HLAIntrinsics::pabsw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PABSW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Absolute Value (SSSE3).
		inline void Cx86HLAIntrinsics::pabsw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PABSW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Absolute Value (SSSE3).
		inline void Cx86HLAIntrinsics::pabsw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PABSW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Absolute Value (SSSE3).
		inline void Cx86HLAIntrinsics::pabsd( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PABSD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Absolute Value (SSSE3).
		inline void Cx86HLAIntrinsics::pabsd( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PABSD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Absolute Value (SSSE3).
		inline void Cx86HLAIntrinsics::pabsd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PABSD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Absolute Value (SSSE3).
		inline void Cx86HLAIntrinsics::pabsd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PABSD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Multiply High with Round and Scale (SSSE3).
		inline void Cx86HLAIntrinsics::pmulhrsw( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PMULHRSW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Multiply High with Round and Scale (SSSE3).
		inline void Cx86HLAIntrinsics::pmulhrsw( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMULHRSW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Multiply High with Round and Scale (SSSE3).
		inline void Cx86HLAIntrinsics::pmulhrsw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMULHRSW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Multiply High with Round and Scale (SSSE3).
		inline void Cx86HLAIntrinsics::pmulhrsw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMULHRSW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shuffle Bytes (SSSE3).
		inline void Cx86HLAIntrinsics::pshufb( const CMMVar& dst, const CMMVar& src )
		{
			_emitInstruction( INST_PSHUFB, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Shuffle Bytes (SSSE3).
		inline void Cx86HLAIntrinsics::pshufb( const CMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSHUFB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shuffle Bytes (SSSE3).
		inline void Cx86HLAIntrinsics::pshufb( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PSHUFB, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Shuffle Bytes (SSSE3).
		inline void Cx86HLAIntrinsics::pshufb( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PSHUFB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Shuffle Bytes (SSSE3).
		inline void Cx86HLAIntrinsics::palignr( const CMMVar& dst, const CMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PALIGNR, &dst, &src, &imm8 );
		}
	
		//------------------------------------------------------------------------------
		// Packed Shuffle Bytes (SSSE3).
		inline void Cx86HLAIntrinsics::palignr( const CMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PALIGNR, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Packed Shuffle Bytes (SSSE3).
		inline void Cx86HLAIntrinsics::palignr( const CXMMVar& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PALIGNR, &dst, &src, &imm8 );
		}
	
		//------------------------------------------------------------------------------
		// Packed Shuffle Bytes (SSSE3).
		inline void Cx86HLAIntrinsics::palignr( const CXMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PALIGNR, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// [SSE4.1]

		//------------------------------------------------------------------------------
		// Blend Packed DP-FP Values (SSE4.1).
		inline void Cx86HLAIntrinsics::blendpd( const CXMMVar& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_BLENDPD, &dst, &src, &imm8 );
		}
	
		//------------------------------------------------------------------------------
		// Blend Packed DP-FP Values (SSE4.1).
		inline void Cx86HLAIntrinsics::blendpd( const CXMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_BLENDPD, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Blend Packed SP-FP Values (SSE4.1).
		inline void Cx86HLAIntrinsics::blendps( const CXMMVar& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_BLENDPS, &dst, &src, &imm8 );
		}
	
		//------------------------------------------------------------------------------
		// Blend Packed SP-FP Values (SSE4.1).
		inline void Cx86HLAIntrinsics::blendps( const CXMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_BLENDPS, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Variable Blend Packed DP-FP Values (SSE4.1).
		inline void Cx86HLAIntrinsics::blendvpd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_BLENDVPD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Variable Blend Packed DP-FP Values (SSE4.1).
		inline void Cx86HLAIntrinsics::blendvpd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_BLENDVPD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Variable Blend Packed SP-FP Values (SSE4.1).
		inline void Cx86HLAIntrinsics::blendvps( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_BLENDVPS, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Variable Blend Packed SP-FP Values (SSE4.1).
		inline void Cx86HLAIntrinsics::blendvps( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_BLENDVPS, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Dot Product of Packed DP-FP Values (SSE4.1).
		inline void Cx86HLAIntrinsics::dppd( const CXMMVar& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_DPPD, &dst, &src, &imm8 );
		}
	
		//------------------------------------------------------------------------------
		// Dot Product of Packed DP-FP Values (SSE4.1).
		inline void Cx86HLAIntrinsics::dppd( const CXMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_DPPD, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Dot Product of Packed SP-FP Values (SSE4.1).
		inline void Cx86HLAIntrinsics::dpps( const CXMMVar& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_DPPS, &dst, &src, &imm8 );
		}
	
		//------------------------------------------------------------------------------
		// Dot Product of Packed SP-FP Values (SSE4.1).
		inline void Cx86HLAIntrinsics::dpps( const CXMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_DPPS, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Extract Packed SP-FP Value (SSE4.1).
		inline void Cx86HLAIntrinsics::extractps( const CXMMVar& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_EXTRACTPS, &dst, &src, &imm8 );
		}
	
		//------------------------------------------------------------------------------
		// Extract Packed SP-FP Value (SSE4.1).
		inline void Cx86HLAIntrinsics::extractps( const CXMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_EXTRACTPS, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Load Double Quadword Non-Temporal Aligned Hint (SSE4.1).
		inline void Cx86HLAIntrinsics::movntdqa( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_MOVNTDQA, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Compute Multiple Packed Sums of Absolute Difference (SSE4.1).
		inline void Cx86HLAIntrinsics::mpsadbw( const CXMMVar& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_MPSADBW, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Compute Multiple Packed Sums of Absolute Difference (SSE4.1).
		inline void Cx86HLAIntrinsics::mpsadbw( const CXMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_MPSADBW, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Pack with Unsigned Saturation (SSE4.1).
		inline void Cx86HLAIntrinsics::packusdw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PACKUSDW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Pack with Unsigned Saturation (SSE4.1).
		inline void Cx86HLAIntrinsics::packusdw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PACKUSDW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Variable Blend Packed Bytes (SSE4.1).
		inline void Cx86HLAIntrinsics::pblendvb( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PBLENDVB, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Variable Blend Packed Bytes (SSE4.1).
		inline void Cx86HLAIntrinsics::pblendvb( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PBLENDVB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Blend Packed Words (SSE4.1).
		inline void Cx86HLAIntrinsics::pblendw( const CXMMVar& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PBLENDW, &dst, &src, &imm8 );
		}
	
		//------------------------------------------------------------------------------
		// Blend Packed Words (SSE4.1).
		inline void Cx86HLAIntrinsics::pblendw( const CXMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PBLENDW, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Compare Packed Qword Data for Equal (SSE4.1).
		inline void Cx86HLAIntrinsics::pcmpeqq( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PCMPEQQ, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Compare Packed Qword Data for Equal (SSE4.1).
		inline void Cx86HLAIntrinsics::pcmpeqq( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PCMPEQQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Extract Byte (SSE4.1).
		inline void Cx86HLAIntrinsics::pextrb( const CGPVar& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PEXTRB, &dst, &src, &imm8 );
		}
	
		//------------------------------------------------------------------------------
		// Extract Byte (SSE4.1).
		inline void Cx86HLAIntrinsics::pextrb( const CMem& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PEXTRB, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Extract Dword (SSE4.1).
		inline void Cx86HLAIntrinsics::pextrd( const CGPVar& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PEXTRD, &dst, &src, &imm8 );
		}
	
		//------------------------------------------------------------------------------
		// Extract Dword (SSE4.1).
		inline void Cx86HLAIntrinsics::pextrd( const CMem& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PEXTRD, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Extract Dword (SSE4.1).
		inline void Cx86HLAIntrinsics::pextrq( const CGPVar& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PEXTRQ, &dst, &src, &imm8 );
		}
	
		//------------------------------------------------------------------------------
		// Extract Dword (SSE4.1).
		inline void Cx86HLAIntrinsics::pextrq( const CMem& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PEXTRQ, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Packed Horizontal Word Minimum (SSE4.1).
		inline void Cx86HLAIntrinsics::phminposuw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PHMINPOSUW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Horizontal Word Minimum (SSE4.1).
		inline void Cx86HLAIntrinsics::phminposuw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PHMINPOSUW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Insert Byte (SSE4.1).
		inline void Cx86HLAIntrinsics::pinsrb( const CXMMVar& dst, const CGPVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PINSRB, &dst, &src, &imm8 );
		}
	
		//------------------------------------------------------------------------------
		// Insert Byte (SSE4.1).
		inline void Cx86HLAIntrinsics::pinsrb( const CXMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PINSRB, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Insert Dword (SSE4.1).
		inline void Cx86HLAIntrinsics::pinsrd( const CXMMVar& dst, const CGPVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PINSRD, &dst, &src, &imm8 );
		}
	
		//------------------------------------------------------------------------------
		// Insert Dword (SSE4.1).
		inline void Cx86HLAIntrinsics::pinsrd( const CXMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PINSRD, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Insert Dword (SSE4.1).
		inline void Cx86HLAIntrinsics::pinsrq( const CXMMVar& dst, const CGPVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PINSRQ, &dst, &src, &imm8 );
		}
	
		//------------------------------------------------------------------------------
		// Insert Dword (SSE4.1).
		inline void Cx86HLAIntrinsics::pinsrq( const CXMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PINSRQ, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Insert Word (SSE2).
		inline void Cx86HLAIntrinsics::pinsrw( const CXMMVar& dst, const CGPVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PINSRW, &dst, &src, &imm8 );
		}
	
		//------------------------------------------------------------------------------
		// Insert Word (SSE2).
		inline void Cx86HLAIntrinsics::pinsrw( const CXMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PINSRW, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Maximum of Packed Word Integers (SSE4.1).
		inline void Cx86HLAIntrinsics::pmaxuw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMAXUW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Maximum of Packed Word Integers (SSE4.1).
		inline void Cx86HLAIntrinsics::pmaxuw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMAXUW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Maximum of Packed Signed Byte Integers (SSE4.1).
		inline void Cx86HLAIntrinsics::pmaxsb( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMAXSB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Maximum of Packed Signed Byte Integers (SSE4.1).
		inline void Cx86HLAIntrinsics::pmaxsb( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMAXSB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Maximum of Packed Signed Dword Integers (SSE4.1).
		inline void Cx86HLAIntrinsics::pmaxsd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMAXSD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Maximum of Packed Signed Dword Integers (SSE4.1).
		inline void Cx86HLAIntrinsics::pmaxsd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMAXSD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Maximum of Packed Unsigned Dword Integers (SSE4.1).
		inline void Cx86HLAIntrinsics::pmaxud( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMAXUD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Maximum of Packed Unsigned Dword Integers (SSE4.1).
		inline void Cx86HLAIntrinsics::pmaxud( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMAXUD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Minimum of Packed Signed Byte Integers (SSE4.1).
		inline void Cx86HLAIntrinsics::pminsb( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMINSB, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Minimum of Packed Signed Byte Integers (SSE4.1).
		inline void Cx86HLAIntrinsics::pminsb( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMINSB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Minimum of Packed Word Integers (SSE4.1).
		inline void Cx86HLAIntrinsics::pminuw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMINUW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Minimum of Packed Word Integers (SSE4.1).
		inline void Cx86HLAIntrinsics::pminuw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMINUW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Minimum of Packed Dword Integers (SSE4.1).
		inline void Cx86HLAIntrinsics::pminud( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMINUD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Minimum of Packed Dword Integers (SSE4.1).
		inline void Cx86HLAIntrinsics::pminud( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMINUD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Minimum of Packed Dword Integers (SSE4.1).
		inline void Cx86HLAIntrinsics::pminsd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMINSD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Minimum of Packed Dword Integers (SSE4.1).
		inline void Cx86HLAIntrinsics::pminsd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMINSD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Move with Sign Extend (SSE4.1).
		inline void Cx86HLAIntrinsics::pmovsxbw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMOVSXBW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Move with Sign Extend (SSE4.1).
		inline void Cx86HLAIntrinsics::pmovsxbw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMOVSXBW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Move with Sign Extend (SSE4.1).
		inline void Cx86HLAIntrinsics::pmovsxbd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMOVSXBD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Move with Sign Extend (SSE4.1).
		inline void Cx86HLAIntrinsics::pmovsxbd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMOVSXBD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Move with Sign Extend (SSE4.1).
		inline void Cx86HLAIntrinsics::pmovsxbq( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMOVSXBQ, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Move with Sign Extend (SSE4.1).
		inline void Cx86HLAIntrinsics::pmovsxbq( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMOVSXBQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Move with Sign Extend (SSE4.1).
		inline void Cx86HLAIntrinsics::pmovsxwd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMOVSXWD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Move with Sign Extend (SSE4.1).
		inline void Cx86HLAIntrinsics::pmovsxwd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMOVSXWD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// (SSE4.1).
		inline void Cx86HLAIntrinsics::pmovsxwq( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMOVSXWQ, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// (SSE4.1).
		inline void Cx86HLAIntrinsics::pmovsxwq( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMOVSXWQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// (SSE4.1).
		inline void Cx86HLAIntrinsics::pmovsxdq( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMOVSXDQ, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// (SSE4.1).
		inline void Cx86HLAIntrinsics::pmovsxdq( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMOVSXDQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Move with Zero Extend (SSE4.1).
		inline void Cx86HLAIntrinsics::pmovzxbw( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMOVZXBW, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Move with Zero Extend (SSE4.1).
		inline void Cx86HLAIntrinsics::pmovzxbw( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMOVZXBW, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Move with Zero Extend (SSE4.1).
		inline void Cx86HLAIntrinsics::pmovzxbd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMOVZXBD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Move with Zero Extend (SSE4.1).
		inline void Cx86HLAIntrinsics::pmovzxbd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMOVZXBD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Move with Zero Extend (SSE4.1).
		inline void Cx86HLAIntrinsics::pmovzxbq( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMOVZXBQ, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Move with Zero Extend (SSE4.1).
		inline void Cx86HLAIntrinsics::pmovzxbq( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMOVZXBQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Move with Zero Extend (SSE4.1).
		inline void Cx86HLAIntrinsics::pmovzxwd( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMOVZXWD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Packed Move with Zero Extend (SSE4.1).
		inline void Cx86HLAIntrinsics::pmovzxwd( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMOVZXWD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// (SSE4.1).
		inline void Cx86HLAIntrinsics::pmovzxwq( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMOVZXWQ, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// (SSE4.1).
		inline void Cx86HLAIntrinsics::pmovzxwq( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMOVZXWQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// (SSE4.1).
		inline void Cx86HLAIntrinsics::pmovzxdq( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMOVZXDQ, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// (SSE4.1).
		inline void Cx86HLAIntrinsics::pmovzxdq( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMOVZXDQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Multiply Packed Signed Dword Integers (SSE4.1).
		inline void Cx86HLAIntrinsics::pmuldq( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMULDQ, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Multiply Packed Signed Dword Integers (SSE4.1).
		inline void Cx86HLAIntrinsics::pmuldq( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMULDQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Multiply Packed Signed Integers and Store Low Result (SSE4.1).
		inline void Cx86HLAIntrinsics::pmulld( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PMULLD, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Multiply Packed Signed Integers and Store Low Result (SSE4.1).
		inline void Cx86HLAIntrinsics::pmulld( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PMULLD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Logical Compare (SSE4.1).
		inline void Cx86HLAIntrinsics::ptest( const CXMMVar& op1, const CXMMVar& op2 )
		{
			_emitInstruction( INST_PTEST, &op1, &op2 );
		}
	
		//------------------------------------------------------------------------------
		// Logical Compare (SSE4.1).
		inline void Cx86HLAIntrinsics::ptest( const CXMMVar& op1, const CMem& op2 )
		{
			_emitInstruction( INST_PTEST, &op1, &op2 );
		}

		//------------------------------------------------------------------------------
		// Round Packed SP-FP Values (SSE4.1).
		inline void Cx86HLAIntrinsics::roundps( const CXMMVar& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_ROUNDPS, &dst, &src, &imm8 );
		}
	
		//------------------------------------------------------------------------------
		// Round Packed SP-FP Values (SSE4.1).
		inline void Cx86HLAIntrinsics::roundps( const CXMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_ROUNDPS, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Round Scalar SP-FP Values (SSE4.1).
		inline void Cx86HLAIntrinsics::roundss( const CXMMVar& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_ROUNDSS, &dst, &src, &imm8 );
		}
	
		//------------------------------------------------------------------------------
		// Round Scalar SP-FP Values (SSE4.1).
		inline void Cx86HLAIntrinsics::roundss( const CXMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_ROUNDSS, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Round Packed DP-FP Values (SSE4.1).
		inline void Cx86HLAIntrinsics::roundpd( const CXMMVar& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_ROUNDPD, &dst, &src, &imm8 );
		}
	
		//------------------------------------------------------------------------------
		// Round Packed DP-FP Values (SSE4.1).
		inline void Cx86HLAIntrinsics::roundpd( const CXMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_ROUNDPD, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Round Scalar DP-FP Values (SSE4.1).
		inline void Cx86HLAIntrinsics::roundsd( const CXMMVar& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_ROUNDSD, &dst, &src, &imm8 );
		}
	
		//------------------------------------------------------------------------------
		// Round Scalar DP-FP Values (SSE4.1).
		inline void Cx86HLAIntrinsics::roundsd( const CXMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_ROUNDSD, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// [SSE4.2]

		//------------------------------------------------------------------------------
		// Accumulate CRC32 Value (polynomial 0x11EDC6F41) (SSE4.2).
		inline void Cx86HLAIntrinsics::crc32( const CGPVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_CRC32, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Accumulate CRC32 Value (polynomial 0x11EDC6F41) (SSE4.2).
		inline void Cx86HLAIntrinsics::crc32( const CGPVar& dst, const CMem& src )
		{
			_emitInstruction( INST_CRC32, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Packed Compare Explicit Length Strings, Return Index (SSE4.2).
		inline void Cx86HLAIntrinsics::pcmpestri( const CXMMVar& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PCMPESTRI, &dst, &src, &imm8 );
		}
	
		//------------------------------------------------------------------------------
		// Packed Compare Explicit Length Strings, Return Index (SSE4.2).
		inline void Cx86HLAIntrinsics::pcmpestri( const CXMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PCMPESTRI, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Packed Compare Explicit Length Strings, Return Mask (SSE4.2).
		inline void Cx86HLAIntrinsics::pcmpestrm( const CXMMVar& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PCMPESTRM, &dst, &src, &imm8 );
		}
	
		//------------------------------------------------------------------------------
		// Packed Compare Explicit Length Strings, Return Mask (SSE4.2).
		inline void Cx86HLAIntrinsics::pcmpestrm( const CXMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PCMPESTRM, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Packed Compare Implicit Length Strings, Return Index (SSE4.2).
		inline void Cx86HLAIntrinsics::pcmpistri( const CXMMVar& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PCMPISTRI, &dst, &src, &imm8 );
		}
	
		//------------------------------------------------------------------------------
		// Packed Compare Implicit Length Strings, Return Index (SSE4.2).
		inline void Cx86HLAIntrinsics::pcmpistri( const CXMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PCMPISTRI, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Packed Compare Implicit Length Strings, Return Mask (SSE4.2).
		inline void Cx86HLAIntrinsics::pcmpistrm( const CXMMVar& dst, const CXMMVar& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PCMPISTRM, &dst, &src, &imm8 );
		}
	
		//------------------------------------------------------------------------------
		// Packed Compare Implicit Length Strings, Return Mask (SSE4.2).
		inline void Cx86HLAIntrinsics::pcmpistrm( const CXMMVar& dst, const CMem& src, const CImm& imm8 )
		{
			_emitInstruction( INST_PCMPISTRM, &dst, &src, &imm8 );
		}

		//------------------------------------------------------------------------------
		// Compare Packed Data for Greater Than (SSE4.2).
		inline void Cx86HLAIntrinsics::pcmpgtq( const CXMMVar& dst, const CXMMVar& src )
		{
			_emitInstruction( INST_PCMPGTQ, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Compare Packed Data for Greater Than (SSE4.2).
		inline void Cx86HLAIntrinsics::pcmpgtq( const CXMMVar& dst, const CMem& src )
		{
			_emitInstruction( INST_PCMPGTQ, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Return the Count of Number of Bits Set to 1 (SSE4.2).
		inline void Cx86HLAIntrinsics::popcnt( const CGPVar& dst, const CGPVar& src )
		{
			_emitInstruction( INST_POPCNT, &dst, &src );
		}
	
		//------------------------------------------------------------------------------
		// Return the Count of Number of Bits Set to 1 (SSE4.2).
		inline void Cx86HLAIntrinsics::popcnt( const CGPVar& dst, const CMem& src )
		{
			_emitInstruction( INST_POPCNT, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// [AMD only]
		// Prefetch (3dNow - Amd).
		// Loads the entire 64-byte aligned memory sequence containing the
		// specified memory address into the L1 data cache. The position of
		// the specified memory address within the 64-byte cache line is
		// irrelevant. If a cache hit occurs, or if a memory fault is detected,
		// no bus cycle is initiated and the instruction is treated as a NOP.
		inline void Cx86HLAIntrinsics::amd_prefetch( const CMem& mem )
		{
			_emitInstruction( INST_AMD_PREFETCH, &mem );
		}

		//------------------------------------------------------------------------------
		// Prefetch and set cache to modified (3dNow - Amd).
		// The PREFETCHW instruction loads the prefetched line and sets the
		// cache-line state to Modified, in anticipation of subsequent data
		// writes to the line. The PREFETCH instruction, by contrast, typically
		// sets the cache-line state to Exclusive (depending on the hardware
		// implementation).
		inline void Cx86HLAIntrinsics::amd_prefetchw( const CMem& mem )
		{
			_emitInstruction( INST_AMD_PREFETCHW, &mem );
		}

		//------------------------------------------------------------------------------
		// [Intel only]
		// Move Data After Swapping Bytes (SSE3 - Intel Atom).
		inline void Cx86HLAIntrinsics::movbe( const CGPVar& dst, const CMem& src )
		{
			//assert(!dst.isGPB());
			_emitInstruction( INST_MOVBE, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// Move Data After Swapping Bytes (SSE3 - Intel Atom).
		inline void Cx86HLAIntrinsics::movbe( const CMem& dst, const CGPVar& src )
		{
			//assert(!src.isGPB());
			_emitInstruction( INST_MOVBE, &dst, &src );
		}

		//------------------------------------------------------------------------------
		// [Emit Options]

		//------------------------------------------------------------------------------
		// Assert LOCK# Signal Prefix.
		//
		// This instruction causes the processor's LOCK# signal to be asserted
		// during execution of the accompanying instruction (turns the
		// instruction into an atomic instruction). In a multiprocessor environment,
		// the LOCK# signal insures that the processor has exclusive use of any shared
		// memory while the signal is asserted.
		//
		// The LOCK prefix can be prepended only to the following instructions and
		// to those forms of the instructions that use a memory operand: ADD, ADC,
		// AND, BTC, BTR, BTS, CMPXCHG, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD,
		// and XCHG. An undefined opcode exception will be generated if the LOCK
		// prefix is used with any other instruction. The XCHG instruction always
		// asserts the LOCK# signal regardless of the presence or absence of the LOCK
		// prefix.
		inline void Cx86HLAIntrinsics::lock()
		{
			m_uiEmitOptions |= EMIT_OPTION_LOCK_PREFIX;
		}

		//------------------------------------------------------------------------------
		// Force REX prefix to be emitted.
		// This option should be used carefully, because there are unencodable
		// combinations. If you want to access ah, bh, ch or dh registers then you
		// can't emit REX prefix and it will cause an illegal instruction error.
		// Note REX prefix is only valid for X64/AMD64 platform.
		inline void Cx86HLAIntrinsics::rex()
		{
			m_uiEmitOptions |= EMIT_OPTION_REX_PREFIX;
		}

		//------------------------------------------------------------------------------
		inline void Cx86HLAIntrinsics::fstp( const CMem& dst )
		{
			_emitInstruction( INST_FSTP, &dst );
		}

	}//nsx86
}//nsArch

#endif	( QOR_ARCH == QOR_ARCH_X86_32 )
