//FunctionPrototype.cpp

// Copyright (c) 2008-2010, Petr Kobalicek <kobalicek.petr@gmail.com>
// Copyright (c) Querysoft Limited 2012
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Implements an x86 function prototype

#include "ArchQOR.h"

#if		( QOR_ARCH == QOR_ARCH_X86_32 || QOR_ARCH == QOR_ARCH_X86_64 )

#include "ArchQOR/x86/HLAssembler/FunctionPrototype.h"
#include "ArchQOR/x86/HLAssembler/HLAssembler.h"
#include "CodeQOR/Utils/Utils.h"
#include <assert.h>

//------------------------------------------------------------------------------
namespace nsArch
{
	namespace nsx86
	{
		//------------------------------------------------------------------------------
		CFunctionPrototype::CFunctionPrototype() __QCMP_THROW
		{			
			_clear();// Safe defaults.
		}

		//------------------------------------------------------------------------------
		CFunctionPrototype::~CFunctionPrototype() __QCMP_THROW
		{
		}

		//------------------------------------------------------------------------------
		void CFunctionPrototype::setPrototype( Cmp_unsigned__int32 callingConvention, const Cmp_unsigned__int32* arguments, Cmp_unsigned__int32 argumentsCount, Cmp_unsigned__int32 returnValue ) __QCMP_THROW
		{
			_setCallingConvention( callingConvention );

			if( argumentsCount > 32 )
			{
				argumentsCount = 32;
			}
			_setPrototype( arguments, argumentsCount, returnValue );
		}

		//------------------------------------------------------------------------------
		Cmp_unsigned__int32 CFunctionPrototype::findArgumentByRegisterCode( Cmp_unsigned__int32 regCode ) const __QCMP_THROW
		{
			Cmp_unsigned__int32 type = regCode & REG_TYPE_MASK;
			Cmp_unsigned__int32 idx = regCode & REG_INDEX_MASK;

			Cmp_unsigned__int32 clazz;
			Cmp_unsigned__int32 i;

			switch( type )
			{
			case REG_TYPE_GPD:
			case REG_TYPE_GPQ:
				clazz = VariableInfo::CLASS_GP;
				break;

			case REG_TYPE_MM:
				clazz = VariableInfo::CLASS_MM;
				break;

			case REG_TYPE_XMM:
				clazz = VariableInfo::CLASS_XMM;
				break;

			default:
				return static_cast< Cmp_unsigned__int32 >( INVALID_VALUE );
			}

			for( i = 0; i < m_uiArgumentsCount; i++ )
			{
				const Argument& arg = m_Arguments[ i ];
				if( ( getVariableClass( arg.variableType ) & clazz ) != 0 && ( arg.registerIndex == idx ) )
				{
					return i;
				}
			}

			return static_cast< Cmp_unsigned__int32 >( INVALID_VALUE );
		}

		//------------------------------------------------------------------------------
		void CFunctionPrototype::_clear() __QCMP_THROW
		{
			m_uiCallingConvention = CALL_CONV_NONE;
			m_uiCalleePopsStack = false;

			m_uiArgumentsCount = 0;
			m_uiArgumentsDirection = ARGUMENT_DIR_RIGHT_TO_LEFT;
			m_uiArgumentsStackSize = 0;

			m_uiReturnValue = static_cast< Cmp_unsigned__int32 >( INVALID_VALUE );

			nsCodeQOR::memset32( m_auiArgumentsGPList , static_cast< Cmp_unsigned__int32 >( INVALID_VALUE ), __QCS_ARRAY_SIZE( m_auiArgumentsGPList ) );
			nsCodeQOR::memset32( m_auiArgumentsXMMList, static_cast< Cmp_unsigned__int32 >( INVALID_VALUE ), __QCS_ARRAY_SIZE( m_auiArgumentsXMMList ) );

			m_uiArgumentsGP  = 0;
			m_uiArgumentsMM  = 0;
			m_uiArgumentsXMM = 0;

			m_uiPreservedGP  = 0;
			m_uiPreservedMM  = 0;
			m_uiPreservedXMM = 0;

			m_uiPassedGP  = 0;
			m_uiPassedMM  = 0;
			m_uiPassedXMM = 0;
		}

		//------------------------------------------------------------------------------
		void CFunctionPrototype::_setCallingConvention( Cmp_unsigned__int32 callingConvention ) __QCMP_THROW
		{
			// Safe defaults.
			_clear();

			m_uiCallingConvention = callingConvention;

			// [X86 Calling Conventions]

#	if ( QOR_ARCH_WORDSIZE == 32 )
			m_uiPreservedGP  = ( 1 << REG_INDEX_EBX ) |
			( 1 << REG_INDEX_ESP ) |
			( 1 << REG_INDEX_EBP ) |
			( 1 << REG_INDEX_ESI ) |
			( 1 << REG_INDEX_EDI ) ;
			m_uiPreservedXMM = 0;

			switch( m_uiCallingConvention )
			{
			case CALL_CONV_CDECL:
				break;

			case CALL_CONV_STDCALL:
				m_uiCalleePopsStack = true;
				break;

			case CALL_CONV_MSTHISCALL:
				m_uiCalleePopsStack = true;
				m_auiArgumentsGPList[ 0 ] = REG_INDEX_ECX;

				m_uiArgumentsGP = ( 1 << REG_INDEX_ECX );
				break;

			case CALL_CONV_MSFASTCALL:
				m_uiCalleePopsStack = true;
				m_auiArgumentsGPList[ 0 ] = REG_INDEX_ECX;
				m_auiArgumentsGPList[ 1 ] = REG_INDEX_EDX;

				m_uiArgumentsGP =  ( 1 << REG_INDEX_ECX ) | ( 1 << REG_INDEX_EDX ) ;
				break;

			case CALL_CONV_BORLANDFASTCALL:
				m_uiCalleePopsStack = true;
				m_uiArgumentsDirection = ARGUMENT_DIR_LEFT_TO_RIGHT;
				m_auiArgumentsGPList[ 0 ] = REG_INDEX_EAX;
				m_auiArgumentsGPList[ 1 ] = REG_INDEX_EDX;
				m_auiArgumentsGPList[ 2 ] = REG_INDEX_ECX;

				m_uiArgumentsGP =  ( 1 << REG_INDEX_EAX ) | ( 1 << REG_INDEX_EDX ) | ( 1 << REG_INDEX_ECX ) ;
				break;

			case CALL_CONV_GCCFASTCALL:
				m_uiCalleePopsStack = true;
				m_auiArgumentsGPList[ 0 ] = REG_INDEX_ECX;
				m_auiArgumentsGPList[ 1 ] = REG_INDEX_EDX;

				m_uiArgumentsGP =  ( 1 << REG_INDEX_ECX ) | ( 1 << REG_INDEX_EDX ) ;
				break;

			case CALL_CONV_GCCREGPARM_1:
				m_uiCalleePopsStack = false;
				m_auiArgumentsGPList[ 0 ] = REG_INDEX_EAX;

				m_uiArgumentsGP =  ( 1 << REG_INDEX_EAX ) ;
				break;

			case CALL_CONV_GCCREGPARM_2:
				m_uiCalleePopsStack = false;
				m_auiArgumentsGPList[ 0 ] = REG_INDEX_EAX;
				m_auiArgumentsGPList[ 1 ] = REG_INDEX_EDX;

				m_uiArgumentsGP =  ( 1 << REG_INDEX_EAX ) | ( 1 << REG_INDEX_EDX ) ;
				break;

			case CALL_CONV_GCCREGPARM_3:
				m_uiCalleePopsStack = false;
				m_auiArgumentsGPList[ 0 ] = REG_INDEX_EAX;
				m_auiArgumentsGPList[ 1 ] = REG_INDEX_EDX;
				m_auiArgumentsGPList[ 2 ] = REG_INDEX_ECX;
				m_uiArgumentsGP =  ( 1 << REG_INDEX_EAX ) | ( 1 << REG_INDEX_EDX ) | ( 1 << REG_INDEX_ECX ) ;
				break;

			default:
				// Illegal calling convention.
				assert( 0 );
			}
#	endif // ( QOR_ARCH_WORDSIZE == 32 )

			// [X64 Calling Conventions]

#	if ( QOR_ARCH_WORDSIZE == 64 )
			switch( m_uiCallingConvention )
			{
			case CALL_CONV_X64W:
				m_auiArgumentsGPList[ 0 ] = REG_INDEX_RCX;
				m_auiArgumentsGPList[ 1 ] = REG_INDEX_RDX;
				m_auiArgumentsGPList[ 2 ] = REG_INDEX_R8;
				m_auiArgumentsGPList[ 3 ] = REG_INDEX_R9;

				m_auiArgumentsXMMList[ 0 ] = REG_INDEX_XMM0;
				m_auiArgumentsXMMList[ 1 ] = REG_INDEX_XMM1;
				m_auiArgumentsXMMList[ 2 ] = REG_INDEX_XMM2;
				m_auiArgumentsXMMList[ 3 ] = REG_INDEX_XMM3;

				m_uiArgumentsGP =  ( 1 << REG_INDEX_RCX  ) | 
				( 1 << REG_INDEX_RDX ) |
				( 1 << REG_INDEX_R8 ) |
				( 1 << REG_INDEX_R9 ) ;

				m_uiArgumentsXMM = ( 1 << REG_INDEX_XMM0 ) |
				( 1 << REG_INDEX_XMM1 ) |
				( 1 << REG_INDEX_XMM2 ) |
				( 1 << REG_INDEX_XMM3 ) ;

				m_uiPreservedGP =  ( 1 << REG_INDEX_RBX  ) |
				( 1 << REG_INDEX_RSP ) |
				( 1 << REG_INDEX_RBP ) |
				( 1 << REG_INDEX_RSI ) |
				( 1 << REG_INDEX_RDI ) |
				( 1 << REG_INDEX_R12 ) |
				( 1 << REG_INDEX_R13 ) |
				( 1 << REG_INDEX_R14 ) |
				( 1 << REG_INDEX_R15 ) ;

				m_uiPreservedXMM = ( 1 << REG_INDEX_XMM6 ) |
				( 1 << REG_INDEX_XMM7 ) |
				( 1 << REG_INDEX_XMM8 ) |
				( 1 << REG_INDEX_XMM9 ) |
				( 1 << REG_INDEX_XMM10 ) |
				( 1 << REG_INDEX_XMM11 ) |
				( 1 << REG_INDEX_XMM12 ) |
				( 1 << REG_INDEX_XMM13 ) |
				( 1 << REG_INDEX_XMM14 ) |
				( 1 << REG_INDEX_XMM15 ) ;
			break;

			case CALL_CONV_X64U:
				m_auiArgumentsGPList[ 0 ] = REG_INDEX_RDI;
				m_auiArgumentsGPList[ 1 ] = REG_INDEX_RSI;
				m_auiArgumentsGPList[ 2 ] = REG_INDEX_RDX;
				m_auiArgumentsGPList[ 3 ] = REG_INDEX_RCX;
				m_auiArgumentsGPList[ 4 ] = REG_INDEX_R8;
				m_auiArgumentsGPList[ 5 ] = REG_INDEX_R9;

				m_auiArgumentsXMMList[ 0 ] = REG_INDEX_XMM0;
				m_auiArgumentsXMMList[ 1 ] = REG_INDEX_XMM1;
				m_auiArgumentsXMMList[ 2 ] = REG_INDEX_XMM2;
				m_auiArgumentsXMMList[ 3 ] = REG_INDEX_XMM3;
				m_auiArgumentsXMMList[ 4 ] = REG_INDEX_XMM4;
				m_auiArgumentsXMMList[ 5 ] = REG_INDEX_XMM5;
				m_auiArgumentsXMMList[ 6 ] = REG_INDEX_XMM6;
				m_auiArgumentsXMMList[ 7 ] = REG_INDEX_XMM7;

				m_uiArgumentsGP =  ( 1 << REG_INDEX_RDI ) |
				( 1 << REG_INDEX_RSI  ) |
				( 1 << REG_INDEX_RDX  ) |
				( 1 << REG_INDEX_RCX  ) |
				( 1 << REG_INDEX_R8   ) |
				( 1 << REG_INDEX_R9   ) ;

				m_uiArgumentsXMM = ( 1 << REG_INDEX_XMM0 ) |
				( 1 << REG_INDEX_XMM1 ) |
				( 1 << REG_INDEX_XMM2 ) |
				( 1 << REG_INDEX_XMM3 ) |
				( 1 << REG_INDEX_XMM4 ) |
				( 1 << REG_INDEX_XMM5 ) |
				( 1 << REG_INDEX_XMM6 ) |
				( 1 << REG_INDEX_XMM7 ) ;

				m_uiPreservedGP =  ( 1 << REG_INDEX_RBX  ) |
				( 1 << REG_INDEX_RSP  ) |
				( 1 << REG_INDEX_RBP  ) |
				( 1 << REG_INDEX_R12  ) |
				( 1 << REG_INDEX_R13  ) |
				( 1 << REG_INDEX_R14  ) |
				( 1 << REG_INDEX_R15  ) ;
				break;

			default:
				// Illegal calling convention.
				assert( 0 );
			}
#	endif // ( QOR_ARCH_WORDSIZE == 64 )
		}

		//------------------------------------------------------------------------------
		void CFunctionPrototype::_setPrototype( const Cmp_unsigned__int32* argumentsData, Cmp_unsigned__int32 argumentsCount, Cmp_unsigned__int32 returnValue ) __QCMP_THROW
		{
			assert( argumentsCount <= 32 );

			Cmp__int32 i;
			Cmp__int32 posGP = 0;
			Cmp__int32 stackOffset = 0;

#	if ( QOR_ARCH_WORDSIZE == 64 )
			Cmp__int32 posXMM = 0;
#	endif//( QOR_ARCH_WORDSIZE == 64 )			

			m_uiReturnValue = returnValue;

			for( i = 0; i < (Cmp_int_ptr)argumentsCount; i++ )
			{
				Argument& a = m_Arguments[ i ];
				a.variableType = argumentsData[ i ];
				a.registerIndex = static_cast< Cmp_unsigned__int32 >( INVALID_VALUE );
				a.stackOffset = INVALID_VALUE;
			}

			m_uiArgumentsCount = (Cmp_unsigned__int32)argumentsCount;
			if( m_uiArgumentsCount == 0 )
			{
				return;
			}

			// [X86 Calling Conventions (32-bit)]

#	if ( QOR_ARCH_WORDSIZE == 32 )
			// Register arguments (Integer), always left-to-right.
			for( i = 0; i != static_cast< Cmp__int32 >( argumentsCount ); i++ )
			{
				Argument& a = m_Arguments[ i ];
				if (isVariableInteger( a.variableType ) && posGP < 16 && m_auiArgumentsGPList[ posGP ] != INVALID_VALUE )
				{
					a.registerIndex = m_auiArgumentsGPList[ posGP++ ];
					m_uiPassedGP |= nsCodeQOR::maskFromIndex( a.registerIndex );
				}
			}

			// Stack arguments.
			bool ltr = m_uiArgumentsDirection == ARGUMENT_DIR_LEFT_TO_RIGHT;
			Cmp_int_ptr istart = ltr ? 0 : (Cmp_int_ptr)argumentsCount - 1;
			Cmp_int_ptr iend   = ltr ? (Cmp_int_ptr)argumentsCount : -1;
			Cmp_int_ptr istep  = ltr ? 1 : -1;

			for( i = istart; i != iend; i += istep )
			{
				Argument& a = m_Arguments[ i ];
				if( a.registerIndex != INVALID_VALUE )
				{
					continue;
				}

				if( isVariableInteger( a.variableType ) )
				{
					stackOffset -= 4;
					a.stackOffset = stackOffset;
				}
				else if( isVariableFloat( a.variableType ) )
				{
					Cmp__int32 size = (Cmp__int32)variableInfo[ a.variableType ].size;
					stackOffset -= size;
					a.stackOffset = stackOffset;
				}
			}
#	endif // ( QOR_ARCH_WORDSIZE == 32 )

			// [X64 Calling Conventions (64-bit)]

#	if ( QOR_ARCH_WORDSIZE == 64 )
			// Windows 64-bit specific.
			if( m_uiCallingConvention == CALL_CONV_X64W )
			{
				Cmp_int_ptr max = argumentsCount < 4 ? argumentsCount : 4;

				// Register arguments (Integer / FP), always left to right.
				for( i = 0; i != max; i++ )
				{
					Argument& a = m_Arguments[i];

					if( isVariableInteger( a.variableType ) )
					{
						a.registerIndex = m_auiArgumentsGPList[ i ];
						m_uiPassedGP |= nsCodeQOR::maskFromIndex( a.registerIndex );
					}
					else if( isVariableFloat( a.variableType ) )
					{
						a.registerIndex = m_auiArgumentsXMMList[ i ];
						m_uiPassedXMM |= nsCodeQOR::maskFromIndex( a.registerIndex );
					}
				}

				// Stack arguments (always right-to-left).
				for( i = argumentsCount - 1; i != -1; i-- )
				{
					Argument& a = m_Arguments[ i ];
					if( a.isAssigned() )
					{
						continue;
					}

					if( isVariableInteger( a.variableType ) )
					{
						stackOffset -= 8; // Always 8 bytes.
						a.stackOffset = stackOffset;
					}
					else if( isVariableFloat( a.variableType ) )
					{
						Cmp__int32 size = (Cmp__int32)variableInfo[ a.variableType ].size;
						stackOffset -= size;
						a.stackOffset = stackOffset;
					}
				}

				// 32 bytes shadow space (X64W calling convention specific).
				stackOffset -= 4 * 8;
			}
			// Linux/Unix 64-bit (AMD64 calling convention).
			else
			{
				// Register arguments (Integer), always left to right.
				for (i = 0; i != argumentsCount; i++)
				{
					Argument& a = m_Arguments[i];
					if( isVariableInteger( a.variableType ) && posGP < 32 && m_auiArgumentsGPList[ posGP ] != INVALID_VALUE )
					{
						a.registerIndex = m_auiArgumentsGPList[ posGP++ ];
						m_uiPassedGP |= nsCodeQOR::maskFromIndex( a.registerIndex );
					}
				}

				// Register arguments (FP), always left to right.
				for( i = 0; i != argumentsCount; i++ )
				{
					Argument& a = m_Arguments[i];
					if( isVariableFloat( a.variableType ) )
					{
						a.registerIndex = m_auiArgumentsXMMList[ posXMM++ ];
						m_uiPassedXMM |= nsCodeQOR::maskFromIndex( a.registerIndex );
					}
				}

				// Stack arguments.
				for( i = argumentsCount - 1; i != -1; i-- )
				{
					Argument& a = m_Arguments[ i ];
					if( a.isAssigned() )
					{
						continue;
					}

					if( isVariableInteger( a.variableType ) )
					{
						stackOffset -= 8;
						a.stackOffset = stackOffset;
					}
					else if( isVariableFloat( a.variableType ) )
					{
						Cmp__int32 size = (Cmp__int32)variableInfo[ a.variableType ].size;

						stackOffset -= size;
						a.stackOffset = stackOffset;
					}
				}
			}
#	endif // ( QOR_ARCH_WORDSIZE == 64 )

			// Modify stack offset (all function parameters will be in positive stack
			// offset that is never zero).
			for( i = 0; i < (Cmp_int_ptr)argumentsCount; i++ )
			{
				if( m_Arguments[ i ].registerIndex == INVALID_VALUE )
				{
					m_Arguments[ i ].stackOffset += sizeof(Cmp_int_ptr) - stackOffset;
				}
			}

			m_uiArgumentsStackSize = (Cmp_unsigned__int32)(-stackOffset);
		}

		//------------------------------------------------------------------------------
		void CFunctionPrototype::_setReturnValue( Cmp_unsigned__int32 valueId ) __QCMP_THROW
		{
			// TODO.
		}

	}//nsx86
}//nsArch

#endif//( QOR_ARCH == QOR_ARCH_X86_32 || QOR_ARCH == QOR_ARCH_X86_64 )
