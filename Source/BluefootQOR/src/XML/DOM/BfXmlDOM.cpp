//BfXmlDOM.cpp

// Copyright Querysoft Limited 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Derived from QtSDK/QtSources/4.8.0/src/xml/dom/qdom.cpp under the following 
//LGPL license

/****************************************************************************
**
** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
** All rights reserved.
** Contact: Nokia Corporation (qt-info@nokia.com)
**
** This file is part of the QtXml module of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:LGPL$
** GNU Lesser General Public License Usage
** This file may be used under the terms of the GNU Lesser General Public
** License version 2.1 as published by the Free Software Foundation and
** appearing in the file LICENSE.LGPL included in the packaging of this
** file. Please review the following information to ensure the GNU Lesser
** General Public License version 2.1 requirements will be met:
** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
** In addition, as a special exception, Nokia gives you certain additional
** rights. These rights are described in the Nokia Qt LGPL Exception
** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU General
** Public License version 3.0 as published by the Free Software Foundation
** and appearing in the file LICENSE.GPL included in the packaging of this
** file. Please review the following information to ensure the GNU General
** Public License version 3.0 requirements will be met:
** http://www.gnu.org/copyleft/gpl.html.
**
** Other Usage
** Alternatively, this file may be used in accordance with the terms and
** conditions contained in a signed written agreement between you and Nokia.
**
**
**
**
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include "BluefootQOR/XML/DOM/BfXmlDOM.h"
#include "BluefootQOR/XML/SAX/BfXmlDefaultHandler.h"
//#include "BluefootQOR/XML/SAX/BfXmlSimpleReader.h"
#include "BluefootQOR/XML/SAX/BfXmlLocator.h"
#include "BluefootQOR/XML/SAX/BfXmlInputSource.h"
#include "BluefootQOR/XML/SAX/BfXmlParseException.h"
#include "BluefootQOR/XML/SAX/BfXmlAttributes.h"
#include <vector>
#include <map>
#include <assert.h>

//#include <qplatformdefs.h>
//#include <qdom.h>
//#include "private/qxmlutils_p.h"

//#include <qatomic.h>
//#include <qbuffer.h>
//#include <qhash.h>
//#include <qiodevice.h>
//#include <qlist.h>
//#include <qregexp.h>
//#include <qtextcodec.h>
//#include <qtextstream.h>
//#include <qxml.h>
//#include <qvariant.h>
//#include <qmap.h>
//#include <qshareddata.h>
//#include <qdebug.h>
#include <stdio.h>

//------------------------------------------------------------------------------
namespace nsBluefoot
{

	/*
	  ### old todo comments -- I don't know if they still apply...

	  If the document dies, remove all pointers to it from children
	  which can not be deleted at this time.

	  If a node dies and has direct children which can not be deleted,
	  then remove the pointer to the parent.

	  createElement and friends create double reference counts.
	*/

	/* ##### new TODOs:

	  Remove emtpy emthods in the *Private classes

	  Make a lot of the (mostly empty) methods in the public classes inline.
	  Specially constructors assignment operators and comparison operators are candidates.

	  The virtual isXxx functions in *Private can probably be replaced by inline methods checking the nodeType().
	*/

	/*
	  Reference counting:

	  Some simple rules:
	  1) If an intern object returns a pointer to another intern object
		 then the reference count of the returned object is not increased.
	  2) If an extern object is created and gets a pointer to some intern
		 object, then the extern object increases the intern objects reference count.
	  3) If an extern object is deleted, then it decreases the reference count
		 on its associated intern object and deletes it if nobody else hold references
		 on the intern object.
	*/


	//Helper to split a qualified name into the prefix and local name.	
	static void qt_split_namespace( nsCodeQOR::CUCS2String& prefix, nsCodeQOR::CUCS2String& name, const nsCodeQOR::CUCS2String& qName, bool hasURI )
	{
		/*
    int i = qName.indexOf(QLatin1Char(':'));
    if (i == -1) {
        if (hasURI)
            prefix = QLatin1String("");
        else
            prefix.clear();
        name = qName;
    } else {
        prefix = qName.left(i);
        name = qName.mid(i + 1);
    }
*/
		int i = qName.Find( ':' );
		
		if( i == -1 ) 
		{
			if( hasURI )
			{
				prefix = nsCodeQOR::CUCS2String( _TXT( "" ) );
			}
			else
			{
				prefix.Clear();
			}
			name = qName;
		} 
		else 
		{
			prefix = qName.Left( i );
			name = qName.Mid( i + 1 );
		}
	}

	/**************************************************************
	 *
	 * Private class declerations
	 *
	 **************************************************************/

	//------------------------------------------------------------------------------
	class CDomImplementationPrivate
	{
	public:

		inline CDomImplementationPrivate() {}

		CDomImplementationPrivate* clone();

		unsigned long m_ulRefCount;
		//QAtomicInt ref;

		static CDomImplementation::InvalidDataPolicy invalidDataPolicy;
	};

	//------------------------------------------------------------------------------
	class CDomNodePrivate
	{
	public:

		CDomNodePrivate( CDomDocumentPrivate*, CDomNodePrivate* parent = 0 );
		CDomNodePrivate( CDomNodePrivate* n, bool deep );
		virtual ~CDomNodePrivate();

		//------------------------------------------------------------------------------
		nsCodeQOR::CUCS2String nodeName() const 
		{ 
			return name; 
		}

		//------------------------------------------------------------------------------
		nsCodeQOR::CUCS2String nodeValue() const 
		{ 
			return value; 
		}

		//------------------------------------------------------------------------------
		virtual void setNodeValue( const nsCodeQOR::CUCS2String& v ) 
		{ 
			value = v; 
		}

		CDomDocumentPrivate* ownerDocument();
		void setOwnerDocument( CDomDocumentPrivate* doc );

		virtual CDomNodePrivate* insertBefore( CDomNodePrivate* newChild, CDomNodePrivate* refChild );
		virtual CDomNodePrivate* insertAfter( CDomNodePrivate* newChild, CDomNodePrivate* refChild );
		virtual CDomNodePrivate* replaceChild( CDomNodePrivate* newChild, CDomNodePrivate* oldChild );
		virtual CDomNodePrivate* removeChild( CDomNodePrivate* oldChild );
		virtual CDomNodePrivate* appendChild( CDomNodePrivate* newChild );

		CDomNodePrivate* namedItem( const nsCodeQOR::CUCS2String& name );

		virtual CDomNodePrivate* cloneNode( bool deep = true );
		virtual void normalize();
		virtual void clear();

		//------------------------------------------------------------------------------
		inline CDomNodePrivate* parent() const 
		{ 
			return hasParent ? ownerNode : 0; 
		}

		//------------------------------------------------------------------------------
		inline void setParent( CDomNodePrivate* p ) 
		{ 
			ownerNode = p; 
			hasParent = true; 
		}

		//------------------------------------------------------------------------------
		void setNoParent() 
		{
			ownerNode = hasParent ? ( CDomNodePrivate* )ownerDocument() : 0;
			hasParent = false;
		}

		// Dynamic cast
		virtual bool isAttr() const                     { return false; }
		virtual bool isCDATASection() const             { return false; }
		virtual bool isDocumentFragment() const         { return false; }
		virtual bool isDocument() const                 { return false; }
		virtual bool isDocumentType() const             { return false; }
		virtual bool isElement() const                  { return false; }
		virtual bool isEntityReference() const          { return false; }
		virtual bool isText() const                     { return false; }
		virtual bool isEntity() const                   { return false; }
		virtual bool isNotation() const                 { return false; }
		virtual bool isProcessingInstruction() const    { return false; }
		virtual bool isCharacterData() const            { return false; }
		virtual bool isComment() const                  { return false; }

		//------------------------------------------------------------------------------
		virtual CDomNode::NodeType nodeType() const 
		{ 
			return CDomNode::BaseNode; 
		}

		//virtual void save( CTextStream&, int, int ) const;

		void setLocation(int lineNumber, int columnNumber);

		// Variables
		//QAtomicInt ref;
		unsigned long m_ulRefCount;

		CDomNodePrivate* prev;
		CDomNodePrivate* next;
		CDomNodePrivate* ownerNode; // either the node's parent or the node's owner document
		CDomNodePrivate* first;
		CDomNodePrivate* last;

		nsCodeQOR::CUCS2String name; // this is the local name if prefix != null
		nsCodeQOR::CUCS2String value;
		nsCodeQOR::CUCS2String prefix; // set this only for ElementNode and AttributeNode
		nsCodeQOR::CUCS2String namespaceURI; // set this only for ElementNode and AttributeNode
		bool createdWithDom1Interface : 1;
		bool hasParent                : 1;

		int lineNumber;
		int columnNumber;
	};

	//------------------------------------------------------------------------------
	class CDomNodeListPrivate
	{
	public:

		CDomNodeListPrivate(CDomNodePrivate*);
		CDomNodeListPrivate(CDomNodePrivate*, const nsCodeQOR::CUCS2String& );
		CDomNodeListPrivate(CDomNodePrivate*, const nsCodeQOR::CUCS2String&, const nsCodeQOR::CUCS2String& );
		~CDomNodeListPrivate();

		bool operator== (const CDomNodeListPrivate&) const;
		bool operator!= (const CDomNodeListPrivate&) const;

		void createList();
		CDomNodePrivate* item(int index);
		unsigned int length() const;

		//QAtomicInt ref;
		unsigned long m_ulRefCount;
		
		//This list contains the children of this node.
		CDomNodePrivate* node_impl;
		nsCodeQOR::CUCS2String tagname;
		nsCodeQOR::CUCS2String nsURI;
		std::vector< CDomNodePrivate* > list;
		long timestamp;
	};

	//------------------------------------------------------------------------------
	class CDomNamedNodeMapPrivate
	{
	public:

		CDomNamedNodeMapPrivate(CDomNodePrivate*);
		~CDomNamedNodeMapPrivate();

		CDomNodePrivate* namedItem(const nsCodeQOR::CUCS2String& name) const;
		CDomNodePrivate* namedItemNS(const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String& localName) const;
		CDomNodePrivate* setNamedItem(CDomNodePrivate* arg);
		CDomNodePrivate* setNamedItemNS(CDomNodePrivate* arg);
		CDomNodePrivate* removeNamedItem(const nsCodeQOR::CUCS2String& name);
		CDomNodePrivate* item(int index) const;
		unsigned int length() const;
		bool contains(const nsCodeQOR::CUCS2String& name) const;
		bool containsNS(const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String & localName) const;

		/**
		 * Remove all children from the map.
		 */
		void clearMap();
		bool isReadOnly() { return readonly; }
		void setReadOnly(bool r) { readonly = r; }
		bool isAppendToParent() { return appendToParent; }
		/**
		 * If true, then the node will redirect insert/remove calls
		 * to its parent by calling CDomNodePrivate::appendChild or removeChild.
		 * In addition the map wont increase or decrease the reference count
		 * of the nodes it contains.
		 *
		 * By default this value is false and the map will handle reference counting
		 * by itself.
		 */
		void setAppendToParent(bool b) { appendToParent = b; }

		/**
		 * Creates a copy of the map. It is a deep copy
		 * that means that all children are cloned.
		 */
		CDomNamedNodeMapPrivate* clone(CDomNodePrivate* parent);

		// Variables
		//QAtomicInt ref;
		unsigned long m_ulRefCount;

		std::map< nsCodeQOR::CUCS2String, CDomNodePrivate* > map;
		CDomNodePrivate* parent;
		bool readonly;
		bool appendToParent;
	};

	//------------------------------------------------------------------------------
	class CDomDocumentTypePrivate : public CDomNodePrivate
	{
	public:

		CDomDocumentTypePrivate( CDomDocumentPrivate*, CDomNodePrivate* parent = 0 );
		CDomDocumentTypePrivate( CDomDocumentTypePrivate* n, bool deep );
		~CDomDocumentTypePrivate();
		void init();

		// Reimplemented from CDomNodePrivate
		CDomNodePrivate* cloneNode( bool deep = true );
		CDomNodePrivate* insertBefore( CDomNodePrivate* newChild, CDomNodePrivate* refChild );
		CDomNodePrivate* insertAfter( CDomNodePrivate* newChild, CDomNodePrivate* refChild );
		CDomNodePrivate* replaceChild( CDomNodePrivate* newChild, CDomNodePrivate* oldChild );
		CDomNodePrivate* removeChild( CDomNodePrivate* oldChild );
		CDomNodePrivate* appendChild( CDomNodePrivate* newChild );

		//------------------------------------------------------------------------------
		virtual bool isDocumentType() const 
		{ 
			return true; 
		}

		//------------------------------------------------------------------------------
		CDomNode::NodeType nodeType() const 
		{ 
			return CDomNode::DocumentTypeNode; 
		}

		//void save( CTextStream& s, int, int ) const;

		// Variables
		CDomNamedNodeMapPrivate* entities;
		CDomNamedNodeMapPrivate* notations;
		nsCodeQOR::CUCS2String publicId;
		nsCodeQOR::CUCS2String systemId;
		nsCodeQOR::CUCS2String internalSubset;
	};

	//------------------------------------------------------------------------------
	class CDomDocumentFragmentPrivate : public CDomNodePrivate
	{
	public:

		CDomDocumentFragmentPrivate( CDomDocumentPrivate*, CDomNodePrivate* parent = 0 );
		CDomDocumentFragmentPrivate( CDomNodePrivate* n, bool deep );

		// Reimplemented from CDomNodePrivate
		virtual CDomNodePrivate* cloneNode( bool deep = true );
		//------------------------------------------------------------------------------
		virtual bool isDocumentFragment() const 
		{ 
			return true; 
		}

		//------------------------------------------------------------------------------
		CDomNode::NodeType nodeType() const 
		{ 
			return CDomNode::DocumentFragmentNode; 
		}
	};

	//------------------------------------------------------------------------------
	class CDomCharacterDataPrivate : public CDomNodePrivate
	{
	public:

		CDomCharacterDataPrivate( CDomDocumentPrivate*, CDomNodePrivate* parent, const nsCodeQOR::CUCS2String& data );
		CDomCharacterDataPrivate( CDomCharacterDataPrivate* n, bool deep );

		unsigned int dataLength() const;
		nsCodeQOR::CUCS2String substringData( unsigned long offset, unsigned long count ) const;
		void appendData( const nsCodeQOR::CUCS2String& arg );
		void insertData( unsigned long offset, const nsCodeQOR::CUCS2String& arg );
		void deleteData( unsigned long offset, unsigned long count );
		void replaceData( unsigned long offset, unsigned long count, const nsCodeQOR::CUCS2String& arg );

		//------------------------------------------------------------------------------
		// Reimplemented from CDomNodePrivate
		virtual bool isCharacterData() const 
		{ 
			return true; 
		}

		//------------------------------------------------------------------------------
		CDomNode::NodeType nodeType() const 
		{ 
			return CDomNode::CharacterDataNode; 
		}

		CDomNodePrivate* cloneNode( bool deep = true );
	};

	//------------------------------------------------------------------------------
	class CDomTextPrivate : public CDomCharacterDataPrivate
	{
	public:

		CDomTextPrivate( CDomDocumentPrivate*, CDomNodePrivate* parent, const nsCodeQOR::CUCS2String& val );
		CDomTextPrivate( CDomTextPrivate* n, bool deep );

		CDomTextPrivate* splitText( int offset );

		// Reimplemented from CDomNodePrivate
		CDomNodePrivate* cloneNode( bool deep = true );
	
		//------------------------------------------------------------------------------
		virtual bool isText() const 
		{ 
			return true; 
		}

		//------------------------------------------------------------------------------
		CDomNode::NodeType nodeType() const 
		{ 
			return CDomNode::TextNode; 
		}

		//virtual void save( CTextStream& s, int, int ) const;
	};

	//------------------------------------------------------------------------------
	class CDomAttrPrivate : public CDomNodePrivate
	{
	public:

		CDomAttrPrivate( CDomDocumentPrivate*, CDomNodePrivate*, const nsCodeQOR::CUCS2String& name );
		CDomAttrPrivate( CDomDocumentPrivate*, CDomNodePrivate*, const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String& qName );
		CDomAttrPrivate( CDomAttrPrivate* n, bool deep );

		bool specified() const;

		// Reimplemented from CDomNodePrivate
		void setNodeValue( const nsCodeQOR::CUCS2String& v );
		CDomNodePrivate* cloneNode( bool deep = true );
		
		//------------------------------------------------------------------------------
		virtual bool isAttr() const 
		{ 
			return true; 
		}
		
		//------------------------------------------------------------------------------
		CDomNode::NodeType nodeType() const 
		{ 
			return CDomNode::AttributeNode; 
		}

		//virtual void save( CTextStream& s, int, int ) const;

		// Variables
		bool m_specified;
	};

	//------------------------------------------------------------------------------
	class CDomElementPrivate : public CDomNodePrivate
	{
	public:

		CDomElementPrivate( CDomDocumentPrivate*, CDomNodePrivate* parent, const nsCodeQOR::CUCS2String& name );
		CDomElementPrivate( CDomDocumentPrivate*, CDomNodePrivate* parent, const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String& qName );
		CDomElementPrivate( CDomElementPrivate* n, bool deep );
		~CDomElementPrivate();

		nsCodeQOR::CUCS2String attribute( const nsCodeQOR::CUCS2String& name, const nsCodeQOR::CUCS2String& defValue ) const;
		nsCodeQOR::CUCS2String attributeNS( const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String& localName, const nsCodeQOR::CUCS2String& defValue ) const;
		void setAttribute( const nsCodeQOR::CUCS2String& name, const nsCodeQOR::CUCS2String& value );
		void setAttributeNS( const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String& qName, const nsCodeQOR::CUCS2String& newValue );
		void removeAttribute( const nsCodeQOR::CUCS2String& name );
		CDomAttrPrivate* attributeNode( const nsCodeQOR::CUCS2String& name );
		CDomAttrPrivate* attributeNodeNS( const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String& localName );
		CDomAttrPrivate* setAttributeNode( CDomAttrPrivate* newAttr );
		CDomAttrPrivate* setAttributeNodeNS( CDomAttrPrivate* newAttr );
		CDomAttrPrivate* removeAttributeNode( CDomAttrPrivate* oldAttr );
		bool hasAttribute( const nsCodeQOR::CUCS2String& name );
		bool hasAttributeNS( const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String& localName );

		nsCodeQOR::CUCS2String text();

		//------------------------------------------------------------------------------
		// Reimplemented from CDomNodePrivate
		CDomNamedNodeMapPrivate* attributes() 
		{ 
			return m_attr; 
		}

		//------------------------------------------------------------------------------
		bool hasAttributes() 
		{ 
			return( m_attr->length() > 0 ); 
		}

		//------------------------------------------------------------------------------
		virtual bool isElement() const 
		{ 
			return true; 
		}

		//------------------------------------------------------------------------------
		CDomNode::NodeType nodeType() const 
		{ 
			return CDomNode::ElementNode; 
		}

		CDomNodePrivate* cloneNode( bool deep = true );
		//virtual void save( CTextStream& s, int, int ) const;

		// Variables
		CDomNamedNodeMapPrivate* m_attr;
	};

	//------------------------------------------------------------------------------
	class CDomCommentPrivate : public CDomCharacterDataPrivate
	{
	public:

		CDomCommentPrivate( CDomDocumentPrivate*, CDomNodePrivate* parent, const nsCodeQOR::CUCS2String& val );
		CDomCommentPrivate( CDomCommentPrivate* n, bool deep );

		// Reimplemented from CDomNodePrivate
		CDomNodePrivate* cloneNode( bool deep = true );

		//------------------------------------------------------------------------------
		virtual bool isComment() const 
		{ 
			return true; 
		}
		
		//------------------------------------------------------------------------------
		CDomNode::NodeType nodeType() const 
		{ 
			return CDomNode::CommentNode; 
		}

		//virtual void save(CTextStream& s, int, int) const;
	};

	//------------------------------------------------------------------------------
	class CDomCDATASectionPrivate : public CDomTextPrivate
	{
	public:

		CDomCDATASectionPrivate( CDomDocumentPrivate*, CDomNodePrivate* parent, const nsCodeQOR::CUCS2String& val );
		CDomCDATASectionPrivate( CDomCDATASectionPrivate* n, bool deep );

		// Reimplemented from CDomNodePrivate
		CDomNodePrivate* cloneNode( bool deep = true );

		//------------------------------------------------------------------------------
		virtual bool isCDATASection() const 
		{ 
			return true; 
		}

		//------------------------------------------------------------------------------
		CDomNode::NodeType nodeType() const 
		{ 
			return CDomNode::CDATASectionNode; 
		}

		//virtual void save(CTextStream& s, int, int) const;
	};

	//------------------------------------------------------------------------------
	class CDomNotationPrivate : public CDomNodePrivate
	{
	public:

		CDomNotationPrivate( CDomDocumentPrivate*, CDomNodePrivate* parent, const nsCodeQOR::CUCS2String& name, const nsCodeQOR::CUCS2String& pub, const nsCodeQOR::CUCS2String& sys );
		CDomNotationPrivate( CDomNotationPrivate* n, bool deep );

		// Reimplemented from CDomNodePrivate
		CDomNodePrivate* cloneNode( bool deep = true );
		
		//------------------------------------------------------------------------------
		virtual bool isNotation() const 
		{ 
			return true; 
		}

		//------------------------------------------------------------------------------
		CDomNode::NodeType nodeType() const 
		{ 
			return CDomNode::NotationNode; 
		}

		//virtual void save( CTextStream& s, int, int ) const;

		// Variables
		nsCodeQOR::CUCS2String m_sys;
		nsCodeQOR::CUCS2String m_pub;
	};

	//------------------------------------------------------------------------------
	class CDomEntityPrivate : public CDomNodePrivate
	{
	public:

		CDomEntityPrivate( CDomDocumentPrivate*, CDomNodePrivate* parent, const nsCodeQOR::CUCS2String& name, const nsCodeQOR::CUCS2String& pub, const nsCodeQOR::CUCS2String& sys, const nsCodeQOR::CUCS2String& notation );
		CDomEntityPrivate( CDomEntityPrivate* n, bool deep );

		// Reimplemented from CDomNodePrivate
		CDomNodePrivate* cloneNode( bool deep = true );

		//------------------------------------------------------------------------------
		virtual bool isEntity() const 
		{ 
			return true; 
		}

		//------------------------------------------------------------------------------
		CDomNode::NodeType nodeType() const 
		{ 
			return CDomNode::EntityNode; 
		}

		//virtual void save( CTextStream& s, int, int ) const;

		// Variables
		nsCodeQOR::CUCS2String m_sys;
		nsCodeQOR::CUCS2String m_pub;
		nsCodeQOR::CUCS2String m_notationName;
	};

	//------------------------------------------------------------------------------
	class CDomEntityReferencePrivate : public CDomNodePrivate
	{
	public:

		CDomEntityReferencePrivate( CDomDocumentPrivate*, CDomNodePrivate* parent, const nsCodeQOR::CUCS2String& name );
		CDomEntityReferencePrivate( CDomNodePrivate* n, bool deep );

		// Reimplemented from CDomNodePrivate
		CDomNodePrivate* cloneNode( bool deep = true );

		//------------------------------------------------------------------------------
		bool isEntityReference() const 
		{ 
			return true; 
		}

		//------------------------------------------------------------------------------
		CDomNode::NodeType nodeType() const 
		{ 
			return CDomNode::EntityReferenceNode; 
		}

		//virtual void save( CTextStream& s, int, int ) const;
	};

	//------------------------------------------------------------------------------
	class CDomProcessingInstructionPrivate : public CDomNodePrivate
	{
	public:

		CDomProcessingInstructionPrivate( CDomDocumentPrivate*, CDomNodePrivate* parent, const nsCodeQOR::CUCS2String& target, const nsCodeQOR::CUCS2String& data );
		CDomProcessingInstructionPrivate( CDomProcessingInstructionPrivate* n, bool deep );

		// Reimplemented from CDomNodePrivate
		CDomNodePrivate* cloneNode( bool deep = true );

		//------------------------------------------------------------------------------
		virtual bool isProcessingInstruction() const 
		{ 
			return true; 
		}

		//------------------------------------------------------------------------------
		CDomNode::NodeType nodeType() const 
		{ 
			return CDomNode::ProcessingInstructionNode; 
		}

		//virtual void save( CTextStream& s, int, int ) const;
	};

	//------------------------------------------------------------------------------
	class CDomDocumentPrivate : public CDomNodePrivate
	{
	public:

		CDomDocumentPrivate();
		CDomDocumentPrivate( const nsCodeQOR::CUCS2String& name );
		CDomDocumentPrivate( CDomDocumentTypePrivate* dt );
		CDomDocumentPrivate( CDomDocumentPrivate* n, bool deep );
		~CDomDocumentPrivate();

		bool setContent( CBFSource* source, bool namespaceProcessing, nsCodeQOR::CUCS2String* errorMsg, int* errorLine, int* errorColumn );
		bool setContent( CBFSource* source, CXmlReader *reader, nsCodeQOR::CUCS2String* errorMsg, int* errorLine, int* errorColumn );

		// Attributes
		//------------------------------------------------------------------------------
		CDomDocumentTypePrivate* doctype() 
		{ 
			return type;
		}

		//------------------------------------------------------------------------------
		CDomImplementationPrivate* implementation() 
		{ 
			return impl;
		}

		CDomElementPrivate* documentElement();

		// Factories
		CDomElementPrivate* createElement( const nsCodeQOR::CUCS2String& tagName );
		CDomElementPrivate* createElementNS( const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String& qName );
		CDomDocumentFragmentPrivate* createDocumentFragment();
		CDomTextPrivate* createTextNode( const nsCodeQOR::CUCS2String& data );
		CDomCommentPrivate* createComment( const nsCodeQOR::CUCS2String& data );
		CDomCDATASectionPrivate* createCDATASection( const nsCodeQOR::CUCS2String& data );
		CDomProcessingInstructionPrivate* createProcessingInstruction( const nsCodeQOR::CUCS2String& target, const nsCodeQOR::CUCS2String& data );
		CDomAttrPrivate* createAttribute( const nsCodeQOR::CUCS2String& name );
		CDomAttrPrivate* createAttributeNS( const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String& qName );
		CDomEntityReferencePrivate* createEntityReference( const nsCodeQOR::CUCS2String& name );

		CDomNodePrivate* importNode( const CDomNodePrivate* importedNode, bool deep );

		// Reimplemented from CDomNodePrivate
		CDomNodePrivate* cloneNode( bool deep = true );

		//------------------------------------------------------------------------------
		bool isDocument() const 
		{ 
			return true; 
		}

		//------------------------------------------------------------------------------
		CDomNode::NodeType nodeType() const 
		{ 
			return CDomNode::DocumentNode; 
		}

		void clear();

		// Variables
		//QExplicitlySharedDataPointer< CDomImplementationPrivate > impl;
		CDomImplementationPrivate* impl;

		//QExplicitlySharedDataPointer< CDomDocumentTypePrivate > type;
		CDomDocumentTypePrivate* type;

		void saveDocument( CTextStream& stream, const int indent, CDomNode::EncodingPolicy encUsed ) const;

		/* \internal
		   Counter for the CDomNodeListPrivate timestamps.

		   This is a cache optimization, that might in some cases be effective. The
		   dilemma is that CDomNode::childNodes() returns a list, but the
		   implementation stores the children in a linked list. Hence, in order to
		   get the children out through childNodes(), a list must be populated each
		   time, which is O(N).

		   DOM has the requirement of node references being live, see DOM Core
		   Level 3, 1.1.1 The DOM Structure Model, which means that changes to the
		   underlying documents must be reflected in node lists.

		   This mechanism, nodeListTime, is a caching optimization that reduces the
		   amount of times the node list is rebuilt, by only doing so when the
		   document actually changes. However, a change to anywhere in any document
		   invalidate all lists, since no dependency tracking is done.

		   It functions by that all modifying functions(insertBefore() and so on)
		   increment the count; each CDomNodeListPrivate copies nodeListTime on
		   construction, and compares its own value to nodeListTime in order to
		   determine whether it needs to rebuild.

		   This is reentrant. The nodeListTime may overflow, but that's ok since we
		   check for equalness, not whether nodeListTime is smaller than the list's
		   stored timestamp.
		*/
		long nodeListTime;
	};


	//------------------------------------------------------------------------------
	class CDomHandler : public CXmlDefaultHandler
	{
	public:

		CDomHandler( CDomDocumentPrivate* d, bool namespaceProcessing );
		~CDomHandler();

		// content handler
		bool endDocument();
		bool startElement( const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String& localName, const nsCodeQOR::CUCS2String& qName, const CXmlAttributes& atts );
		bool endElement( const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String& localName, const nsCodeQOR::CUCS2String& qName );
		bool characters( const nsCodeQOR::CUCS2String& ch );
		bool processingInstruction( const nsCodeQOR::CUCS2String& target, const nsCodeQOR::CUCS2String& data );
		bool skippedEntity( const nsCodeQOR::CUCS2String& name );

		// error handler
		bool fatalError( const CXmlParseException& exception );

		// lexical handler
		bool startCDATA();
		bool endCDATA();
		bool startEntity( const nsCodeQOR::CUCS2String& );
		bool endEntity( const nsCodeQOR::CUCS2String& );
		bool startDTD( const nsCodeQOR::CUCS2String& name, const nsCodeQOR::CUCS2String& publicId, const nsCodeQOR::CUCS2String& systemId );
		bool comment( const nsCodeQOR::CUCS2String& ch );

		// decl handler
		bool externalEntityDecl( const nsCodeQOR::CUCS2String &name, const nsCodeQOR::CUCS2String &publicId, const nsCodeQOR::CUCS2String &systemId ) ;

		// DTD handler
		bool notationDecl( const nsCodeQOR::CUCS2String & name, const nsCodeQOR::CUCS2String & publicId, const nsCodeQOR::CUCS2String & systemId );
		bool unparsedEntityDecl( const nsCodeQOR::CUCS2String &name, const nsCodeQOR::CUCS2String &publicId, const nsCodeQOR::CUCS2String &systemId, const nsCodeQOR::CUCS2String &notationName );

		void setDocumentLocator( CXmlLocator* locator );

		nsCodeQOR::CUCS2String errorMsg;
		int errorLine;
		int errorColumn;

	private:

		CDomDocumentPrivate *doc;
		CDomNodePrivate *node;
		nsCodeQOR::CUCS2String entityName;
		bool cdata;
		bool nsProcessing;
		CXmlLocator *locator;

#ifdef Q_OS_SYMBIAN
		// Workaround crash in elf2e32 under Wine.
		virtual void dummy() {}
#endif
	};

/**************************************************************
 *
 * Functions for verifying legal data
 *
 **************************************************************/
CDomImplementation::InvalidDataPolicy CDomImplementationPrivate::invalidDataPolicy = CDomImplementation::AcceptInvalidChars;

// [5] Name ::= (Letter | '_' | ':') (NameChar)*

static nsCodeQOR::CUCS2String fixedXmlName(const nsCodeQOR::CUCS2String &_name, bool *ok, bool namespaces = false)
{
	//TODO:
    nsCodeQOR::CUCS2String name, prefix;
	/*
    if (namespaces)
        qt_split_namespace(prefix, name, _name, true);
    else
        name = _name;

    if( name.empty() ) 
	{
        *ok = false;
        return nsCodeQOR::CUCS2String();
    }

    if (CDomImplementationPrivate::invalidDataPolicy == CDomImplementation::AcceptInvalidChars) {
        *ok = true;
        return _name;
    }
	*/
    nsCodeQOR::CUCS2String result;
	/*
    bool firstChar = true;
    for (int i = 0; i < name.size(); ++i) 
	{
        char c = name.at(i);
        if (firstChar) 
		{
            if (QXmlUtils::isLetter(c) || c == '_' || c == ':' ) 
			{
                result.append( &c, 1 );
                firstChar = false;
            } 
			else if ( CDomImplementationPrivate::invalidDataPolicy == CDomImplementation::ReturnNullNode) 
			{
                *ok = false;
                return nsCodeQOR::CUCS2String();
            }
        } 
		else 
		{
            if (QXmlUtils::isNameChar(c))
			{
                result.append( &c, 1 );
			}
            else if (CDomImplementationPrivate::invalidDataPolicy == CDomImplementation::ReturnNullNode) 
			{
                *ok = false;
                return nsCodeQOR::CUCS2String();
            }
        }
    }

    if (result.empty()) 
	{
        *ok = false;
        return nsCodeQOR::CUCS2String();
    }

    *ok = true;
    if (namespaces && !prefix.empty())
        return prefix + ':' + result;
	*/
    return result;
}

// [14] CharData ::= [^<&]* - ([^<&]* ']]>' [^<&]*)
// '<', '&' and "]]>" will be escaped when writing

static nsCodeQOR::CUCS2String fixedCharData(const nsCodeQOR::CUCS2String &data, bool *ok)
{
    if (CDomImplementationPrivate::invalidDataPolicy == CDomImplementation::AcceptInvalidChars) 
	{
        *ok = true;
        return data;
    }

    nsCodeQOR::CUCS2String result;
	//TODO:
	/*
    for (int i = 0; i < data.size(); ++i) 
	{
        char c = data.at(i);
        if (QXmlUtils::isChar(c)) 
		{
            result.append( &c, 1 );
        } 
		else if (CDomImplementationPrivate::invalidDataPolicy == CDomImplementation::ReturnNullNode) 
		{
            *ok = false;
            return nsCodeQOR::CUCS2String();
        }
    }

    *ok = true;
	*/
    return result;
}

// [15] Comment ::= '<!--' ((Char - '-') | ('-' (Char - '-')))* '-->'
// can't escape "--", since entities are not recognised within comments

static nsCodeQOR::CUCS2String fixedComment(const nsCodeQOR::CUCS2String &data, bool *ok)
{
    if( CDomImplementationPrivate::invalidDataPolicy == CDomImplementation::AcceptInvalidChars) 
	{
        *ok = true;
        return data;
    }

    nsCodeQOR::CUCS2String fixedData = fixedCharData(data, ok);
    if (!*ok)
        return nsCodeQOR::CUCS2String();

    for (;;) 
	{
        int idx = fixedData.Find(nsCodeQOR::CUCS2String( _TXT( "--" ) ) );
        if (idx == -1)
		{
            break;
		}
        
		if (CDomImplementationPrivate::invalidDataPolicy == CDomImplementation::ReturnNullNode) 
		{
            *ok = false;
            return nsCodeQOR::CUCS2String();
        }
        fixedData.Remove(idx, 2);
    }

    *ok = true;
    return fixedData;
}

// [20] CData ::= (Char* - (Char* ']]>' Char*))
// can't escape "]]>", since entities are not recognised within comments

static nsCodeQOR::CUCS2String fixedCDataSection(const nsCodeQOR::CUCS2String &data, bool *ok)
{
    if (CDomImplementationPrivate::invalidDataPolicy == CDomImplementation::AcceptInvalidChars) 
	{
        *ok = true;
        return data;
    }

    nsCodeQOR::CUCS2String fixedData = fixedCharData(data, ok);
    if (!*ok)
        return nsCodeQOR::CUCS2String();

    for (;;) 
	{
        int idx = fixedData.Find( nsCodeQOR::CUCS2String( _TXT( "]]>" ) ) );
        
		if (idx == -1)
		{
            break;
		}

        if (CDomImplementationPrivate::invalidDataPolicy == CDomImplementation::ReturnNullNode) 
		{
            *ok = false;
            return nsCodeQOR::CUCS2String();
        }
        fixedData.Remove(idx, 3);
    }

    *ok = true;
    return fixedData;
}

// [16] PI ::= '<?' PITarget (S (Char* - (Char* '?>' Char*)))? '?>'

static nsCodeQOR::CUCS2String fixedPIData(const nsCodeQOR::CUCS2String &data, bool *ok)
{
    if (CDomImplementationPrivate::invalidDataPolicy == CDomImplementation::AcceptInvalidChars) {
        *ok = true;
        return data;
    }

    nsCodeQOR::CUCS2String fixedData = fixedCharData(data, ok);
    if (!*ok)
        return nsCodeQOR::CUCS2String();

    for (;;) 
	{
        int idx = fixedData.Find( nsCodeQOR::CUCS2String( _TXT( "?>" ) ) );
        if (idx == -1 )
		{
            break;
		}

        if( CDomImplementationPrivate::invalidDataPolicy == CDomImplementation::ReturnNullNode) 
		{
            *ok = false;
            return nsCodeQOR::CUCS2String();
        }

        fixedData.Remove( idx, 2 );
    }

    *ok = true;
    return fixedData;
}

// [12] PubidLiteral ::= '"' PubidChar* '"' | "'" (PubidChar - "'")* "'"
// The correct quote will be chosen when writing

static nsCodeQOR::CUCS2String fixedPubidLiteral(const nsCodeQOR::CUCS2String &data, bool *ok)
{
    if (CDomImplementationPrivate::invalidDataPolicy == CDomImplementation::AcceptInvalidChars) {
        *ok = true;
        return data;
    }

    nsCodeQOR::CUCS2String result;
	//TODO:
	/*
    if(QXmlUtils::isPublicID(data))
	{
        result = data;
	}
    else if (CDomImplementationPrivate::invalidDataPolicy == CDomImplementation::ReturnNullNode) 
	{
        *ok = false;
        return nsCodeQOR::CUCS2String();
    }

    if( result.find( '\'' ) != nsCodeQOR::CUCS2String::npos && result.find( '"' ) != nsCodeQOR::CUCS2String::npos ) 
	{
        if( CDomImplementationPrivate::invalidDataPolicy == CDomImplementation::ReturnNullNode ) 
		{
            *ok = false;
            return nsCodeQOR::CUCS2String();
        } 
		else 
		{
            result.erase( result.find( '\'' ), 1 );
        }
    }

    *ok = true;
	*/
    return result;
}

// [11] SystemLiteral ::= ('"' [^"]* '"') | ("'" [^']* "'")
// The correct quote will be chosen when writing

static nsCodeQOR::CUCS2String fixedSystemLiteral(const nsCodeQOR::CUCS2String &data, bool *ok)
{
    if (CDomImplementationPrivate::invalidDataPolicy == CDomImplementation::AcceptInvalidChars) 
	{
        *ok = true;
        return data;
    }

    nsCodeQOR::CUCS2String result = data;

    if( result.Find( '\'' ) != -1 && result.Find( '"' ) != -1 ) 
	{
        if (CDomImplementationPrivate::invalidDataPolicy == CDomImplementation::ReturnNullNode) 
		{
            *ok = false;
            return nsCodeQOR::CUCS2String();
        } 
		else 
		{
            result.Remove( result.Find( '\'' ), 1 );
        }
    }

    *ok = true;
    return result;
}

/**************************************************************
 *
 * CDomImplementationPrivate
 *
 **************************************************************/

CDomImplementationPrivate* CDomImplementationPrivate::clone()
{
    return new CDomImplementationPrivate;
}

/**************************************************************
 *
 * CDomImplementation
 *
 **************************************************************/

/*!
    \class CDomImplementation
    \reentrant
    \brief The CDomImplementation class provides information about the
    features of the DOM implementation.

    \inmodule QtXml
    \ingroup xml-tools

    This class describes the features that are supported by the DOM
    implementation. Currently the XML subset of DOM Level 1 and DOM
    Level 2 Core are supported.

    Normally you will use the function CDomDocument::implementation()
    to get the implementation object.

    You can create a new document type with createDocumentType() and a
    new document with createDocument().

    For further information about the Document Object Model see
    \l{http://www.w3.org/TR/REC-DOM-Level-1/}{Level 1} and
    \l{http://www.w3.org/TR/DOM-Level-2-Core/}{Level 2 Core}. For a more
    general introduction of the DOM implementation see the CDomDocument
    documentation.

    The QDom classes have a few issues of nonconformance with the XML
    specifications that cannot be fixed in Qt 4 without breaking backward
    compatibility. The QtXmlPatterns module and the QXmlStreamReader and
    QXmlStreamWriter classes have a higher degree of a conformance.

    \sa hasFeature()
*/

/*!
    Constructs a CDomImplementation object.
*/
CDomImplementation::CDomImplementation()
{
    impl = 0;
}

/*!
    Constructs a copy of \a x.
*/
CDomImplementation::CDomImplementation(const CDomImplementation &x)
{
    impl = x.impl;
    if (impl)
	{
        impl->m_ulRefCount++;;
	}
}

CDomImplementation::CDomImplementation( CDomImplementationPrivate* p )
{
    // We want to be co-owners, so increase the reference count
    impl = p;
    if (impl)
	{
        impl->m_ulRefCount++;
	}
}

/*!
    Assigns \a x to this DOM implementation.
*/
CDomImplementation& CDomImplementation::operator=(const CDomImplementation &x)
{
    if (x.impl)
	{
        x.impl->m_ulRefCount++;
	}

    if( impl && ! --( impl->m_ulRefCount ) )
	{
        delete impl;
	}
    impl = x.impl;
    return *this;
}

/*!
    Returns true if \a x and this DOM implementation object were
    created from the same CDomDocument; otherwise returns false.
*/
bool CDomImplementation::operator==(const CDomImplementation &x) const
{
    return (impl == x.impl);
}

/*!
    Returns true if \a x and this DOM implementation object were
    created from different QDomDocuments; otherwise returns false.
*/
bool CDomImplementation::operator!=(const CDomImplementation &x) const
{
    return (impl != x.impl);
}

/*!
    Destroys the object and frees its resources.
*/
CDomImplementation::~CDomImplementation()
{
    if( impl && ! --( impl->m_ulRefCount ) )
	{
        delete impl;
	}
}

/*!
    The function returns true if QDom implements the requested \a
    version of a \a feature; otherwise returns false.

    The currently supported features and their versions:
    \table
    \header \i Feature \i Version
    \row \i XML \i 1.0
    \endtable
*/
bool CDomImplementation::hasFeature(const nsCodeQOR::CUCS2String& feature, const nsCodeQOR::CUCS2String& version) const
{
    if( feature == nsCodeQOR::CUCS2String( _TXT( "XML" ) ) ) 
	{
        if( version.IsEmpty() || version == nsCodeQOR::CUCS2String( _TXT( "1.0" ) ) ) 
		{
            return true;
        }
    }
    // ### add DOM level 2 features
    return false;
}

/*!
    Creates a document type node for the name \a qName.

    \a publicId specifies the public identifier of the external
    subset. If you specify an empty string (nsCodeQOR::CUCS2String()) as the \a
    publicId, this means that the document type has no public
    identifier.

    \a systemId specifies the system identifier of the external
    subset. If you specify an empty string as the \a systemId, this
    means that the document type has no system identifier.

    Since you cannot have a public identifier without a system
    identifier, the public identifier is set to an empty string if
    there is no system identifier.

    DOM level 2 does not support any other document type declaration
    features.

    The only way you can use a document type that was created this
    way, is in combination with the createDocument() function to
    create a CDomDocument with this document type.

    In the DOM specification, this is the only way to create a non-null
    document. For historical reasons, Qt also allows to create the
    document using the default empty constructor. The resulting document
    is null, but becomes non-null when a factory function, for example
    CDomDocument::createElement(), is called. The document also becomes
    non-null when setContent() is called.

    \sa createDocument()
*/
CDomDocumentType CDomImplementation::createDocumentType( const nsCodeQOR::CUCS2String& qName, const nsCodeQOR::CUCS2String& publicId, const nsCodeQOR::CUCS2String& systemId )
{
    bool ok;
    nsCodeQOR::CUCS2String fixedName = fixedXmlName(qName, &ok, true);
    if (!ok)
        return CDomDocumentType();

    nsCodeQOR::CUCS2String fixedPublicId = fixedPubidLiteral(publicId, &ok);
    if (!ok)
        return CDomDocumentType();

    nsCodeQOR::CUCS2String fixedSystemId = fixedSystemLiteral(systemId, &ok);
    if (!ok)
        return CDomDocumentType();

    CDomDocumentTypePrivate *dt = new CDomDocumentTypePrivate(0);
    dt->name = fixedName;
    if (systemId.IsEmpty()) {
        dt->publicId.Clear();
        dt->systemId.Clear();
    } else {
        dt->publicId = fixedPublicId;
        dt->systemId = fixedSystemId;
    }
    dt->m_ulRefCount--;
    return CDomDocumentType(dt);
}

/*!
    Creates a DOM document with the document type \a doctype. This
    function also adds a root element node with the qualified name \a
    qName and the namespace URI \a nsURI.
*/
CDomDocument CDomImplementation::createDocument(const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String& qName, const CDomDocumentType& doctype)
{
    CDomDocument doc(doctype);
    CDomElement root = doc.createElementNS(nsURI, qName);
    if (root.isNull())
        return CDomDocument();
    doc.appendChild(root);
    return doc;
}

/*!
    Returns false if the object was created by
    CDomDocument::implementation(); otherwise returns true.
*/
bool CDomImplementation::isNull()
{
    return (impl == 0);
}

/*!
    \enum CDomImplementation::InvalidDataPolicy

    This enum specifies what should be done when a factory function
    in CDomDocument is called with invalid data.
    \value AcceptInvalidChars The data should be stored in the DOM object
        anyway. In this case the resulting XML document might not be well-formed.
        This is the default value and QDom's behavior in Qt < 4.1.
    \value DropInvalidChars The invalid characters should be removed from
        the data.
    \value ReturnNullNode The factory function should return a null node.

    \sa setInvalidDataPolicy() invalidDataPolicy()
*/

/*!
   \enum CDomNode::EncodingPolicy
   \since 4.3

   This enum specifies how CDomNode::save() determines what encoding to use
   when serializing.

   \value EncodingFromDocument The encoding is fetched from the document.
   \value EncodingFromTextStream The encoding is fetched from the CTextStream.

   See also the overload of the save() function that takes an EncodingPolicy.
*/

/*!
    \since 4.1
    \nonreentrant

    Returns the invalid data policy, which specifies what should be done when
    a factory function in CDomDocument is passed invalid data.

    \sa setInvalidDataPolicy() InvalidDataPolicy
*/

CDomImplementation::InvalidDataPolicy CDomImplementation::invalidDataPolicy()
{
    return CDomImplementationPrivate::invalidDataPolicy;
}

/*!
    \since 4.1
    \nonreentrant

    Sets the invalid data policy, which specifies what should be done when
    a factory function in CDomDocument is passed invalid data.

    The \a policy is set for all instances of CDomDocument which already
    exist and which will be created in the future.

    \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 0

    \sa invalidDataPolicy() InvalidDataPolicy
*/

void CDomImplementation::setInvalidDataPolicy(InvalidDataPolicy policy)
{
    CDomImplementationPrivate::invalidDataPolicy = policy;
}

/**************************************************************
 *
 * CDomNodeListPrivate
 *
 **************************************************************/

CDomNodeListPrivate::CDomNodeListPrivate(CDomNodePrivate *n_impl)
{
    m_ulRefCount = 1;
    node_impl = n_impl;
    if( node_impl )
	{
        node_impl->m_ulRefCount++;
	}
    timestamp = 0;
}

CDomNodeListPrivate::CDomNodeListPrivate(CDomNodePrivate *n_impl, const nsCodeQOR::CUCS2String &name)
{
    m_ulRefCount = 1;
    node_impl = n_impl;
    if( node_impl )
	{
        node_impl->m_ulRefCount++;
	}
    tagname = name;
    timestamp = 0;
}

CDomNodeListPrivate::CDomNodeListPrivate(CDomNodePrivate *n_impl, const nsCodeQOR::CUCS2String &_nsURI, const nsCodeQOR::CUCS2String &localName)
{
    m_ulRefCount = 1;
    node_impl = n_impl;
    if( node_impl )
	{
        node_impl->m_ulRefCount++;
	}
    tagname = localName;
    nsURI = _nsURI;
    timestamp = 0;
}

CDomNodeListPrivate::~CDomNodeListPrivate()
{
    if( node_impl && !( --( node_impl->m_ulRefCount ) ) )
	{
        delete node_impl;
	}
}

bool CDomNodeListPrivate::operator==(const CDomNodeListPrivate &other) const
{
    return (node_impl == other.node_impl) && (tagname == other.tagname);
}

bool CDomNodeListPrivate::operator!=(const CDomNodeListPrivate &other) const
{
    return (node_impl != other.node_impl) || (tagname != other.tagname);
}

void CDomNodeListPrivate::createList()
{
    if (!node_impl)
        return;

    const CDomDocumentPrivate *const doc = node_impl->ownerDocument();
    if (doc && timestamp != doc->nodeListTime)
        timestamp = doc->nodeListTime;

    CDomNodePrivate* p = node_impl->first;

    list.clear();
    if (tagname.IsEmpty()) {
        while (p) {
            list.push_back(p);
            p = p->next;
        }
    } else if (nsURI.IsEmpty()) {
        while (p && p != node_impl) {
            if (p->isElement() && p->nodeName() == tagname) {
                list.push_back(p);
            }
            if (p->first)
                p = p->first;
            else if (p->next)
                p = p->next;
            else {
                p = p->parent();
                while (p && p != node_impl && !p->next)
                    p = p->parent();
                if (p && p != node_impl)
                    p = p->next;
            }
        }
    } else {
        while (p && p != node_impl) {
            if (p->isElement() && p->name==tagname && p->namespaceURI==nsURI) {
                list.push_back(p);
            }
            if (p->first)
                p = p->first;
            else if (p->next)
                p = p->next;
            else {
                p = p->parent();
                while (p && p != node_impl && !p->next)
                    p = p->parent();
                if (p && p != node_impl)
                    p = p->next;
            }
        }
    }
}

CDomNodePrivate* CDomNodeListPrivate::item(int index)
{
    if (!node_impl)
        return 0;

    const CDomDocumentPrivate *const doc = node_impl->ownerDocument();
    if (!doc || timestamp != doc->nodeListTime)
        createList();

    if (index >= list.size())
        return 0;

    return list.at(index);
}

unsigned int CDomNodeListPrivate::length() const
{
    if (!node_impl)
        return 0;

    const CDomDocumentPrivate *const doc = node_impl->ownerDocument();
    if (!doc || timestamp != doc->nodeListTime) {
        CDomNodeListPrivate *that = const_cast<CDomNodeListPrivate *>(this);
        that->createList();
    }

    return list.size();
}

/**************************************************************
 *
 * CDomNodeList
 *
 **************************************************************/

/*!
    \class CDomNodeList
    \reentrant
    \brief The CDomNodeList class is a list of CDomNode objects.

    \inmodule QtXml
    \ingroup xml-tools

    Lists can be obtained by CDomDocument::elementsByTagName() and
    CDomNode::childNodes(). The Document Object Model (DOM) requires
    these lists to be "live": whenever you change the underlying
    document, the contents of the list will get updated.

    You can get a particular node from the list with item(). The
    number of items in the list is returned by length().

    For further information about the Document Object Model see
    \l{http://www.w3.org/TR/REC-DOM-Level-1/}{Level 1} and
    \l{http://www.w3.org/TR/DOM-Level-2-Core/}{Level 2 Core}.
    For a more general introduction of the DOM implementation see the
    CDomDocument documentation.

    \sa CDomNode::childNodes() CDomDocument::elementsByTagName()
*/

/*!
    Creates an empty node list.
*/
CDomNodeList::CDomNodeList()
{
    impl = 0;
}

CDomNodeList::CDomNodeList(CDomNodeListPrivate* p)
{
    impl = p;
}

/*!
    Constructs a copy of \a n.
*/
CDomNodeList::CDomNodeList(const CDomNodeList& n)
{
    impl = n.impl;
    if (impl)
	{
        impl->m_ulRefCount++;
	}
}

/*!
    Assigns \a n to this node list.
*/
CDomNodeList& CDomNodeList::operator=(const CDomNodeList &n)
{
    if (n.impl)
	{
        n.impl->m_ulRefCount++;
	}
    if( impl && !( --( impl->m_ulRefCount ) ) )
	{
        delete impl;
	}
    impl = n.impl;
    return *this;
}

/*!
    Returns true if the node list \a n and this node list are equal;
    otherwise returns false.
*/
bool CDomNodeList::operator==(const CDomNodeList &n) const
{
    if (impl == n.impl)
        return true;
    if (!impl || !n.impl)
        return false;
    return (*impl == *n.impl);
}

/*!
    Returns true the node list \a n and this node list are not equal;
    otherwise returns false.
*/
bool CDomNodeList::operator!=(const CDomNodeList &n) const
{
    return !operator==(n);
}

/*!
    Destroys the object and frees its resources.
*/
CDomNodeList::~CDomNodeList()
{
    if( impl && !( --( impl->m_ulRefCount ) ) )
	{
        delete impl;
	}
}

/*!
    Returns the node at position \a index.

    If \a index is negative or if \a index >= length() then a null
    node is returned (i.e. a node for which CDomNode::isNull() returns
    true).

    \sa length()
*/
CDomNode CDomNodeList::item(int index) const
{
    if (!impl)
        return CDomNode();

    return CDomNode(impl->item(index));
}

/*!
    Returns the number of nodes in the list.
*/
unsigned int CDomNodeList::length() const
{
    if (!impl)
        return 0;
    return impl->length();
}

/*!
    \fn bool CDomNodeList::isEmpty() const

    Returns true if the list contains no items; otherwise returns false.
    This function is provided for Qt API consistency.
*/

/*!
    \fn int CDomNodeList::count() const

    This function is provided for Qt API consistency. It is equivalent to length().
*/

/*!
    \fn int CDomNodeList::size() const

    This function is provided for Qt API consistency. It is equivalent to length().
*/

/*!
    \fn CDomNode CDomNodeList::at(int index) const

    This function is provided for Qt API consistency. It is equivalent
    to item().

    If \a index is negative or if \a index >= length() then a null
    node is returned (i.e. a node for which CDomNode::isNull() returns
    true).
*/

/**************************************************************
 *
 * CDomNodePrivate
 *
 **************************************************************/

inline void CDomNodePrivate::setOwnerDocument(CDomDocumentPrivate *doc)
{
    ownerNode = doc;
    hasParent = false;
}

CDomNodePrivate::CDomNodePrivate(CDomDocumentPrivate *doc, CDomNodePrivate *par)
{
    m_ulRefCount = 1;
    if( par )
	{
        setParent( par );
	}
    else
	{
        setOwnerDocument( doc );
	}
    prev = 0;
    next = 0;
    first = 0;
    last = 0;
    createdWithDom1Interface = true;
    lineNumber = -1;
    columnNumber = -1;
}

CDomNodePrivate::CDomNodePrivate(CDomNodePrivate *n, bool deep)
{
    m_ulRefCount = 1;
    setOwnerDocument(n->ownerDocument());
    prev = 0;
    next = 0;
    first = 0;
    last = 0;

    name = n->name;
    value = n->value;
    prefix = n->prefix;
    namespaceURI = n->namespaceURI;
    createdWithDom1Interface = n->createdWithDom1Interface;
    lineNumber = -1;
    columnNumber = -1;

    if( !deep )
	{
        return;
	}

    for( CDomNodePrivate* x = n->first; x; x = x->next )
	{
        appendChild( x->cloneNode( true ) );
	}
}

CDomNodePrivate::~CDomNodePrivate()
{
    CDomNodePrivate* p = first;
    CDomNodePrivate* n;

    while (p) 
	{
        n = p->next;
        if( !( --( p->m_ulRefCount ) ) )
		{
            delete p;
		}
        else
		{
            p->setNoParent();
		}
        p = n;
    }
    first = 0;
    last = 0;
}

void CDomNodePrivate::clear()
{
    CDomNodePrivate* p = first;
    CDomNodePrivate* n;

    while( p ) 
	{
        n = p->next;
        if( ! ( --(p->m_ulRefCount ) ) )
		{
            delete p;
		}
        p = n;
    }
    first = 0;
    last = 0;
}

CDomNodePrivate* CDomNodePrivate::namedItem(const nsCodeQOR::CUCS2String &n)
{
    CDomNodePrivate* p = first;
    while (p) {
        if (p->nodeName() == n)
            return p;
        p = p->next;
    }
    return 0;
}


CDomNodePrivate* CDomNodePrivate::insertBefore(CDomNodePrivate* newChild, CDomNodePrivate* refChild)
{
    // Error check
    if (!newChild)
        return 0;

    // Error check
    if (newChild == refChild)
        return 0;

    // Error check
    if (refChild && refChild->parent() != this)
        return 0;

    // "mark lists as dirty"
    CDomDocumentPrivate *const doc = ownerDocument();
    if(doc)
        doc->nodeListTime++;

    // Special handling for inserting a fragment. We just insert
    // all elements of the fragment instead of the fragment itself.
    if (newChild->isDocumentFragment()) {
        // Fragment is empty ?
        if (newChild->first == 0)
            return newChild;

        // New parent
        CDomNodePrivate* n = newChild->first;
        while (n)  {
            n->setParent(this);
            n = n->next;
        }

        // Insert at the beginning ?
        if (!refChild || refChild->prev == 0) {
            if (first)
                first->prev = newChild->last;
            newChild->last->next = first;
            if (!last)
                last = newChild->last;
            first = newChild->first;
        } else {
            // Insert in the middle
            newChild->last->next = refChild;
            newChild->first->prev = refChild->prev;
            refChild->prev->next = newChild->first;
            refChild->prev = newChild->last;
        }

        // No need to increase the reference since CDomDocumentFragment
        // does not decrease the reference.

        // Remove the nodes from the fragment
        newChild->first = 0;
        newChild->last = 0;
        return newChild;
    }

    // No more errors can occur now, so we take
    // ownership of the node.
    newChild->m_ulRefCount++;

    if (newChild->parent())
        newChild->parent()->removeChild(newChild);

    newChild->setParent(this);

    if (!refChild) 
	{
        if (first)
            first->prev = newChild;
        newChild->next = first;
        if (!last)
            last = newChild;
        first = newChild;
        return newChild;
    }

    if (refChild->prev == 0) 
	{
        if (first)
            first->prev = newChild;
        newChild->next = first;
        if (!last)
            last = newChild;
        first = newChild;
        return newChild;
    }

    newChild->next = refChild;
    newChild->prev = refChild->prev;
    refChild->prev->next = newChild;
    refChild->prev = newChild;

    return newChild;
}

CDomNodePrivate* CDomNodePrivate::insertAfter(CDomNodePrivate* newChild, CDomNodePrivate* refChild)
{
    // Error check
    if (!newChild)
        return 0;

    // Error check
    if (newChild == refChild)
        return 0;

    // Error check
    if (refChild && refChild->parent() != this)
        return 0;

    // "mark lists as dirty"
    CDomDocumentPrivate *const doc = ownerDocument();
    if(doc)
        doc->nodeListTime++;

    // Special handling for inserting a fragment. We just insert
    // all elements of the fragment instead of the fragment itself.
    if (newChild->isDocumentFragment()) {
        // Fragment is empty ?
        if (newChild->first == 0)
            return newChild;

        // New parent
        CDomNodePrivate* n = newChild->first;
        while (n) {
            n->setParent(this);
            n = n->next;
        }

        // Insert at the end
        if (!refChild || refChild->next == 0) {
            if (last)
                last->next = newChild->first;
            newChild->first->prev = last;
            if (!first)
                first = newChild->first;
            last = newChild->last;
        } else { // Insert in the middle
            newChild->first->prev = refChild;
            newChild->last->next = refChild->next;
            refChild->next->prev = newChild->last;
            refChild->next = newChild->first;
        }

        // No need to increase the reference since CDomDocumentFragment
        // does not decrease the reference.

        // Remove the nodes from the fragment
        newChild->first = 0;
        newChild->last = 0;
        return newChild;
    }

    // Release new node from its current parent
    if (newChild->parent())
        newChild->parent()->removeChild(newChild);

    // No more errors can occur now, so we take
    // ownership of the node
    newChild->m_ulRefCount++;

    newChild->setParent(this);

    // Insert at the end
    if (!refChild) 
	{
        if (last)
            last->next = newChild;
        newChild->prev = last;
        if (!first)
            first = newChild;
        last = newChild;
        return newChild;
    }

    if (refChild->next == 0) 
	{
        if (last)
            last->next = newChild;
        newChild->prev = last;
        if (!first)
            first = newChild;
        last = newChild;
        return newChild;
    }

    newChild->prev = refChild;
    newChild->next = refChild->next;
    refChild->next->prev = newChild;
    refChild->next = newChild;

    return newChild;
}

CDomNodePrivate* CDomNodePrivate::replaceChild(CDomNodePrivate* newChild, CDomNodePrivate* oldChild)
{
    if (!newChild || !oldChild)
        return 0;
    if (oldChild->parent() != this)
        return 0;
    if (newChild == oldChild)
        return 0;

    // mark lists as dirty
    CDomDocumentPrivate *const doc = ownerDocument();
    if(doc)
        doc->nodeListTime++;

    // Special handling for inserting a fragment. We just insert
    // all elements of the fragment instead of the fragment itself.
    if (newChild->isDocumentFragment()) {
        // Fragment is empty ?
        if (newChild->first == 0)
            return newChild;

        // New parent
        CDomNodePrivate* n = newChild->first;
        while (n) {
            n->setParent(this);
            n = n->next;
        }


        if (oldChild->next)
            oldChild->next->prev = newChild->last;
        if (oldChild->prev)
            oldChild->prev->next = newChild->first;

        newChild->last->next = oldChild->next;
        newChild->first->prev = oldChild->prev;

        if (first == oldChild)
            first = newChild->first;
        if (last == oldChild)
            last = newChild->last;

        oldChild->setNoParent();
        oldChild->next = 0;
        oldChild->prev = 0;

        // No need to increase the reference since CDomDocumentFragment
        // does not decrease the reference.

        // Remove the nodes from the fragment
        newChild->first = 0;
        newChild->last = 0;

        // We are no longer interested in the old node
        if (oldChild)
		{
            oldChild->m_ulRefCount--;
		}

        return oldChild;
    }

    // No more errors can occur now, so we take
    // ownership of the node
    newChild->m_ulRefCount++;

    // Release new node from its current parent
    if (newChild->parent())
        newChild->parent()->removeChild(newChild);

    newChild->setParent(this);

    if (oldChild->next)
        oldChild->next->prev = newChild;
    if (oldChild->prev)
        oldChild->prev->next = newChild;

    newChild->next = oldChild->next;
    newChild->prev = oldChild->prev;

    if (first == oldChild)
        first = newChild;
    if (last == oldChild)
        last = newChild;

    oldChild->setNoParent();
    oldChild->next = 0;
    oldChild->prev = 0;

    // We are no longer interested in the old node
    if( oldChild )
	{
        oldChild->m_ulRefCount--;
	}

    return oldChild;
}

CDomNodePrivate* CDomNodePrivate::removeChild(CDomNodePrivate* oldChild)
{
    // Error check
    if (oldChild->parent() != this)
        return 0;

    // "mark lists as dirty"
    CDomDocumentPrivate *const doc = ownerDocument();
    if(doc)
        doc->nodeListTime++;

    // Perhaps oldChild was just created with "createElement" or that. In this case
    // its parent is CDomDocument but it is not part of the documents child list.
    if (oldChild->next == 0 && oldChild->prev == 0 && first != oldChild)
        return 0;

    if (oldChild->next)
        oldChild->next->prev = oldChild->prev;
    if (oldChild->prev)
        oldChild->prev->next = oldChild->next;

    if (last == oldChild)
        last = oldChild->prev;
    if (first == oldChild)
        first = oldChild->next;

    oldChild->setNoParent();
    oldChild->next = 0;
    oldChild->prev = 0;

    // We are no longer interested in the old node
    oldChild->m_ulRefCount--;

    return oldChild;
}

CDomNodePrivate* CDomNodePrivate::appendChild(CDomNodePrivate* newChild)
{
    // No reference manipulation needed. Done in insertAfter.
    return insertAfter(newChild, 0);
}

CDomDocumentPrivate* CDomNodePrivate::ownerDocument()
{
    CDomNodePrivate* p = this;
    while (p && !p->isDocument()) {
        if (!p->hasParent)
            return (CDomDocumentPrivate*)p->ownerNode;
        p = p->parent();
    }

    return static_cast<CDomDocumentPrivate *>(p);
}

CDomNodePrivate* CDomNodePrivate::cloneNode(bool deep)
{
    CDomNodePrivate* p = new CDomNodePrivate(this, deep);
    // We are not interested in this node
    p->m_ulRefCount--;
    return p;
}

static void qNormalizeNode(CDomNodePrivate* n)
{
    CDomNodePrivate* p = n->first;
    CDomTextPrivate* t = 0;

    while (p) 
	{
        if (p->isText()) 
		{
            if (t) 
			{
                CDomNodePrivate* tmp = p->next;
                t->appendData(p->nodeValue());
                n->removeChild(p);
                p = tmp;
            } 
			else 
			{
                t = (CDomTextPrivate*)p;
                p = p->next;
            }
        } 
		else 
		{
            p = p->next;
            t = 0;
        }
    }
}

void CDomNodePrivate::normalize()
{
    // ### This one has moved from CDomElementPrivate to this position. It is
    // not tested.
    qNormalizeNode(this);
}

/*! \internal
  \a depth is used for indentation, it seems.
 */
/*
void CDomNodePrivate::save(CTextStream& s, int depth, int indent) const
{
    const CDomNodePrivate* n = first;
    while (n) {
        n->save(s, depth, indent);
        n = n->next;
    }
}
*/
void CDomNodePrivate::setLocation(int lineNumber, int columnNumber)
{
    this->lineNumber = lineNumber;
    this->columnNumber = columnNumber;
}

/**************************************************************
 *
 * CDomNode
 *
 **************************************************************/

#define IMPL ((CDomNodePrivate*)impl)

/*!
    \class CDomNode
    \reentrant
    \brief The CDomNode class is the base class for all the nodes in a DOM tree.

    \inmodule QtXml
    \ingroup xml-tools


    Many functions in the DOM return a CDomNode.

    You can find out the type of a node using isAttr(),
    isCDATASection(), isDocumentFragment(), isDocument(),
    isDocumentType(), isElement(), isEntityReference(), isText(),
    isEntity(), isNotation(), isProcessingInstruction(),
    isCharacterData() and isComment().

    A CDomNode can be converted into one of its subclasses using
    toAttr(), toCDATASection(), toDocumentFragment(), toDocument(),
    toDocumentType(), toElement(), toEntityReference(), toText(),
    toEntity(), toNotation(), toProcessingInstruction(),
    toCharacterData() or toComment(). You can convert a node to a null
    node with clear().

    Copies of the CDomNode class share their data using explicit
    sharing. This means that modifying one node will change all
    copies. This is especially useful in combination with functions
    which return a CDomNode, e.g. firstChild(). You can make an
    independent (deep) copy of the node with cloneNode().

    A CDomNode can be null, much like a null pointer. Creating a copy
    of a null node results in another null node. It is not
    possible to modify a null node, but it is possible to assign another,
    possibly non-null node to it. In this case, the copy of the null node
    will remain null. You can check if a CDomNode is null by calling isNull().
    The empty constructor of a CDomNode (or any of the derived classes) creates
    a null node.

    Nodes are inserted with insertBefore(), insertAfter() or
    appendChild(). You can replace one node with another using
    replaceChild() and remove a node with removeChild().

    To traverse nodes use firstChild() to get a node's first child (if
    any), and nextSibling() to traverse. CDomNode also provides
    lastChild(), previousSibling() and parentNode(). To find the first
    child node with a particular node name use namedItem().

    To find out if a node has children use hasChildNodes() and to get
    a list of all of a node's children use childNodes().

    The node's name and value (the meaning of which varies depending
    on its type) is returned by nodeName() and nodeValue()
    respectively. The node's type is returned by nodeType(). The
    node's value can be set with setNodeValue().

    The document to which the node belongs is returned by
    ownerDocument().

    Adjacent CDomText nodes can be merged into a single node with
    normalize().

    \l CDomElement nodes have attributes which can be retrieved with
    attributes().

    CDomElement and CDomAttr nodes can have namespaces which can be
    retrieved with namespaceURI(). Their local name is retrieved with
    localName(), and their prefix with prefix(). The prefix can be set
    with setPrefix().

    You can write the XML representation of the node to a text stream
    with save().

    The following example looks for the first element in an XML document and
    prints the names of all the elements that are its direct children.
    \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 1

    For further information about the Document Object Model see
    \l{http://www.w3.org/TR/REC-DOM-Level-1/}{Level 1} and
    \l{http://www.w3.org/TR/DOM-Level-2-Core/}{Level 2 Core}.
    For a more general introduction of the DOM implementation see the
    CDomDocument documentation.
*/

/*!
    Constructs a \link isNull() null\endlink node.
*/
CDomNode::CDomNode()
{
    impl = 0;
}

/*!
    Constructs a copy of \a n.

    The data of the copy is shared (shallow copy): modifying one node
    will also change the other. If you want to make a deep copy, use
    cloneNode().
*/
CDomNode::CDomNode(const CDomNode &n)
{
    impl = n.impl;
    if (impl)
	{
        impl->m_ulRefCount++;
	}
}

/*!  \internal
  Constructs a new node for the data \a n.
*/
CDomNode::CDomNode(CDomNodePrivate *n)
{
    impl = n;
    if (impl)
	{
        impl->m_ulRefCount++;
	}
}

/*!
    Assigns a copy of \a n to this DOM node.

    The data of the copy is shared (shallow copy): modifying one node
    will also change the other. If you want to make a deep copy, use
    cloneNode().
*/
CDomNode& CDomNode::operator=(const CDomNode &n)
{
    if (n.impl)
	{
        n.impl->m_ulRefCount++;
	}

    if( impl && !( --( impl->m_ulRefCount ) ) )
	{
        delete impl;
	}
    impl = n.impl;
    return *this;
}

/*!
    Returns true if \a n and this DOM node are equal; otherwise
    returns false.

    Any instance of CDomNode acts as a reference to an underlying data
    structure in CDomDocument. The test for equality checks if the two
    references point to the same underlying node. For example:

    \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 2

    The two nodes (CDomElement is a CDomNode subclass) both refer to
    the document's root element, and \c {element1 == element2} will
    return true. On the other hand:

    \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 3

    Even though both nodes are empty elements carrying the same name,
    \c {element3 == element4} will return false because they refer to
    two different nodes in the underlying data structure.
*/
bool CDomNode::operator== (const CDomNode& n) const
{
    return (impl == n.impl);
}

/*!
    Returns true if \a n and this DOM node are not equal; otherwise
    returns false.
*/
bool CDomNode::operator!= (const CDomNode& n) const
{
    return (impl != n.impl);
}

/*!
    Destroys the object and frees its resources.
*/
CDomNode::~CDomNode()
{
    if (impl && !( --( impl->m_ulRefCount ) ) )
	{
        delete impl;
	}
}

/*!
    Returns the name of the node.

    The meaning of the name depends on the subclass:

    \table
    \header \i Name \i Meaning
    \row \i CDomAttr \i The name of the attribute
    \row \i CDomCDATASection \i The string "#cdata-section"
    \row \i CDomComment \i The string "#comment"
    \row \i CDomDocument \i The string "#document"
    \row \i CDomDocumentFragment \i The string "#document-fragment"
    \row \i CDomDocumentType \i The name of the document type
    \row \i CDomElement \i The tag name
    \row \i CDomEntity \i The name of the entity
    \row \i CDomEntityReference \i The name of the referenced entity
    \row \i CDomNotation \i The name of the notation
    \row \i CDomProcessingInstruction \i The target of the processing instruction
    \row \i CDomText \i The string "#text"
    \endtable

    \bold{Note:} This function does not take the presence of namespaces into account
    when processing the names of element and attribute nodes. As a result, the
    returned name can contain any namespace prefix that may be present.
    To obtain the node name of an element or attribute, use localName(); to
    obtain the namespace prefix, use namespaceURI().

    \sa nodeValue()
*/
nsCodeQOR::CUCS2String CDomNode::nodeName() const
{
    if( !impl )
	{
        return nsCodeQOR::CUCS2String();
	}

    if( !IMPL->prefix.IsEmpty() )
	{
		IMPL->prefix.Append( _TXT( ":" ) );
		IMPL->prefix.Append( IMPL->name );
        return IMPL->prefix;
	}
    return IMPL->name;
}

/*!
    Returns the value of the node.

    The meaning of the value depends on the subclass:
    \table
    \header \i Name \i Meaning
    \row \i CDomAttr \i The attribute value
    \row \i CDomCDATASection \i The content of the CDATA section
    \row \i CDomComment \i The comment
    \row \i CDomProcessingInstruction \i The data of the processing instruction
    \row \i CDomText \i The text
    \endtable

    All the other subclasses do not have a node value and will return
    an empty string.

    \sa setNodeValue() nodeName()
*/
nsCodeQOR::CUCS2String CDomNode::nodeValue() const
{
    if (!impl)
        return nsCodeQOR::CUCS2String();
    return IMPL->value;
}

/*!
    Sets the node's value to \a v.

    \sa nodeValue()
*/
void CDomNode::setNodeValue(const nsCodeQOR::CUCS2String& v)
{
    if (!impl)
        return;
    IMPL->setNodeValue(v);
}

/*!
    \enum CDomNode::NodeType

    This enum defines the type of the node:
    \value ElementNode
    \value AttributeNode
    \value TextNode
    \value CDATASectionNode
    \value EntityReferenceNode
    \value EntityNode
    \value ProcessingInstructionNode
    \value CommentNode
    \value DocumentNode
    \value DocumentTypeNode
    \value DocumentFragmentNode
    \value NotationNode
    \value BaseNode  A CDomNode object, i.e. not a CDomNode subclass.
    \value CharacterDataNode
*/

/*!
    Returns the type of the node.

    \sa toAttr(), toCDATASection(), toDocumentFragment(),
    toDocument() toDocumentType(), toElement(), toEntityReference(),
    toText(), toEntity() toNotation(), toProcessingInstruction(),
    toCharacterData(), toComment()
*/
CDomNode::NodeType CDomNode::nodeType() const
{
    if (!impl)
        return CDomNode::BaseNode;
    return IMPL->nodeType();
}

/*!
    Returns the parent node. If this node has no parent, a null node
    is returned (i.e. a node for which isNull() returns true).
*/
CDomNode CDomNode::parentNode() const
{
    if (!impl)
        return CDomNode();
    return CDomNode(IMPL->parent());
}

/*!
    Returns a list of all direct child nodes.

    Most often you will call this function on a CDomElement object.

    For example, if the XML document looks like this:
    \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 4
    Then the list of child nodes for the "body"-element will contain
    the node created by the &lt;h1&gt; tag and the node created by the
    &lt;p&gt; tag.

    The nodes in the list are not copied; so changing the nodes in the
    list will also change the children of this node.

    \sa firstChild() lastChild()
*/
CDomNodeList CDomNode::childNodes() const
{
    if (!impl)
        return CDomNodeList();
    return CDomNodeList(new CDomNodeListPrivate(impl));
}

/*!
    Returns the first child of the node. If there is no child node, a
    \link isNull() null node\endlink is returned. Changing the
    returned node will also change the node in the document tree.

    \sa lastChild() childNodes()
*/
CDomNode CDomNode::firstChild() const
{
    if (!impl)
        return CDomNode();
    return CDomNode(IMPL->first);
}

/*!
    Returns the last child of the node. If there is no child node, a
    \link isNull() null node\endlink is returned. Changing the
    returned node will also change the node in the document tree.

    \sa firstChild() childNodes()
*/
CDomNode CDomNode::lastChild() const
{
    if (!impl)
        return CDomNode();
    return CDomNode(IMPL->last);
}

/*!
    Returns the previous sibling in the document tree. Changing the
    returned node will also change the node in the document tree.

    For example, if you have XML like this:
    \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 5
    and this CDomNode represents the &lt;p&gt; tag, previousSibling()
    will return the node representing the &lt;h1&gt; tag.

    \sa nextSibling()
*/
CDomNode CDomNode::previousSibling() const
{
    if (!impl)
        return CDomNode();
    return CDomNode(IMPL->prev);
}

/*!
    Returns the next sibling in the document tree. Changing the
    returned node will also change the node in the document tree.

    If you have XML like this:
    \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 6
    and this CDomNode represents the <p> tag, nextSibling() will
    return the node representing the <h2> tag.

    \sa previousSibling()
*/
CDomNode CDomNode::nextSibling() const
{
    if (!impl)
        return CDomNode();
    return CDomNode(IMPL->next);
}


// ###### don't think this is part of the DOM and
/*!
    Returns a named node map of all attributes. Attributes are only
    provided for \l{CDomElement}s.

    Changing the attributes in the map will also change the attributes
    of this CDomNode.
*/
CDomNamedNodeMap CDomNode::attributes() const
{
    if (!impl || !impl->isElement())
	{
        return CDomNamedNodeMap();
	}

    return CDomNamedNodeMap(static_cast<CDomElementPrivate *>(impl)->attributes());
}

/*!
    Returns the document to which this node belongs.
*/
CDomDocument CDomNode::ownerDocument() const
{
    if (!impl)
        return CDomDocument();
    return CDomDocument(IMPL->ownerDocument());
}

/*!
    Creates a deep (not shallow) copy of the CDomNode.

    If \a deep is true, then the cloning is done recursively which
    means that all the node's children are deep copied too. If \a deep
    is false only the node itself is copied and the copy will have no
    child nodes.
*/
CDomNode CDomNode::cloneNode(bool deep) const
{
    if (!impl)
        return CDomNode();
    return CDomNode(IMPL->cloneNode(deep));
}

/*!
    Calling normalize() on an element converts all its children into a
    standard form. This means that adjacent CDomText objects will be
    merged into a single text object (CDomCDATASection nodes are not
    merged).
*/
void CDomNode::normalize()
{
    if (!impl)
        return;
    IMPL->normalize();
}

/*!
    Returns true if the DOM implementation implements the feature \a
    feature and this feature is supported by this node in the version
    \a version; otherwise returns false.

    \sa CDomImplementation::hasFeature()
*/
bool CDomNode::isSupported(const nsCodeQOR::CUCS2String& feature, const nsCodeQOR::CUCS2String& version) const
{
    CDomImplementation i;
    return i.hasFeature(feature, version);
}

/*!
    Returns the namespace URI of this node or an empty string if the
    node has no namespace URI.

    Only nodes of type \link CDomNode::NodeType ElementNode\endlink or
    \link CDomNode::NodeType AttributeNode\endlink can have
    namespaces. A namespace URI must be specified at creation time and
    cannot be changed later.

    \sa prefix() localName() CDomDocument::createElementNS()
    CDomDocument::createAttributeNS()
*/
nsCodeQOR::CUCS2String CDomNode::namespaceURI() const
{
    if (!impl)
        return nsCodeQOR::CUCS2String();
    return IMPL->namespaceURI;
}

/*!
    Returns the namespace prefix of the node or an empty string if the
    node has no namespace prefix.

    Only nodes of type \link CDomNode::NodeType ElementNode\endlink or
    \link CDomNode::NodeType AttributeNode\endlink can have
    namespaces. A namespace prefix must be specified at creation time.
    If a node was created with a namespace prefix, you can change it
    later with setPrefix().

    If you create an element or attribute with
    CDomDocument::createElement() or CDomDocument::createAttribute(),
    the prefix will be an empty string. If you use
    CDomDocument::createElementNS() or
    CDomDocument::createAttributeNS() instead, the prefix will not be
    an empty string; but it might be an empty string if the name does
    not have a prefix.

    \sa setPrefix() localName() namespaceURI()
    CDomDocument::createElementNS() CDomDocument::createAttributeNS()
*/
nsCodeQOR::CUCS2String CDomNode::prefix() const
{
    if (!impl)
        return nsCodeQOR::CUCS2String();
    return IMPL->prefix;
}

/*!
    If the node has a namespace prefix, this function changes the
    namespace prefix of the node to \a pre. Otherwise this function
    does nothing.

    Only nodes of type \link CDomNode::NodeType ElementNode\endlink or
    \link CDomNode::NodeType AttributeNode\endlink can have
    namespaces. A namespace prefix must have be specified at creation
    time; it is not possible to add a namespace prefix afterwards.

    \sa prefix() localName() namespaceURI()
    CDomDocument::createElementNS() CDomDocument::createAttributeNS()
*/
void CDomNode::setPrefix(const nsCodeQOR::CUCS2String& pre)
{
    if (!impl || IMPL->prefix.IsEmpty())
        return;
    if (isAttr() || isElement())
        IMPL->prefix = pre;
}

/*!
    If the node uses namespaces, this function returns the local name
    of the node; otherwise it returns an empty string.

    Only nodes of type \link CDomNode::NodeType ElementNode\endlink or
    \link CDomNode::NodeType AttributeNode\endlink can have
    namespaces. A namespace must have been specified at creation time;
    it is not possible to add a namespace afterwards.

    \sa prefix() namespaceURI() CDomDocument::createElementNS()
    CDomDocument::createAttributeNS()
*/
nsCodeQOR::CUCS2String CDomNode::localName() const
{
    if (!impl || IMPL->createdWithDom1Interface)
        return nsCodeQOR::CUCS2String();
    return IMPL->name;
}

/*!
    Returns true if the node has attributes; otherwise returns false.

    \sa attributes()
*/
bool CDomNode::hasAttributes() const
{
    if (!impl || !impl->isElement())
        return false;
    return static_cast<CDomElementPrivate *>(impl)->hasAttributes();
}

/*!
    Inserts the node \a newChild before the child node \a refChild.
    \a refChild must be a direct child of this node. If \a refChild is
    \link isNull() null\endlink then \a newChild is inserted as the
    node's first child.

    If \a newChild is the child of another node, it is reparented to
    this node. If \a newChild is a child of this node, then its
    position in the list of children is changed.

    If \a newChild is a CDomDocumentFragment, then the children of the
    fragment are removed from the fragment and inserted before \a
    refChild.

    Returns a new reference to \a newChild on success or a \link
    isNull() null node\endlink on failure.

    The DOM specification disallow inserting attribute nodes, but due
    to historical reasons QDom accept them nevertheless.

    \sa insertAfter() replaceChild() removeChild() appendChild()
*/
CDomNode CDomNode::insertBefore(const CDomNode& newChild, const CDomNode& refChild)
{
    if (!impl)
        return CDomNode();
    return CDomNode(IMPL->insertBefore(newChild.impl, refChild.impl));
}

/*!
    Inserts the node \a newChild after the child node \a refChild. \a
    refChild must be a direct child of this node. If \a refChild is
    \link isNull() null\endlink then \a newChild is appended as this
    node's last child.

    If \a newChild is the child of another node, it is reparented to
    this node. If \a newChild is a child of this node, then its
    position in the list of children is changed.

    If \a newChild is a CDomDocumentFragment, then the children of the
    fragment are removed from the fragment and inserted after \a
    refChild.

    Returns a new reference to \a newChild on success or a \link
    isNull() null node\endlink on failure.

    The DOM specification disallow inserting attribute nodes, but due
    to historical reasons QDom accept them nevertheless.

    \sa insertBefore() replaceChild() removeChild() appendChild()
*/
CDomNode CDomNode::insertAfter(const CDomNode& newChild, const CDomNode& refChild)
{
    if (!impl)
        return CDomNode();
    return CDomNode(IMPL->insertAfter(newChild.impl, refChild.impl));
}

/*!
    Replaces \a oldChild with \a newChild. \a oldChild must be a
    direct child of this node.

    If \a newChild is the child of another node, it is reparented to
    this node. If \a newChild is a child of this node, then its
    position in the list of children is changed.

    If \a newChild is a CDomDocumentFragment, then \a oldChild is
    replaced by all of the children of the fragment.

    Returns a new reference to \a oldChild on success or a \link
    isNull() null node\endlink an failure.

    \sa insertBefore() insertAfter() removeChild() appendChild()
*/
CDomNode CDomNode::replaceChild(const CDomNode& newChild, const CDomNode& oldChild)
{
    if (!impl || !newChild.impl || !oldChild.impl)
        return CDomNode();
    return CDomNode(IMPL->replaceChild(newChild.impl, oldChild.impl));
}

/*!
    Removes \a oldChild from the list of children. \a oldChild must be
    a direct child of this node.

    Returns a new reference to \a oldChild on success or a \link
    isNull() null node\endlink on failure.

    \sa insertBefore() insertAfter() replaceChild() appendChild()
*/
CDomNode CDomNode::removeChild(const CDomNode& oldChild)
{
    if (!impl)
        return CDomNode();

    if (oldChild.isNull())
        return CDomNode();

    return CDomNode(IMPL->removeChild(oldChild.impl));
}

/*!
    Appends \a newChild as the node's last child.

    If \a newChild is the child of another node, it is reparented to
    this node. If \a newChild is a child of this node, then its
    position in the list of children is changed.

    If \a newChild is a CDomDocumentFragment, then the children of the
    fragment are removed from the fragment and appended.

    If \a newChild is a CDomElement and this node is a CDomDocument that
    already has an element node as a child, \a newChild is not added as
    a child and a null node is returned.

    Returns a new reference to \a newChild on success or a \link
    isNull() null node\endlink on failure.

    Calling this function on a null node(created, for example, with
    the default constructor) does nothing and returns a \link isNull()
    null node\endlink.

    The DOM specification disallow inserting attribute nodes, but for
    historical reasons, QDom accepts them anyway.

    \sa insertBefore() insertAfter() replaceChild() removeChild()
*/
CDomNode CDomNode::appendChild(const CDomNode& newChild)
{
    if (!impl) 
	{
        //TODO:qWarning("Calling appendChild() on a null node does nothing.");
        return CDomNode();
    }
    return CDomNode(IMPL->appendChild(newChild.impl));
}

/*!
    Returns true if the node has one or more children; otherwise
    returns false.
*/
bool CDomNode::hasChildNodes() const
{
    if (!impl)
        return false;
    return IMPL->first != 0;
}

/*!
    Returns true if this node is null (i.e. if it has no type or
    contents); otherwise returns false.
*/
bool CDomNode::isNull() const
{
    return (impl == 0);
}

/*!
    Converts the node into a null node; if it was not a null node
    before, its type and contents are deleted.

    \sa isNull()
*/
void CDomNode::clear()
{
    if (impl && !( --( impl->m_ulRefCount ) ) )
	{
        delete impl;
	}
    impl = 0;
}

/*!
    Returns the first direct child node for which nodeName() equals \a
    name.

    If no such direct child exists, a \link isNull() null node\endlink
    is returned.

    \sa nodeName()
*/
CDomNode CDomNode::namedItem(const nsCodeQOR::CUCS2String& name) const
{
    if (!impl)
        return CDomNode();
    return CDomNode(impl->namedItem(name));
}

/*!
    Writes the XML representation of the node and all its children to
    the stream \a str. This function uses \a indent as the amount of
    space to indent the node.

    If this node is a document node, the encoding of text stream \a str's encoding is
    set by treating a processing instruction by name "xml" as an XML declaration, if such a one exists,
    and otherwise defaults to UTF-8. XML declarations are not processing instructions, but this
    behavior exists for historical reasons. If this node is not a document node,
    the text stream's encoding is used.

    If the document contains invalid XML characters or characters that cannot be
    encoded in the given encoding, the result and behavior is undefined.

*/
/*
void CDomNode::save(CTextStream& str, int indent) const
{
    save(str, indent, CDomNode::EncodingFromDocument);
}
*/
/*!
    If \a encodingPolicy is CDomNode::EncodingFromDocument, this function behaves as save(CTextStream &str, int indent).

    If \a encodingPolicy is EncodingFromTextStream and this node is a document node, this
    function behaves as save(CTextStream &str, int indent) with the exception that the encoding
    specified in the text stream \a str is used.

    If the document contains invalid XML characters or characters that cannot be
    encoded in the given encoding, the result and behavior is undefined.

    \since 4.2
 */
/*
void CDomNode::save(CTextStream& str, int indent, EncodingPolicy encodingPolicy) const
{
    if (!impl)
        return;

    if(isDocument())
        static_cast<const CDomDocumentPrivate *>(impl)->saveDocument(str, indent, encodingPolicy);
    else
        IMPL->save(str, 1, indent);
}
*/
/*!
    \relates CDomNode

    Writes the XML representation of the node \a node and all its
    children to the stream \a str.
*/
/*
CTextStream& operator<<(CTextStream& str, const CDomNode& node)
{
    node.save(str, 1);

    return str;
}
*/
/*!
    Returns true if the node is an attribute; otherwise returns false.

    If this function returns true, it does not imply that this object
    is a QDomAttribute; you can get the QDomAttribute with
    toAttribute().

    \sa toAttr()
*/
bool CDomNode::isAttr() const
{
    if(impl)
        return impl->isAttr();
    return false;
}

/*!
    Returns true if the node is a CDATA section; otherwise returns
    false.

    If this function returns true, it does not imply that this object
    is a CDomCDATASection; you can get the CDomCDATASection with
    toCDATASection().

    \sa toCDATASection()
*/
bool CDomNode::isCDATASection() const
{
    if(impl)
        return impl->isCDATASection();
    return false;
}

/*!
    Returns true if the node is a document fragment; otherwise returns
    false.

    If this function returns true, it does not imply that this object
    is a CDomDocumentFragment; you can get the CDomDocumentFragment
    with toDocumentFragment().

    \sa toDocumentFragment()
*/
bool CDomNode::isDocumentFragment() const
{
    if(impl)
        return impl->isDocumentFragment();
    return false;
}

/*!
    Returns true if the node is a document; otherwise returns false.

    If this function returns true, it does not imply that this object
    is a CDomDocument; you can get the CDomDocument with toDocument().

    \sa toDocument()
*/
bool CDomNode::isDocument() const
{
    if(impl)
        return impl->isDocument();
    return false;
}

/*!
    Returns true if the node is a document type; otherwise returns
    false.

    If this function returns true, it does not imply that this object
    is a CDomDocumentType; you can get the CDomDocumentType with
    toDocumentType().

    \sa toDocumentType()
*/
bool CDomNode::isDocumentType() const
{
    if(impl)
        return impl->isDocumentType();
    return false;
}

/*!
    Returns true if the node is an element; otherwise returns false.

    If this function returns true, it does not imply that this object
    is a CDomElement; you can get the CDomElement with toElement().

    \sa toElement()
*/
bool CDomNode::isElement() const
{
    if(impl)
        return impl->isElement();
    return false;
}

/*!
    Returns true if the node is an entity reference; otherwise returns
    false.

    If this function returns true, it does not imply that this object
    is a CDomEntityReference; you can get the CDomEntityReference with
    toEntityReference().

    \sa toEntityReference()
*/
bool CDomNode::isEntityReference() const
{
    if(impl)
        return impl->isEntityReference();
    return false;
}

/*!
    Returns true if the node is a text node; otherwise returns false.

    If this function returns true, it does not imply that this object
    is a CDomText; you can get the CDomText with toText().

    \sa toText()
*/
bool CDomNode::isText() const
{
    if(impl)
        return impl->isText();
    return false;
}

/*!
    Returns true if the node is an entity; otherwise returns false.

    If this function returns true, it does not imply that this object
    is a CDomEntity; you can get the CDomEntity with toEntity().

    \sa toEntity()
*/
bool CDomNode::isEntity() const
{
    if(impl)
        return impl->isEntity();
    return false;
}

/*!
    Returns true if the node is a notation; otherwise returns false.

    If this function returns true, it does not imply that this object
    is a CDomNotation; you can get the CDomNotation with toNotation().

    \sa toNotation()
*/
bool CDomNode::isNotation() const
{
    if(impl)
        return impl->isNotation();
    return false;
}

/*!
    Returns true if the node is a processing instruction; otherwise
    returns false.

    If this function returns true, it does not imply that this object
    is a CDomProcessingInstruction; you can get the
    QProcessingInstruction with toProcessingInstruction().

    \sa toProcessingInstruction()
*/
bool CDomNode::isProcessingInstruction() const
{
    if(impl)
        return impl->isProcessingInstruction();
    return false;
}

/*!
    Returns true if the node is a character data node; otherwise
    returns false.

    If this function returns true, it does not imply that this object
    is a CDomCharacterData; you can get the CDomCharacterData with
    toCharacterData().

    \sa toCharacterData()
*/
bool CDomNode::isCharacterData() const
{
    if (impl)
        return impl->isCharacterData();
    return false;
}

/*!
    Returns true if the node is a comment; otherwise returns false.

    If this function returns true, it does not imply that this object
    is a CDomComment; you can get the CDomComment with toComment().

    \sa toComment()
*/
bool CDomNode::isComment() const
{
    if (impl)
        return impl->isComment();
    return false;
}

#undef IMPL

/*!
    Returns the first child element with tag name \a tagName if tagName is non-empty;
    otherwise returns the first child element.  Returns a null element if no
    such child exists.

    \sa lastChildElement() previousSiblingElement() nextSiblingElement()
*/

CDomElement CDomNode::firstChildElement(const nsCodeQOR::CUCS2String &tagName) const
{
    for (CDomNode child = firstChild(); !child.isNull(); child = child.nextSibling()) {
        if (child.isElement()) {
            CDomElement elt = child.toElement();
            if (tagName.IsEmpty() || elt.tagName() == tagName)
                return elt;
        }
    }
    return CDomElement();
}

/*!
    Returns the last child element with tag name \a tagName if tagName is non-empty;
    otherwise returns the first child element. Returns a null element if no
    such child exists.

    \sa firstChildElement() previousSiblingElement() nextSiblingElement()
*/

CDomElement CDomNode::lastChildElement(const nsCodeQOR::CUCS2String &tagName) const
{
    for (CDomNode child = lastChild(); !child.isNull(); child = child.previousSibling()) {
        if (child.isElement()) {
            CDomElement elt = child.toElement();
            if (tagName.IsEmpty() || elt.tagName() == tagName)
                return elt;
        }
    }
    return CDomElement();
}

/*!
    Returns the next sibling element with tag name \a tagName if \a tagName
    is non-empty; otherwise returns any next sibling element.
    Returns a null element if no such sibling exists.

    \sa firstChildElement() previousSiblingElement() lastChildElement()
*/

CDomElement CDomNode::nextSiblingElement(const nsCodeQOR::CUCS2String &tagName) const
{
    for (CDomNode sib = nextSibling(); !sib.isNull(); sib = sib.nextSibling()) {
        if (sib.isElement()) {
            CDomElement elt = sib.toElement();
            if (tagName.IsEmpty() || elt.tagName() == tagName)
                return elt;
        }
    }
    return CDomElement();
}

/*!
    Returns the previous sibilng element with tag name \a tagName if \a tagName
    is non-empty; otherwise returns any previous sibling element.
    Returns a null element if no such sibling exists.

    \sa firstChildElement(), nextSiblingElement(), lastChildElement()
*/

CDomElement CDomNode::previousSiblingElement(const nsCodeQOR::CUCS2String &tagName) const
{
    for (CDomNode sib = previousSibling(); !sib.isNull(); sib = sib.previousSibling()) {
        if (sib.isElement()) {
            CDomElement elt = sib.toElement();
            if (tagName.IsEmpty() || elt.tagName() == tagName)
                return elt;
        }
    }
    return CDomElement();
}

/*!
    \since 4.1

    For nodes created by CDomDocument::setContent(), this function
    returns the line number in the XML document where the node was parsed.
    Otherwise, -1 is returned.

    \sa columnNumber(), CDomDocument::setContent()
*/
int CDomNode::lineNumber() const
{
    return impl ? impl->lineNumber : -1;
}

/*!
    \since 4.1

    For nodes created by CDomDocument::setContent(), this function
    returns the column number in the XML document where the node was parsed.
    Otherwise, -1 is returned.

    \sa lineNumber(), CDomDocument::setContent()
*/
int CDomNode::columnNumber() const
{
    return impl ? impl->columnNumber : -1;
}


/**************************************************************
 *
 * CDomNamedNodeMapPrivate
 *
 **************************************************************/

CDomNamedNodeMapPrivate::CDomNamedNodeMapPrivate(CDomNodePrivate* n)
{
    m_ulRefCount = 1;
    readonly = false;
    parent = n;
    appendToParent = false;
}

CDomNamedNodeMapPrivate::~CDomNamedNodeMapPrivate()
{
    clearMap();
}

CDomNamedNodeMapPrivate* CDomNamedNodeMapPrivate::clone(CDomNodePrivate* p)
{
	nsCodeQOR::CTLRef< CDomNamedNodeMapPrivate > m( new CDomNamedNodeMapPrivate( p ), true );
    m->readonly = readonly;
    m->appendToParent = appendToParent;

    std::map< nsCodeQOR::CUCS2String, CDomNodePrivate*>::const_iterator it = map.cbegin();
    for (; it != map.cend(); ++it) 
	{
        CDomNodePrivate *new_node = (*it).second->cloneNode();
        new_node->setParent(p);
        m->setNamedItem(new_node);
    }

    // we are no longer interested in ownership
    m->m_ulRefCount--;
    return m.Detach();
}

void CDomNamedNodeMapPrivate::clearMap()
{
    // Dereference all of our children if we took references
    if (!appendToParent) 
	{
        std::map< nsCodeQOR::CUCS2String, CDomNodePrivate* >::const_iterator it = map.cbegin();
        for(; it != map.cend(); ++it )
		{
            if( !( --( it->second->m_ulRefCount ) ) )
			{
                delete it->second;
			}
		}
    }
    map.clear();
}

CDomNodePrivate* CDomNamedNodeMapPrivate::namedItem(const nsCodeQOR::CUCS2String& name) const
{
    CDomNodePrivate* p = map.find( name )->second;
    return p;
}

CDomNodePrivate* CDomNamedNodeMapPrivate::namedItemNS(const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String& localName) const
{
    std::map< nsCodeQOR::CUCS2String, CDomNodePrivate* >::const_iterator it = map.cbegin();
    CDomNodePrivate *n;
    for (; it != map.cend(); ++it) 
	{
        n = it->second;
        if (!n->prefix.IsEmpty()) 
		{
            // node has a namespace
            if (n->namespaceURI == nsURI && n->name == localName)
			{
                return n;
			}
        }
    }
    return 0;
}

//------------------------------------------------------------------------------
CDomNodePrivate* CDomNamedNodeMapPrivate::setNamedItem( CDomNodePrivate* arg )
{
	//TODO:
	/*
    if( readonly || !arg )
	{
        return 0;
	}

    if( appendToParent )
	{
        return parent->appendChild( arg );
	}

    CDomNodePrivate *n = map.find( arg->nodeName() )->second;
    // We take a reference
    arg->m_ulRefCount++;
    map.insert( std::make_pair( arg->nodeName(), arg ) );
    return n;
	*/
	return 0;
}

//------------------------------------------------------------------------------
CDomNodePrivate* CDomNamedNodeMapPrivate::setNamedItemNS( CDomNodePrivate* arg )
{
    if( readonly || !arg )
	{
        return 0;
	}

    if( appendToParent )
	{
        return parent->appendChild( arg);
	}

    if( !arg->prefix.IsEmpty() )  
	{
        // node has a namespace
        CDomNodePrivate* n = namedItemNS( arg->namespaceURI, arg->name );
        // We take a reference
        arg->m_ulRefCount++;
        map.insert( std::make_pair( arg->nodeName(), arg ) );
        return n;
    } 
	else 
	{
        // ### check the following code if it is ok
        return setNamedItem( arg );
    }
}

//------------------------------------------------------------------------------
CDomNodePrivate* CDomNamedNodeMapPrivate::removeNamedItem( const nsCodeQOR::CUCS2String& name )
{
    if( readonly )
	{
        return 0;
	}

    CDomNodePrivate* p = namedItem( name );
    if( p == 0 )
	{
        return 0;
	}

    if( appendToParent )
	{
        return parent->removeChild( p );
	}

    map.erase( map.find( p->nodeName() ) );
    // We took a reference, so we have to free one here
    p->m_ulRefCount--;
    return p;
}

//------------------------------------------------------------------------------
CDomNodePrivate* CDomNamedNodeMapPrivate::item( int index ) const
{
    if( (unsigned int)index >= length() )
	{
        return 0;
	}
	std::map< nsCodeQOR::CUCS2String, CDomNodePrivate* >::const_iterator it = map.begin();
	while( index > 0 )
	{
		++it;
		--index;
	}
	return it->second;
}

// ### Qt 5: convert all length/size() functions in QDom to use int instead of uint.
unsigned int CDomNamedNodeMapPrivate::length() const
{
    return map.size();
}

//------------------------------------------------------------------------------
bool CDomNamedNodeMapPrivate::contains( const nsCodeQOR::CUCS2String& name ) const
{
    return map.find( name ) != map.end();
}

//------------------------------------------------------------------------------
bool CDomNamedNodeMapPrivate::containsNS( const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String & localName ) const
{
    return namedItemNS( nsURI, localName ) != 0;
}


#define IMPL ((CDomNamedNodeMapPrivate*)impl)

/*!
    \class CDomNamedNodeMap
    \reentrant
    \brief The CDomNamedNodeMap class contains a collection of nodes
    that can be accessed by name.

    \inmodule QtXml
    \ingroup xml-tools

    Note that CDomNamedNodeMap does not inherit from CDomNodeList.
    QDomNamedNodeMaps do not provide any specific node ordering.
    Although nodes in a CDomNamedNodeMap may be accessed by an ordinal
    index, this is simply to allow a convenient enumeration of the
    contents of a CDomNamedNodeMap, and does not imply that the DOM
    specifies an ordering of the nodes.

    The CDomNamedNodeMap is used in three places:
    \list 1
    \i CDomDocumentType::entities() returns a map of all entities
        described in the DTD.
    \i CDomDocumentType::notations() returns a map of all notations
        described in the DTD.
    \i CDomNode::attributes() returns a map of all attributes of an
        element.
    \endlist

    Items in the map are identified by the name which CDomNode::name()
    returns. Nodes are retrieved using namedItem(), namedItemNS() or
    item(). New nodes are inserted with setNamedItem() or
    setNamedItemNS() and removed with removeNamedItem() or
    removeNamedItemNS(). Use contains() to see if an item with the
    given name is in the named node map. The number of items is
    returned by length().

    Terminology: in this class we use "item" and "node"
    interchangeably.
*/

/*!
    Constructs an empty named node map.
*/
CDomNamedNodeMap::CDomNamedNodeMap()
{
    impl = 0;
}

/*!
    Constructs a copy of \a n.
*/
CDomNamedNodeMap::CDomNamedNodeMap(const CDomNamedNodeMap &n)
{
    impl = n.impl;
    if (impl)
        impl->m_ulRefCount++;
}

CDomNamedNodeMap::CDomNamedNodeMap(CDomNamedNodeMapPrivate *n)
{
    impl = n;
    if (impl)
	{
        impl->m_ulRefCount++;
	}
}

/*!
    Assigns \a n to this named node map.
*/
CDomNamedNodeMap& CDomNamedNodeMap::operator=(const CDomNamedNodeMap &n)
{
    if (n.impl)
	{
        n.impl->m_ulRefCount++;
	}

    if (impl && !--(impl->m_ulRefCount) )
	{
        delete impl;
	}
    impl = n.impl;
    return *this;
}

/*!
    Returns true if \a n and this named node map are equal; otherwise
    returns false.
*/
bool CDomNamedNodeMap::operator== (const CDomNamedNodeMap& n) const
{
    return (impl == n.impl);
}

/*!
    Returns true if \a n and this named node map are not equal;
    otherwise returns false.
*/
bool CDomNamedNodeMap::operator!= (const CDomNamedNodeMap& n) const
{
    return (impl != n.impl);
}

/*!
    Destroys the object and frees its resources.
*/
CDomNamedNodeMap::~CDomNamedNodeMap()
{
    if (impl && ! --(impl->m_ulRefCount) )
	{
        delete impl;
	}
}

/*!
    Returns the node called \a name.

    If the named node map does not contain such a node, a \link
    CDomNode::isNull() null node\endlink is returned. A node's name is
    the name returned by CDomNode::nodeName().

    \sa setNamedItem() namedItemNS()
*/
CDomNode CDomNamedNodeMap::namedItem(const nsCodeQOR::CUCS2String& name) const
{
    if (!impl)
        return CDomNode();
    return CDomNode(((CDomNamedNodeMapPrivate*)impl)->namedItem(name));
}

/*!
    Inserts the node \a newNode into the named node map. The name used
    by the map is the node name of \a newNode as returned by
    CDomNode::nodeName().

    If the new node replaces an existing node, i.e. the map contains a
    node with the same name, the replaced node is returned.

    \sa namedItem() removeNamedItem() setNamedItemNS()
*/
CDomNode CDomNamedNodeMap::setNamedItem(const CDomNode& newNode)
{
    if (!impl)
        return CDomNode();
    return CDomNode(((CDomNamedNodeMapPrivate*)impl)->setNamedItem((CDomNodePrivate*)newNode.impl));
}

/*!
    Removes the node called \a name from the map.

    The function returns the removed node or a \link
    CDomNode::isNull() null node\endlink if the map did not contain a
    node called \a name.

    \sa setNamedItem() namedItem() removeNamedItemNS()
*/
CDomNode CDomNamedNodeMap::removeNamedItem(const nsCodeQOR::CUCS2String& name)
{
    if (!impl)
        return CDomNode();
    return CDomNode(((CDomNamedNodeMapPrivate*)impl)->removeNamedItem(name));
}

/*!
    Retrieves the node at position \a index.

    This can be used to iterate over the map. Note that the nodes in
    the map are ordered arbitrarily.

    \sa length()
*/
CDomNode CDomNamedNodeMap::item(int index) const
{
    if (!impl)
        return CDomNode();
    return CDomNode(((CDomNamedNodeMapPrivate*)impl)->item(index));
}

/*!
    Returns the node associated with the local name \a localName and
    the namespace URI \a nsURI.

    If the map does not contain such a node, a \link
    CDomNode::isNull() null node\endlink is returned.

    \sa setNamedItemNS() namedItem()
*/
CDomNode CDomNamedNodeMap::namedItemNS(const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String& localName) const
{
    if (!impl)
        return CDomNode();
    return CDomNode(((CDomNamedNodeMapPrivate*)impl)->namedItemNS(nsURI, localName));
}

/*!
    Inserts the node \a newNode in the map. If a node with the same
    namespace URI and the same local name already exists in the map,
    it is replaced by \a newNode. If the new node replaces an existing
    node, the replaced node is returned.

    \sa namedItemNS() removeNamedItemNS() setNamedItem()
*/
CDomNode CDomNamedNodeMap::setNamedItemNS(const CDomNode& newNode)
{
    if (!impl)
        return CDomNode();
    return CDomNode(((CDomNamedNodeMapPrivate*)impl)->setNamedItemNS((CDomNodePrivate*)newNode.impl));
}

/*!
    Removes the node with the local name \a localName and the
    namespace URI \a nsURI from the map.

    The function returns the removed node or a \link
    CDomNode::isNull() null node\endlink if the map did not contain a
    node with the local name \a localName and the namespace URI \a
    nsURI.

    \sa setNamedItemNS() namedItemNS() removeNamedItem()
*/
CDomNode CDomNamedNodeMap::removeNamedItemNS(const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String& localName)
{
    if (!impl)
        return CDomNode();
    CDomNodePrivate *n = ((CDomNamedNodeMapPrivate*)impl)->namedItemNS(nsURI, localName);
    if (!n)
        return CDomNode();
    return CDomNode(((CDomNamedNodeMapPrivate*)impl)->removeNamedItem(n->name));
}

/*!
    Returns the number of nodes in the map.

    \sa item()
*/
unsigned int CDomNamedNodeMap::length() const
{
    if (!impl)
        return 0;
    return ((CDomNamedNodeMapPrivate*)impl)->length();
}

/*!
    \fn bool CDomNamedNodeMap::isEmpty() const

    Returns true if the map is empty; otherwise returns false. This function is
    provided for Qt API consistency.
*/

/*!
    \fn int CDomNamedNodeMap::count() const

    This function is provided for Qt API consistency. It is equivalent to length().
*/

/*!
    \fn int CDomNamedNodeMap::size() const

    This function is provided for Qt API consistency. It is equivalent to length().
*/

/*!
    Returns true if the map contains a node called \a name; otherwise
    returns false.

    \bold{Note:} This function does not take the presence of namespaces into account.
    Use namedItemNS() to test whether the map contains a node with a specific namespace
    URI and name.
*/
bool CDomNamedNodeMap::contains(const nsCodeQOR::CUCS2String& name) const
{
    if (!impl)
        return false;
    return ((CDomNamedNodeMapPrivate*)impl)->contains(name);
}



/**************************************************************
 *
 * CDomDocumentTypePrivate
 *
 **************************************************************/

//------------------------------------------------------------------------------
CDomDocumentTypePrivate::CDomDocumentTypePrivate( CDomDocumentPrivate* doc, CDomNodePrivate* parent ) : CDomNodePrivate( doc, parent )
{
    init();
}

//------------------------------------------------------------------------------
CDomDocumentTypePrivate::CDomDocumentTypePrivate( CDomDocumentTypePrivate* n, bool deep ) : CDomNodePrivate( n, deep )
{
    init();
    // Refill the maps with our new children
    CDomNodePrivate* p = first;
    while( p ) 
	{
        if( p->isEntity() )
		{
            // Don't use normal insert function since we would create infinite recursion
            entities->map.insert( std::make_pair( p->nodeName(), p ) );
		}
        if( p->isNotation() )
		{
            // Don't use normal insert function since we would create infinite recursion
            notations->map.insert( std::make_pair( p->nodeName(), p ) );
		}
        p = p->next;
    }
}

//------------------------------------------------------------------------------
CDomDocumentTypePrivate::~CDomDocumentTypePrivate()
{
    if( ! ( --( entities->m_ulRefCount ) ) )
	{
        delete entities;
	}
    if( ! ( --( notations->m_ulRefCount ) ) )
	{
        delete notations;
	}
}

//------------------------------------------------------------------------------
void CDomDocumentTypePrivate::init()
{
    entities = new CDomNamedNodeMapPrivate(this);
    try 
	{
        notations = new CDomNamedNodeMapPrivate(this);
        publicId.Clear();
        systemId.Clear();
        internalSubset.Clear();

        entities->setAppendToParent( true );
        notations->setAppendToParent( true );
    } 
	catch( ... )
	{
        delete entities;
        __QCMP_RETHROW;
    }
}

//------------------------------------------------------------------------------
CDomNodePrivate* CDomDocumentTypePrivate::cloneNode( bool deep )
{
    CDomNodePrivate* p = new CDomDocumentTypePrivate( this, deep );
    // We are not interested in this node
    p->m_ulRefCount--;
    return p;
}

//------------------------------------------------------------------------------
CDomNodePrivate* CDomDocumentTypePrivate::insertBefore( CDomNodePrivate* newChild, CDomNodePrivate* refChild )
{
    // Call the original implementation
    CDomNodePrivate* p = CDomNodePrivate::insertBefore( newChild, refChild );
    // Update the maps
    if( p && p->isEntity() )
	{
        entities->map.insert(std::make_pair( p->nodeName(), p ) );
	}
    else if( p && p->isNotation() )
	{
        notations->map.insert( std::make_pair( p->nodeName(), p ) );
	}

    return p;
}

//------------------------------------------------------------------------------
CDomNodePrivate* CDomDocumentTypePrivate::insertAfter( CDomNodePrivate* newChild, CDomNodePrivate* refChild )
{
    // Call the original implementation
    CDomNodePrivate* p = CDomNodePrivate::insertAfter( newChild, refChild );
    // Update the maps
    if( p && p->isEntity() )
	{
        entities->map.insert( std::make_pair( p->nodeName(), p ) );
	}
    else if( p && p->isNotation() )
	{
        notations->map.insert( std::make_pair( p->nodeName(), p ) );
	}

    return p;
}

//------------------------------------------------------------------------------
CDomNodePrivate* CDomDocumentTypePrivate::replaceChild( CDomNodePrivate* newChild, CDomNodePrivate* oldChild )
{
    // Call the origianl implementation
    CDomNodePrivate* p = CDomNodePrivate::replaceChild( newChild, oldChild );
    // Update the maps
    if( p ) 
	{
        if( oldChild && oldChild->isEntity() )
		{
            entities->map.erase( entities->map.find( oldChild->nodeName() ) );
		}
        else if( oldChild && oldChild->isNotation() )
		{
            notations->map.erase( notations->map.find( oldChild->nodeName() ) );
		}

        if( p->isEntity() )
		{
            entities->map.insert( std::make_pair( p->nodeName(), p ) );
		}
        else if( p->isNotation() )
		{
            notations->map.insert( std::make_pair( p->nodeName(), p ) );
		}
    }

    return p;
}

//------------------------------------------------------------------------------
CDomNodePrivate* CDomDocumentTypePrivate::removeChild( CDomNodePrivate* oldChild )
{
    // Call the origianl implementation
    CDomNodePrivate* p = CDomNodePrivate::removeChild( oldChild );
    // Update the maps
    if( p && p->isEntity() )
	{
        entities->map.erase( entities->map.find( p->nodeName() ) );
	}
    else if( p && p->isNotation() )
	{
        notations->map.erase( entities->map.find(p ->nodeName() ) );
	}

    return p;
}

//------------------------------------------------------------------------------
CDomNodePrivate* CDomDocumentTypePrivate::appendChild( CDomNodePrivate* newChild )
{
    return insertAfter( newChild, 0 );
}

//------------------------------------------------------------------------------
static nsCodeQOR::CUCS2String quotedValue( const nsCodeQOR::CUCS2String &data )
{
    char quote = data.Find( '\'' ) == -1 ? '\'' : '"';
    return quote + data + quote;
}

//------------------------------------------------------------------------------
/*
void CDomDocumentTypePrivate::save(CTextStream& s, int, int indent) const
{
    if (name.empty())
        return;

    s << "<!DOCTYPE " << name;

    if (!publicId.empty()) {
        s << " PUBLIC " << quotedValue(publicId);
        if (!systemId.empty()) {
            s << ' ' << quotedValue(systemId);
        }
    } else if (!systemId.empty()) {
        s << " SYSTEM " << quotedValue(systemId);
    }

    if (entities->length()>0 || notations->length()>0) 
	{
        s << " [" << std::endl;

        std::map< nsCodeQOR::CUCS2String, CDomNodePrivate* >::const_iterator it2 = notations->map.cbegin();
        for (; it2 != notations->map.cend(); ++it2)
            (*it2)->save(s, 0, indent);

        std::map< nsCodeQOR::CUCS2String, CDomNodePrivate* >::const_iterator it = entities->map.cbegin();
        for (; it != entities->map.cend(); ++it)
            (*it)->save(s, 0, indent);

        s << ']';
    }

    s << '>' << std::endl;
}
*/
/**************************************************************
 *
 * CDomDocumentType
 *
 **************************************************************/

#define IMPL ((CDomDocumentTypePrivate*)impl)

/*!
    \class CDomDocumentType
    \reentrant
    \brief The CDomDocumentType class is the representation of the DTD
    in the document tree.

    \inmodule QtXml
    \ingroup xml-tools

    The CDomDocumentType class allows read-only access to some of the
    data structures in the DTD: it can return a map of all entities()
    and notations(). In addition the function name() returns the name
    of the document type as specified in the &lt;!DOCTYPE name&gt;
    tag. This class also provides the publicId(), systemId() and
    internalSubset() functions.

    \sa CDomDocument
*/

/*!
    Creates an empty CDomDocumentType object.
*/
CDomDocumentType::CDomDocumentType() : CDomNode()
{
}

/*!
    Constructs a copy of \a n.

    The data of the copy is shared (shallow copy): modifying one node
    will also change the other. If you want to make a deep copy, use
    cloneNode().
*/
CDomDocumentType::CDomDocumentType(const CDomDocumentType& n)
    : CDomNode(n)
{
}

CDomDocumentType::CDomDocumentType(CDomDocumentTypePrivate* n)
    : CDomNode(n)
{
}

/*!
    Assigns \a n to this document type.

    The data of the copy is shared (shallow copy): modifying one node
    will also change the other. If you want to make a deep copy, use
    cloneNode().
*/
CDomDocumentType& CDomDocumentType::operator= (const CDomDocumentType& n)
{
    return (CDomDocumentType&) CDomNode::operator=(n);
}

/*!
    Returns the name of the document type as specified in the
    &lt;!DOCTYPE name&gt; tag.

    \sa nodeName()
*/
nsCodeQOR::CUCS2String CDomDocumentType::name() const
{
    if (!impl)
        return nsCodeQOR::CUCS2String();
    return ((CDomDocumentTypePrivate*)impl)->nodeName();
}

/*!
    Returns a map of all entities described in the DTD.
*/
CDomNamedNodeMap CDomDocumentType::entities() const
{
    if (!impl)
        return CDomNamedNodeMap();
    return CDomNamedNodeMap(((CDomDocumentTypePrivate*)impl)->entities);
}

/*!
    Returns a map of all notations described in the DTD.
*/
CDomNamedNodeMap CDomDocumentType::notations() const
{
    if (!impl)
        return CDomNamedNodeMap();
    return CDomNamedNodeMap(((CDomDocumentTypePrivate*)impl)->notations);
}

/*!
    Returns the public identifier of the external DTD subset or
    an empty string if there is no public identifier.

    \sa systemId() internalSubset() CDomImplementation::createDocumentType()
*/
nsCodeQOR::CUCS2String CDomDocumentType::publicId() const
{
    if (!impl)
        return nsCodeQOR::CUCS2String();
    return ((CDomDocumentTypePrivate*)impl)->publicId;
}

/*!
    Returns the system identifier of the external DTD subset or
    an empty string if there is no system identifier.

    \sa publicId() internalSubset() CDomImplementation::createDocumentType()
*/
nsCodeQOR::CUCS2String CDomDocumentType::systemId() const
{
    if (!impl)
        return nsCodeQOR::CUCS2String();
    return ((CDomDocumentTypePrivate*)impl)->systemId;
}

/*!
    Returns the internal subset of the document type or an empty
    string if there is no internal subset.

    \sa publicId() systemId()
*/
nsCodeQOR::CUCS2String CDomDocumentType::internalSubset() const
{
    if (!impl)
        return nsCodeQOR::CUCS2String();
    return ((CDomDocumentTypePrivate*)impl)->internalSubset;
}

/*
    Are these needed at all? The only difference when removing these
    two methods in all subclasses is that we'd get a different type
    for null nodes.
*/

/*!
    \fn CDomNode::NodeType CDomDocumentType::nodeType() const

    Returns \c DocumentTypeNode.

    \sa isDocumentType() CDomNode::toDocumentType()
*/



/**************************************************************
 *
 * CDomDocumentFragmentPrivate
 *
 **************************************************************/

CDomDocumentFragmentPrivate::CDomDocumentFragmentPrivate(CDomDocumentPrivate* doc, CDomNodePrivate* parent)
    : CDomNodePrivate(doc, parent)
{
    name = nsCodeQOR::CUCS2String( _TXT( "#document-fragment" ) );
}

CDomDocumentFragmentPrivate::CDomDocumentFragmentPrivate(CDomNodePrivate* n, bool deep)
    : CDomNodePrivate(n, deep)
{
}

CDomNodePrivate* CDomDocumentFragmentPrivate::cloneNode(bool deep)
{
    CDomNodePrivate* p = new CDomDocumentFragmentPrivate(this, deep);
    // We are not interested in this node
    p->m_ulRefCount--;
    return p;
}

/**************************************************************
 *
 * CDomDocumentFragment
 *
 **************************************************************/

/*!
    \class CDomDocumentFragment
    \reentrant
    \brief The CDomDocumentFragment class is a tree of QDomNodes which is not usually a complete CDomDocument.

    \inmodule QtXml
    \ingroup xml-tools

    If you want to do complex tree operations it is useful to have a
    lightweight class to store nodes and their relations.
    CDomDocumentFragment stores a subtree of a document which does not
    necessarily represent a well-formed XML document.

    CDomDocumentFragment is also useful if you want to group several
    nodes in a list and insert them all together as children of some
    node. In these cases CDomDocumentFragment can be used as a
    temporary container for this list of children.

    The most important feature of CDomDocumentFragment is that it is
    treated in a special way by CDomNode::insertAfter(),
    CDomNode::insertBefore(), CDomNode::replaceChild() and
    CDomNode::appendChild(): instead of inserting the fragment itself, all
    the fragment's children are inserted.
*/

/*!
    Constructs an empty document fragment.
*/
CDomDocumentFragment::CDomDocumentFragment()
{
}

CDomDocumentFragment::CDomDocumentFragment(CDomDocumentFragmentPrivate* n)
    : CDomNode(n)
{
}

/*!
    Constructs a copy of \a x.

    The data of the copy is shared (shallow copy): modifying one node
    will also change the other. If you want to make a deep copy, use
    cloneNode().
*/
CDomDocumentFragment::CDomDocumentFragment(const CDomDocumentFragment& x)
    : CDomNode(x)
{
}

/*!
    Assigns \a x to this DOM document fragment.

    The data of the copy is shared (shallow copy): modifying one node
    will also change the other. If you want to make a deep copy, use
    cloneNode().
*/
CDomDocumentFragment& CDomDocumentFragment::operator= (const CDomDocumentFragment& x)
{
    return (CDomDocumentFragment&) CDomNode::operator=(x);
}

/*!
    \fn CDomNode::NodeType CDomDocumentFragment::nodeType() const

    Returns \c DocumentFragment.

    \sa isDocumentFragment() CDomNode::toDocumentFragment()
*/

/**************************************************************
 *
 * CDomCharacterDataPrivate
 *
 **************************************************************/

CDomCharacterDataPrivate::CDomCharacterDataPrivate(CDomDocumentPrivate* d, CDomNodePrivate* p,
                                                      const nsCodeQOR::CUCS2String& data)
    : CDomNodePrivate(d, p)
{
    value = data;
    name = nsCodeQOR::CUCS2String( _TXT( "#character-data" ) );
}

CDomCharacterDataPrivate::CDomCharacterDataPrivate(CDomCharacterDataPrivate* n, bool deep)
    : CDomNodePrivate(n, deep)
{
}

CDomNodePrivate* CDomCharacterDataPrivate::cloneNode(bool deep)
{
    CDomNodePrivate* p = new CDomCharacterDataPrivate(this, deep);
    // We are not interested in this node
    p->m_ulRefCount--;
    return p;
}

unsigned int CDomCharacterDataPrivate::dataLength() const
{
    return value.Len();
}

nsCodeQOR::CUCS2String CDomCharacterDataPrivate::substringData(unsigned long offset, unsigned long n) const
{
    return value.Mid( offset, n );
}

void CDomCharacterDataPrivate::insertData(unsigned long offset, const nsCodeQOR::CUCS2String& arg)
{
    value.Insert( offset, const_cast< nsCodeQOR::CUCS2String& >( arg ) );
}

void CDomCharacterDataPrivate::deleteData( unsigned long offset, unsigned long n )
{
	value.Remove( offset, n );
}

void CDomCharacterDataPrivate::replaceData(unsigned long offset, unsigned long n, const nsCodeQOR::CUCS2String& arg)
{
    value.Replace(offset, n, const_cast< nsCodeQOR::CUCS2String& >( arg ) );
}

void CDomCharacterDataPrivate::appendData(const nsCodeQOR::CUCS2String& arg)
{
    value.Append( arg );
}

/**************************************************************
 *
 * CDomCharacterData
 *
 **************************************************************/

#define IMPL ((CDomCharacterDataPrivate*)impl)

/*!
    \class CDomCharacterData
    \reentrant
    \brief The CDomCharacterData class represents a generic string in the DOM.

    \inmodule QtXml
    \ingroup xml-tools

    Character data as used in XML specifies a generic data string.
    More specialized versions of this class are CDomText, CDomComment
    and CDomCDATASection.

    The data string is set with setData() and retrieved with data().
    You can retrieve a portion of the data string using
    substringData(). Extra data can be appended with appendData(), or
    inserted with insertData(). Portions of the data string can be
    deleted with deleteData() or replaced with replaceData(). The
    length of the data string is returned by length().

    The node type of the node containing this character data is
    returned by nodeType().

    \sa CDomText CDomComment CDomCDATASection
*/

/*!
    Constructs an empty character data object.
*/
CDomCharacterData::CDomCharacterData()
{
}

/*!
    Constructs a copy of \a x.

    The data of the copy is shared (shallow copy): modifying one node
    will also change the other. If you want to make a deep copy, use
    cloneNode().
*/
CDomCharacterData::CDomCharacterData(const CDomCharacterData& x)
    : CDomNode(x)
{
}

CDomCharacterData::CDomCharacterData(CDomCharacterDataPrivate* n)
    : CDomNode(n)
{
}

/*!
    Assigns \a x to this character data.

    The data of the copy is shared (shallow copy): modifying one node
    will also change the other. If you want to make a deep copy, use
    cloneNode().
*/
CDomCharacterData& CDomCharacterData::operator= (const CDomCharacterData& x)
{
    return (CDomCharacterData&) CDomNode::operator=(x);
}

/*!
    Returns the string stored in this object.

    If the node is a \link isNull() null node\endlink, it will return
    an empty string.
*/
nsCodeQOR::CUCS2String CDomCharacterData::data() const
{
    if (!impl)
        return nsCodeQOR::CUCS2String();
    return impl->nodeValue();
}

/*!
    Sets this object's string to \a v.
*/
void CDomCharacterData::setData(const nsCodeQOR::CUCS2String& v)
{
    if (impl)
        impl->setNodeValue(v);
}

/*!
    Returns the length of the stored string.
*/
unsigned int CDomCharacterData::length() const
{
    if (impl)
        return ((CDomCharacterDataPrivate*)impl)->dataLength();
    return 0;
}

/*!
    Returns the substring of length \a count from position \a offset.
*/
nsCodeQOR::CUCS2String CDomCharacterData::substringData(unsigned long offset, unsigned long count)
{
    if (!impl)
        return nsCodeQOR::CUCS2String();
    return ((CDomCharacterDataPrivate*)impl)->substringData(offset, count);
}

/*!
    Appends the string \a arg to the stored string.
*/
void CDomCharacterData::appendData(const nsCodeQOR::CUCS2String& arg)
{
    if (impl)
        ((CDomCharacterDataPrivate*)impl)->appendData(arg);
}

/*!
    Inserts the string \a arg into the stored string at position \a offset.
*/
void CDomCharacterData::insertData(unsigned long offset, const nsCodeQOR::CUCS2String& arg)
{
    if (impl)
        ((CDomCharacterDataPrivate*)impl)->insertData(offset, arg);
}

/*!
    Deletes a substring of length \a count from position \a offset.
*/
void CDomCharacterData::deleteData(unsigned long offset, unsigned long count)
{
    if (impl)
        ((CDomCharacterDataPrivate*)impl)->deleteData(offset, count);
}

/*!
    Replaces the substring of length \a count starting at position \a
    offset with the string \a arg.
*/
void CDomCharacterData::replaceData(unsigned long offset, unsigned long count, const nsCodeQOR::CUCS2String& arg)
{
    if (impl)
        ((CDomCharacterDataPrivate*)impl)->replaceData(offset, count, arg);
}

/*!
    Returns the type of node this object refers to (i.e. \c TextNode,
    \c CDATASectionNode, \c CommentNode or \c CharacterDataNode). For
    a \link isNull() null node\endlink, returns \c CharacterDataNode.
*/
CDomNode::NodeType CDomCharacterData::nodeType() const
{
    if (!impl)
        return CharacterDataNode;
    return CDomNode::nodeType();
}



/**************************************************************
 *
 * CDomAttrPrivate
 *
 **************************************************************/

CDomAttrPrivate::CDomAttrPrivate(CDomDocumentPrivate* d, CDomNodePrivate* parent, const nsCodeQOR::CUCS2String& name_)
    : CDomNodePrivate(d, parent)
{
    name = name_;
    m_specified = false;
}

CDomAttrPrivate::CDomAttrPrivate(CDomDocumentPrivate* d, CDomNodePrivate* p, const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String& qName)
    : CDomNodePrivate(d, p)
{
    qt_split_namespace(prefix, name, qName, !nsURI.IsEmpty());
    namespaceURI = nsURI;
    createdWithDom1Interface = false;
    m_specified = false;
}

CDomAttrPrivate::CDomAttrPrivate(CDomAttrPrivate* n, bool deep)
    : CDomNodePrivate(n, deep)
{
    m_specified = n->specified();
}

void CDomAttrPrivate::setNodeValue(const nsCodeQOR::CUCS2String& v)
{
    value = v;
    CDomTextPrivate *t = new CDomTextPrivate(0, this, v);
    // keep the refcount balanced: appendChild() does a ref anyway.
    t->m_ulRefCount--;
    if (first) 
	{
        delete removeChild(first);
    }
    appendChild(t);
}

CDomNodePrivate* CDomAttrPrivate::cloneNode(bool deep)
{
    CDomNodePrivate* p = new CDomAttrPrivate(this, deep);
    // We are not interested in this node
    p->m_ulRefCount--;
    return p;
}

bool CDomAttrPrivate::specified() const
{
    return m_specified;
}

/* \internal
  Encode & escape \a str. Yes, it makes no sense to return a nsCodeQOR::CUCS2String,
  but is so for legacy reasons.

  Remember that content produced should be able to roundtrip with 2.11 End-of-Line Handling
  and 3.3.3 Attribute-Value Normalization.

  If \a performAVN is true, characters will be escaped to survive Attribute Value Normalization.
  If \a encodeEOLs is true, characters will be escaped to survive End-of-Line Handling.
*/
static nsCodeQOR::CUCS2String encodeText(const nsCodeQOR::CUCS2String &str,
                          CTextStream &s,
                          const bool encodeQuotes = true,
                          const bool performAVN = false,
                          const bool encodeEOLs = false)
{
	//TODO:
	/*
#ifdef QT_NO_TEXTCODEC
    Q_UNUSED(s);
#else
    const CTextCodec* const codec = s.codec();
    assert(codec);
#endif
    nsCodeQOR::CUCS2String retval(str);
    int len = retval.length();
    int i = 0;

    while (i < len) {
        const char ati(retval.at(i));

        if (ati == '<' ) {
            retval.replace(i, 1, nsCodeQOR::CUCS2String("&lt;"));
            len += 3;
            i += 4;
        } else if (encodeQuotes && (ati == '"' )) {
            retval.replace(i, 1, nsCodeQOR::CUCS2String("&quot;"));
            len += 5;
            i += 6;
        } else if (ati == '&' ) {
            retval.replace(i, 1, nsCodeQOR::CUCS2String("&amp;"));
            len += 4;
            i += 5;
        } 
		else if (ati == '>' && i >= 2 && retval[i - 1] == ']' && retval[i - 2] == ']' ) 
		{
            retval.replace(i, 1, nsCodeQOR::CUCS2String("&gt;"));
            len += 3;
            i += 4;
        } else if (performAVN &&
                   (ati == 0xA ||
                    ati == 0xD ||
                    ati == 0x9 )) {
            const nsCodeQOR::CUCS2String replacement(nsCodeQOR::CUCS2String("&#x") + nsCodeQOR::CUCS2String::number(ati.unicode(), 16) + ';' );
            retval.replace(i, 1, replacement);
            i += replacement.length();
            len += replacement.length() - 1;
        } 
		else if (encodeEOLs && ati == 0xD ) 
		{
            retval.replace(i, 1, nsCodeQOR::CUCS2String("&#xd;")); // Replace a single 0xD with a ref for 0xD
            len += 4;
            i += 5;
        } else {
#ifndef QT_NO_TEXTCODEC
            if(codec->canEncode(ati))
                ++i;
            else
#endif
            {
                // We have to use a character reference to get it through.
                const unsigned short codepoint(ati.unicode());
                const nsCodeQOR::CUCS2String replacement(nsCodeQOR::CUCS2String("&#x") + nsCodeQOR::CUCS2String::number(codepoint, 16) + ';' );
                retval.replace(i, 1, replacement);
                i += replacement.length();
                len += replacement.length() - 1;
            }
        }
    }

    return retval;
	*/
	return nsCodeQOR::CUCS2String( _TXT( "" ) );
}

/*
void CDomAttrPrivate::save(CTextStream& s, int, int) const
{
    if (namespaceURI.empty()) 
	{
        s << name << "=\"" << encodeText(value, s, true, true) << '\"';
    } 
	else 
	{
        s << prefix << ':' << name << "=\"" << encodeText(value, s, true, true) << '\"';
        / This is a fix for 138243, as good as it gets.
         
          CDomElementPrivate::save() output a namespace declaration if
          the element is in a namespace, no matter what. This function do as well, meaning
          that we get two identical namespace declaration if we don't have the if-
          statement below.
         
          This doesn't work when the parent element has the same prefix as us but
          a different namespace. However, this can only occur by the user modifying the element,
          and we don't do fixups by that anyway, and hence it's the user responsibility to not
          arrive in those situations. /
        if( !ownerNode || ownerNode->prefix != prefix ) 
		{
            s << " xmlns:" << prefix << "=\"" << encodeText(namespaceURI, s, true, true) << '\"';
        }
    }
}
*/
/**************************************************************
 *
 * CDomAttr
 *
 **************************************************************/

#define IMPL ((CDomAttrPrivate*)impl)

/*!
    \class CDomAttr
    \reentrant
    \brief The CDomAttr class represents one attribute of a CDomElement.

    \inmodule QtXml
    \ingroup xml-tools

    For example, the following piece of XML produces an element with
    no children, but two attributes:

    \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 7

    You can access the attributes of an element with code like this:

    \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 8

    This example also shows that changing an attribute received from
    an element changes the attribute of the element. If you do not
    want to change the value of the element's attribute you must
    use cloneNode() to get an independent copy of the attribute.

    CDomAttr can return the name() and value() of an attribute. An
    attribute's value is set with setValue(). If specified() returns
    true the value was set with setValue(). The node this
    attribute is attached to (if any) is returned by ownerElement().

    For further information about the Document Object Model see
    \l{http://www.w3.org/TR/REC-DOM-Level-1/} and
    \l{http://www.w3.org/TR/DOM-Level-2-Core/}.
    For a more general introduction of the DOM implementation see the
    CDomDocument documentation.
*/


/*!
    Constructs an empty attribute.
*/
CDomAttr::CDomAttr()
{
}

/*!
    Constructs a copy of \a x.

    The data of the copy is shared (shallow copy): modifying one node
    will also change the other. If you want to make a deep copy, use
    cloneNode().
*/
CDomAttr::CDomAttr( const CDomAttr& x ) : CDomNode( x )
{
}

CDomAttr::CDomAttr( CDomAttrPrivate* n ) : CDomNode( n )
{
}

/*!
    Assigns \a x to this DOM attribute.

    The data of the copy is shared (shallow copy): modifying one node
    will also change the other. If you want to make a deep copy, use
    cloneNode().
*/
CDomAttr& CDomAttr::operator= (const CDomAttr& x)
{
    return (CDomAttr&) CDomNode::operator=(x);
}

/*!
    Returns the attribute's name.
*/
nsCodeQOR::CUCS2String CDomAttr::name() const
{
    if (!impl)
        return nsCodeQOR::CUCS2String();
    return impl->nodeName();
}

/*!
    Returns true if the attribute has been set by the user with setValue().
    Returns false if the value hasn't been specified or set.

    \sa setValue()
*/
bool CDomAttr::specified() const
{
    if (!impl)
        return false;
    return ((CDomAttrPrivate*)impl)->specified();
}

/*!
    Returns the element node this attribute is attached to or a \link
    CDomNode::isNull() null node\endlink if this attribute is not
    attached to any element.
*/
CDomElement CDomAttr::ownerElement() const
{
    assert(impl->parent());
    if (!impl->parent()->isElement())
        return CDomElement();
    return CDomElement((CDomElementPrivate*)(impl->parent()));
}

/*!
    Returns the value of the attribute or an empty string if the
    attribute has not been specified.

    \sa specified() setValue()
*/
nsCodeQOR::CUCS2String CDomAttr::value() const
{
    if (!impl)
        return nsCodeQOR::CUCS2String();
    return impl->nodeValue();
}

/*!
    Sets the attribute's value to \a v.

    \sa value()
*/
void CDomAttr::setValue(const nsCodeQOR::CUCS2String& v)
{
    if (!impl)
        return;
    impl->setNodeValue(v);
    ((CDomAttrPrivate*)impl)->m_specified = true;
}

/*!
    \fn CDomNode::NodeType CDomAttr::nodeType() const

    Returns \link CDomNode::NodeType AttributeNode\endlink.
*/



/**************************************************************
 *
 * CDomElementPrivate
 *
 **************************************************************/

CDomElementPrivate::CDomElementPrivate(CDomDocumentPrivate* d, CDomNodePrivate* p,
                                          const nsCodeQOR::CUCS2String& tagname)
    : CDomNodePrivate(d, p)
{
    name = tagname;
    m_attr = new CDomNamedNodeMapPrivate(this);
}

CDomElementPrivate::CDomElementPrivate(CDomDocumentPrivate* d, CDomNodePrivate* p, const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String& qName) : CDomNodePrivate(d, p)
{
    qt_split_namespace(prefix, name, qName, !nsURI.IsEmpty());
    namespaceURI = nsURI;
    createdWithDom1Interface = false;
    m_attr = new CDomNamedNodeMapPrivate(this);
}

CDomElementPrivate::CDomElementPrivate(CDomElementPrivate* n, bool deep) : CDomNodePrivate(n, deep)
{
    m_attr = n->m_attr->clone(this);
    // Reference is down to 0, so we set it to 1 here.
    m_attr->m_ulRefCount++;
}

CDomElementPrivate::~CDomElementPrivate()
{
    if( !( --( m_attr->m_ulRefCount ) ) )
	{
        delete m_attr;
	}
}

CDomNodePrivate* CDomElementPrivate::cloneNode(bool deep)
{
    CDomNodePrivate* p = new CDomElementPrivate(this, deep);
    // We are not interested in this node
    p->m_ulRefCount--;
    return p;
}

nsCodeQOR::CUCS2String CDomElementPrivate::attribute(const nsCodeQOR::CUCS2String& name_, const nsCodeQOR::CUCS2String& defValue) const
{
    CDomNodePrivate* n = m_attr->namedItem(name_);
    if (!n)
	{
        return defValue;
	}

    return n->nodeValue();
}


nsCodeQOR::CUCS2String CDomElementPrivate::attributeNS(const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String& localName, const nsCodeQOR::CUCS2String& defValue) const
{
    CDomNodePrivate* n = m_attr->namedItemNS(nsURI, localName);
    if (!n)
	{
        return defValue;
	}

    return n->nodeValue();
}

void CDomElementPrivate::setAttribute(const nsCodeQOR::CUCS2String& aname, const nsCodeQOR::CUCS2String& newValue)
{
    CDomNodePrivate* n = m_attr->namedItem(aname);
    if (!n) 
	{
        n = new CDomAttrPrivate(ownerDocument(), this, aname);
        n->setNodeValue(newValue);

        // Referencing is done by the map, so we set the reference counter back
        // to 0 here. This is ok since we created the CDomAttrPrivate.
        n->m_ulRefCount--;
        m_attr->setNamedItem(n);
    } 
	else 
	{
        n->setNodeValue(newValue);
    }
}

void CDomElementPrivate::setAttributeNS(const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String& qName, const nsCodeQOR::CUCS2String& newValue)
{
    nsCodeQOR::CUCS2String prefix, localName;
    qt_split_namespace(prefix, localName, qName, true);
    CDomNodePrivate* n = m_attr->namedItemNS(nsURI, localName);
    if (!n) 
	{
        n = new CDomAttrPrivate(ownerDocument(), this, nsURI, qName);
        n->setNodeValue(newValue);

        // Referencing is done by the map, so we set the reference counter back
        // to 0 here. This is ok since we created the CDomAttrPrivate.
        n->m_ulRefCount--;
        m_attr->setNamedItem(n);
    } 
	else 
	{
        n->setNodeValue(newValue);
        n->prefix = prefix;
    }
}

void CDomElementPrivate::removeAttribute( const nsCodeQOR::CUCS2String& aname )
{
    CDomNodePrivate* p = m_attr->removeNamedItem( aname );
    if( p && p->m_ulRefCount == 0 )
	{
        delete p;
	}
}

CDomAttrPrivate* CDomElementPrivate::attributeNode(const nsCodeQOR::CUCS2String& aname)
{
    return (CDomAttrPrivate*)m_attr->namedItem(aname);
}

CDomAttrPrivate* CDomElementPrivate::attributeNodeNS(const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String& localName)
{
    return (CDomAttrPrivate*)m_attr->namedItemNS(nsURI, localName);
}

CDomAttrPrivate* CDomElementPrivate::setAttributeNode(CDomAttrPrivate* newAttr)
{
    CDomNodePrivate* n = m_attr->namedItem(newAttr->nodeName());

    // Referencing is done by the maps
    m_attr->setNamedItem(newAttr);

    newAttr->setParent(this);

    return (CDomAttrPrivate*)n;
}

CDomAttrPrivate* CDomElementPrivate::setAttributeNodeNS(CDomAttrPrivate* newAttr)
{
    CDomNodePrivate* n = 0;
    if (!newAttr->prefix.IsEmpty())
        n = m_attr->namedItemNS(newAttr->namespaceURI, newAttr->name);

    // Referencing is done by the maps
    m_attr->setNamedItem(newAttr);

    return (CDomAttrPrivate*)n;
}

CDomAttrPrivate* CDomElementPrivate::removeAttributeNode(CDomAttrPrivate* oldAttr)
{
    return (CDomAttrPrivate*)m_attr->removeNamedItem(oldAttr->nodeName());
}

bool CDomElementPrivate::hasAttribute(const nsCodeQOR::CUCS2String& aname)
{
    return m_attr->contains(aname);
}

bool CDomElementPrivate::hasAttributeNS(const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String& localName)
{
    return m_attr->containsNS(nsURI, localName);
}

nsCodeQOR::CUCS2String CDomElementPrivate::text()
{
    nsCodeQOR::CUCS2String t(nsCodeQOR::CUCS2String( _TXT( "" ) ) );

    CDomNodePrivate* p = first;
    while( p ) 
	{
        if( p->isText() || p->isCDATASection() )
		{
            t.Append( p->nodeValue() );
		}
        else if( p->isElement() )
		{
            t.Append( ( (CDomElementPrivate*)p)->text() );
		}
        p = p->next;
    }

    return t;
}

/*
void CDomElementPrivate::save(CTextStream& s, int depth, int indent) const
{
    if (!(prev && prev->isText()))
        s << nsCodeQOR::CUCS2String(indent < 1 ? 0 : depth * indent, ' ' );

    nsCodeQOR::CUCS2String qName(name);
    nsCodeQOR::CUCS2String nsDecl(nsCodeQOR::CUCS2String(""));
    if (!namespaceURI.empty()) 
	{
        / ### Qt 5:
         
          If we still have QDom, optimize this so that we only declare namespaces that are not
          yet declared. We loose default namespace mappings, so maybe we should rather store
          the information that we get from startPrefixMapping()/endPrefixMapping() and use them.
          Modifications becomes more complex then, however.
         
          We cannot do this during the Qt 4 series because it would require too invasive changes, and
          hence possibly behavioral changes.
         /
        if (prefix.empty()) 
		{
            nsDecl = nsCodeQOR::CUCS2String(" xmlns");
        } else {
            qName = prefix + ':' + name;
            nsDecl = nsCodeQOR::CUCS2String(" xmlns:") + prefix;
        }
        nsDecl += nsCodeQOR::CUCS2String("=\"") + encodeText(namespaceURI, s) + '\"';
    }
    s << '<' << qName << nsDecl;

    QSet<nsCodeQOR::CUCS2String> outputtedPrefixes;

    // Write out attributes.
    if (!m_attr->map.empty()) 
	{
        std::map< nsCodeQOR::CUCS2String, CDomNodePrivate* >::const_iterator it = m_attr->map.cbegin();
        for (; it != m_attr->map.cend(); ++it) 
		{
            s << ' ';
            if (it.value()->namespaceURI.isNull()) {
                s << it.value()->name << "=\"" << encodeText(it.value()->value, s, true, true) << '\"';
            } else {
                s << it.value()->prefix << ':' << it.value()->name << "=\"" << encodeText(it.value()->value, s, true, true) << '\"';
                / This is a fix for 138243, as good as it gets.
                 
                  CDomElementPrivate::save() output a namespace declaration if
                  the element is in a namespace, no matter what. This function do as well, meaning
                  that we get two identical namespace declaration if we don't have the if-
                  statement below.
                 
                  This doesn't work when the parent element has the same prefix as us but
                  a different namespace. However, this can only occur by the user modifying the element,
                  and we don't do fixups by that anyway, and hence it's the user responsibility to not
                  arrive in those situations. /
                if((!it.value()->ownerNode ||
                   it.value()->ownerNode->prefix != it.value()->prefix) &&
                   !outputtedPrefixes.contains(it.value()->prefix)) {
                    s << " xmlns:" << it.value()->prefix << "=\"" << encodeText(it.value()->namespaceURI, s, true, true) << '\"';
                    outputtedPrefixes.insert(it.value()->prefix);
                }
            }
        }
    }

    if (last) {
        // has child nodes
        if (first->isText())
            s << '>';
        else {
            s << '>';

            // -1 disables new lines.
            if (indent != -1)
                s << std::endl;
        }
        CDomNodePrivate::save(s, depth + 1, indent); if (!last->isText())
            s << nsCodeQOR::CUCS2String(indent < 1 ? 0 : depth * indent, ' ' );

        s << "</" << qName << '>';
    } else {
        s << "/>";
    }
    if (!(next && next->isText())) 
	{
        // -1 disables new lines.
        if (indent != -1)
            s << std::endl;
    }
}
*/
/**************************************************************
 *
 * CDomElement
 *
 **************************************************************/

#define IMPL ((CDomElementPrivate*)impl)

/*!
    \class CDomElement
    \reentrant
    \brief The CDomElement class represents one element in the DOM tree.

    \inmodule QtXml
    \ingroup xml-tools

    Elements have a tagName() and zero or more attributes associated
    with them. The tag name can be changed with setTagName().

    Element attributes are represented by CDomAttr objects that can
    be queried using the attribute() and attributeNode() functions.
    You can set attributes with the setAttribute() and
    setAttributeNode() functions. Attributes can be removed with
    removeAttribute(). There are namespace-aware equivalents to these
    functions, i.e. setAttributeNS(), setAttributeNodeNS() and
    removeAttributeNS().

    If you want to access the text of a node use text(), e.g.
    \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 9
    The text() function operates recursively to find the text (since
    not all elements contain text). If you want to find all the text
    in all of a node's children, iterate over the children looking for
    CDomText nodes, e.g.
    \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 10
    Note that we attempt to convert each node to a text node and use
    text() rather than using firstChild().toText().data() or
    n.toText().data() directly on the node, because the node may not
    be a text element.

    You can get a list of all the decendents of an element which have
    a specified tag name with elementsByTagName() or
    elementsByTagNameNS().

    To browse the elements of a dom document use firstChildElement(), lastChildElement(),
    nextSiblingElement() and previousSiblingElement(). For example, to iterate over all
    child elements called "entry" in a root element called "database", you can use:
    \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 11

    For further information about the Document Object Model see
    \l{http://www.w3.org/TR/REC-DOM-Level-1/}{Level 1} and
    \l{http://www.w3.org/TR/DOM-Level-2-Core/}{Level 2 Core}.
    For a more general introduction of the DOM implementation see the
    CDomDocument documentation.
*/

/*!
    Constructs an empty element. Use the CDomDocument::createElement()
    function to construct elements with content.
*/
CDomElement::CDomElement()
    : CDomNode()
{
}

/*!
    Constructs a copy of \a x.

    The data of the copy is shared (shallow copy): modifying one node
    will also change the other. If you want to make a deep copy, use
    cloneNode().
*/
CDomElement::CDomElement(const CDomElement& x)
    : CDomNode(x)
{
}

CDomElement::CDomElement(CDomElementPrivate* n)
    : CDomNode(n)
{
}

/*!
    Assigns \a x to this DOM element.

    The data of the copy is shared (shallow copy): modifying one node
    will also change the other. If you want to make a deep copy, use
    cloneNode().
*/
CDomElement& CDomElement::operator= (const CDomElement& x)
{
    return (CDomElement&) CDomNode::operator=(x);
}

/*!
    \fn CDomNode::NodeType CDomElement::nodeType() const

    Returns \c ElementNode.
*/

/*!
    Sets this element's tag name to \a name.

    \sa tagName()
*/
void CDomElement::setTagName(const nsCodeQOR::CUCS2String& name)
{
    if (impl)
        impl->name = name;
}

/*!
    Returns the tag name of this element. For an XML element like this:

    \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 12

    the tagname would return "img".

    \sa setTagName()
*/
nsCodeQOR::CUCS2String CDomElement::tagName() const
{
    if (!impl)
        return nsCodeQOR::CUCS2String();
    return impl->nodeName();
}


/*!
    Returns a CDomNamedNodeMap containing all this element's attributes.

    \sa attribute() setAttribute() attributeNode() setAttributeNode()
*/
CDomNamedNodeMap CDomElement::attributes() const
{
    if (!impl)
        return CDomNamedNodeMap();
    return CDomNamedNodeMap(((CDomElementPrivate*)impl)->attributes());
}

/*!
    Returns the attribute called \a name. If the attribute does not
    exist \a defValue is returned.

    \sa setAttribute() attributeNode() setAttributeNode() attributeNS()
*/
nsCodeQOR::CUCS2String CDomElement::attribute(const nsCodeQOR::CUCS2String& name, const nsCodeQOR::CUCS2String& defValue) const
{
    if (!impl)
        return defValue;
    return ((CDomElementPrivate*)impl)->attribute(name, defValue);
}

/*!
    Adds an attribute called \a name with value \a value. If an
    attribute with the same name exists, its value is replaced by \a
    value.

    \sa attribute() setAttributeNode() setAttributeNS()
*/
void CDomElement::setAttribute(const nsCodeQOR::CUCS2String& name, const nsCodeQOR::CUCS2String& value)
{
    if (!impl)
        return;
    ((CDomElementPrivate*)impl)->setAttribute(name, value);
}

/*!
  \fn void CDomElement::setAttribute(const nsCodeQOR::CUCS2String& name, int value)

    \overload
    The number is formatted according to the current locale.
*/

/*!
  \fn void CDomElement::setAttribute(const nsCodeQOR::CUCS2String& name, uint value)

    \overload
    The number is formatted according to the current locale.
*/

/*!
    \overload

    The number is formatted according to the current locale.
*/
void CDomElement::setAttribute(const nsCodeQOR::CUCS2String& name, Cmp_long_long value)
{
	//TODO:
	/*
    if (!impl)
        return;
    nsCodeQOR::CUCS2String x;
    x.setNum(value);
    ((CDomElementPrivate*)impl)->setAttribute(name, x);
	*/
}

/*!
    \overload

    The number is formatted according to the current locale.
*/
void CDomElement::setAttribute(const nsCodeQOR::CUCS2String& name, Cmp_unsigned_long_long value)
{
	//TODO:
	/*
    if (!impl)
        return;
    nsCodeQOR::CUCS2String x;
    x.setNum(value);
    ((CDomElementPrivate*)impl)->setAttribute(name, x);
	*/
}

/*!
    \overload

    The number is formatted according to the current locale.
*/
void CDomElement::setAttribute(const nsCodeQOR::CUCS2String& name, float value)
{
	//TODO:
	/*
    if (!impl)
        return;
    nsCodeQOR::CUCS2String x;
    x.setNum(value);
    ((CDomElementPrivate*)impl)->setAttribute(name, x);
	*/
}

/*!
    \overload

    The number is formatted according to the current locale.
*/
void CDomElement::setAttribute(const nsCodeQOR::CUCS2String& name, double value)
{
	//TODO:
	/*
    if (!impl)
        return;
    nsCodeQOR::CUCS2String x;
    char buf[256];
    int count = qsnprintf(buf, sizeof(buf), "%.16g", value);
    if (count > 0)
        x = nsCodeQOR::CUCS2String(buf, count);
    else
        x.setNum(value); // Fallback
    ((CDomElementPrivate*)impl)->setAttribute(name, x);
	*/
}

/*!
    Removes the attribute called name \a name from this element.

    \sa setAttribute() attribute() removeAttributeNS()
*/
void CDomElement::removeAttribute(const nsCodeQOR::CUCS2String& name)
{
    if (!impl)
        return;
    ((CDomElementPrivate*)impl)->removeAttribute(name);
}

/*!
    Returns the CDomAttr object that corresponds to the attribute
    called \a name. If no such attribute exists a \link
    CDomNode::isNull() null attribute\endlink is returned.

    \sa setAttributeNode() attribute() setAttribute() attributeNodeNS()
*/
CDomAttr CDomElement::attributeNode(const nsCodeQOR::CUCS2String& name)
{
    if (!impl)
        return CDomAttr();
    return CDomAttr(((CDomElementPrivate*)impl)->attributeNode(name));
}

/*!
    Adds the attribute \a newAttr to this element.

    If the element has another attribute that has the same name as \a
    newAttr, this function replaces that attribute and returns it;
    otherwise the function returns a \link CDomNode::isNull() null
    attribute\endlink.

    \sa attributeNode() setAttribute() setAttributeNodeNS()
*/
CDomAttr CDomElement::setAttributeNode(const CDomAttr& newAttr)
{
    if (!impl)
        return CDomAttr();
    return CDomAttr(((CDomElementPrivate*)impl)->setAttributeNode(((CDomAttrPrivate*)newAttr.impl)));
}

/*!
    Removes the attribute \a oldAttr from the element and returns it.

    \sa attributeNode() setAttributeNode()
*/
CDomAttr CDomElement::removeAttributeNode(const CDomAttr& oldAttr)
{
    if (!impl)
        return CDomAttr(); // ### should this return oldAttr?
    return CDomAttr(((CDomElementPrivate*)impl)->removeAttributeNode(((CDomAttrPrivate*)oldAttr.impl)));
}

/*!
  Returns a CDomNodeList containing all descendants of this element
  named \a tagname encountered during a preorder traversal of the
  element subtree with this element as its root. The order of the
  elements in the returned list is the order they are encountered
  during the preorder traversal.

  \sa elementsByTagNameNS() CDomDocument::elementsByTagName()
*/
CDomNodeList CDomElement::elementsByTagName(const nsCodeQOR::CUCS2String& tagname) const
{
    return CDomNodeList(new CDomNodeListPrivate(impl, tagname));
}

/*!
  Returns true if this element has an attribute called \a name;
  otherwise returns false.

  \bold{Note:} This function does not take the presence of namespaces
  into account.  As a result, the specified name will be tested
  against fully-qualified attribute names that include any namespace
  prefixes that may be present.

  Use hasAttributeNS() to explicitly test for attributes with specific
  namespaces and names.
*/
bool CDomElement::hasAttribute(const nsCodeQOR::CUCS2String& name) const
{
    if (!impl)
        return false;
    return ((CDomElementPrivate*)impl)->hasAttribute(name);
}

/*!
    Returns the attribute with the local name \a localName and the
    namespace URI \a nsURI. If the attribute does not exist \a
    defValue is returned.

    \sa setAttributeNS() attributeNodeNS() setAttributeNodeNS() attribute()
*/
nsCodeQOR::CUCS2String CDomElement::attributeNS(const nsCodeQOR::CUCS2String nsURI, const nsCodeQOR::CUCS2String& localName, const nsCodeQOR::CUCS2String& defValue) const
{
    if (!impl)
        return defValue;
    return ((CDomElementPrivate*)impl)->attributeNS(nsURI, localName, defValue);
}

/*!
    Adds an attribute with the qualified name \a qName and the
    namespace URI \a nsURI with the value \a value. If an attribute
    with the same local name and namespace URI exists, its prefix is
    replaced by the prefix of \a qName and its value is repaced by \a
    value.

    Although \a qName is the qualified name, the local name is used to
    decide if an existing attribute's value should be replaced.

    \sa attributeNS() setAttributeNodeNS() setAttribute()
*/
void CDomElement::setAttributeNS(const nsCodeQOR::CUCS2String nsURI, const nsCodeQOR::CUCS2String& qName, const nsCodeQOR::CUCS2String& value)
{
    if (!impl)
        return;
    ((CDomElementPrivate*)impl)->setAttributeNS(nsURI, qName, value);
}

/*!
  \fn void CDomElement::setAttributeNS(const nsCodeQOR::CUCS2String nsURI, const nsCodeQOR::CUCS2String& qName, int value)

    \overload
*/

/*!
  \fn void CDomElement::setAttributeNS(const nsCodeQOR::CUCS2String nsURI, const nsCodeQOR::CUCS2String& qName, uint value)

    \overload
*/

/*!
    \overload
*/
void CDomElement::setAttributeNS(const nsCodeQOR::CUCS2String nsURI, const nsCodeQOR::CUCS2String& qName, Cmp_long_long value)
{
	//TODO:
	/*
    if (!impl)
        return;
    nsCodeQOR::CUCS2String x;
    x.setNum(value);
    ((CDomElementPrivate*)impl)->setAttributeNS(nsURI, qName, x);
	*/
}

/*!
    \overload
*/
void CDomElement::setAttributeNS(const nsCodeQOR::CUCS2String nsURI, const nsCodeQOR::CUCS2String& qName, Cmp_unsigned_long_long value)
{
	//TODO:
	/*
    if (!impl)
        return;
    nsCodeQOR::CUCS2String x;
    x.setNum(value);
    ((CDomElementPrivate*)impl)->setAttributeNS(nsURI, qName, x);
	*/
}

/*!
    \overload
*/
void CDomElement::setAttributeNS(const nsCodeQOR::CUCS2String nsURI, const nsCodeQOR::CUCS2String& qName, double value)
{
	//TODO:
	/*
    if (!impl)
        return;
    nsCodeQOR::CUCS2String x;
    x.setNum(value);
    ((CDomElementPrivate*)impl)->setAttributeNS(nsURI, qName, x);
	*/
}

/*!
    Removes the attribute with the local name \a localName and the
    namespace URI \a nsURI from this element.

    \sa setAttributeNS() attributeNS() removeAttribute()
*/
void CDomElement::removeAttributeNS(const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String& localName)
{
    if (!impl)
        return;
    CDomNodePrivate *n = ((CDomElementPrivate*)impl)->attributeNodeNS(nsURI, localName);
    if (!n)
        return;
    ((CDomElementPrivate*)impl)->removeAttribute(n->nodeName());
}

/*!
    Returns the CDomAttr object that corresponds to the attribute
    with the local name \a localName and the namespace URI \a nsURI.
    If no such attribute exists a \l{CDomNode::isNull()}{null
    attribute} is returned.

    \sa setAttributeNode() attribute() setAttribute()
*/
CDomAttr CDomElement::attributeNodeNS(const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String& localName)
{
    if (!impl)
        return CDomAttr();
    return CDomAttr(((CDomElementPrivate*)impl)->attributeNodeNS(nsURI, localName));
}

/*!
    Adds the attribute \a newAttr to this element.

    If the element has another attribute that has the same local name
    and namespace URI as \a newAttr, this function replaces that
    attribute and returns it; otherwise the function returns a \link
    CDomNode::isNull() null attribute\endlink.

    \sa attributeNodeNS() setAttributeNS() setAttributeNode()
*/
CDomAttr CDomElement::setAttributeNodeNS(const CDomAttr& newAttr)
{
    if (!impl)
        return CDomAttr();
    return CDomAttr(((CDomElementPrivate*)impl)->setAttributeNodeNS(((CDomAttrPrivate*)newAttr.impl)));
}

/*!
  Returns a CDomNodeList containing all descendants of this element
  with local name \a localName and namespace URI \a nsURI encountered
  during a preorder traversal of the element subtree with this element
  as its root. The order of the elements in the returned list is the
  order they are encountered during the preorder traversal.

  \sa elementsByTagName() CDomDocument::elementsByTagNameNS()
*/
CDomNodeList CDomElement::elementsByTagNameNS(const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String& localName) const
{
    return CDomNodeList(new CDomNodeListPrivate(impl, nsURI, localName));
}

/*!
    Returns true if this element has an attribute with the local name
    \a localName and the namespace URI \a nsURI; otherwise returns
    false.
*/
bool CDomElement::hasAttributeNS(const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String& localName) const
{
    if (!impl)
        return false;
    return ((CDomElementPrivate*)impl)->hasAttributeNS(nsURI, localName);
}

/*!
    Returns the element's text or an empty string.

    Example:
    \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 13

    The function text() of the CDomElement for the \c{<h1>} tag,
    will return the following text:

    \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 14

    Comments are ignored by this function. It only evaluates CDomText
    and CDomCDATASection objects.
*/
nsCodeQOR::CUCS2String CDomElement::text() const
{
    if (!impl)
        return nsCodeQOR::CUCS2String();
    return ((CDomElementPrivate*)impl)->text();
}


/**************************************************************
 *
 * CDomTextPrivate
 *
 **************************************************************/

CDomTextPrivate::CDomTextPrivate(CDomDocumentPrivate* d, CDomNodePrivate* parent, const nsCodeQOR::CUCS2String& val)
    : CDomCharacterDataPrivate(d, parent, val)
{
    name = nsCodeQOR::CUCS2String( _TXT( "#text" ) );
}

CDomTextPrivate::CDomTextPrivate(CDomTextPrivate* n, bool deep)
    : CDomCharacterDataPrivate(n, deep)
{
}

CDomNodePrivate* CDomTextPrivate::cloneNode(bool deep)
{
    CDomNodePrivate* p = new CDomTextPrivate(this, deep);
    // We are not interested in this node
    p->m_ulRefCount--;
    return p;
}

CDomTextPrivate* CDomTextPrivate::splitText(int offset)
{
	//TODO:
	/*
    if (!parent()) 
	{
        //TODO:qWarning("CDomText::splitText  The node has no parent. So I can not split");
        return 0;
    }

    CDomTextPrivate* t = new CDomTextPrivate(ownerDocument(), 0, value.mid(offset));
    value.truncate(offset);

    parent()->insertAfter(t, this);

    return t;
	*/
	return 0;
}

/*
void CDomTextPrivate::save(CTextStream& s, int, int) const
{
    CDomTextPrivate *that = const_cast<CDomTextPrivate*>(this);
    s << encodeText(value, s, !(that->parent() && that->parent()->isElement()), false, true);
}
*/
/**************************************************************
 *
 * CDomText
 *
 **************************************************************/

#define IMPL ((CDomTextPrivate*)impl)

/*!
    \class CDomText
    \reentrant
    \brief The CDomText class represents text data in the parsed XML document.

    \inmodule QtXml
    \ingroup xml-tools

    You can split the text in a CDomText object over two CDomText
    objecs with splitText().

    For further information about the Document Object Model see
    \l{http://www.w3.org/TR/REC-DOM-Level-1/}{Level 1} and
    \l{http://www.w3.org/TR/DOM-Level-2-Core/}{Level 2 Core}.
    For a more general introduction of the DOM implementation see the
    CDomDocument documentation.
*/

/*!
    Constructs an empty CDomText object.

    To construct a CDomText with content, use CDomDocument::createTextNode().
*/
CDomText::CDomText()
    : CDomCharacterData()
{
}

/*!
    Constructs a copy of \a x.

    The data of the copy is shared (shallow copy): modifying one node
    will also change the other. If you want to make a deep copy, use
    cloneNode().
*/
CDomText::CDomText(const CDomText& x)
    : CDomCharacterData(x)
{
}

CDomText::CDomText(CDomTextPrivate* n)
    : CDomCharacterData(n)
{
}

/*!
    Assigns \a x to this DOM text.

    The data of the copy is shared (shallow copy): modifying one node
    will also change the other. If you want to make a deep copy, use
    cloneNode().
*/
CDomText& CDomText::operator= (const CDomText& x)
{
    return (CDomText&) CDomNode::operator=(x);
}

/*!
    \fn CDomNode::NodeType CDomText::nodeType() const

    Returns \c TextNode.
*/

/*!
    Splits this DOM text object into two CDomText objects. This object
    keeps its first \a offset characters and the second (newly
    created) object is inserted into the document tree after this
    object with the remaining characters.

    The function returns the newly created object.

    \sa CDomNode::normalize()
*/
CDomText CDomText::splitText(int offset)
{
    if (!impl)
        return CDomText();
    return CDomText(((CDomTextPrivate*)impl)->splitText(offset));
}



/**************************************************************
 *
 * CDomCommentPrivate
 *
 **************************************************************/

CDomCommentPrivate::CDomCommentPrivate(CDomDocumentPrivate* d, CDomNodePrivate* parent, const nsCodeQOR::CUCS2String& val)
    : CDomCharacterDataPrivate(d, parent, val)
{
    name = nsCodeQOR::CUCS2String( _TXT( "#comment" ) );
}

CDomCommentPrivate::CDomCommentPrivate(CDomCommentPrivate* n, bool deep)
    : CDomCharacterDataPrivate(n, deep)
{
}


CDomNodePrivate* CDomCommentPrivate::cloneNode(bool deep)
{
    CDomNodePrivate* p = new CDomCommentPrivate(this, deep);
    // We are not interested in this node
    p->m_ulRefCount--;
    return p;
}

/*
void CDomCommentPrivate::save(CTextStream& s, int depth, int indent) const
{
    // We don't output whitespace if we would pollute a text node.
    if (!(prev && prev->isText()))
        s << nsCodeQOR::CUCS2String(indent < 1 ? 0 : depth * indent, ' ' );

    s << "<!--" << value;
    if (value.endsWith( '-' ))
        s << ' '; // Ensures that XML comment doesn't end with --->
    s << "-->";

    if (!(next && next->isText()))
        s << std::endl;
}
*/

/**************************************************************
 *
 * CDomComment
 *
 **************************************************************/

/*!
    \class CDomComment
    \reentrant
    \brief The CDomComment class represents an XML comment.

    \inmodule QtXml
    \ingroup xml-tools

    A comment in the parsed XML such as this:
    \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 15
    is represented by CDomComment objects in the parsed Dom tree.

    For further information about the Document Object Model see
    \l{http://www.w3.org/TR/REC-DOM-Level-1/} and
    \l{http://www.w3.org/TR/DOM-Level-2-Core/}.
    For a more general introduction of the DOM implementation see the
    CDomDocument documentation.
*/

/*!
    Constructs an empty comment. To construct a comment with content,
    use the CDomDocument::createComment() function.
*/
CDomComment::CDomComment()
    : CDomCharacterData()
{
}

/*!
    Constructs a copy of \a x.

    The data of the copy is shared (shallow copy): modifying one node
    will also change the other. If you want to make a deep copy, use
    cloneNode().
*/
CDomComment::CDomComment(const CDomComment& x)
    : CDomCharacterData(x)
{
}

CDomComment::CDomComment(CDomCommentPrivate* n)
    : CDomCharacterData(n)
{
}

/*!
    Assigns \a x to this DOM comment.

    The data of the copy is shared (shallow copy): modifying one node
    will also change the other. If you want to make a deep copy, use
    cloneNode().
*/
CDomComment& CDomComment::operator= (const CDomComment& x)
{
    return (CDomComment&) CDomNode::operator=(x);
}

/*!
    \fn CDomNode::NodeType CDomComment::nodeType() const

    Returns \c CommentNode.
*/

/**************************************************************
 *
 * CDomCDATASectionPrivate
 *
 **************************************************************/

CDomCDATASectionPrivate::CDomCDATASectionPrivate(CDomDocumentPrivate* d, CDomNodePrivate* parent, const nsCodeQOR::CUCS2String& val)
    : CDomTextPrivate(d, parent, val)
{
    name = nsCodeQOR::CUCS2String( _TXT( "#cdata-section" ) );
}

CDomCDATASectionPrivate::CDomCDATASectionPrivate(CDomCDATASectionPrivate* n, bool deep)
    : CDomTextPrivate(n, deep)
{
}

CDomNodePrivate* CDomCDATASectionPrivate::cloneNode(bool deep)
{
    CDomNodePrivate* p = new CDomCDATASectionPrivate(this, deep);
    // We are not interested in this node
    p->m_ulRefCount--;
    return p;
}

/*
void CDomCDATASectionPrivate::save(CTextStream& s, int, int) const
{
    // ### How do we escape "]]>" ?
    // "]]>" is not allowed; so there should be none in value anyway
    s << "<![CDATA[" << value << "]]>";
}
*/
/**************************************************************
 *
 * CDomCDATASection
 *
 **************************************************************/

/*!
    \class CDomCDATASection
    \reentrant
    \brief The CDomCDATASection class represents an XML CDATA section.

    \inmodule QtXml
    \ingroup xml-tools

    CDATA sections are used to escape blocks of text containing
    characters that would otherwise be regarded as markup. The only
    delimiter that is recognized in a CDATA section is the "]]&gt;"
    string that terminates the CDATA section. CDATA sections cannot be
    nested. Their primary purpose is for including material such as
    XML fragments, without needing to escape all the delimiters.

    Adjacent CDomCDATASection nodes are not merged by the
    CDomNode::normalize() function.

    For further information about the Document Object Model see
    \l{http://www.w3.org/TR/REC-DOM-Level-1/} and
    \l{http://www.w3.org/TR/DOM-Level-2-Core/}.
    For a more general introduction of the DOM implementation see the
    CDomDocument documentation.
*/

/*!
    Constructs an empty CDATA section. To create a CDATA section with
    content, use the CDomDocument::createCDATASection() function.
*/
CDomCDATASection::CDomCDATASection()
    : CDomText()
{
}

/*!
    Constructs a copy of \a x.

    The data of the copy is shared (shallow copy): modifying one node
    will also change the other. If you want to make a deep copy, use
    cloneNode().
*/
CDomCDATASection::CDomCDATASection(const CDomCDATASection& x)
    : CDomText(x)
{
}

CDomCDATASection::CDomCDATASection(CDomCDATASectionPrivate* n)
    : CDomText(n)
{
}

/*!
    Assigns \a x to this CDATA section.

    The data of the copy is shared (shallow copy): modifying one node
    will also change the other. If you want to make a deep copy, use
    cloneNode().
*/
CDomCDATASection& CDomCDATASection::operator= (const CDomCDATASection& x)
{
    return (CDomCDATASection&) CDomNode::operator=(x);
}

/*!
    \fn CDomNode::NodeType CDomCDATASection::nodeType() const

    Returns \c CDATASection.
*/

/**************************************************************
 *
 * CDomNotationPrivate
 *
 **************************************************************/

CDomNotationPrivate::CDomNotationPrivate(CDomDocumentPrivate* d, CDomNodePrivate* parent,
                                            const nsCodeQOR::CUCS2String& aname,
                                            const nsCodeQOR::CUCS2String& pub, const nsCodeQOR::CUCS2String& sys)
    : CDomNodePrivate(d, parent)
{
    name = aname;
    m_pub = pub;
    m_sys = sys;
}

CDomNotationPrivate::CDomNotationPrivate(CDomNotationPrivate* n, bool deep)
    : CDomNodePrivate(n, deep)
{
    m_sys = n->m_sys;
    m_pub = n->m_pub;
}

CDomNodePrivate* CDomNotationPrivate::cloneNode(bool deep)
{
    CDomNodePrivate* p = new CDomNotationPrivate(this, deep);
    // We are not interested in this node
    p->m_ulRefCount--;
    return p;
}

/*
void CDomNotationPrivate::save(CTextStream& s, int, int) const
{
    s << "<!NOTATION " << name << ' ';
    if (!m_pub.isNull())  {
        s << "PUBLIC " << quotedValue(m_pub);
        if (!m_sys.isNull())
            s << ' ' << quotedValue(m_sys);
    }  else {
        s << "SYSTEM " << quotedValue(m_sys);
    }
    s << '>' << endl;
}
*/
/**************************************************************
 *
 * CDomNotation
 *
 **************************************************************/

#define IMPL ((CDomNotationPrivate*)impl)

/*!
    \class CDomNotation
    \reentrant
    \brief The CDomNotation class represents an XML notation.

    \inmodule QtXml
    \ingroup xml-tools

    A notation either declares, by name, the format of an unparsed
    entity (see section 4.7 of the XML 1.0 specification), or is used
    for formal declaration of processing instruction targets (see
    section 2.6 of the XML 1.0 specification).

    DOM does not support editing notation nodes; they are therefore
    read-only.

    A notation node does not have any parent.

    You can retrieve the publicId() and systemId() from a notation
    node.

    For further information about the Document Object Model see
    \l{http://www.w3.org/TR/REC-DOM-Level-1/}{Level 1} and
    \l{http://www.w3.org/TR/DOM-Level-2-Core/}{Level 2 Core}.
    For a more general introduction of the DOM implementation see the
    CDomDocument documentation.
*/


/*!
    Constructor.
*/
CDomNotation::CDomNotation()
    : CDomNode()
{
}

/*!
    Constructs a copy of \a x.

    The data of the copy is shared (shallow copy): modifying one node
    will also change the other. If you want to make a deep copy, use
    cloneNode().
*/
CDomNotation::CDomNotation(const CDomNotation& x)
    : CDomNode(x)
{
}

CDomNotation::CDomNotation(CDomNotationPrivate* n)
    : CDomNode(n)
{
}

/*!
    Assigns \a x to this DOM notation.

    The data of the copy is shared (shallow copy): modifying one node
    will also change the other. If you want to make a deep copy, use
    cloneNode().
*/
CDomNotation& CDomNotation::operator= (const CDomNotation& x)
{
    return (CDomNotation&) CDomNode::operator=(x);
}

/*!
    \fn CDomNode::NodeType CDomNotation::nodeType() const

    Returns \c NotationNode.
*/

/*!
    Returns the public identifier of this notation.
*/
nsCodeQOR::CUCS2String CDomNotation::publicId() const
{
    if (!impl)
        return nsCodeQOR::CUCS2String();
    return ((CDomNotationPrivate*)impl)->m_pub;
}

/*!
    Returns the system identifier of this notation.
*/
nsCodeQOR::CUCS2String CDomNotation::systemId() const
{
    if (!impl)
        return nsCodeQOR::CUCS2String();
    return ((CDomNotationPrivate*)impl)->m_sys;
}


/**************************************************************
 *
 * CDomEntityPrivate
 *
 **************************************************************/

CDomEntityPrivate::CDomEntityPrivate(CDomDocumentPrivate* d, CDomNodePrivate* parent,
                                        const nsCodeQOR::CUCS2String& aname,
                                        const nsCodeQOR::CUCS2String& pub, const nsCodeQOR::CUCS2String& sys, const nsCodeQOR::CUCS2String& notation)
    : CDomNodePrivate(d, parent)
{
    name = aname;
    m_pub = pub;
    m_sys = sys;
    m_notationName = notation;
}

CDomEntityPrivate::CDomEntityPrivate(CDomEntityPrivate* n, bool deep)
    : CDomNodePrivate(n, deep)
{
    m_sys = n->m_sys;
    m_pub = n->m_pub;
    m_notationName = n->m_notationName;
}

CDomNodePrivate* CDomEntityPrivate::cloneNode(bool deep)
{
    CDomNodePrivate* p = new CDomEntityPrivate(this, deep);
    // We are not interested in this node
	p->m_ulRefCount--;
    return p;
}

/*
  Encode an entity value upon saving.
*/
static std::vector< byte > encodeEntity( const std::vector< byte >& str)
{
    std::vector< byte > tmp( str);
    unsigned int len = tmp.size();
    unsigned int i = 0;
	//TODO:
	/*
    const char* d = tmp.data();
    while (i < len) 
	{
        if (d[i] == '%')
		{
            tmp.replace(i, 1, "&#60;");
            d = tmp;
            len += 4;
            i += 5;
        }
        else if (d[i] == '"') 
		{
            tmp.replace(i, 1, "&#34;");
            d = tmp;
            len += 4;
            i += 5;
        } else if (d[i] == '&' && i + 1 < len && d[i+1] == '#') 
		{
            // Don't encode &lt; or &quot; or &custom;.
            // Only encode character references
            tmp.replace(i, 1, "&#38;");
            d = tmp;
            len += 4;
            i += 5;
        } else {
            ++i;
        }
    }
	*/
    return tmp;
}

/*
void CDomEntityPrivate::save(CTextStream& s, int, int) const
{
    nsCodeQOR::CUCS2String _name = name;
    if (_name.startsWith( '%' ))
        _name = nsCodeQOR::CUCS2String("% ") + _name.mid(1);

    if (m_sys.empty() && m_pub.empty()) 
	{
        s << "<!ENTITY " << _name << " \"" << encodeEntity(value.toUtf8()) << "\">" << std::endl;
    } else 
	{
        s << "<!ENTITY " << _name << ' ';
        if (m_pub.empty()) 
		{
            s << "SYSTEM " << quotedValue(m_sys);
        } 
		else 
		{
            s << "PUBLIC " << quotedValue(m_pub) << ' ' << quotedValue(m_sys);
        }
        if (! m_notationName.empty()) 
		{
            s << " NDATA " << m_notationName;
        }
        s << '>' << endl;
    }
}
*/
/**************************************************************
 *
 * CDomEntity
 *
 **************************************************************/

#define IMPL ((CDomEntityPrivate*)impl)

/*!
    \class CDomEntity
    \reentrant
    \brief The CDomEntity class represents an XML entity.

    \inmodule QtXml
    \ingroup xml-tools

    This class represents an entity in an XML document, either parsed
    or unparsed. Note that this models the entity itself not the
    entity declaration.

    DOM does not support editing entity nodes; if a user wants to make
    changes to the contents of an entity, every related
    CDomEntityReference node must be replaced in the DOM tree by a
    clone of the entity's contents, and then the desired changes must
    be made to each of the clones instead. All the descendants of an
    entity node are read-only.

    An entity node does not have any parent.

    You can access the entity's publicId(), systemId() and
    notationName() when available.

    For further information about the Document Object Model see
    \l{http://www.w3.org/TR/REC-DOM-Level-1/}{Level 1} and
    \l{http://www.w3.org/TR/DOM-Level-2-Core/}{Level 2 Core}.
    For a more general introduction of the DOM implementation see the
    CDomDocument documentation.
*/


/*!
    Constructs an empty entity.
*/
CDomEntity::CDomEntity()
    : CDomNode()
{
}


/*!
    Constructs a copy of \a x.

    The data of the copy is shared (shallow copy): modifying one node
    will also change the other. If you want to make a deep copy, use
    cloneNode().
*/
CDomEntity::CDomEntity(const CDomEntity& x)
    : CDomNode(x)
{
}

CDomEntity::CDomEntity(CDomEntityPrivate* n)
    : CDomNode(n)
{
}

/*!
    Assigns \a x to this DOM entity.

    The data of the copy is shared (shallow copy): modifying one node
    will also change the other. If you want to make a deep copy, use
    cloneNode().
*/
CDomEntity& CDomEntity::operator= (const CDomEntity& x)
{
    return (CDomEntity&) CDomNode::operator=(x);
}

/*!
    \fn CDomNode::NodeType CDomEntity::nodeType() const

    Returns \c EntityNode.
*/

/*!
    Returns the public identifier associated with this entity. If the
    public identifier was not specified an empty string is returned.
*/
nsCodeQOR::CUCS2String CDomEntity::publicId() const
{
    if (!impl)
        return nsCodeQOR::CUCS2String();
    return ((CDomEntityPrivate*)impl)->m_pub;
}

/*!
    Returns the system identifier associated with this entity. If the
    system identifier was not specified an empty string is returned.
*/
nsCodeQOR::CUCS2String CDomEntity::systemId() const
{
    if (!impl)
        return nsCodeQOR::CUCS2String();
    return ((CDomEntityPrivate*)impl)->m_sys;
}

/*!
    For unparsed entities this function returns the name of the
    notation for the entity. For parsed entities this function returns
    an empty string.
*/
nsCodeQOR::CUCS2String CDomEntity::notationName() const
{
    if (!impl)
        return nsCodeQOR::CUCS2String();
    return ((CDomEntityPrivate*)impl)->m_notationName;
}


/**************************************************************
 *
 * CDomEntityReferencePrivate
 *
 **************************************************************/

CDomEntityReferencePrivate::CDomEntityReferencePrivate(CDomDocumentPrivate* d, CDomNodePrivate* parent, const nsCodeQOR::CUCS2String& aname)
    : CDomNodePrivate(d, parent)
{
    name = aname;
}

CDomEntityReferencePrivate::CDomEntityReferencePrivate(CDomNodePrivate* n, bool deep)
    : CDomNodePrivate(n, deep)
{
}

CDomNodePrivate* CDomEntityReferencePrivate::cloneNode(bool deep)
{
    CDomNodePrivate* p = new CDomEntityReferencePrivate(this, deep);
    // We are not interested in this node
    p->m_ulRefCount--;
    return p;
}

/*
void CDomEntityReferencePrivate::save(CTextStream& s, int, int) const
{
    s << '&' << name << ';';
}
*/
/**************************************************************
 *
 * CDomEntityReference
 *
 **************************************************************/

/*!
    \class CDomEntityReference
    \reentrant
    \brief The CDomEntityReference class represents an XML entity reference.

    \inmodule QtXml
    \ingroup xml-tools

    A CDomEntityReference object may be inserted into the DOM tree
    when an entity reference is in the source document, or when the
    user wishes to insert an entity reference.

    Note that character references and references to predefined
    entities are expanded by the XML processor so that characters are
    represented by their Unicode equivalent rather than by an entity
    reference.

    Moreover, the XML processor may completely expand references to
    entities while building the DOM tree, instead of providing
    CDomEntityReference objects.

    If it does provide such objects, then for a given entity reference
    node, it may be that there is no entity node representing the
    referenced entity; but if such an entity exists, then the child
    list of the entity reference node is the same as that of the
    entity  node. As with the entity node, all descendants of the
    entity reference are read-only.

    For further information about the Document Object Model see
    \l{http://www.w3.org/TR/REC-DOM-Level-1/}{Level 1} and
    \l{http://www.w3.org/TR/DOM-Level-2-Core/}{Level 2 Core}.
    For a more general introduction of the DOM implementation see the
    CDomDocument documentation.
*/

/*!
    Constructs an empty entity reference. Use
    CDomDocument::createEntityReference() to create a entity reference
    with content.
*/
CDomEntityReference::CDomEntityReference()
    : CDomNode()
{
}

/*!
    Constructs a copy of \a x.

    The data of the copy is shared (shallow copy): modifying one node
    will also change the other. If you want to make a deep copy, use
    cloneNode().
*/
CDomEntityReference::CDomEntityReference(const CDomEntityReference& x)
    : CDomNode(x)
{
}

CDomEntityReference::CDomEntityReference(CDomEntityReferencePrivate* n)
    : CDomNode(n)
{
}

/*!
    Assigns \a x to this entity reference.

    The data of the copy is shared (shallow copy): modifying one node
    will also change the other. If you want to make a deep copy, use
    cloneNode().
*/
CDomEntityReference& CDomEntityReference::operator= (const CDomEntityReference& x)
{
    return (CDomEntityReference&) CDomNode::operator=(x);
}

/*!
    \fn CDomNode::NodeType CDomEntityReference::nodeType() const

    Returns \c EntityReference.
*/

/**************************************************************
 *
 * CDomProcessingInstructionPrivate
 *
 **************************************************************/

CDomProcessingInstructionPrivate::CDomProcessingInstructionPrivate(CDomDocumentPrivate* d, CDomNodePrivate* parent, const nsCodeQOR::CUCS2String& target, const nsCodeQOR::CUCS2String& data) : CDomNodePrivate(d, parent)
{
    name = target;
    value = data;
}

CDomProcessingInstructionPrivate::CDomProcessingInstructionPrivate(CDomProcessingInstructionPrivate* n, bool deep)
    : CDomNodePrivate(n, deep)
{
}


CDomNodePrivate* CDomProcessingInstructionPrivate::cloneNode(bool deep)
{
    CDomNodePrivate* p = new CDomProcessingInstructionPrivate(this, deep);
    // We are not interested in this node
    p->m_ulRefCount--;
    return p;
}

/*
void CDomProcessingInstructionPrivate::save(CTextStream& s, int, int) const
{
    s << "<?" << name << ' ' << value << "?>" << endl;
}
*/
/**************************************************************
 *
 * CDomProcessingInstruction
 *
 **************************************************************/

/*!
    \class CDomProcessingInstruction
    \reentrant
    \brief The CDomProcessingInstruction class represents an XML processing
    instruction.

    \inmodule QtXml
    \ingroup xml-tools

    Processing instructions are used in XML to keep processor-specific
    information in the text of the document.

    The XML declaration that appears at the top of an XML document,
    typically \tt{<?xml version='1.0' encoding='UTF-8'?>}, is treated by QDom as a
    processing instruction. This is unfortunate, since the XML declaration is
    not a processing instruction; among other differences, it cannot be
    inserted into a document anywhere but on the first line.

    Do not use this function to create an xml declaration, since although it
    has the same syntax as a processing instruction, it isn't, and might not
    be treated by QDom as such.

    The content of the processing instruction is retrieved with data()
    and set with setData(). The processing instruction's target is
    retrieved with target().

    For further information about the Document Object Model see
    \l{http://www.w3.org/TR/REC-DOM-Level-1/}{Level 1} and
    \l{http://www.w3.org/TR/DOM-Level-2-Core/}{Level 2 Core}.
    For a more general introduction of the DOM implementation see the
    CDomDocument documentation.
*/

/*!
    Constructs an empty processing instruction. Use
    CDomDocument::createProcessingInstruction() to create a processing
    instruction with content.
*/
CDomProcessingInstruction::CDomProcessingInstruction()
    : CDomNode()
{
}

/*!
    Constructs a copy of \a x.

    The data of the copy is shared (shallow copy): modifying one node
    will also change the other. If you want to make a deep copy, use
    cloneNode().
*/
CDomProcessingInstruction::CDomProcessingInstruction(const CDomProcessingInstruction& x)
    : CDomNode(x)
{
}

CDomProcessingInstruction::CDomProcessingInstruction(CDomProcessingInstructionPrivate* n)
    : CDomNode(n)
{
}

/*!
    Assigns \a x to this processing instruction.

    The data of the copy is shared (shallow copy): modifying one node
    will also change the other. If you want to make a deep copy, use
    cloneNode().
*/
CDomProcessingInstruction& CDomProcessingInstruction::operator= (const CDomProcessingInstruction& x)
{
    return (CDomProcessingInstruction&) CDomNode::operator=(x);
}

/*!
    \fn CDomNode::NodeType CDomProcessingInstruction::nodeType() const

    Returns \c ProcessingInstructionNode.
*/

/*!
    Returns the target of this processing instruction.

    \sa data()
*/
nsCodeQOR::CUCS2String CDomProcessingInstruction::target() const
{
    if (!impl)
        return nsCodeQOR::CUCS2String();
    return impl->nodeName();
}

/*!
    Returns the content of this processing instruction.

    \sa setData() target()
*/
nsCodeQOR::CUCS2String CDomProcessingInstruction::data() const
{
    if (!impl)
        return nsCodeQOR::CUCS2String();
    return impl->nodeValue();
}

/*!
    Sets the data contained in the processing instruction to \a d.

    \sa data()
*/
void CDomProcessingInstruction::setData(const nsCodeQOR::CUCS2String& d)
{
    if (!impl)
        return;
    impl->setNodeValue(d);
}

/**************************************************************
 *
 * CDomDocumentPrivate
 *
 **************************************************************/

CDomDocumentPrivate::CDomDocumentPrivate()
    : CDomNodePrivate(0),
      impl(new CDomImplementationPrivate),
      nodeListTime(1)
{
    type = new CDomDocumentTypePrivate(this, this);
    type->m_ulRefCount--;

    name = nsCodeQOR::CUCS2String( _TXT( "#document" ) );
}

CDomDocumentPrivate::CDomDocumentPrivate(const nsCodeQOR::CUCS2String& aname)
    : CDomNodePrivate(0),
      impl(new CDomImplementationPrivate),
      nodeListTime(1)
{
    type = new CDomDocumentTypePrivate(this, this);
    type->m_ulRefCount--;
    type->name = aname;

    name = nsCodeQOR::CUCS2String( _TXT( "#document" ) );
}

CDomDocumentPrivate::CDomDocumentPrivate(CDomDocumentTypePrivate* dt)
    : CDomNodePrivate(0),
      impl(new CDomImplementationPrivate),
      nodeListTime(1)
{
    if (dt != 0) {
        type = dt;
    } else {
        type = new CDomDocumentTypePrivate(this, this);
        type->m_ulRefCount--;
    }

    name = nsCodeQOR::CUCS2String( _TXT( "#document" ) );
}

CDomDocumentPrivate::CDomDocumentPrivate(CDomDocumentPrivate* n, bool deep)
    : CDomNodePrivate(n, deep),
      impl(n->impl->clone()),
      nodeListTime(1)
{
    type = static_cast<CDomDocumentTypePrivate*>(n->type->cloneNode());
    type->setParent(this);
}

CDomDocumentPrivate::~CDomDocumentPrivate()
{
}

void CDomDocumentPrivate::clear()
{
	delete impl;
	impl = 0;
    
    delete type;
	type = 0;
    CDomNodePrivate::clear();
}

static void initializeReader( CXmlSimpleReader &reader, bool namespaceProcessing )
{
    reader.SetFeature( nsCodeQOR::CUCS2String( _TXT( "http://xml.org/sax/features/namespaces" ) ), namespaceProcessing );
    reader.SetFeature( nsCodeQOR::CUCS2String( _TXT( "http://xml.org/sax/features/namespace-prefixes" ) ), !namespaceProcessing );
    reader.SetFeature( nsCodeQOR::CUCS2String( _TXT( "http://trolltech.com/xml/features/report-whitespace-only-CharData" ) ), false ); // Shouldn't change in Qt 4
}

bool CDomDocumentPrivate::setContent( CBFSource* source, bool namespaceProcessing, nsCodeQOR::CUCS2String* errorMsg, int *errorLine, int *errorColumn)
{
    CXmlSimpleReader reader;
    initializeReader(reader, namespaceProcessing);
    return setContent( source, &reader, errorMsg, errorLine, errorColumn );
}

bool CDomDocumentPrivate::setContent( CBFSource* source, CXmlReader *reader, nsCodeQOR::CUCS2String *errorMsg, int *errorLine, int *errorColumn)
{
    clear();
    impl = new CDomImplementationPrivate;
    type = new CDomDocumentTypePrivate(this, this);
    type->m_ulRefCount--;

    bool namespaceProcessing = reader->Feature(nsCodeQOR::CUCS2String( _TXT( "http://xml.org/sax/features/namespaces" ) ) ) && !reader->Feature(nsCodeQOR::CUCS2String( _TXT( "http://xml.org/sax/features/namespace-prefixes" ) ) );

    CDomHandler hnd(this, namespaceProcessing);

    reader->ContentHandler.Configure(&hnd, false);
    reader->ErrorHandler.Configure(&hnd, false);
    reader->LexicalHandler.Configure(&hnd, false);
    reader->DeclHandler.Configure(&hnd, false);
    reader->DTDHandler.Configure(&hnd, false);

    if (!reader->Parse(source)) 
	{
        if (errorMsg)
            *errorMsg = hnd.errorMsg;
        if (errorLine)
            *errorLine = hnd.errorLine;
        if (errorColumn)
            *errorColumn = hnd.errorColumn;
        return false;
    }

    return true;
}

CDomNodePrivate* CDomDocumentPrivate::cloneNode(bool deep)
{
    CDomNodePrivate *p = new CDomDocumentPrivate(this, deep);
    // We are not interested in this node
    p->m_ulRefCount--;
    return p;
}

CDomElementPrivate* CDomDocumentPrivate::documentElement()
{
    CDomNodePrivate *p = first;
    
	while( p && !p->isElement() )
	{
        p = p->next;
	}

    return static_cast<CDomElementPrivate *>(p);
}

CDomElementPrivate* CDomDocumentPrivate::createElement(const nsCodeQOR::CUCS2String &tagName)
{
    bool ok;
    nsCodeQOR::CUCS2String fixedName = fixedXmlName(tagName, &ok);
    if (!ok)
	{
        return 0;
	}

    CDomElementPrivate *e = new CDomElementPrivate(this, 0, fixedName);
    e->m_ulRefCount--;
    return e;
}

CDomElementPrivate* CDomDocumentPrivate::createElementNS(const nsCodeQOR::CUCS2String &nsURI, const nsCodeQOR::CUCS2String &qName)
{
    bool ok;
    nsCodeQOR::CUCS2String fixedName = fixedXmlName(qName, &ok, true);
    if (!ok)
	{
        return 0;
	}

    CDomElementPrivate *e = new CDomElementPrivate(this, 0, nsURI, fixedName);
    e->m_ulRefCount--;
    return e;
}

CDomDocumentFragmentPrivate* CDomDocumentPrivate::createDocumentFragment()
{
    CDomDocumentFragmentPrivate *f = new CDomDocumentFragmentPrivate(this, (CDomNodePrivate*)0);
    f->m_ulRefCount--;
    return f;
}

CDomTextPrivate* CDomDocumentPrivate::createTextNode(const nsCodeQOR::CUCS2String &data)
{
    bool ok;
    nsCodeQOR::CUCS2String fixedData = fixedCharData(data, &ok);
    if (!ok)
        return 0;

    CDomTextPrivate *t = new CDomTextPrivate(this, 0, fixedData);
    t->m_ulRefCount--;
    return t;
}

CDomCommentPrivate* CDomDocumentPrivate::createComment(const nsCodeQOR::CUCS2String &data)
{
    bool ok;
    nsCodeQOR::CUCS2String fixedData = fixedComment(data, &ok);
    if (!ok)
        return 0;

    CDomCommentPrivate *c = new CDomCommentPrivate(this, 0, fixedData);
    c->m_ulRefCount--;
    return c;
}

CDomCDATASectionPrivate* CDomDocumentPrivate::createCDATASection(const nsCodeQOR::CUCS2String &data)
{
    bool ok;
    nsCodeQOR::CUCS2String fixedData = fixedCDataSection(data, &ok);
    if (!ok)
        return 0;

    CDomCDATASectionPrivate *c = new CDomCDATASectionPrivate(this, 0, fixedData);
    c->m_ulRefCount--;
    return c;
}

CDomProcessingInstructionPrivate* CDomDocumentPrivate::createProcessingInstruction( const nsCodeQOR::CUCS2String &target, const nsCodeQOR::CUCS2String &data )
{
    bool ok;
    nsCodeQOR::CUCS2String fixedData = fixedPIData(data, &ok);
    if (!ok)
        return 0;
    // [17] PITarget ::= Name - (('X' | 'x') ('M' | 'm') ('L' | 'l'))
    nsCodeQOR::CUCS2String fixedTarget = fixedXmlName( target, &ok );
    if( !ok )
	{
        return 0;
	}

    CDomProcessingInstructionPrivate *p = new CDomProcessingInstructionPrivate(this, 0, fixedTarget, fixedData);
    p->m_ulRefCount--;
    return p;
}

CDomAttrPrivate* CDomDocumentPrivate::createAttribute(const nsCodeQOR::CUCS2String &aname)
{
    bool ok;
    nsCodeQOR::CUCS2String fixedName = fixedXmlName(aname, &ok);
    if (!ok)
        return 0;

    CDomAttrPrivate *a = new CDomAttrPrivate(this, 0, fixedName);
    a->m_ulRefCount--;
    return a;
}

CDomAttrPrivate* CDomDocumentPrivate::createAttributeNS(const nsCodeQOR::CUCS2String &nsURI, const nsCodeQOR::CUCS2String &qName)
{
    bool ok;
    nsCodeQOR::CUCS2String fixedName = fixedXmlName(qName, &ok, true);
    if (!ok)
        return 0;

    CDomAttrPrivate *a = new CDomAttrPrivate(this, 0, nsURI, fixedName);
    a->m_ulRefCount--;
    return a;
}

CDomEntityReferencePrivate* CDomDocumentPrivate::createEntityReference(const nsCodeQOR::CUCS2String &aname)
{
    bool ok;
    nsCodeQOR::CUCS2String fixedName = fixedXmlName(aname, &ok);
    if (!ok)
        return 0;

    CDomEntityReferencePrivate *e = new CDomEntityReferencePrivate(this, 0, fixedName);
    e->m_ulRefCount--;
    return e;
}

CDomNodePrivate* CDomDocumentPrivate::importNode(const CDomNodePrivate *importedNode, bool deep)
{
    CDomNodePrivate *node = 0;
    switch (importedNode->nodeType()) {
        case CDomNode::AttributeNode:
            node = new CDomAttrPrivate((CDomAttrPrivate*)importedNode, true);
            break;
        case CDomNode::DocumentFragmentNode:
            node = new CDomDocumentFragmentPrivate((CDomDocumentFragmentPrivate*)importedNode, deep);
            break;
        case CDomNode::ElementNode:
            node = new CDomElementPrivate((CDomElementPrivate*)importedNode, deep);
            break;
        case CDomNode::EntityNode:
            node = new CDomEntityPrivate((CDomEntityPrivate*)importedNode, deep);
            break;
        case CDomNode::EntityReferenceNode:
            node = new CDomEntityReferencePrivate((CDomEntityReferencePrivate*)importedNode, false);
            break;
        case CDomNode::NotationNode:
            node = new CDomNotationPrivate((CDomNotationPrivate*)importedNode, deep);
            break;
        case CDomNode::ProcessingInstructionNode:
            node = new CDomProcessingInstructionPrivate((CDomProcessingInstructionPrivate*)importedNode, deep);
            break;
        case CDomNode::TextNode:
            node = new CDomTextPrivate((CDomTextPrivate*)importedNode, deep);
            break;
        case CDomNode::CDATASectionNode:
            node = new CDomCDATASectionPrivate((CDomCDATASectionPrivate*)importedNode, deep);
            break;
        case CDomNode::CommentNode:
            node = new CDomCommentPrivate((CDomCommentPrivate*)importedNode, deep);
            break;
        default:
            break;
    }

    if( node ) 
	{
        node->setOwnerDocument(this);
        // The CDomNode constructor increases the refcount, so deref first to
        // keep refcount balanced.
        node->m_ulRefCount--;
    }
    return node;
}

/*
void CDomDocumentPrivate::saveDocument(CTextStream& s, const int indent, CDomNode::EncodingPolicy encUsed) const
{
    const CDomNodePrivate* n = first;

    if(encUsed == CDomNode::EncodingFromDocument) 
	{
#ifndef QT_NO_TEXTCODEC
        const CDomNodePrivate* n = first;

        QTextCodec *codec = 0;

        if (n && n->isProcessingInstruction() && n->nodeName() == nsCodeQOR::CUCS2String("xml")) {
            // we have an XML declaration
            nsCodeQOR::CUCS2String data = n->nodeValue();
            QRegExp encoding(nsCodeQOR::CUCS2String("encoding\\s*=\\s*((\"([^\"]*)\")|('([^']*)'))"));
            encoding.indexIn(data);
            nsCodeQOR::CUCS2String enc = encoding.cap(3);
            if (enc.empty())
                enc = encoding.cap(5);
            if (!enc.empty())
                codec = QTextCodec::codecForName(enc.toLatin1().data());
        }
        if (!codec)
            codec = QTextCodec::codecForName("UTF-8");
        if (codec)
            s.setCodec(codec);
#endif
        bool doc = false;

        while (n) {
            if (!doc && !(n->isProcessingInstruction() && n->nodeName() == nsCodeQOR::CUCS2String("xml"))) {
                // save doctype after XML declaration
                type->save(s, 0, indent);
                doc = true;
            }
            n->save(s, 0, indent);
            n = n->next;
        }
    }
    else {

        // Write out the XML declaration.
#ifdef QT_NO_TEXTCODEC
        const nsCodeQOR::CUCS2String codecName("iso-8859-1");
#else
        const QTextCodec *const codec = s.codec();
        Q_ASSERT_X(codec, "CDomNode::save()", "A codec must be specified in the text stream.");
        const QByteArray codecName = codec->name();
#endif

        s << "<?xml version=\"1.0\" encoding=\""
          << codecName
          << "\"?>\n";

        //  Skip the first processing instruction by name "xml", if any such exists.
        const CDomNodePrivate* startNode = n;

        // First, we try to find the PI and sets the startNode to the one appearing after it.
        while (n) {
            if(n->isProcessingInstruction() && n->nodeName() == nsCodeQOR::CUCS2String("xml")) {
                startNode = n->next;
                break;
            }
            else
                n = n->next;
        }

        // Now we serialize all the nodes after the faked XML declaration(the PI).
        while(startNode) {
            startNode->save(s, 0, indent);
            startNode = startNode->next;
        }
    }
}
*/
/**************************************************************
 *
 * CDomDocument
 *
 **************************************************************/

#define IMPL ((CDomDocumentPrivate*)impl)

/*!
    \class CDomDocument
    \reentrant
    \brief The CDomDocument class represents an XML document.

    \inmodule QtXml

    \ingroup xml-tools

    The CDomDocument class represents the entire XML document.
    Conceptually, it is the root of the document tree, and provides
    the primary access to the document's data.

    Since elements, text nodes, comments, processing instructions,
    etc., cannot exist outside the context of a document, the document
    class also contains the factory functions needed to create these
    objects. The node objects created have an ownerDocument() function
    which associates them with the document within whose context they
    were created. The DOM classes that will be used most often are
    CDomNode, CDomDocument, CDomElement and CDomText.

    The parsed XML is represented internally by a tree of objects that
    can be accessed using the various QDom classes. All QDom classes
    only \e reference objects in the internal tree. The internal
    objects in the DOM tree will get deleted once the last QDom
    object referencing them and the CDomDocument itself are deleted.

    Creation of elements, text nodes, etc. is done using the various
    factory functions provided in this class. Using the default
    constructors of the QDom classes will only result in empty
    objects that cannot be manipulated or inserted into the Document.

    The CDomDocument class has several functions for creating document
    data, for example, createElement(), createTextNode(),
    createComment(), createCDATASection(),
    createProcessingInstruction(), createAttribute() and
    createEntityReference(). Some of these functions have versions
    that support namespaces, i.e. createElementNS() and
    createAttributeNS(). The createDocumentFragment() function is used
    to hold parts of the document; this is useful for manipulating for
    complex documents.

    The entire content of the document is set with setContent(). This
    function parses the string it is passed as an XML document and
    creates the DOM tree that represents the document. The root
    element is available using documentElement(). The textual
    representation of the document can be obtained using toString().

    It is possible to insert a node from another document into the
    document using importNode().

    You can obtain a list of all the elements that have a particular
    tag with elementsByTagName() or with elementsByTagNameNS().

    The QDom classes are typically used as follows:
    \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 16

    Once \c doc and \c elem go out of scope, the whole internal tree
    representing the XML document is deleted.

    To create a document using DOM use code like this:
    \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 17

    For further information about the Document Object Model see
    the Document Object Model (DOM)
    \l{http://www.w3.org/TR/REC-DOM-Level-1/}{Level 1} and
    \l{http://www.w3.org/TR/DOM-Level-2-Core/}{Level 2 Core}
    Specifications.

    \sa {DOM Bookmarks Example}, {Simple DOM Model Example}
*/


/*!
    Constructs an empty document.
*/
CDomDocument::CDomDocument()
{
    impl = 0;
}

/*!
    Creates a document and sets the name of the document type to \a
    name.
*/
CDomDocument::CDomDocument(const nsCodeQOR::CUCS2String& name)
{
    // We take over ownership
    impl = new CDomDocumentPrivate(name);
}

/*!
    Creates a document with the document type \a doctype.

    \sa CDomImplementation::createDocumentType()
*/
CDomDocument::CDomDocument(const CDomDocumentType& doctype)
{
    impl = new CDomDocumentPrivate((CDomDocumentTypePrivate*)(doctype.impl));
}

/*!
    Constructs a copy of \a x.

    The data of the copy is shared (shallow copy): modifying one node
    will also change the other. If you want to make a deep copy, use
    cloneNode().
*/
CDomDocument::CDomDocument(const CDomDocument& x)
    : CDomNode(x)
{
}

CDomDocument::CDomDocument(CDomDocumentPrivate* x)
    : CDomNode(x)
{
}

/*!
    Assigns \a x to this DOM document.

    The data of the copy is shared (shallow copy): modifying one node
    will also change the other. If you want to make a deep copy, use
    cloneNode().
*/
CDomDocument& CDomDocument::operator= (const CDomDocument& x)
{
    return (CDomDocument&) CDomNode::operator=(x);
}

/*!
    Destroys the object and frees its resources.
*/
CDomDocument::~CDomDocument()
{
}

/*!
    \overload

    This function reads the XML document from the string \a text, returning
    true if the content was successfully parsed; otherwise returns false.
    Since \a text is already a Unicode string, no encoding detection
    is done.
*/
bool CDomDocument::setContent(const nsCodeQOR::CUCS2String& text, bool namespaceProcessing, nsCodeQOR::CUCS2String *errorMsg, int *errorLine, int *errorColumn)
{
    if (!impl)
        impl = new CDomDocumentPrivate();
    CBFUCS2StringSource source;
    source.SetData( const_cast< nsCodeQOR::CUCS2String& >( text ));
    return ((CDomDocumentPrivate*)impl)->setContent(&source, namespaceProcessing, errorMsg, errorLine, errorColumn);
}

/*!
    \nonreentrant

    This function parses the XML document from the byte array \a
    data and sets it as the content of the document. It tries to
    detect the encoding of the document as required by the XML
    specification.

    If \a namespaceProcessing is true, the parser recognizes
    namespaces in the XML file and sets the prefix name, local name
    and namespace URI to appropriate values. If \a namespaceProcessing
    is false, the parser does no namespace processing when it reads
    the XML file.

    If a parse error occurs, this function returns false and the error
    message is placed in \c{*}\a{errorMsg}, the line number in
    \c{*}\a{errorLine} and the column number in \c{*}\a{errorColumn}
    (unless the associated pointer is set to 0); otherwise this
    function returns true. The various error messages are described in
    the CXmlParseException class documentation. Note that, if you
    want to display these error messages to your application's users,
    they will be displayed in English unless they are explicitly
    translated.

    If \a namespaceProcessing is true, the function CDomNode::prefix()
    returns a string for all elements and attributes. It returns an
    empty string if the element or attribute has no prefix.

    Text nodes consisting only of whitespace are stripped and won't
    appear in the CDomDocument. If this behavior is not desired,
    one can use the setContent() overload that allows a CXmlReader to be
    supplied.

    If \a namespaceProcessing is false, the functions
    CDomNode::prefix(), CDomNode::localName() and
    CDomNode::namespaceURI() return an empty string.

    Entity references are handled as follows:
    \list
    \o References to internal general entities and character entities occurring in the
        content are included. The result is a CDomText node with the references replaced
        by their corresponding entity values.
    \o References to parameter entities occurring in the internal subset are included.
        The result is a CDomDocumentType node which contains entity and notation declarations
        with the references replaced by their corresponding entity values.
    \o Any general parsed entity reference which is not defined in the internal subset and
        which occurs in the content is represented as a CDomEntityReference node.
    \o Any parsed entity reference which is not defined in the internal subset and which
        occurs outside of the content is replaced with an empty string.
    \o Any unparsed entity reference is replaced with an empty string.
    \endlist

    \sa CDomNode::namespaceURI() CDomNode::localName()
    CDomNode::prefix() nsCodeQOR::CUCS2String::isNull() nsCodeQOR::CUCS2String::isEmpty()
*/
/*
bool CDomDocument::setContent(const QByteArray &data, bool namespaceProcessing, nsCodeQOR::CUCS2String *errorMsg, int *errorLine, int *errorColumn)
{
    if (!impl)
        impl = new CDomDocumentPrivate();
    QBuffer buf;
    buf.setData(data);
    CXmlInputSource source(&buf);
    return ((CDomDocumentPrivate*)impl)->setContent(&source, namespaceProcessing, errorMsg, errorLine, errorColumn);
}
*/
/*!
    \overload

    This function reads the XML document from the IO device \a dev, returning
    true if the content was successfully parsed; otherwise returns false.
*/
/*
bool CDomDocument::setContent(QIODevice* dev, bool namespaceProcessing, nsCodeQOR::CUCS2String *errorMsg, int *errorLine, int *errorColumn)
{
    if (!impl)
        impl = new CDomDocumentPrivate();
    CXmlInputSource source(dev);
    return ((CDomDocumentPrivate*)impl)->setContent(&source, namespaceProcessing, errorMsg, errorLine, errorColumn);
}
*/
/*!
    \overload
    \since 4.5

    This function reads the XML document from the CXmlInputSource \a source,
    returning true if the content was successfully parsed; otherwise returns false.

*/
bool CDomDocument::setContent( CBFSource* source, bool namespaceProcessing, nsCodeQOR::CUCS2String *errorMsg, int *errorLine, int *errorColumn )
{
    if (!impl)
        impl = new CDomDocumentPrivate();
    CXmlSimpleReader reader;
    initializeReader(reader, namespaceProcessing);
    return ((CDomDocumentPrivate*)impl)->setContent(source, &reader, errorMsg, errorLine, errorColumn);
}

/*!
    \overload

    This function reads the XML document from the string \a text, returning
    true if the content was successfully parsed; otherwise returns false.
    Since \a text is already a Unicode string, no encoding detection
    is performed.

    No namespace processing is performed either.
*/
bool CDomDocument::setContent(const nsCodeQOR::CUCS2String& text, nsCodeQOR::CUCS2String *errorMsg, int *errorLine, int *errorColumn)
{
    return setContent(text, false, errorMsg, errorLine, errorColumn);
}

/*!
    \overload

    This function reads the XML document from the byte array \a buffer,
    returning true if the content was successfully parsed; otherwise returns
    false.

    No namespace processing is performed.
*/
/*
bool CDomDocument::setContent(const QByteArray& buffer, nsCodeQOR::CUCS2String *errorMsg, int *errorLine, int *errorColumn )
{
    return setContent(buffer, false, errorMsg, errorLine, errorColumn);
}
*/
/*!
    \overload

    This function reads the XML document from the IO device \a dev, returning
    true if the content was successfully parsed; otherwise returns false.

    No namespace processing is performed.
*/
/*
bool CDomDocument::setContent(QIODevice* dev, nsCodeQOR::CUCS2String *errorMsg, int *errorLine, int *errorColumn )
{
    return setContent(dev, false, errorMsg, errorLine, errorColumn);
}
*/
/*!
    \overload

    This function reads the XML document from the CXmlInputSource \a source and
    parses it with the CXmlReader \a reader, returning true if the content was
    successfully parsed; otherwise returns false.

    This function doesn't change the features of the \a reader. If you want to
    use certain features for parsing you can use this function to set up the
    reader appropriately.

    \sa CXmlSimpleReader
*/
bool CDomDocument::setContent( CBFSource* source, CXmlReader *reader, nsCodeQOR::CUCS2String *errorMsg, int *errorLine, int *errorColumn )
{
    if (!impl)
        impl = new CDomDocumentPrivate();
    return ((CDomDocumentPrivate*)impl)->setContent(source, reader, errorMsg, errorLine, errorColumn);
}

/*!
    Converts the parsed document back to its textual representation.

    This function uses \a indent as the amount of space to indent
    subelements.

    If \a indent is -1, no whitespace at all is added.
*/
nsCodeQOR::CUCS2String CDomDocument::toString(int indent) const
{
    nsCodeQOR::CUCS2String str;
	//TODO:
	/*
    CTextStream s(&str, QIODevice::WriteOnly);
    save(s, indent);
	*/
    return str;
}

/*!
    Converts the parsed document back to its textual representation
    and returns a QByteArray containing the data encoded as UTF-8.

    This function uses \a indent as the amount of space to indent
    subelements.

    \sa toString()
*/
/*
QByteArray CDomDocument::toByteArray(int indent) const
{
    // ### if there is an encoding specified in the xml declaration, this
    // encoding declaration should be changed to utf8
    return toString(indent).toUtf8();
}
*/

/*!
    Returns the document type of this document.
*/
CDomDocumentType CDomDocument::doctype() const
{
    if (!impl)
        return CDomDocumentType();
    return CDomDocumentType(((CDomDocumentPrivate*)impl)->doctype());
}

/*!
    Returns a CDomImplementation object.
*/
CDomImplementation CDomDocument::implementation() const
{
    if (!impl)
        return CDomImplementation();
    return CDomImplementation(((CDomDocumentPrivate*)impl)->implementation());
}

/*!
    Returns the root element of the document.
*/
CDomElement CDomDocument::documentElement() const
{
    if (!impl)
        return CDomElement();
    return CDomElement(((CDomDocumentPrivate*)impl)->documentElement());
}

/*!
    Creates a new element called \a tagName that can be inserted into
    the DOM tree, e.g. using CDomNode::appendChild().

    If \a tagName is not a valid XML name, the behavior of this function is governed
    by CDomImplementation::InvalidDataPolicy.

    \sa createElementNS() CDomNode::appendChild() CDomNode::insertBefore()
    CDomNode::insertAfter()
*/
CDomElement CDomDocument::createElement(const nsCodeQOR::CUCS2String& tagName)
{
    if (!impl)
        impl = new CDomDocumentPrivate();
    return CDomElement(((CDomDocumentPrivate*)impl)->createElement(tagName));
}

/*!
    Creates a new document fragment, that can be used to hold parts of
    the document, e.g. when doing complex manipulations of the
    document tree.
*/
CDomDocumentFragment CDomDocument::createDocumentFragment()
{
    if (!impl)
        impl = new CDomDocumentPrivate();
    return CDomDocumentFragment(((CDomDocumentPrivate*)impl)->createDocumentFragment());
}

/*!
    Creates a text node for the string \a value that can be inserted
    into the document tree, e.g. using CDomNode::appendChild().

    If \a value contains characters which cannot be stored as character
    data of an XML document (even in the form of character references), the
    behavior of this function is governed by CDomImplementation::InvalidDataPolicy.

    \sa CDomNode::appendChild() CDomNode::insertBefore() CDomNode::insertAfter()
*/
CDomText CDomDocument::createTextNode(const nsCodeQOR::CUCS2String& value)
{
    if (!impl)
        impl = new CDomDocumentPrivate();
    return CDomText(((CDomDocumentPrivate*)impl)->createTextNode(value));
}

/*!
    Creates a new comment for the string \a value that can be inserted
    into the document, e.g. using CDomNode::appendChild().

    If \a value contains characters which cannot be stored in an XML comment,
    the behavior of this function is governed by CDomImplementation::InvalidDataPolicy.

    \sa CDomNode::appendChild() CDomNode::insertBefore() CDomNode::insertAfter()
*/
CDomComment CDomDocument::createComment(const nsCodeQOR::CUCS2String& value)
{
    if (!impl)
        impl = new CDomDocumentPrivate();
    return CDomComment(((CDomDocumentPrivate*)impl)->createComment(value));
}

/*!
    Creates a new CDATA section for the string \a value that can be
    inserted into the document, e.g. using CDomNode::appendChild().

    If \a value contains characters which cannot be stored in a CDATA section,
    the behavior of this function is governed by
    CDomImplementation::InvalidDataPolicy.

    \sa CDomNode::appendChild() CDomNode::insertBefore() CDomNode::insertAfter()
*/
CDomCDATASection CDomDocument::createCDATASection( const nsCodeQOR::CUCS2String& value )
{
    if( !impl )
	{
        impl = new CDomDocumentPrivate();
	}
    return CDomCDATASection(((CDomDocumentPrivate*)impl)->createCDATASection(value));
}

/*!
    Creates a new processing instruction that can be inserted into the
    document, e.g. using CDomNode::appendChild(). This function sets
    the target for the processing instruction to \a target and the
    data to \a data.

    If \a target is not a valid XML name, or data if contains characters which cannot
    appear in a processing instruction, the behavior of this function is governed by
    CDomImplementation::InvalidDataPolicy.

    \sa CDomNode::appendChild() CDomNode::insertBefore() CDomNode::insertAfter()
*/
CDomProcessingInstruction CDomDocument::createProcessingInstruction( const nsCodeQOR::CUCS2String& target, const nsCodeQOR::CUCS2String& data )
{
    if( !impl )
	{
        impl = new CDomDocumentPrivate();
	}
    return CDomProcessingInstruction(((CDomDocumentPrivate*)impl)->createProcessingInstruction(target, data));
}


/*!
    Creates a new attribute called \a name that can be inserted into
    an element, e.g. using CDomElement::setAttributeNode().

    If \a name is not a valid XML name, the behavior of this function is governed by
    CDomImplementation::InvalidDataPolicy.

    \sa createAttributeNS()
*/
CDomAttr CDomDocument::createAttribute(const nsCodeQOR::CUCS2String& name)
{
    if (!impl)
        impl = new CDomDocumentPrivate();
    return CDomAttr(((CDomDocumentPrivate*)impl)->createAttribute(name));
}

/*!
    Creates a new entity reference called \a name that can be inserted
    into the document, e.g. using CDomNode::appendChild().

    If \a name is not a valid XML name, the behavior of this function is governed by
    CDomImplementation::InvalidDataPolicy.

    \sa CDomNode::appendChild() CDomNode::insertBefore() CDomNode::insertAfter()
*/
CDomEntityReference CDomDocument::createEntityReference(const nsCodeQOR::CUCS2String& name)
{
    if (!impl)
        impl = new CDomDocumentPrivate();
    return CDomEntityReference(((CDomDocumentPrivate*)impl)->createEntityReference(name));
}

/*!
    Returns a CDomNodeList, that contains all the elements in the
    document with the name \a tagname. The order of the node list is
    the order they are encountered in a preorder traversal of the
    element tree.

    \sa elementsByTagNameNS() CDomElement::elementsByTagName()
*/
CDomNodeList CDomDocument::elementsByTagName(const nsCodeQOR::CUCS2String& tagname) const
{
    return CDomNodeList(new CDomNodeListPrivate(impl, tagname));
}

/*!
    Imports the node \a importedNode from another document to this
    document. \a importedNode remains in the original document; this
    function creates a copy that can be used within this document.

    This function returns the imported node that belongs to this
    document. The returned node has no parent. It is not possible to
    import CDomDocument and CDomDocumentType nodes. In those cases
    this function returns a \link CDomNode::isNull() null node\endlink.

    If \a deep is true, this function imports not only the node \a
    importedNode but its whole subtree; if it is false, only the \a
    importedNode is imported. The argument \a deep has no effect on
    CDomAttr and CDomEntityReference nodes, since the descendants of
    CDomAttr nodes are always imported and those of
    CDomEntityReference nodes are never imported.

    The behavior of this function is slightly different depending on
    the node types:
    \table
    \header \i Node Type \i Behavior
    \row \i CDomAttr
         \i The owner element is set to 0 and the specified flag is
            set to true in the generated attribute. The whole subtree
            of \a importedNode is always imported for attribute nodes:
            \a deep has no effect.
    \row \i CDomDocument
         \i Document nodes cannot be imported.
    \row \i CDomDocumentFragment
         \i If \a deep is true, this function imports the whole
            document fragment; otherwise it only generates an empty
            document fragment.
    \row \i CDomDocumentType
         \i Document type nodes cannot be imported.
    \row \i CDomElement
         \i Attributes for which CDomAttr::specified() is true are
            also imported, other attributes are not imported. If \a
            deep is true, this function also imports the subtree of \a
            importedNode; otherwise it imports only the element node
            (and some attributes, see above).
    \row \i CDomEntity
         \i Entity nodes can be imported, but at the moment there is
            no way to use them since the document type is read-only in
            DOM level 2.
    \row \i CDomEntityReference
         \i Descendants of entity reference nodes are never imported:
            \a deep has no effect.
    \row \i CDomNotation
         \i Notation nodes can be imported, but at the moment there is
            no way to use them since the document type is read-only in
            DOM level 2.
    \row \i CDomProcessingInstruction
         \i The target and value of the processing instruction is
            copied to the new node.
    \row \i CDomText
         \i The text is copied to the new node.
    \row \i CDomCDATASection
         \i The text is copied to the new node.
    \row \i CDomComment
         \i The text is copied to the new node.
    \endtable

    \sa CDomElement::setAttribute() CDomNode::insertBefore()
        CDomNode::insertAfter() CDomNode::replaceChild() CDomNode::removeChild()
        CDomNode::appendChild()
*/
CDomNode CDomDocument::importNode(const CDomNode& importedNode, bool deep)
{
    if (!impl)
        impl = new CDomDocumentPrivate();
    return CDomNode(((CDomDocumentPrivate*)impl)->importNode(importedNode.impl, deep));
}

/*!
    Creates a new element with namespace support that can be inserted
    into the DOM tree. The name of the element is \a qName and the
    namespace URI is \a nsURI. This function also sets
    CDomNode::prefix() and CDomNode::localName() to appropriate values
    (depending on \a qName).

    If \a qName is an empty string, returns a null element regardless of
    whether the invalid data policy is set.

    \sa createElement()
*/
CDomElement CDomDocument::createElementNS(const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String& qName)
{
    if (!impl)
        impl = new CDomDocumentPrivate();
    return CDomElement(((CDomDocumentPrivate*)impl)->createElementNS(nsURI, qName));
}

/*!
    Creates a new attribute with namespace support that can be
    inserted into an element. The name of the attribute is \a qName
    and the namespace URI is \a nsURI. This function also sets
    CDomNode::prefix() and CDomNode::localName() to appropriate values
    (depending on \a qName).

    If \a qName is not a valid XML name, the behavior of this function is governed by
    CDomImplementation::InvalidDataPolicy.

    \sa createAttribute()
*/
CDomAttr CDomDocument::createAttributeNS(const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String& qName)
{
    if (!impl)
        impl = new CDomDocumentPrivate();
    return CDomAttr(((CDomDocumentPrivate*)impl)->createAttributeNS(nsURI, qName));
}

/*!
    Returns a CDomNodeList that contains all the elements in the
    document with the local name \a localName and a namespace URI of
    \a nsURI. The order of the node list is the order they are
    encountered in a preorder traversal of the element tree.

    \sa elementsByTagName() CDomElement::elementsByTagNameNS()
*/
CDomNodeList CDomDocument::elementsByTagNameNS(const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String& localName)
{
    return CDomNodeList(new CDomNodeListPrivate(impl, nsURI, localName));
}

/*!
    Returns the element whose ID is equal to \a elementId. If no
    element with the ID was found, this function returns a \link
    CDomNode::isNull() null element\endlink.

    Since the QDomClasses do not know which attributes are element
    IDs, this function returns always a \link CDomNode::isNull() null
    element\endlink. This may change in a future version.
*/
CDomElement CDomDocument::elementById(const nsCodeQOR::CUCS2String& /*elementId*/)
{
    //TODO:qWarning("elementById() is not implemented and will always return a null node.");
    return CDomElement();
}

/*!
    \fn CDomNode::NodeType CDomDocument::nodeType() const

    Returns \c DocumentNode.
*/


/**************************************************************
 *
 * Node casting functions
 *
 **************************************************************/

/*!
    Converts a CDomNode into a CDomAttr. If the node is not an
    attribute, the returned object will be \link CDomNode::isNull()
    null\endlink.

    \sa isAttr()
*/
CDomAttr CDomNode::toAttr() const
{
    if (impl && impl->isAttr())
        return CDomAttr(((CDomAttrPrivate*)impl));
    return CDomAttr();
}

/*!
    Converts a CDomNode into a CDomCDATASection. If the node is not a
    CDATA section, the returned object will be \link
    CDomNode::isNull() null\endlink.

    \sa isCDATASection()
*/
CDomCDATASection CDomNode::toCDATASection() const
{
    if (impl && impl->isCDATASection())
        return CDomCDATASection(((CDomCDATASectionPrivate*)impl));
    return CDomCDATASection();
}

/*!
    Converts a CDomNode into a CDomDocumentFragment. If the node is
    not a document fragment the returned object will be \link
    CDomNode::isNull() null\endlink.

    \sa isDocumentFragment()
*/
CDomDocumentFragment CDomNode::toDocumentFragment() const
{
    if (impl && impl->isDocumentFragment())
        return CDomDocumentFragment(((CDomDocumentFragmentPrivate*)impl));
    return CDomDocumentFragment();
}

/*!
    Converts a CDomNode into a CDomDocument. If the node is not a
    document the returned object will be \link CDomNode::isNull()
    null\endlink.

    \sa isDocument()
*/
CDomDocument CDomNode::toDocument() const
{
    if (impl && impl->isDocument())
        return CDomDocument(((CDomDocumentPrivate*)impl));
    return CDomDocument();
}

/*!
    Converts a CDomNode into a CDomDocumentType. If the node is not a
    document type the returned object will be \link CDomNode::isNull()
    null\endlink.

    \sa isDocumentType()
*/
CDomDocumentType CDomNode::toDocumentType() const
{
    if (impl && impl->isDocumentType())
        return CDomDocumentType(((CDomDocumentTypePrivate*)impl));
    return CDomDocumentType();
}

/*!
    Converts a CDomNode into a CDomElement. If the node is not an
    element the returned object will be \link CDomNode::isNull()
    null\endlink.

    \sa isElement()
*/
CDomElement CDomNode::toElement() const
{
    if (impl && impl->isElement())
        return CDomElement(((CDomElementPrivate*)impl));
    return CDomElement();
}

/*!
    Converts a CDomNode into a CDomEntityReference. If the node is not
    an entity reference, the returned object will be \link
    CDomNode::isNull() null\endlink.

    \sa isEntityReference()
*/
CDomEntityReference CDomNode::toEntityReference() const
{
    if (impl && impl->isEntityReference())
        return CDomEntityReference(((CDomEntityReferencePrivate*)impl));
    return CDomEntityReference();
}

/*!
    Converts a CDomNode into a CDomText. If the node is not a text,
    the returned object will be \link CDomNode::isNull() null\endlink.

    \sa isText()
*/
CDomText CDomNode::toText() const
{
    if (impl && impl->isText())
        return CDomText(((CDomTextPrivate*)impl));
    return CDomText();
}

/*!
    Converts a CDomNode into a CDomEntity. If the node is not an
    entity the returned object will be \link CDomNode::isNull()
    null\endlink.

    \sa isEntity()
*/
CDomEntity CDomNode::toEntity() const
{
    if (impl && impl->isEntity())
        return CDomEntity(((CDomEntityPrivate*)impl));
    return CDomEntity();
}

/*!
    Converts a CDomNode into a CDomNotation. If the node is not a
    notation the returned object will be \link CDomNode::isNull()
    null\endlink.

    \sa isNotation()
*/
CDomNotation CDomNode::toNotation() const
{
    if (impl && impl->isNotation())
        return CDomNotation(((CDomNotationPrivate*)impl));
    return CDomNotation();
}

/*!
    Converts a CDomNode into a CDomProcessingInstruction. If the node
    is not a processing instruction the returned object will be \link
    CDomNode::isNull() null\endlink.

    \sa isProcessingInstruction()
*/
CDomProcessingInstruction CDomNode::toProcessingInstruction() const
{
    if (impl && impl->isProcessingInstruction())
        return CDomProcessingInstruction(((CDomProcessingInstructionPrivate*)impl));
    return CDomProcessingInstruction();
}

/*!
    Converts a CDomNode into a CDomCharacterData. If the node is not a
    character data node the returned object will be \link
    CDomNode::isNull() null\endlink.

    \sa isCharacterData()
*/
CDomCharacterData CDomNode::toCharacterData() const
{
    if (impl && impl->isCharacterData())
        return CDomCharacterData(((CDomCharacterDataPrivate*)impl));
    return CDomCharacterData();
}

/*!
    Converts a CDomNode into a CDomComment. If the node is not a
    comment the returned object will be \link CDomNode::isNull()
    null\endlink.

    \sa isComment()
*/
CDomComment CDomNode::toComment() const
{
    if (impl && impl->isComment())
        return CDomComment(((CDomCommentPrivate*)impl));
    return CDomComment();
}

/**************************************************************
 *
 * CDomHandler
 *
 **************************************************************/

CDomHandler::CDomHandler(CDomDocumentPrivate* adoc, bool namespaceProcessing)
    : errorLine(0), errorColumn(0), doc(adoc), node(adoc), cdata(false),
        nsProcessing(namespaceProcessing), locator(0)
{
}

CDomHandler::~CDomHandler()
{
}

bool CDomHandler::endDocument()
{
    // ### is this really necessary? (rms)
    if (node != doc)
        return false;
    return true;
}

bool CDomHandler::startDTD(const nsCodeQOR::CUCS2String& name, const nsCodeQOR::CUCS2String& publicId, const nsCodeQOR::CUCS2String& systemId)
{
    doc->doctype()->name = name;
    doc->doctype()->publicId = publicId;
    doc->doctype()->systemId = systemId;
    return true;
}

bool CDomHandler::startElement(const nsCodeQOR::CUCS2String& nsURI, const nsCodeQOR::CUCS2String&, const nsCodeQOR::CUCS2String& qName, const CXmlAttributes& atts)
{
    // tag name
    CDomNodePrivate* n;
    if (nsProcessing) {
        n = doc->createElementNS(nsURI, qName);
    } else {
        n = doc->createElement(qName);
    }

    if (!n)
        return false;

    n->setLocation(locator->LineNumber(), locator->ColumnNumber());

    node->appendChild(n);
    node = n;

    // attributes
    for( int i = 0; i< atts.Length(); i++ )
    {
        if( nsProcessing ) 
		{
            ((CDomElementPrivate*)node)->setAttributeNS(atts.Uri(i), atts.QName(i), atts.Value(i));
        } 
		else 
		{
            ((CDomElementPrivate*)node)->setAttribute(atts.QName(i), atts.Value(i));
        }
    }

    return true;
}

bool CDomHandler::endElement(const nsCodeQOR::CUCS2String&, const nsCodeQOR::CUCS2String&, const nsCodeQOR::CUCS2String&)
{
    if (!node || node == doc)
        return false;
    node = node->parent();

    return true;
}

//------------------------------------------------------------------------------
bool CDomHandler::characters( const nsCodeQOR::CUCS2String& ch )
{
    // No text as child of some document
    if( node == doc )
	{
        return false;
	}

    //QScopedPointer<CDomNodePrivate> n;
	nsCodeQOR::CTLRef< CDomNodePrivate > n;
    if( cdata ) 
	{
        n.Attach( doc->createCDATASection( ch ) );
    } 
	else if( !entityName.IsEmpty() ) 
	{
		nsCodeQOR::CTLRef< CDomNodePrivate > e( new CDomEntityPrivate( doc, 0, entityName, nsCodeQOR::CUCS2String(), nsCodeQOR::CUCS2String(), nsCodeQOR::CUCS2String() ), true );
        //QScopedPointer<CDomEntityPrivate> e(new CDomEntityPrivate(doc, 0, entityName, nsCodeQOR::CUCS2String(), nsCodeQOR::CUCS2String(), nsCodeQOR::CUCS2String()));
        e->value = ch;
        doc->doctype()->appendChild( e );
        e.Detach();
        n.Attach( doc->createEntityReference( entityName ) );
    } 
	else 
	{
        n.Attach( doc->createTextNode( ch ) );
    }
    n->setLocation(locator->LineNumber(), locator->ColumnNumber());
    node->appendChild( n );
    n.Detach();

    return true;
}

bool CDomHandler::processingInstruction(const nsCodeQOR::CUCS2String& target, const nsCodeQOR::CUCS2String& data)
{
    CDomNodePrivate *n;
    n = doc->createProcessingInstruction(target, data);
    if (n) {
        n->setLocation(locator->LineNumber(), locator->ColumnNumber());
        node->appendChild(n);
        return true;
    }
    else
        return false;
}

extern bool qt_xml_skipped_entity_in_content;
bool CDomHandler::skippedEntity(const nsCodeQOR::CUCS2String& name)
{
    // we can only handle inserting entity references into content
    if (!qt_xml_skipped_entity_in_content)
        return true;

    CDomNodePrivate *n = doc->createEntityReference(name);
    n->setLocation(locator->LineNumber(), locator->ColumnNumber());
    node->appendChild(n);
    return true;
}

bool CDomHandler::fatalError(const CXmlParseException& exception)
{
    errorMsg = exception.Message();
    errorLine =  exception.LineNumber();
    errorColumn =  exception.ColumnNumber();
    return CXmlDefaultHandler::fatalError(exception);
}

bool CDomHandler::startCDATA()
{
    cdata = true;
    return true;
}

bool CDomHandler::endCDATA()
{
    cdata = false;
    return true;
}

bool CDomHandler::startEntity(const nsCodeQOR::CUCS2String &name)
{
    entityName = name;
    return true;
}

bool CDomHandler::endEntity(const nsCodeQOR::CUCS2String &)
{
    entityName.Clear();
    return true;
}

bool CDomHandler::comment(const nsCodeQOR::CUCS2String& ch)
{
    CDomNodePrivate *n;
    n = doc->createComment(ch);
    n->setLocation(locator->LineNumber(), locator->ColumnNumber());
    node->appendChild(n);
    return true;
}

bool CDomHandler::unparsedEntityDecl(const nsCodeQOR::CUCS2String &name, const nsCodeQOR::CUCS2String &publicId, const nsCodeQOR::CUCS2String &systemId, const nsCodeQOR::CUCS2String &notationName)
{
    CDomEntityPrivate* e = new CDomEntityPrivate(doc, 0, name,
            publicId, systemId, notationName);
    doc->doctype()->appendChild(e);
    return true;
}

bool CDomHandler::externalEntityDecl(const nsCodeQOR::CUCS2String &name, const nsCodeQOR::CUCS2String &publicId, const nsCodeQOR::CUCS2String &systemId)
{
    return unparsedEntityDecl(name, publicId, systemId, nsCodeQOR::CUCS2String());
}

bool CDomHandler::notationDecl(const nsCodeQOR::CUCS2String & name, const nsCodeQOR::CUCS2String & publicId, const nsCodeQOR::CUCS2String & systemId)
{
    CDomNotationPrivate* n = new CDomNotationPrivate(doc, 0, name, publicId, systemId);
    doc->doctype()->appendChild(n);
    return true;
}

void CDomHandler::setDocumentLocator(CXmlLocator *locator)
{
    this->locator = locator;
}

}//nsBluefoot
