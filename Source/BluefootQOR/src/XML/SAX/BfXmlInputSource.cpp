//BfXmlInputSource.cpp

// Copyright Querysoft Limited 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.


#include "BluefootQOR/XML/SAX/BfXmlInputSource.h"

//------------------------------------------------------------------------------
namespace nsBluefoot
{
	//------------------------------------------------------------------------------
	class CXmlInputSourcePrivate
	{
	public:

//		QIODevice *inputDevice;
//		QTextStream *inputStream;

		nsCodeQOR::CUCS2String str;
		const nsCodeQOR::CChar16* unicode;
		int pos;
		int length;
		bool nextReturnedEndOfData;

	#ifndef QT_NO_TEXTCODEC
//		QTextDecoder *encMapper;
	#endif

		nsCodeQOR::CTArray< byte > encodingDeclBytes;
		//QByteArray encodingDeclBytes;
		nsCodeQOR::CUCS2String encodingDeclChars;
		bool lookingForEncodingDecl;
	};





	/*!
		\class CXmlInputSource
		\reentrant
		\brief The CXmlInputSource class provides the input data for the
		QXmlReader subclasses.

		\inmodule QtXml
		\ingroup xml-tools

		All subclasses of QXmlReader read the input XML document from this
		class.

		This class recognizes the encoding of the data by reading the
		encoding declaration in the XML file if it finds one, and reading
		the data using the corresponding encoding. If it does not find an
		encoding declaration, then it assumes that the data is either in
		UTF-8 or UTF-16, depending on whether it can find a byte-order
		mark.

		There are two ways to populate the input source with data: you can
		construct it with a QIODevice* so that the input source reads the
		data from that device. Or you can set the data explicitly with one
		of the setData() functions.

		Usually you either construct a CXmlInputSource that works on a
		QIODevice* or you construct an empty CXmlInputSource and set the
		data with setData(). There are only rare occasions where you would
		want to mix both methods.

		The QXmlReader subclasses use the next() function to read the
		input character by character. If you want to start from the
		beginning again, use reset().

		The functions data() and fetchData() are useful if you want to do
		something with the data other than parsing, e.g. displaying the
		raw XML file. The benefit of using the QXmlInputClass in such
		cases is that it tries to use the correct encoding.
	*/

	// the following two are guaranteed not to be a character
	const unsigned short CXmlInputSource::EndOfData = 0xfffe;
	const unsigned short CXmlInputSource::EndOfDocument = 0xffff;

	//------------------------------------------------------------------------------
	//Common part of the constructors.
	void CXmlInputSource::Init()
	{
		d = new CXmlInputSourcePrivate;

		d->nextReturnedEndOfData = true;
		d->encodingDeclBytes.Clear();
		d->encodingDeclChars.Clear();
		d->lookingForEncodingDecl = true;
	}

	//------------------------------------------------------------------------------
	//Constructs an input source which contains no data.
	CXmlInputSource::CXmlInputSource()
	{
		Init();
	}

	//------------------------------------------------------------------------------
	CXmlInputSource::~CXmlInputSource()
	{
		delete d;
	}

	//------------------------------------------------------------------------------
	/*!
	Returns the next character of the input source. If this function
	reaches the end of available data, it returns
	CXmlInputSource::EndOfData. If you call next() after that, it
	tries to fetch more data by calling fetchData(). If the
	fetchData() call results in new data, this function returns the
	first character of that data; otherwise it returns
	CXmlInputSource::EndOfDocument.

	Readers, such as QXmlSimpleReader, will assume that the end of
	the XML document has been reached if the this function returns
	CXmlInputSource::EndOfDocument, and will check that the
	supplied input is well-formed. Therefore, when reimplementing
	this function, it is important to ensure that this behavior is
	duplicated.
	*/
	nsCodeQOR::CChar16 CXmlInputSource::Next()
	{
		if( d->pos >= d->length )
		{
			if( d->nextReturnedEndOfData )
			{
				d->nextReturnedEndOfData = false;
				FetchData();
				if( d->pos >= d->length )
				{
					return EndOfDocument;
				}
				return Next();
			}
			d->nextReturnedEndOfData = true;
			return EndOfData;
		}

		nsCodeQOR::CChar16 c = d->unicode[ d->pos++ ];
		if( c.Unicode() == EndOfData )
		{
			c = EndOfDocument;
		}
		return c;
	}

	//------------------------------------------------------------------------------
	/* This function sets the position used by next() to the beginning of
		the data returned by data(). This is useful if you want to use the
		input source for more than one parse.

		\note In the case that the underlying data source is a QIODevice,
		the current position in the device is not automatically set to the
		start of input. Call QIODevice::seek(0) on the device to do this.

		\sa next()
	*/
	void CXmlInputSource::Reset()
	{
		d->nextReturnedEndOfData = false;
		d->pos = 0;
	}

	//------------------------------------------------------------------------------
	/* Returns the data the input source contains or an empty string if the
		input source does not contain any data.

		\sa setData() CXmlInputSource() fetchData()
	*/
	nsCodeQOR::CUCS2String CXmlInputSource::Data() const
	{
		if( d->nextReturnedEndOfData )
		{
			CXmlInputSource* that = const_cast< CXmlInputSource* >( this );
			that->d->nextReturnedEndOfData = false;
			that->FetchData();
		}
		return d->str;
	}

	//------------------------------------------------------------------------------
	/* Sets the data of the input source to \a dat.

		If the input source already contains data, this function deletes
		that data first.

		\sa data()
	*/
	void CXmlInputSource::SetData( const nsCodeQOR::CUCS2String& dat )
	{
		d->str = dat;
		d->unicode = dat;
		d->pos = 0;
		d->length = d->str.Len();
		d->nextReturnedEndOfData = false;
	}

	//------------------------------------------------------------------------------
	/*
		The data \a dat is passed through the correct text-codec, before
		it is set.
	*/
	void CXmlInputSource::SetData( const nsCodeQOR::CTLRef< byte >& data )
	{
		SetData( FromRawData( data ) );
	}
	
	//------------------------------------------------------------------------------
	/* This function reads more data from the device that was set during
		construction. If the input source already contained data, this
		function deletes that data first.

		This object contains no data after a call to this function if the
		object was constructed without a device to read data from or if
		this function was not able to get more data from the device.

		There are two occasions where a fetch is done implicitly by
		another function call: during construction (so that the object
		starts out with some initial data where available), and during a
		call to next() (if the data had run out).

		You don't normally need to use this function if you use next().
	*/
	void CXmlInputSource::FetchData()
	{
		enum
		{
			BufferSize = 1024
		};

		/*
		nsCodeQOR::CTLRef< byte > rawData;

		if( d->inputDevice || d->inputStream )
		{
		}
		*/
	}

	//------------------------------------------------------------------------------
	static std::string ExtractEncodingDecl( const std::string& text, bool *needMoreText)
	{
		return std::string("");
	}

	//------------------------------------------------------------------------------
	/*!
		This function reads the XML file from \a data and tries to
		recognize the encoding. It converts the raw data \a data into a
		QString and returns it. It tries its best to get the correct
		encoding for the XML file.

		If \a beginning is true, this function assumes that the data
		starts at the beginning of a new XML docment and looks for an
		encoding declaration. If \a beginning is false, it converts the
		raw data using the encoding determined from prior calls.
	*/
	nsCodeQOR::CUCS2String CXmlInputSource::FromRawData( const nsCodeQOR::CTLRef< byte > &data, bool beginning)
	{
		return nsCodeQOR::CUCS2String();
	}

}//nsBluefoot
