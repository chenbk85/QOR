//MTDOMNode.cpp

// Copyright Querysoft Limited 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "MammutQOR/Models/DOM/MTDOMNode.h"

#define ATT_NAME _TXT( "NodeName" )
#define ATT_VALUE _TXT( "Value" )
#define ATT_TYPE _TXT( "Type" )
#define ATT_PARENT _TXT( "Parent " )
#define ATT_CHILDREN _TXT( "Children" )
#define ATT_FIRSTCHILD _TXT( "FirstChild" )
#define ATT_LASTCHILD _TXT( "LastChild" )
#define ATT_PREVIOUSSIBLING _TXT( "PreviousSibling" )
#define ATT_NEXTSIBLING _TXT( "NextSibling" )
#define ATT_ATTRIBUTES _TXT( "Attributes" )
#define ATT_DOCUMENT _TXT( "Document" )

//------------------------------------------------------------------------------
namespace nsMammut
{
	//------------------------------------------------------------------------------
	CDOMNode::CDOMNode(CModel* pContainer) : CPropertySet(pContainer)
	, m_NodeName(this, ATT_NAME)
	, m_NodeValue(this, ATT_VALUE)
	, m_NodeType(this, ATT_TYPE)
	, m_ParentNode(this, ATT_PARENT)
	, m_ChildNodes(this, ATT_CHILDREN)
	, m_FirstChild(this, ATT_FIRSTCHILD, m_ChildNodes.Value().begin().Index())
	, m_LastChild(this, ATT_LASTCHILD, m_ChildNodes.Value().end().Index())
	, m_PreviousSibling(this, ATT_PREVIOUSSIBLING, m_ParentNode.Value()->m_ChildNodes.Value().end().Index() )
	, m_NextSibling(this, ATT_NEXTSIBLING, m_ParentNode.Value()->m_ChildNodes.Value().end().Index() )
	, m_Attributes( this, ATT_ATTRIBUTES )
	, m_OwnerDocument( this, ATT_DOCUMENT )
	{
	}

	//------------------------------------------------------------------------------
	CDOMNode::CDOMNode(const CDOMNode& src) : CPropertySet(src)
	, m_NodeName(this, src.m_NodeName )
	, m_NodeValue(this, src.m_NodeValue)
	, m_NodeType(this, src.m_NodeType)
	, m_ParentNode(this, src.m_ParentNode)
	, m_ChildNodes(this, src.m_ChildNodes)
	, m_FirstChild(this, src.m_FirstChild)
	, m_LastChild(this, src.m_LastChild)
	, m_PreviousSibling(this, src.m_PreviousSibling)
	, m_NextSibling(this, src.m_NextSibling)
	, m_Attributes(this, src.m_Attributes)
	, m_OwnerDocument(this, src.m_OwnerDocument)
	{
	}

	//--------------------------------------------------------------------------------
	//Construct from a generic PropertySet
	CDOMNode::CDOMNode( CPropertySet& src ) : CPropertySet(src)
	, m_NodeName(this, ATT_NAME, src[ ATT_NAME ] )
	, m_NodeValue(this, ATT_VALUE, src[ ATT_VALUE ] )
	, m_NodeType(this, ATT_TYPE, src[ ATT_TYPE ] )
	, m_ParentNode(this, ATT_PARENT, src[ ATT_PARENT ] )
	, m_ChildNodes(this, ATT_CHILDREN, src[ ATT_CHILDREN ] )
	, m_FirstChild(this, ATT_FIRSTCHILD, src[ ATT_FIRSTCHILD ] )
	, m_LastChild(this, ATT_LASTCHILD, src[ ATT_LASTCHILD ] )
	, m_PreviousSibling(this, ATT_PREVIOUSSIBLING, src[ ATT_PREVIOUSSIBLING ] )
	, m_NextSibling(this, ATT_NEXTSIBLING, src[ ATT_NEXTSIBLING ] )
	, m_Attributes(this, ATT_ATTRIBUTES, src[ ATT_ATTRIBUTES ] )
	, m_OwnerDocument(this, ATT_DOCUMENT, src[ ATT_DOCUMENT ] )
	{
	}

	//------------------------------------------------------------------------------
	CDOMNode::~CDOMNode()
	{
	}

	//------------------------------------------------------------------------------
	CDOMNode& CDOMNode::operator = ( const CDOMNode& src )
	{
		if (&src != this)
		{
			nsMammut::CPropertySet::operator=(src);
			m_NodeName = src.m_NodeName;
			m_NodeValue= src.m_NodeValue;
			m_NodeType = src.m_NodeType;
			m_ParentNode = src.m_ParentNode;
			m_ChildNodes = src.m_ChildNodes;
			m_FirstChild = src.m_FirstChild;
			m_LastChild = src.m_LastChild;
			m_PreviousSibling = src.m_PreviousSibling;
			m_NextSibling = src.m_NextSibling;
			m_Attributes = src.m_Attributes;
			m_OwnerDocument = src.m_OwnerDocument;
		}
		return *this;
	}

	//--------------------------------------------------------------------------------
	//assign from a generic property set
	CDOMNode& CDOMNode::operator = ( nsMammut::CPropertySet& src )
	{
		if (&src != this)
		{
			nsMammut::CPropertySet::operator=(src);
			m_NodeName = src[ ATT_NAME ];
			m_NodeValue = src[ATT_VALUE];
			m_NodeType = src[ATT_TYPE];
			m_ParentNode = src[ATT_PARENT];
			m_ChildNodes = src[ATT_CHILDREN];
			m_FirstChild = src[ATT_FIRSTCHILD];
			m_LastChild = src[ATT_LASTCHILD];
			m_PreviousSibling = src[ATT_PREVIOUSSIBLING];
			m_NextSibling = src[ATT_NEXTSIBLING];
			m_Attributes = src[ATT_ATTRIBUTES];
			m_OwnerDocument = src[ATT_DOCUMENT];
		}
		return *this;
	}

	//------------------------------------------------------------------------------
	bool CDOMNode::operator == ( const CDOMNode& src)
	{
		return &( const_cast< CDOMNode& >( src ) ) == this ? true : false;
	}

	//------------------------------------------------------------------------------
	/*Inserts the node newChild before the existing child node refChild. If refChild is null, insert newChild at the end of the list of children.
	If newChild is a DocumentFragment object, all of its children are inserted, in the same order, before refChild. If the newChild is already in the tree, it is first removed.
	Parameters
	newChild of type Node
	The node to insert.
	refChild of type Node
	The reference node, i.e., the node before which the new node must be inserted.
	Return Value
	Node

	The node being inserted.

	Exceptions
	DOMException

	HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does not allow children of the type of the newChild node, or if the node to insert is one of this node's ancestors.

	WRONG_DOCUMENT_ERR: Raised if newChild was created from a different document than the one that created this node.

	NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly or if the parent of the node being inserted is readonly.

	NOT_FOUND_ERR: Raised if refChild is not a child of this node.*/
	CDOMNode& CDOMNode::InsertBefore(CDOMNode& newChild, CDOMNode& refChild)
	{
		m_ChildNodes.Value().insertat(m_ChildNodes.Value().find(refChild), newChild.Ref());
		return newChild;
	}

	//------------------------------------------------------------------------------
	/*Replaces the child node oldChild with newChild in the list of children, and returns the oldChild node.
	If newChild is a DocumentFragment object, oldChild is replaced by all of the DocumentFragment children, which are inserted in the same order. If the newChild is already in the tree, it is first removed.
	Parameters
	newChild of type Node
	The new node to put in the child list.
	oldChild of type Node
	The node being replaced in the list.
	Return Value
	Node

	The node replaced.

	Exceptions
	DOMException

	HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does not allow children of the type of the newChild node, or it the node to put in is one of this node's ancestors.

	WRONG_DOCUMENT_ERR: Raised if newChild was created from a different document than the one that created this node.

	NO_MODIFICATION_ALLOWED_ERR: Raised if this node or the parent of the new node is readonly.

	NOT_FOUND_ERR: Raised if oldChild is not a child of this node.*/
	CDOMNode & CDOMNode::ReplaceChild(CDOMNode & newChild, CDOMNode & oldChild)
	{
		m_ChildNodes.Value().insertat(m_ChildNodes.Value().erase(m_ChildNodes.Value().find(oldChild)), newChild.Ref());
		return oldChild;
	}

	//------------------------------------------------------------------------------
	/*Removes the child node indicated by oldChild from the list of children, and returns it.
	Parameters
	oldChild of type Node
	The node being removed.
	Return Value
	Node

	The node removed.

	Exceptions
	DOMException

	NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.

	NOT_FOUND_ERR: Raised if oldChild is not a child of this node.*/
	CDOMNode& CDOMNode::RemoveChild(CDOMNode& oldChild)
	{
		m_ChildNodes.Value().erase(m_ChildNodes.Value().find(oldChild));
		return oldChild;
	}

	//------------------------------------------------------------------------------
	/*Adds the node newChild to the end of the list of children of this node. If the newChild is already in the tree, it is first removed.
	Parameters
	newChild of type Node
	The node to add.
	If it is a DocumentFragment object, the entire contents of the document fragment are moved into the child list of this node
	Return Value
	Node

	The node added.

	Exceptions
	DOMException

	HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does not allow children of the type of the newChild node, or if the node to append is one of this node's ancestors.

	WRONG_DOCUMENT_ERR: Raised if newChild was created from a different document than the one that created this node.

	NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.*/
	CDOMNode& CDOMNode::AppendChild( CDOMNode& newChild )
	{
		if( ValidChildType( newChild.m_NodeType ) )
		{
			m_ChildNodes.Value().insert( newChild.Ref() );
		}
		else
		{
			//TODO: Raise error
		}
		return newChild;
	}

	//------------------------------------------------------------------------------
	bool CDOMNode::HasChildNodes(void)
	{
		return m_ChildNodes.Value().size() > 0 ? true : false;
	}

	//------------------------------------------------------------------------------
	/*Returns a duplicate of this node, i.e., serves as a generic copy constructor for nodes.The duplicate node has no parent; (parentNode is null.).
	Cloning an Element copies all attributes and their values, including those generated by the XML processor to represent defaulted attributes, but this method does not copy any text it contains unless it is a deep clone, since the text is contained in a child Text node.Cloning an Attribute directly, as opposed to be cloned as part of an Element cloning operation, returns a specified attribute(specified is true).Cloning any other type of node simply returns a copy of this node.
	Note that cloning an immutable subtree results in a mutable copy, but the children of an EntityReference clone are readonly.In addition, clones of unspecified Attr nodes are specified.And, cloning Document, DocumentType, Entity, and Notation nodes is implementation dependent.
	Parameters
	deep of type boolean
	If true, recursively clone the subtree under the specified node; if false, clone only the node itself(and its attributes, if it is an Element).
	Return Value
	Node

	The duplicate node.

	Exceptions
	DOMException

	NOT_SUPPORTED_ERR : Raised if this node is a of type DOCUMENT_NODE, DOCUMENT_TYPE_NODE, ENTITY_NODE, or NOTATION_NODE and the implementation does not support cloning this type of node.*/
	CDOMNode& CDOMNode::CloneNode(bool bDeep)
	{
		CDOMNode* pClone = new CDOMNode(*this);
		//TODO: fullfil spec above
		return *pClone;
	}

	//------------------------------------------------------------------------------
	bool CDOMNode::ValidChildType( CMUint16 NodeType )
	{
		return false;
	}

}//nsMammut

