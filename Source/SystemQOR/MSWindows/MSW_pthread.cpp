//MSW_pthread.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//MSWindows POSIX threads implementation

#include "SystemQOR.h"
#include <errno.h>
#include <pthread.h>
#include <semaphore.h>
#include <exception>
#include "SystemQOR/MSWindows/MSW_pthread.h"
#include <sys/timeb.h>
#include "WinQL/WinQL.h"
#include "WinQL/Application/Threading/WinQLTLS.h"
#include "WinQL/CodeServices/Handles/WinQLHandle.h"

#if		(QOR_SYS_OS == QOR_SYS_MSW)

//--------------------------------------------------------------------------------
namespace nsWin32
{
	//--------------------------------------------------------------------------------
	Cpthread::Cpthread()
	{
		__QCS_MEMBER_FCONTEXT( "Cpthread::Cpthread" );
	}

	//--------------------------------------------------------------------------------
	Cpthread::~Cpthread()
	{
		__QCS_MEMBER_FCONTEXT( "Cpthread::~Cpthread" );
	}


//	int Cpthread::ptw32_processInitialized = PTW32_FALSE;
//	pthread_key_t Cpthread::ptw32_selfThreadKey = 0;
//	pthread_key_t Cpthread::ptw32_cleanupKey = 0;
//	pthread_cond_t Cpthread::ptw32_cond_list_head = 0;
//	pthread_cond_t Cpthread::ptw32_cond_list_tail = 0;
//
//	ptw32_thread_t* Cpthread::ptw32_threadReuseTop = PTW32_THREAD_REUSE_EMPTY;
//	ptw32_thread_t* Cpthread::ptw32_threadReuseBottom = PTW32_THREAD_REUSE_EMPTY;
//	int Cpthread::ptw32_concurrency = 0;
//
//	nsWin32::nsSync::CCriticalSection Cpthread::ptw32_thread_reuse_lock;
//	nsWin32::nsSync::CCriticalSection Cpthread::ptw32_mutex_test_init_lock;
//	nsWin32::nsSync::CCriticalSection Cpthread::ptw32_cond_test_init_lock;
//	nsWin32::nsSync::CCriticalSection Cpthread::ptw32_rwlock_test_init_lock;
//	nsWin32::nsSync::CCriticalSection Cpthread::ptw32_spinlock_test_init_lock;
//	nsWin32::nsSync::CCriticalSection Cpthread::ptw32_cond_list_lock;
//
//	pthread_mutexattr_t_ Cpthread::ptw32_recursive_mutexattr_s = { PTHREAD_PROCESS_PRIVATE, PTHREAD_MUTEX_RECURSIVE };
//	pthread_mutexattr_t_ Cpthread::ptw32_errorcheck_mutexattr_s = { PTHREAD_PROCESS_PRIVATE, PTHREAD_MUTEX_ERRORCHECK };
//	pthread_mutexattr_t Cpthread::ptw32_recursive_mutexattr = &ptw32_recursive_mutexattr_s;
//	pthread_mutexattr_t Cpthread::ptw32_errorcheck_mutexattr = &ptw32_errorcheck_mutexattr_s;
//
//	unsigned long( *Cpthread::ptw32_register_cancelation )( PAPCFUNC, void*, unsigned long ) = 0;
//	std::terminate_function Cpthread::ptw32_oldTerminate = 0;
//	long ( __QCMP_STDCALLCONVENTION * Cpthread::ptw32_interlocked_compare_exchange ) ( long*, long, long ) = 0;
//	nsWin32::nsSync::CInterlockedHelper Cpthread::ptw32_InterlockedHelper;
//	nsWin32::nsCodeServices::CTLSHelper Cpthread::ptw32_TLSHelper;
//	nsWin32::nsSync::CWaitHelper Cpthread::ptw32_WaitHelper;
//	nsWin32::nsCodeServices::CErrorHelper Cpthread::ptw32_ErrorHelper;
//	nsWin32::nsCodeServices::CThreadHelper Cpthread::ptw32_ThreadHelper;
//
//	//------------------------------------------------------------------------------
//#if ! defined (__MINGW32__) || (defined (__MSVCRT__) && ! defined (__DMC__))
//	unsigned
//	__stdcall
//#else
//	void
//#endif
//	Cpthread::ptw32_threadStart( void* vthreadParms )
//	{
//		ThreadParms * threadParms = (ThreadParms *) vthreadParms;
//		pthread_t self;
//		ptw32_thread_t* sp;
//		void* ( *start ) ( void* );
//		void* arg;
//
//#ifdef __CLEANUP_SEH
//		unsigned long ei[] = { 0, 0, 0 };
//#endif
//
//#ifdef __CLEANUP_C
//		int setjmp_rc;
//#endif
//		void* status = (void *) 0;
//
//		self = threadParms->tid;
//		sp = (ptw32_thread_t*) self.p;
//		start = threadParms->start;
//		arg = threadParms->arg;
//
//		free( threadParms );
//
//#	if defined (__MINGW32__) && ! defined (__MSVCRT__)
//		/*beginthread does not return the thread id and is running
//		* before it returns us the thread handle, and so we do it here.
//		*/
//		sp->thread = GetCurrentThreadId ();
//		/*Here we're using cancelLock as a general-purpose lock
//		* to make the new thread wait until the creating thread
//		* has the new handle.
//		*/
//		if( pthread_mutex_lock( &sp->cancelLock ) == 0 )
//		{
//			pthread_mutex_unlock( &sp->cancelLock );
//		}
//#	endif
//
//		pthread_setspecific( ptw32_selfThreadKey, sp );
//
//		sp->state = PThreadStateRunning;
//
//#ifdef __CLEANUP_SEH
//
//		__try
//		{
//			//Run the caller's routine;
//			status = sp->exitStatus = (*start) (arg);
//#	ifdef _UWIN
//			if( --pthread_count <= 0 )
//			{
//				exit (0);
//			}
//#	endif
//		}
//		__except( ExceptionFilter( GetExceptionInformation(), ei ) )
//		{
//			switch( ei[ 0 ] )
//			{
//			case PTW32_EPS_CANCEL:
//				status = sp->exitStatus = PTHREAD_CANCELED;
//#	ifdef _UWIN
//				if( --pthread_count <= 0 )
//				{
//					exit( 0 );
//				}
//#	endif
//				break;
//			case PTW32_EPS_EXIT:
//				status = sp->exitStatus;
//				break;
//			default:
//				status = sp->exitStatus = PTHREAD_CANCELED;
//				break;
//			}
//		}
//
//#else /* __CLEANUP_SEH */
//
//#	ifdef __CLEANUP_C
//
//		setjmp_rc = setjmp( sp->start_mark );
//
//		if( 0 == setjmp_rc )
//		{
//			//Run the caller's routine;
//			status = sp->exitStatus = (*start) (arg);
//		}
//		else
//		{
//			switch( setjmp_rc )
//			{
//			case PTW32_EPS_CANCEL:
//				status = sp->exitStatus = PTHREAD_CANCELED;
//				break;
//			case PTW32_EPS_EXIT:
//				status = sp->exitStatus;
//				break;
//			default:
//				status = sp->exitStatus = PTHREAD_CANCELED;
//				break;
//			}
//		}
//
//#	else /* __CLEANUP_C */
//
//#		ifdef __CLEANUP_CXX
//
//		ptw32_oldTerminate = std::set_terminate (&ptw32_terminate);
//
//		try
//		{
//			/*Run the caller's routine in a nested try block so that we
//			* can run the user's terminate function, which may call
//			* pthread_exit() or be canceled.
//			*/
//			try
//			{
//				status = sp->exitStatus = (*start) (arg);
//			}
//			catch( ptw32_exception& )
//			{
//				//Pass these through to the outer block.
//				throw;
//			}
//			catch (...)
//			{
//				/*We want to run the user's terminate function if supplied.
//				* That function may call pthread_exit() or be canceled, which will
//				* be handled by the outer try block.
//				*
//				* ptw32_terminate() will be called if there is no user
//				* supplied function.
//				*/
//
//				std::terminate_function term_func = std::set_terminate( 0 );
//				std::set_terminate( term_func );
//
//				if( term_func != 0 )
//				{
//					term_func ();
//				}
//
//				throw;
//			}
//		}
//		catch( ptw32_exception_cancel& )
//		{
//			//Thread was canceled.
//			status = sp->exitStatus = PTHREAD_CANCELED;
//		}
//		catch( ptw32_exception_exit& )
//		{
//			//Thread was exited via pthread_exit().
//			status = sp->exitStatus;
//		}
//		catch (...)
//		{
//			/*A system unexpected exception has occurred running the user's
//			* terminate routine. We get control back within this block - cleanup
//			* and release the exception out of thread scope.
//			*/
//			status = sp->exitStatus = PTHREAD_CANCELED;
//			pthread_mutex_lock( &sp->cancelLock );
//			sp->state = PThreadStateException;
//			pthread_mutex_unlock (&sp->cancelLock);
//			pthread_win32_thread_detach_np();
//			std::set_terminate( ptw32_oldTerminate );
//			throw;
//			//Never reached.
//		}
//
//		std::set_terminate( ptw32_oldTerminate );
//
//#		else
//
//#			error ERROR [__FILE__, line __LINE__]: Cleanup type undefined.
//
//#		endif /* __CLEANUP_CXX */
//#	endif /* __CLEANUP_C */
//#endif /* __CLEANUP_SEH */
//
//#if defined(PTW32_STATIC_LIB)
//		/*We need to cleanup the pthread now if we have
//		* been statically linked, in which case the cleanup
//		* in dllMain won't get done. Joinable threads will
//		* only be partially cleaned up and must be fully cleaned
//		* up by pthread_join() or pthread_detach().
//		*
//		* Note: if this library has been statically linked,
//		* implicitly created pthreads (those created
//		* for Win32 threads which have called pthreads routines)
//		* must be cleaned up explicitly by the application
//		* (by calling pthread_win32_thread_detach_np()).
//		* For the dll, dllMain will do the cleanup automatically.
//		*/
//		pthread_win32_thread_detach_np ();
//#endif
//
//#if ! defined (__MINGW32__) || defined (__MSVCRT__) || defined (__DMC__)
//		_endthreadex ((unsigned) status);
//#else
//		_endthread ();
//#endif
//
//		//Never reached.
//
//#if ! defined (__MINGW32__) || defined (__MSVCRT__) || defined (__DMC__)
//		return (unsigned) status;
//#endif
//
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::pthread_win32_thread_detach_np()
//	{
//		if( ptw32_processInitialized )
//		{
//			//Don't use pthread_self() - to avoid creating an implicit POSIX thread handle unnecessarily.
//			ptw32_thread_t* sp = (ptw32_thread_t*) pthread_getspecific( ptw32_selfThreadKey );
//
//			if( sp != 0 ) // otherwise Win32 thread with no implicit POSIX handle.
//			{
//				ptw32_callUserDestroyRoutines( sp->ptHandle );
//
//				pthread_mutex_lock( &sp->cancelLock );
//				sp->state = PThreadStateLast;
//				/*If the thread is joinable at this point then it MUST be joined
//				* or detached explicitly by the application.*/
//				pthread_mutex_unlock( &sp->cancelLock );
//
//				if( sp->detachState == PTHREAD_CREATE_DETACHED )
//				{
//					ptw32_threadDestroy( sp->ptHandle );
//					nsWin32::nsCodeServices::CTLSHelper TLSHelper;
//					ptw32_TLSHelper.SetValue( ptw32_selfThreadKey->key, 0 );
//				}
//			}
//		}
//
//		return 1;
//	}
//
//	//------------------------------------------------------------------------------
//	void Cpthread::ptw32_threadDestroy( pthread_t thread )
//	{
//		ptw32_thread_t* tp = (ptw32_thread_t*)thread.p;
//		ptw32_thread_t threadCopy;
//
//		if( tp != 0 )
//		{
//			//Copy thread state so that the thread can be atomically NULLed.
//			memcpy( &threadCopy, tp, sizeof( threadCopy ) );
//
//			/*Thread ID structs are never freed. They're NULLed and reused.
//			* This also sets the thread to PThreadStateInitial (invalid).*/
//			ptw32_threadReusePush( thread );
//
//			// Now work on the copy.
//			if( threadCopy.cancelEvent != 0 )
//			{
//				delete threadCopy.cancelEvent;
//				threadCopy.cancelEvent = 0;
//			}
//
//			(void) pthread_mutex_destroy( &threadCopy.cancelLock );
//			(void) pthread_mutex_destroy( &threadCopy.threadLock );
//
//#if ! defined (__MINGW32__) || defined (__MSVCRT__) || defined (__DMC__)
//			//See documentation for endthread vs endthreadex.
//			if( threadCopy.threadH != 0 )
//			{
//				delete threadCopy.threadH;
//			}
//#endif
//		}
//	}
//
//	//------------------------------------------------------------------------------
//	void Cpthread::ptw32_tkAssocDestroy( ThreadKeyAssoc* assoc )
//	{
//		//Both key->keyLock and thread->threadLock are locked on entry to this routine.
//		if( assoc != 0 )
//		{
//			ThreadKeyAssoc * prev, * next;
//
//			// Remove assoc from thread's keys chain
//			prev = assoc->prevKey;
//			next = assoc->nextKey;
//			if( prev != 0 )
//			{
//				prev->nextKey = next;
//			}
//
//			if( next != 0 )
//			{
//				next->prevKey = prev;
//			}
//
//			if( assoc->thread->keys == assoc )
//			{
//				// We're at the head of the thread's keys chain
//				assoc->thread->keys = next;
//			}
//
//			if( assoc->thread->nextAssoc == assoc )
//			{
//				//Thread is exiting and we're deleting the assoc to be processed next.
//				//Hand thread the assoc after this one.
//				assoc->thread->nextAssoc = next;
//			}
//
//			// Remove assoc from key's threads chain
//			prev = assoc->prevThread;
//			next = assoc->nextThread;
//
//			if( prev != 0 )
//			{
//				prev->nextThread = next;
//			}
//
//			if( next != 0 )
//			{
//				next->prevThread = prev;
//			}
//
//			if( assoc->key->threads == assoc )
//			{
//				// We're at the head of the key's threads chain
//				assoc->key->threads = next;
//			}
//
//			free( assoc );
//		}
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::ptw32_tkAssocCreate( ptw32_thread_t* sp, pthread_key_t key )
//	{
//		ThreadKeyAssoc* assoc;
//
//		/*Have to create an association and add it
//		* to both the key and the thread.
//		*
//		* Both key->keyLock and thread->threadLock are locked on
//		* entry to this routine.*/
//		assoc = (ThreadKeyAssoc*) calloc( 1, sizeof (*assoc) );
//
//		if( assoc == 0 )
//		{
//			return ENOMEM;
//		}
//
//		assoc->thread = sp;
//		assoc->key = key;
//
//		//Register assoc with key
//		assoc->prevThread = 0;
//		assoc->nextThread = (ThreadKeyAssoc *) key->threads;
//		if( assoc->nextThread != 0 )
//		{
//			assoc->nextThread->prevThread = assoc;
//		}
//		key->threads = (void *) assoc;
//
//		//Register assoc with thread
//		assoc->prevKey = 0;
//		assoc->nextKey = (ThreadKeyAssoc *) sp->keys;
//		if (assoc->nextKey != NULL)
//		{
//			assoc->nextKey->prevKey = assoc;
//		}
//		sp->keys = (void *) assoc;
//		return (0);
//	}
//
//	//------------------------------------------------------------------------------
//	void Cpthread::ptw32_cond_wait_cleanup( void* args )
//	{
//		ptw32_cond_wait_cleanup_args_t* cleanup_args = (ptw32_cond_wait_cleanup_args_t*)args;
//		pthread_cond_t cv = cleanup_args->cv;
//		int* resultPtr = cleanup_args->resultPtr;
//		int nSignalsWasLeft;
//		int result;
//
//		/*Whether we got here as a result of signal/broadcast or because of
//		* timeout on wait or thread cancellation we indicate that we are no
//		* longer waiting. The waiter is responsible for adjusting waiters
//		* (to)unblock(ed) counts (protected by unblock lock).
//		*/
//		if( ( result = pthread_mutex_lock( &(cv->mtxUnblockLock) ) ) != 0 )
//		{
//			*resultPtr = result;
//			return;
//		}
//
//		if( 0 != ( nSignalsWasLeft = cv->nWaitersToUnblock ) )
//		{
//			--(cv->nWaitersToUnblock);
//		}
//		else if( INT_MAX / 2 == ++( cv->nWaitersGone ) )
//		{
//			// Use the non-cancellable version of sem_wait()
//			if( ptw32_semwait( &(cv->semBlockLock) ) != 0 )
//			{
//				*resultPtr = errno;
//				/*This is a fatal error for this CV,
//				* so we deliberately don't unlock
//				* cv->mtxUnblockLock before returning.
//				*/
//				return;
//			}
//			cv->nWaitersBlocked -= cv->nWaitersGone;
//			if( sem_post( &(cv->semBlockLock) ) != 0 )
//			{
//				*resultPtr = errno;
//				/*This is a fatal error for this CV,
//				* so we deliberately don't unlock
//				* cv->mtxUnblockLock before returning.
//				*/
//				return;
//			}
//			cv->nWaitersGone = 0;
//		}
//
//		if( ( result = pthread_mutex_unlock( &(cv->mtxUnblockLock) ) ) != 0 )
//		{
//			*resultPtr = result;
//			return;
//		}
//
//		if( 1 == nSignalsWasLeft )
//		{
//			if( sem_post( &(cv->semBlockLock) ) != 0 )
//			{
//				*resultPtr = errno;
//				return;
//			}
//		}
//
//		/*XSH: Upon successful return, the mutex has been locked and is owned
//		* by the calling thread.*/
//		if( ( result = pthread_mutex_lock( cleanup_args->mutexPtr ) ) != 0 )
//		{
//			*resultPtr = result;
//		}
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::ptw32_semwait( sem_t* sem )
//	{
//		int result = 0;
//		sem_t s = *sem;
//
//		if( s == 0 )
//		{
//			result = EINVAL;
//		}
//		else
//		{
//			if( ( result = pthread_mutex_lock( &s->lock ) ) == 0 )
//			{
//				int v = --s->value;
//
//				(void) pthread_mutex_unlock (&s->lock);
//
//				if( v < 0 )
//				{
//					// Must wait
//					if( ptw32_WaitHelper.WaitForSingleObject( s->sem, Infinite ) == Wait_Object_0 )
//					{
//#ifdef NEED_SEM
//						if( pthread_mutex_lock( &s->lock ) == 0 )
//						{
//							if( s->leftToUnblock > 0 )
//							{
//								--s->leftToUnblock;
//								SetEvent( s->sem );
//							}
//							pthread_mutex_unlock( &s->lock );
//						}
//#endif
//						return 0;
//					}
//				}
//				else
//				{
//					return 0;
//				}
//			}
//		}
//
//		if( result != 0 )
//		{
//			errno = result;
//			return -1;
//		}
//
//		return 0;
//	}
//
//	//------------------------------------------------------------------------------
//	unsigned long Cpthread::ptw32_relmillisecs( const timespec* abstime )
//	{
//		const int64_t NANOSEC_PER_MILLISEC = 1000000;
//		const int64_t MILLISEC_PER_SEC = 1000;
//		unsigned long milliseconds;
//		int64_t tmpAbsMilliseconds;
//		int64_t tmpCurrMilliseconds;
//#ifdef NEED_FTIME
//		struct timespec currSysTime;
//		FILETIME ft;
//		SYSTEMTIME st;
//#else /* ! NEED_FTIME */
//		_timeb currSysTime;
//#endif /* NEED_FTIME */
//
//		//Calculate timeout as milliseconds from current system time. 
//
//		/*subtract current system time from abstime in a way that checks
//		* that abstime is never in the past, or is never equivalent to the
//		* defined INFINITE value (0xFFFFFFFF).
//		*
//		* Assume all integers are unsigned, i.e. cannot test if less than 0.
//		*/
//		tmpAbsMilliseconds =  (int64_t)abstime->tv_sec * MILLISEC_PER_SEC;
//		tmpAbsMilliseconds += ((int64_t)abstime->tv_nsec + (NANOSEC_PER_MILLISEC/2)) / NANOSEC_PER_MILLISEC;
//
//		// get current system time
//
//#ifdef NEED_FTIME
//
//		GetSystemTime( &st );
//		SystemTimeToFileTime(&st, &ft);
//		//GetSystemTimeAsFileTime(&ft); would be faster,
//		//but it does not exist on WinCE
//
//		ptw32_filetime_to_timespec( &ft, &currSysTime );
//
//		tmpCurrMilliseconds = (int64_t)currSysTime.tv_sec * MILLISEC_PER_SEC;
//		tmpCurrMilliseconds += ((int64_t)currSysTime.tv_nsec + (NANOSEC_PER_MILLISEC/2)) / NANOSEC_PER_MILLISEC;
//
//#else /* ! NEED_FTIME */
//
//		//TODO: _ftime( &currSysTime );
//
//		tmpCurrMilliseconds = (int64_t) currSysTime.time * MILLISEC_PER_SEC;
//		tmpCurrMilliseconds += (int64_t) currSysTime.millitm;
//
//#endif /* NEED_FTIME */
//
//		if( tmpAbsMilliseconds > tmpCurrMilliseconds )
//		{
//			milliseconds = (unsigned long)( tmpAbsMilliseconds - tmpCurrMilliseconds );
//			if( milliseconds == Infinite )
//			{
//				// Timeouts must be finite
//				milliseconds--;
//			}
//		}
//		else
//		{
//			// The abstime given is in the past
//			milliseconds = 0;
//		}
//
//		return milliseconds;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::ptw32_timed_eventwait( void* event, const struct timespec* abstime )
//	{
//		unsigned long milliseconds;
//		unsigned long status;
//
//		if( event == 0 )
//		{
//			return EINVAL;
//		}
//		else
//		{
//			if( abstime == 0 )
//			{
//				milliseconds = Infinite;
//			}
//			else
//			{
//				//Calculate timeout as milliseconds from current system time. 
//				milliseconds = ptw32_relmillisecs( abstime );				
//			}
//
//			status = ptw32_WaitHelper.WaitForSingleObject( event, milliseconds );
//
//			if( status == Wait_Object_0 )
//			{
//				return 0;
//			}
//			else if( status == Wait_Timeout )
//			{
//				return ETIMEDOUT;
//			}
//			else
//			{
//				return EINVAL;
//			}
//		}
//
//		return 0;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::attr_destroy( pthread_attr_t* p_pthread_attr )
//	{
//		int iResult = 0;		
//
//		if( !is_attr( p_pthread_attr ) )
//		{
//			iResult = EINVAL;
//		}		
//		else
//		{
//			CAttribute* pAttribute = reinterpret_cast< CAttribute* >( *p_pthread_attr );
//			*p_pthread_attr = 0;
//			iResult = pAttribute->Destroy();			
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::attr_getdetachstate( const pthread_attr_t* p_pthread_attr, int* pDetachState )
//	{
//		int iResult = 0;		
//		if( !is_attr( p_pthread_attr ) )
//		{
//			iResult = EINVAL;
//		}		
//		else
//		{
//			CAttribute* pAttribute = reinterpret_cast< CAttribute* >( *p_pthread_attr );
//			iResult = pAttribute->GetDetachState( pDetachState );
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::attr_getguardsize( const pthread_attr_t* p_pthread_attr, size_t* guardsize )
//	{
//		int iResult = 0;
//		if( !is_attr( p_pthread_attr ) )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			CAttribute* pAttribute = reinterpret_cast< CAttribute* >( *p_pthread_attr );
//			iResult = pAttribute->GetGuardSize( guardsize );
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::attr_getinheritsched( const pthread_attr_t* p_pthread_attr, int* inheritsched )
//	{
//		int iResult = 0;
//		if( !is_attr( p_pthread_attr ) )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			CAttribute* pAttribute = reinterpret_cast< CAttribute* >( *p_pthread_attr );
//			iResult = pAttribute->GetInheritSchedule( inheritsched );
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::attr_getschedparam( const pthread_attr_t* p_pthread_attr, struct sched_param* param )
//	{
//		int iResult = 0;
//		if( !is_attr( p_pthread_attr ) )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			CAttribute* pAttribute = reinterpret_cast< CAttribute* >( *p_pthread_attr );
//			iResult = pAttribute->GetScheduleParam( param );
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::attr_getschedpolicy( const pthread_attr_t* p_pthread_attr, int* policy )
//	{
//		int iResult = 0;
//		if( !is_attr( p_pthread_attr ) )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			CAttribute* pAttribute = reinterpret_cast< CAttribute* >( *p_pthread_attr );
//			iResult = pAttribute->GetSchedulePolicy( policy );
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::attr_getscope( const pthread_attr_t* p_pthread_attr, int* contentionscope )
//	{
//		int iResult = 0;
//		if( !is_attr( p_pthread_attr ) )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			CAttribute* pAttribute = reinterpret_cast< CAttribute* >( *p_pthread_attr );
//			iResult = pAttribute->GetContentionScope( contentionscope );
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::attr_getstack( const pthread_attr_t* p_pthread_attr, void** stackaddr, size_t* stacksize )
//	{
//		int iResult = 0;
//		if( !is_attr( p_pthread_attr ) )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			CAttribute* pAttribute = reinterpret_cast< CAttribute* >( *p_pthread_attr );
//			iResult = pAttribute->GetStack( stackaddr, stacksize );
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::attr_getstackaddr( const pthread_attr_t* p_pthread_attr, void** stackaddr )
//	{
//		int iResult = 0;
//		if( !is_attr( p_pthread_attr ) )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			CAttribute* pAttribute = reinterpret_cast< CAttribute* >( *p_pthread_attr );
//			iResult = pAttribute->GetStackAddress( stackaddr );
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::attr_getstacksize( const pthread_attr_t* p_pthread_attr, size_t* stacksize )
//	{
//		int iResult = 0;
//		if( !is_attr( p_pthread_attr ) )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			CAttribute* pAttribute = reinterpret_cast< CAttribute* >( *p_pthread_attr );
//			iResult = pAttribute->GetStackSize( stacksize );
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::attr_init( pthread_attr_t* p_pthread_attr )
//	{
//		int iResult = 0;
//		if( p_pthread_attr != 0 && *p_pthread_attr == 0 )
//		{
//			CAttribute* pAttribute = new CAttribute();
//			if( pAttribute == 0 )
//			{
//				iResult = ENOMEM;
//			}
//			else
//			{
//				iResult = pAttribute->Init();
//			}
//		}
//		else
//		{
//			iResult = EINVAL;
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::attr_setdetachstate( pthread_attr_t* p_pthread_attr, int iDetachState )
//	{
//		int iResult = 0;
//		if( !is_attr( p_pthread_attr ) )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			CAttribute* pAttribute = reinterpret_cast< CAttribute* >( *p_pthread_attr );
//			iResult = pAttribute->SetDetachState( iDetachState );
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::attr_setguardsize( pthread_attr_t* p_pthread_attr, size_t guardsize )
//	{
//		int iResult = 0;
//		if( !is_attr( p_pthread_attr ) )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			CAttribute* pAttribute = reinterpret_cast< CAttribute* >( *p_pthread_attr );
//			iResult = pAttribute->SetGuardSize( guardsize );
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::attr_setinheritsched( pthread_attr_t* p_pthread_attr, int inheritsched )
//	{
//		int iResult = 0;
//		if( !is_attr( p_pthread_attr ) )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			CAttribute* pAttribute = reinterpret_cast< CAttribute* >( *p_pthread_attr );
//			iResult = pAttribute->SetInheritSchedule( inheritsched );
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::attr_setschedparam( pthread_attr_t* p_pthread_attr, const struct sched_param* param )
//	{
//		int iResult = 0;
//		if( !is_attr( p_pthread_attr ) )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			CAttribute* pAttribute = reinterpret_cast< CAttribute* >( *p_pthread_attr );
//			iResult = pAttribute->SetScheduleParam( param );
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::attr_setschedpolicy( pthread_attr_t* p_pthread_attr, int iPolicy )
//	{
//		int iResult = 0;
//		if( !is_attr( p_pthread_attr ) )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			CAttribute* pAttribute = reinterpret_cast< CAttribute* >( *p_pthread_attr );
//			iResult = pAttribute->SetSchedulePolicy( iPolicy );
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::attr_setscope( pthread_attr_t* p_pthread_attr, int iContentionScope )
//	{
//		int iResult = 0;
//		if( !is_attr( p_pthread_attr ) )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			CAttribute* pAttribute = reinterpret_cast< CAttribute* >( *p_pthread_attr );
//			iResult = pAttribute->SetContentionScope( iContentionScope );
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::attr_setstack( pthread_attr_t* p_pthread_attr, void* stackaddr, size_t stacksize )
//	{
//		int iResult = 0;
//		if( !is_attr( p_pthread_attr ) )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			CAttribute* pAttribute = reinterpret_cast< CAttribute* >( *p_pthread_attr );
//			iResult = pAttribute->SetStack( stackaddr, stacksize );
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::attr_setstackaddr( pthread_attr_t* p_pthread_attr, void* pStackAddr )
//	{
//		int iResult = 0;
//		if( !is_attr( p_pthread_attr ) )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			CAttribute* pAttribute = reinterpret_cast< CAttribute* >( *p_pthread_attr );
//			iResult = pAttribute->SetStackAddress( pStackAddr );
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::attr_setstacksize( pthread_attr_t* p_pthread_attr, size_t StackSize )
//	{
//		int iResult = 0;
//		if( !is_attr( p_pthread_attr ) )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			CAttribute* pAttribute = reinterpret_cast< CAttribute* >( *p_pthread_attr );
//			iResult = pAttribute->SetStackSize( StackSize );
//		}
//		return iResult;
//	}
//
//
//	//------------------------------------------------------------------------------
//	int Cpthread::barrier_destroy( pthread_barrier_t* p_pthread_barrier )
//	{
//		int iResult = 0;
//
//		if( !is_barrier( p_pthread_barrier ) )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			CBarrier* pBarrier = reinterpret_cast< CBarrier* >( *p_pthread_barrier );
//			*p_pthread_barrier = 0;
//			iResult = pBarrier->Destroy();
//			if( iResult != 0 )
//			{
//				//Restore pointer in case of failure to delete
//				*p_pthread_barrier = reinterpret_cast< pthread_barrier_t >( pBarrier );
//			}
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::barrier_init( pthread_barrier_t* pp_barrier, const pthread_barrierattr_t* pp_barrier_attr, unsigned uiCount )
//	{
//		int iResult = 0;
//		if( pp_barrier == 0 || uiCount == 0)
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			*pp_barrier = new CBarrier( ( pp_barrier_attr == 0 ) ? 0 : reinterpret_cast< const CBarrier::CBarrierAttrib* >( *pp_barrier_attr ), uiCount );
//			if( *pp_barrier == 0 )
//			{
//				iResult = ENOMEM;
//			}
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::barrier_wait( pthread_barrier_t* pp_barrier )
//	{
//		int iResult = 0;
//		if( pp_barrier == 0 || *pp_barrier == 0 )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			CBarrier* pBarrier = reinterpret_cast< CBarrier* >( *pp_barrier );
//			iResult = pBarrier->Wait();
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::barrierattr_destroy( pthread_barrierattr_t* pp_barrierattr )
//	{
//		int iResult = 0;
//		if( pp_barrierattr == 0 || *pp_barrierattr == 0 )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			CBarrier::CBarrierAttrib* pAttrib = reinterpret_cast< CBarrier::CBarrierAttrib* >( *pp_barrierattr );
//			*pp_barrierattr = 0;
//			iResult = pAttrib->Destroy();
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::barrierattr_getpshared( const pthread_barrierattr_t* pp_barrierattr, int* p_pshared )
//	{
//		int iResult = 0;
//		if( pp_barrierattr == 0 || *pp_barrierattr == 0 )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			CBarrier::CBarrierAttrib* pAttrib = reinterpret_cast< CBarrier::CBarrierAttrib* >( *pp_barrierattr );
//			iResult = pAttrib->GetPShared( p_pshared );
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::barrierattr_init( pthread_barrierattr_t* pp_barrierattr )
//	{
//		int iResult = 0;
//		if( pp_barrierattr == 0 || *pp_barrierattr != 0 )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			*pp_barrierattr = new CBarrier::CBarrierAttrib();
//			if( *pp_barrierattr == 0 )
//			{
//				iResult = ENOMEM;
//			}
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::barrierattr_setpshared( pthread_barrierattr_t* pp_barrierattr, int iPShared )
//	{
//		int iResult = 0;
//		if( pp_barrierattr == 0 || *pp_barrierattr != 0 )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			CBarrier::CBarrierAttrib* pAttrib = reinterpret_cast< CBarrier::CBarrierAttrib* >( *pp_barrierattr );
//			iResult = pAttrib->SetPShared( iPShared );
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::cancel( pthread_t hpthread )
//	{
//		int iResult = 0;
//		if( hpthread.p == 0 )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			int cancel_self;
//			pthread_t self;
//			ptw32_thread_t* tp;
//
//			iResult = Kill( hpthread, 0 );
//
//			if( iResult == 0 )
//			{
//				if( ( self = pthread_self() ).p == 0 )
//				{
//					iResult = ENOMEM;
//				}
//				else
//				{
//					/*TODO:
//					* FIXME!!
//					*
//					* Can a thread cancel itself?
//					*
//					* The standard doesn't
//					* specify an error to be returned if the target
//					* thread is itself.
//					*
//					* If it may, then we need to ensure that a thread can't
//					* deadlock itself trying to cancel itself asyncronously
//					* (pthread_cancel is required to be an async-cancel
//					* safe function).*/
//					cancel_self = pthread_equal( hpthread, self );
//					tp = (ptw32_thread_t*) hpthread.p;
//
//					//Lock for async-cancel safety.
//					pthread_mutex_lock( &tp->cancelLock );
//
//					if( tp->cancelType == PTHREAD_CANCEL_ASYNCHRONOUS && tp->cancelState == PTHREAD_CANCEL_ENABLE 
//						&& tp->state < PThreadStateCanceling )
//					{
//						if( cancel_self )
//						{
//							tp->state = PThreadStateCanceling;
//							tp->cancelState = PTHREAD_CANCEL_DISABLE;
//							(void) pthread_mutex_unlock( &tp->cancelLock );
//							ptw32_throw( PTW32_EPS_CANCEL );
//
//							// Never reached
//						}
//						else
//						{
//							tp->threadH->Suspend();
//
//							if( ptw32_WaitHelper.WaitForSingleObject( tp->threadH->Handle(), 0 ) == Wait_Timeout )
//							{
//								tp->state = PThreadStateCanceling;
//								tp->cancelState = PTHREAD_CANCEL_DISABLE;
//								/*If alertdrv and QueueUserAPCEx is available then the following
//								* will result in a call to QueueUserAPCEx with the args given, otherwise
//								* this will result in a call to ptw32_RegisterCancelation and only
//								* the threadH arg will be used.
//								*/
//								ptw32_register_cancelation( (PAPCFUNC)(&Cpthread::CancelCallback), tp->threadH->Handle(), 0 );
//								(void) pthread_mutex_unlock( &tp->cancelLock );
//								tp->threadH->Resume();
//							}
//						}
//					}
//					else
//					{
//						//Set for deferred cancellation.
//						if( tp->state < PThreadStateCancelPending )
//						{
//							tp->state = PThreadStateCancelPending;
//							if ( !tp->cancelEvent->Set() )
//							{
//								iResult = ESRCH;
//							}
//						}
//						else if (tp->state >= PThreadStateCanceling)
//						{
//							iResult = ESRCH;
//						}
//
//						(void) pthread_mutex_unlock (&tp->cancelLock);
//					}
//				}
//			}
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::cleanup_push( void ( *routine )(void *), void* arg )
//	{
//		int iResult = 0;
//
//		ptw32_cleanup_t* cleanup = new ptw32_cleanup_t;
//
//		cleanup->routine = reinterpret_cast< ptw32_cleanup_callback_t >( routine );
//		cleanup->arg = arg;
//		cleanup->prev = (ptw32_cleanup_t*) pthread_getspecific( Cpthread::ptw32_cleanupKey );
//		pthread_setspecific( Cpthread::ptw32_cleanupKey, reinterpret_cast< void* >( cleanup ) );
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::cleanup_pop( int iExecute )
//	{
//		int iResult = 0;
//		ptw32_cleanup_t* cleanup;
//		cleanup = reinterpret_cast< ptw32_cleanup_t* >( pthread_getspecific( Cpthread::ptw32_cleanupKey ) );
//
//		if( cleanup != 0 )
//		{
//			if( iExecute && ( cleanup->routine != 0 ) )
//			{
//				( *cleanup->routine )( cleanup->arg );
//			}
//			iResult = pthread_setspecific( Cpthread::ptw32_cleanupKey, (void*)cleanup->prev );
//			delete cleanup;
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::create( pthread_t* phThread, const pthread_attr_t* pp_threadattr, void *(*start_routine)(void *), void* arg )
//	{
//		int iResult = EAGAIN;
//		pthread_t thread;
//		ptw32_thread_t* tp;
//		pthread_attr_t a;
//		nsWin32::nsCodeServices::CThread* threadH = 0;		
//		int run = PTW32_TRUE;
//		ThreadParms* parms = 0;
//		long stackSize;
//		int priority;
//		pthread_t self;
//
//		/*Before doing anything, check that tid can be stored through
//		* without invoking a memory protection error (segfault).
//		* Make sure that the assignment below can't be optimised out by the compiler.
//		* This is assured by conditionally assigning *tid again at the end.*/
//
//		phThread->x = 0;
//
//		if( pp_threadattr != 0 )
//		{
//			a = *pp_threadattr;
//		}
//		else
//		{
//			a = 0;
//		}
//
//		if( ( thread = ptw32_new() ).p == 0 )
//		{
//			goto FAIL0;
//		}
//
//		tp = ( ptw32_thread_t* ) thread.p;
//
//		priority = tp->sched_priority;
//
//		if( ( parms = reinterpret_cast< ThreadParms* >( malloc( sizeof( *parms ) ) ) ) ==  0 )
//		{
//			goto FAIL0;
//		}
//
//		parms->tid = thread;
//		parms->start = start_routine;
//		parms->arg = arg;
//
//		//Threads inherit their initial sigmask from their creator thread.
//		self = pthread_self();
//		tp->sigmask = ( (ptw32_thread_t*)self.p )->sigmask;
//
//		if( a != 0 )
//		{
//			stackSize = a->stacksize;
//			tp->detachState = a->detachstate;
//			priority = a->param.sched_priority;
//
//#if (THREAD_PRIORITY_LOWEST > THREAD_PRIORITY_NORMAL)
//			// WinCE
//#else
//			// Everything else
//
//			/*Thread priority must be set to a valid system level
//			* without altering the value set by pthread_attr_setschedparam().*/
//
//			/*PTHREAD_EXPLICIT_SCHED is the default because Win32 threads
//			* don't inherit their creator's priority. They are started with
//			* THREAD_PRIORITY_NORMAL (win32 value). The result of not supplying
//			* an 'attr' arg to pthread_create() is equivalent to defaulting to
//			* PTHREAD_EXPLICIT_SCHED and priority THREAD_PRIORITY_NORMAL.*/
//			if( PTHREAD_INHERIT_SCHED == a->inheritsched )
//			{
//				/*If the thread that called pthread_create() is a Win32 thread
//				* then the inherited priority could be the result of a temporary
//				* system adjustment. This is not the case for POSIX threads.*/
//				self = pthread_self();
//
//				priority = ( (ptw32_thread_t*)self.p )->sched_priority;
//			}
//#endif
//		}
//		else
//		{
//			//Default stackSize
//			stackSize = PTHREAD_STACK_MIN;
//		}
//
//		tp->state = run ? PThreadStateInitial : PThreadStateSuspended;
//		tp->keys = 0;
//
//		/*Threads must be started in suspended mode and resumed if necessary
//		* after _beginthreadex returns us the handle. Otherwise we set up a
//		* race condition between the creating and the created threads.
//		* Note that we also retain a local copy of the handle for use
//		* by us in case thread.p->threadH gets NULLed later but before we've
//		* finished with it here.*/
//
//#if ! defined (__MINGW32__) || defined (__MSVCRT__) || defined (__DMC__) 
//
//		tp->threadH = threadH = reinterpret_cast< nsWin32::nsCodeServices::CThread* >( _beginthreadex (
//			(void *) NULL,	/* No security info             */
//			(unsigned) stackSize,	/* default stack size   */
//			ptw32_threadStart,
//			parms,
//			(unsigned) nsWin32::Create_Suspended,
//			(unsigned *) &(tp->thread)
//		) );
//
//		if( threadH != 0 )
//		{
//			if( a != 0 )
//			{
//				(void) ptw32_setthreadpriority( thread, SCHED_OTHER, priority );
//			}
//
//			if( run )
//			{
//				threadH->Resume();
//			}
//		}
//
//#else // __MINGW32__ && ! __MSVCRT__
//
//		/*This lock will force pthread_threadStart() to wait until we have
//		* the thread handle and have set the priority.*/
//		
//		pthread_mutex_lock( &tp->cancelLock );
//
//		tp->threadH = threadH = (void*) _beginthread( 
//			ptw32_threadStart, 
//			(unsigned) stackSize,
//			/* default stack size*/	parms
//		);
//
//		//Make the return code match _beginthreadex's.
//		
//		if( threadH == (void*) - 1L )
//		{
//			tp->threadH = threadH = 0;
//		}
//		else
//		{
//			if( !run )
//			{
//				/*beginthread does not allow for create flags, so we do it now.
//				* Note that beginthread itself creates the thread in SUSPENDED
//				* mode, and then calls ResumeThread to start it.
//				*/
//				threadH->Suspend();
//			}
//
//			if( a != 0 )
//			{
//				ptw32_setthreadpriority( thread, SCHED_OTHER, priority );
//			}
//		}
//
//		pthread_mutex_unlock( &tp->cancelLock );
//
//#endif /* __MINGW32__ && ! __MSVCRT__ */
//
//		iResult = ( threadH != 0 ) ? 0 : EAGAIN;
//
//		//Fall Through Intentionally
//
//		//Failure Code
//
//		FAIL0:
//		if( iResult != 0 )
//		{
//			ptw32_threadDestroy( thread );
//			tp = 0;
//
//			if( parms != 0 )
//			{
//				free( parms );
//			}
//		}
//		else
//		{
//			*phThread = thread;
//		}
//
//#ifdef _UWIN
//		if( result == 0 )
//		{
//			pthread_count++;
//		}
//#endif
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::detach( pthread_t hThread )
//	{
//		int iResult = 0;
//		bool destroyIt = PTW32_FALSE;
//		ptw32_thread_t* tp = ( ptw32_thread_t* ) hThread.p;
//
//		ptw32_thread_reuse_lock.Enter();
//
//		if( 0 == tp || hThread.x != tp->ptHandle.x )
//		{
//			iResult = ESRCH;
//		}
//		else if( PTHREAD_CREATE_DETACHED == tp->detachState )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			/*Joinable ptw32_thread_t structs are not scavenged until
//			* a join or detach is done. The thread may have exited already,
//			* but all of the state and locks etc are still there.*/
//			iResult = 0;
//
//			if( pthread_mutex_lock( &tp->cancelLock ) == 0 )
//			{
//				if( tp->state != PThreadStateLast )
//				{
//					tp->detachState = PTHREAD_CREATE_DETACHED;
//				}
//				else if( tp->detachState != PTHREAD_CREATE_DETACHED )
//				{
//					//Thread is joinable and has exited or is exiting.
//					destroyIt = PTW32_TRUE;
//				}
//				(void) pthread_mutex_unlock( &tp->cancelLock );
//			}
//			else
//			{
//				// cancelLock shouldn't fail, but if it does ...
//				iResult = ESRCH;
//			}
//		}
//
//		ptw32_thread_reuse_lock.Leave();
//
//		if( iResult == 0 )
//		{
//			// Thread is joinable
//			if( destroyIt )
//			{
//				// The thread has exited or is exiting but has not been joined or
//				// detached. Need to wait in case it's still exiting.
//				ptw32_WaitHelper.WaitForSingleObject( tp->threadH->Handle(), Infinite );
//				ptw32_threadDestroy( hThread );
//			}
//		}
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::equal( pthread_t hThread1, pthread_t hThread2 )
//	{
//		int iResult = 0;
//		//We also accept NULL == NULL - treating NULL as a thread
//		//for this special case, because there is no error that we can return.
//		iResult = ( hThread1.p == hThread2.p && hThread1.x == hThread2.x );
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::exit( void* value_ptr )
//	{
//		int iResult = 0;
//
//		ptw32_thread_t* sp;
//
//		//Don't use pthread_self() to avoid creating an implicit POSIX thread handle unnecessarily.
//		
//		sp = ( ptw32_thread_t* ) pthread_getspecific( ptw32_selfThreadKey );
//
//#ifdef _UWIN
//		if (--pthread_count <= 0)
//		exit( (int)value_ptr );
//#endif
//
//		if( 0 == sp )
//		{
//			/*A POSIX thread handle was never created. I.e. this is a
//			* Win32 thread that has never called a pthreads-win32 routine that
//			* required a POSIX handle.
//			*
//			* Implicit POSIX handles are cleaned up in ptw32_throw() now.*/
//
//#if ! defined (__MINGW32__) || defined (__MSVCRT__)  || defined (__DMC__)
//			_endthreadex ((unsigned) value_ptr);
//#else
//			_endthread ();
//#endif
//
//			// Never reached
//		}
//
//		sp->exitStatus = value_ptr;
//
//		ptw32_throw( PTW32_EPS_EXIT );
//
//		// Never reached.
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::getconcurrency( void )
//	{
//		int iResult = 0;
//		iResult = ptw32_concurrency;
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::getcpuclockid( pthread_t hThread, clockid_t* pClockId )
//	{
//		int iResult = 0;
//		///TODO:
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::getschedparam( pthread_t hThread, int* pPolicy, struct sched_param* pParam )
//	{
//		int iResult = 0;
//
//		// Validate the thread id.
//		iResult = Kill( hThread, 0 );
//		if( 0 == iResult )
//		{
//			//Validate the policy and param args.
//			//Check that a policy constant wasn't passed rather than &policy.
//			if( pPolicy <= (int*) SCHED_MAX || pPolicy == 0 )
//			{
//				iResult = EINVAL;
//			}
//			else
//			{
//				// Fill out the policy.
//				*pPolicy = SCHED_OTHER;
//
//				/*This function must return the priority value set by
//				* the most recent pthread_setschedparam() or pthread_create()
//				* for the target thread. It must not return the actual thread
//				* priority as altered by any system priority adjustments etc.*/
//				pParam->sched_priority = ( (ptw32_thread_t*)hThread.p )->sched_priority;
//			}
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	void* Cpthread::getspecific( pthread_key_t p_pthreadkey )
//	{
//		void* pResult = 0;
//
//		if( p_pthreadkey != 0 )
//		{
//			int lasterror = ptw32_ErrorHelper.GetLastError();
//			//TODO: Restore once WSA wrapper is available
//			//int lastWSAerror = WSAGetLastError ();
//
//			pResult = ptw32_TLSHelper.GetValue( p_pthreadkey->key );
//
//			ptw32_ErrorHelper.SetLastError( lasterror );
//			//WSASetLastError( lastWSAerror );
//		}
//
//		return pResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::join( pthread_t hThread, void** ppValue )
//	{
//		int iResult = 0;
//
//		pthread_t self;
//		ptw32_thread_t * tp = (ptw32_thread_t *) hThread.p;
//
//		ptw32_thread_reuse_lock.Enter();
//
//		if( 0 == tp || hThread.x != tp->ptHandle.x )
//		{
//			iResult = ESRCH;
//		}
//		else if( PTHREAD_CREATE_DETACHED == tp->detachState )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			iResult = 0;
//		}
//
//		ptw32_thread_reuse_lock.Leave();
//
//		if( iResult == 0 )
//		{
//			//The target thread is joinable and can't be reused before we join it.
//			
//			self = pthread_self();
//
//			if( 0 == self.p )
//			{
//				iResult = ENOENT;
//			}
//			else if( pthread_equal( self, hThread ) )
//			{
//				iResult = EDEADLK;
//			}
//			else
//			{
//				/*Pthread_join is a cancelation point.
//				* If we are canceled then our target thread must not be
//				* detached (destroyed). This is guaranteed because
//				* pthreadCancelableWait will not return if we
//				* are canceled.
//				*/
//				iResult = pthreadCancelableWait( tp->threadH->Handle() );
//
//				if( 0 == iResult )
//				{
//					if( ppValue != 0 )
//					{
//						*ppValue = tp->exitStatus;
//					}
//
//					/*The result of making multiple simultaneous calls to
//					* pthread_join() or pthread_detach() specifying the same
//					* target is undefined.*/
//					iResult = pthread_detach( hThread );
//				}
//				else
//				{
//					iResult = ESRCH;
//				}
//			}
//		}
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	pthread_t Cpthread::self( void )
//	{
//		pthread_t Result;
//		pthread_t nil = { 0, 0 };
//		ptw32_thread_t* sp;
//
//#ifdef _UWIN
//		if( !ptw32_selfThreadKey )
//		{
//			return nil;
//		}
//#endif
//
//		sp = (ptw32_thread_t*) pthread_getspecific( ptw32_selfThreadKey );
//
//		if( sp != 0 )
//		{
//			Result = sp->ptHandle;
//		}
//		else
//		{
//			//Need to create an implicit 'self' for the currently executing thread.
//			
//			Result = ptw32_new ();
//			sp = (ptw32_thread_t*) Result.p;
//
//			if( sp != 0 )
//			{
//				/*This is a non-POSIX thread which has chosen to call
//				* a POSIX threads function for some reason. We assume that
//				* it isn't joinable, but we do assume that it's
//				* (deferred) cancelable.*/
//				sp->implicit = 1;
//				sp->detachState = PTHREAD_CREATE_DETACHED;
//				sp->thread = nsWin32::nsCodeServices::CThread::GetCurrentId();
//
//#ifdef NEED_DUPLICATEHANDLE
//				/*DuplicateHandle does not exist on WinCE.
//				*
//				* NOTE:
//				* GetCurrentThread only returns a pseudo-handle
//				* which is only valid in the current thread context.
//				* Therefore, you should not pass the handle to
//				* other threads for whatever purpose.
//				*/
//				sp->threadH = nsWin32::nsCodeServices::CThread::GetCurrent();
//#else
//				//bool CHandle::Duplicate( void* hSourceProcessHandle, void* hTargetProcessHandle, void** lpTargetHandle, unsigned long dwDesiredAccess, bool bInheritHandle, unsigned long dwOptions )
//				nsWin32::nsCodeServices::CHandle Handle( 0 );
//				if( ! Handle.Duplicate( nsWin32::nsCodeServices::CProcess::GetCurrent(),
//					nsWin32::nsCodeServices::CProcess::GetCurrent(), (void**)&sp->threadH, 0, false, nsWin32::Duplicate_Same_Access ) )
//				{
//					/*Should not do this, but we have no alternative if
//					* we can't get a Win32 thread handle.
//					* Thread structs are never freed.*/
//					ptw32_threadReusePush ( Result );
//					return nil;
//				}
//#endif
//				//No need to explicitly serialise access to sched_priority
//				// because the new handle is not yet public.
//				
//				sp->sched_priority = sp->threadH->GetPriority();
//
//				pthread_setspecific( ptw32_selfThreadKey, (void*)sp );
//			}
//		}
//
//		return Result;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::setcancelstate( int iState, int* piOldState )
//	{
//		int iResult = 0;
//		pthread_t self = pthread_self();
//		ptw32_thread_t* sp = (ptw32_thread_t *)self.p;
//
//		if( sp == 0 || ( iState != PTHREAD_CANCEL_ENABLE && iState != PTHREAD_CANCEL_DISABLE ) )
//		{
//			return EINVAL;
//		}
//
//		//Lock for async-cancel safety.
//		
//		pthread_mutex_lock( &sp->cancelLock );
//
//		if( piOldState != 0 )
//		{
//			*piOldState = sp->cancelState;
//		}
//
//		sp->cancelState = iState;
//
//		//Check if there is a pending asynchronous cancel
//		
//		if( iState == PTHREAD_CANCEL_ENABLE && sp->cancelType == PTHREAD_CANCEL_ASYNCHRONOUS
//			&& ptw32_WaitHelper.WaitForSingleObject( sp->cancelEvent->Handle(), 0 ) == Wait_Object_0 )
//		{
//			sp->state = PThreadStateCanceling;
//			sp->cancelState = PTHREAD_CANCEL_DISABLE;
//			sp->cancelEvent->Reset();
//			pthread_mutex_unlock( &sp->cancelLock );
//			ptw32_throw( PTW32_EPS_CANCEL );
//
//			// Never reached
//		}
//
//		(void) pthread_mutex_unlock( &sp->cancelLock );
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::setcanceltype( int iType, int* piOldType )
//	{
//		int iResult = 0;
//		pthread_t self = pthread_self();
//		ptw32_thread_t* sp = (ptw32_thread_t*) self.p;
//
//		if( sp == 0 || ( iType != PTHREAD_CANCEL_DEFERRED && iType != PTHREAD_CANCEL_ASYNCHRONOUS ) )
//		{
//			return EINVAL;
//		}
//
//		//Lock for async-cancel safety.
//		pthread_mutex_lock( &sp->cancelLock );
//
//		if( piOldType != 0 )
//		{
//			*piOldType = sp->cancelType;
//		}
//
//		sp->cancelType = iType;
//
//		//Check if there is a pending asynchronous cancel
//		
//		if( sp->cancelState == PTHREAD_CANCEL_ENABLE && iType == PTHREAD_CANCEL_ASYNCHRONOUS
//			&& ptw32_WaitHelper.WaitForSingleObject( sp->cancelEvent->Handle(), 0 ) == Wait_Object_0 )
//		{
//			sp->state = PThreadStateCanceling;
//			sp->cancelState = PTHREAD_CANCEL_DISABLE;
//			sp->cancelEvent->Reset();
//			pthread_mutex_unlock( &sp->cancelLock );
//			ptw32_throw( PTW32_EPS_CANCEL );
//
//			// Never reached
//		}
//
//		pthread_mutex_unlock( &sp->cancelLock );
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::setconcurrency( int iConcurrency )
//	{
//		int iResult = 0;
//
//		if( iConcurrency < 0 )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			ptw32_concurrency = iConcurrency;
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::setschedparam( pthread_t hThread, int iPolicy, const struct sched_param* pParam )
//	{
//		int iResult = 0;
//
//		// Validate the thread id.
//		iResult = Kill( hThread, 0 );
//		if( 0 == iResult )
//		{
//			// Validate the scheduling policy.
//			if( iPolicy < SCHED_MIN || iPolicy > SCHED_MAX )
//			{
//				iResult = EINVAL;
//			}
//			else
//			{
//				// Ensure the policy is SCHED_OTHER.
//				if( iPolicy != SCHED_OTHER )
//				{
//					iResult = ENOTSUP;
//				}
//				else
//				{
//					iResult = ptw32_setthreadpriority( hThread, iPolicy, pParam->sched_priority );
//				}
//			}
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::setschedprio( pthread_t hThread, int iPriority )
//	{
//		///TODO:
//		int iResult = EINVAL;
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::setspecific( pthread_key_t key, const void* pValue )
//	{
//		int iResult = 0;
//		pthread_t self;
//
//		if( key != ptw32_selfThreadKey )
//		{
//			/*Using pthread_self will implicitly create
//			* an instance of pthread_t for the current
//			* thread if one wasn't explicitly created
//			*/
//			self = pthread_self();
//			if( self.p == 0 )
//			{
//				return ENOENT;
//			}
//		}
//		else
//		{
//			//Resolve catch-22 of registering thread with selfThread key
//			ptw32_thread_t* sp = (ptw32_thread_t*) pthread_getspecific( ptw32_selfThreadKey );
//
//			if( sp == 0 )
//			{
//				if( pValue == 0 )
//				{
//					return ENOENT;
//				}
//				self = *( (pthread_t*)pValue );
//			}
//			else
//			{
//				self = sp->ptHandle;
//			}
//		}
//
//		iResult = 0;
//
//		if( key != 0 )
//		{
//			if( self.p != 0 && key->destructor != 0 && pValue != 0 )
//			{
//				/*Only require associations if we have to
//				* call user destroy routine.
//				* Don't need to locate an existing association
//				* when setting data to NULL for WIN32 since the
//				* data is stored with the operating system; not
//				* on the association; setting assoc to NULL short
//				* circuits the search.*/
//				ThreadKeyAssoc* assoc;
//
//				if( pthread_mutex_lock( &(key->keyLock) ) == 0 )
//				{
//					ptw32_thread_t* sp = (ptw32_thread_t *)self.p;
//
//					pthread_mutex_lock( &(sp->threadLock) );
//
//					assoc = (ThreadKeyAssoc*)sp->keys;
//
//					//Locate existing association
//					
//					while( assoc != 0 )
//					{
//						if( assoc->key == key )
//						{
//							//Association already exists
//							break;
//						}
//						assoc = assoc->nextKey;
//					}
//
//					//create an association if not found
//					
//					if( assoc == 0 )
//					{
//						iResult = ptw32_tkAssocCreate( sp, key );
//					}
//
//					pthread_mutex_unlock( &( sp->threadLock ) );
//				}
//				
//				pthread_mutex_unlock( &( key->keyLock ) );
//			}
//
//			if( iResult == 0 )
//			{
//				if( !ptw32_TLSHelper.SetValue( key->key, (void*)pValue ) )
//				{
//					iResult = EAGAIN;
//				}
//			}
//		}
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	void Cpthread::testcancel( void )
//	{
//		pthread_t self = pthread_self();
//		ptw32_thread_t* sp = (ptw32_thread_t*)self.p;
//
//		if( sp != 0 && sp->state == PThreadStateCancelPending )
//		{
//			/*Pthread_cancel() will have set sp->state to PThreadStateCancelPending
//			* and set an event, so no need to enter kernel space if
//			* sp->state != PThreadStateCancelPending - that only slows us down.
//			*/
//			pthread_mutex_lock( &sp->cancelLock );
//
//			if( sp->cancelState != PTHREAD_CANCEL_DISABLE )
//			{
//				sp->cancelEvent->Reset();
//				sp->state = PThreadStateCanceling;
//				pthread_mutex_unlock( &sp->cancelLock );
//				sp->cancelState = PTHREAD_CANCEL_DISABLE;
//				pthread_mutex_unlock( &sp->cancelLock );
//				ptw32_throw( PTW32_EPS_CANCEL );
//			}
//
//			pthread_mutex_unlock( &sp->cancelLock );
//		}
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::key_create( pthread_key_t* pp_pthreadkey, void (*destructor)(void *) )
//	{
//		int iResult = 0;
//
//		pthread_key_t newkey;
//
//		if( ( newkey = (pthread_key_t)calloc( 1, sizeof( *newkey ) ) ) == 0 )
//		{
//			iResult = ENOMEM;
//		}
//		else if( ( newkey->key = ptw32_TLSHelper.Alloc() ) == ptw32_TLSHelper.OUT_OF_INDEXES )
//		{
//			iResult = EAGAIN;
//
//			free( newkey );
//			newkey = 0;
//		}
//		else if( destructor != 0 )
//		{
//			/*Have to manage associations between thread and key;
//			* Therefore, need a lock that allows multiple threads
//			* to gain exclusive access to the key->threads list.
//			*
//			* The mutex will only be created when it is first locked.
//			*/
//			newkey->keyLock = PTHREAD_MUTEX_INITIALIZER;
//			newkey->destructor = destructor;
//		}
//
//		*pp_pthreadkey = newkey;
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::key_delete( pthread_key_t p_pthreadkey )
//	{
//		int iResult = 0;
//
//		if( p_pthreadkey != 0 )
//		{
//			if( p_pthreadkey->threads != 0 && p_pthreadkey->destructor != 0 &&
//				pthread_mutex_lock( &( p_pthreadkey->keyLock ) ) == 0 )
//			{
//				ThreadKeyAssoc* assoc;
//				/*Run through all Thread<-->Key associations
//				* for this key.
//				*
//				* While we hold at least one of the locks guarding
//				* the assoc, we know that the assoc pointed to by
//				* key->threads is valid.*/
//
//				while( ( assoc = (ThreadKeyAssoc*) p_pthreadkey->threads ) != 0 )
//				{
//					ptw32_thread_t* thread = assoc->thread;
//
//					if( assoc == 0 )
//					{
//						// Finished
//						break;
//					}
//
//					if( pthread_mutex_lock( &( thread->threadLock ) ) == 0 )
//					{
//						/*Since we are starting at the head of the key's threads
//						* chain, this will also point key->threads at the next assoc.
//						* While we hold key->keyLock, no other thread can insert
//						* a new assoc via pthread_setspecific.
//						*/
//						ptw32_tkAssocDestroy( assoc );
//						pthread_mutex_unlock( &( thread->threadLock ) );
//					}
//					else
//					{
//						// Thread or lock is no longer valid?
//						ptw32_tkAssocDestroy( assoc );
//					}
//				}
//				pthread_mutex_unlock( &( p_pthreadkey->keyLock ) );
//			}
//
//			ptw32_TLSHelper.Free( p_pthreadkey->key );
//			if( p_pthreadkey->destructor != 0 )
//			{
//				// A thread could be holding the keyLock
//				while( EBUSY == pthread_mutex_destroy( &( p_pthreadkey->keyLock ) ) )
//				{
//					ptw32_ThreadHelper.Sleep( 1 ); // Ugly.
//				}
//			}
//
//#ifndef NDEBUG
//			memset ( (char*)p_pthreadkey, 0, sizeof( *p_pthreadkey ) );
//#endif
//			free (p_pthreadkey);
//		}
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::cond_broadcast( pthread_cond_t* pp_pthread_cond )
//	{
//		int iResult = 0;
//		if( pp_pthread_cond == 0 || *pp_pthread_cond == 0 )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			CCond* pCond = reinterpret_cast< CCond* >( *pp_pthread_cond );
//			iResult = pCond->Unblock( PTW32_TRUE );			
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::cond_destroy( pthread_cond_t* pp_pthread_cond )
//	{
//		pthread_cond_t cv;
//		int iResult = 0, iResult1 = 0, iResult2 = 0;
//
//		//Assuming any race condition here is harmless.
//		
//		if( pp_pthread_cond == 0 || *pp_pthread_cond == 0 )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			if( *pp_pthread_cond != PTHREAD_COND_INITIALIZER )
//			{
//				CCond* pCond = reinterpret_cast< CCond* >( *pp_pthread_cond );
//				*pp_pthread_cond = 0;
//				iResult = pCond->Destroy();
//				if( iResult != 0 )
//				{
//					*pp_pthread_cond = reinterpret_cast< pthread_cond_t >( pCond );
//				}
//			}
//			else
//			{
//				//See notes in ptw32_cond_check_need_init() above also.
//				
//				ptw32_cond_test_init_lock.Enter();
//
//				//Check again.
//				
//				if( *pp_pthread_cond == PTHREAD_COND_INITIALIZER )
//				{
//					/*This is all we need to do to destroy a statically
//					* initialised cond that has not yet been used (initialised).
//					* If we get to here, another thread waiting to initialise
//					* this cond will get an EINVAL. That's OK.*/
//					*pp_pthread_cond = 0;
//				}
//				else
//				{
//					//The cv has been initialised while we were waiting so assume it's in use.
//					iResult = EBUSY;
//				}
//
//				ptw32_cond_test_init_lock.Leave();
//			}
//
//			iResult = ( ( iResult != 0 ) ? iResult : ( ( iResult1 != 0 ) ? iResult1 : iResult2 ) );
//		}
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::cond_init( pthread_cond_t* pp_pthread_cond, const pthread_condattr_t* pp_pthread_condattr )
//	{
//		int iResult = 0;		
//
//		if( pp_pthread_cond == 0 )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//
//			if( ( pp_pthread_condattr != 0 && *pp_pthread_condattr != 0 ) &&
//				( (*pp_pthread_condattr)->pshared == PTHREAD_PROCESS_SHARED ) )
//			{
//				//Creating condition variable that can be shared between processes.
//				iResult = ENOSYS;			
//			}
//			else
//			{
//				CCond* pCond = new CCond();		
//
//				if( pCond == 0 )
//				{
//					iResult = ENOMEM;
//				}
//				else
//				{
//					iResult = pCond->Init();
//					if( iResult != 0 )
//					{
//						delete pCond;
//					}
//					else
//					{
//						pthread_cond_t cv = reinterpret_cast< pthread_cond_t >( pCond );
//
//						ptw32_cond_list_lock.Enter();
//						cv->next = 0;
//						cv->prev = ptw32_cond_list_tail;
//
//						if( ptw32_cond_list_tail != 0 )
//						{
//							ptw32_cond_list_tail->next = cv;
//						}
//
//						ptw32_cond_list_tail = cv;
//
//						if( ptw32_cond_list_head == 0 )
//						{
//							ptw32_cond_list_head = cv;
//						}
//
//						ptw32_cond_list_lock.Leave();
//						*pp_pthread_cond = cv;
//					}
//				}
//			}
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::cond_signal( pthread_cond_t* pp_pthread_cond )
//	{
//		int iResult = 0;
//		if( pp_pthread_cond == 0 || *pp_pthread_cond == 0 )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			CCond* pCond = reinterpret_cast< CCond* >( *pp_pthread_cond );
//			iResult = pCond->Unblock( 0 );//The '0'(FALSE) unblockAll arg means unblock ONE waiter.
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::cond_timedwait( pthread_cond_t* pp_pthread_cond, pthread_mutex_t* pp_pthread_mutex, const struct timespec* ptimespec )
//	{
//		int iResult = 0;
//
//		if( ptimespec == 0 || pp_pthread_cond == 0 || *pp_pthread_cond == 0 || pp_pthread_mutex == 0 || *pp_pthread_mutex == 0 )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			CCond* pCond = reinterpret_cast< CCond* >( *pp_pthread_cond );
//			CMutex* pMutex = reinterpret_cast< CMutex* >( *pp_pthread_mutex );
//			iResult = pCond->TimedWait( pMutex, ptimespec );			
//		}
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::cond_wait( pthread_cond_t* pp_pthread_cond, pthread_mutex_t* pp_pthread_mutex )
//	{
//		int iResult = 0;
//
//		if( pp_pthread_cond == 0 || *pp_pthread_cond == 0 || pp_pthread_mutex == 0 || *pp_pthread_mutex == 0 )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			//The NULL abstime arg means INFINITE waiting.
//			CCond* pCond = reinterpret_cast< CCond* >( *pp_pthread_cond );
//			CMutex* pMutex = reinterpret_cast< CMutex* >( *pp_pthread_mutex );
//			iResult = pCond->TimedWait( pMutex, 0 );
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::condattr_destroy( pthread_condattr_t* pp_pthread_condattr )
//	{
//		int iResult = 0;
//
//		if( pp_pthread_condattr == 0 || *pp_pthread_condattr == 0 )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			free( *pp_pthread_condattr );
//			*pp_pthread_condattr = 0;
//			iResult = 0;
//		}
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::condattr_getclock( const pthread_condattr_t* pp_pthread_condattr, clockid_t* pClockId )
//	{
//		int iResult = 0;
//		///TODO:
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::condattr_getpshared( const pthread_condattr_t* pp_pthread_condattr, int* piPShared )
//	{
//		int iResult = 0;
//
//		if( ( pp_pthread_condattr != 0 && *pp_pthread_condattr != 0 ) && ( piPShared != 0 ) )
//		{
//			*piPShared = (*pp_pthread_condattr)->pshared;
//		}
//		else
//		{
//			iResult = EINVAL;
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::condattr_init( pthread_condattr_t* pp_pthread_condattr )
//	{
//		int iResult = 0;
//		pthread_condattr_t attr_result = 0;
//		attr_result = (pthread_condattr_t) calloc( 1, sizeof( *attr_result ) );
//		if( attr_result == 0 )
//		{
//			iResult = ENOMEM;
//		}
//		*pp_pthread_condattr = attr_result;
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::condattr_setclock( pthread_condattr_t* pp_pthread_condattr, clockid_t ClockId )
//	{
//		int iResult = 0;
//		///TODO:
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::condattr_setpshared( pthread_condattr_t* pp_pthread_condattr, int iPShared )
//	{
//		int iResult = 0;
//
//		if( ( pp_pthread_condattr != 0 && *pp_pthread_condattr != 0 ) && ( ( iPShared == PTHREAD_PROCESS_SHARED ) || ( iPShared == PTHREAD_PROCESS_PRIVATE ) ) )
//		{
//			if( iPShared == PTHREAD_PROCESS_SHARED )
//			{
//#if !defined( _POSIX_THREAD_PROCESS_SHARED )
//				iResult = ENOSYS;
//				iPShared = PTHREAD_PROCESS_PRIVATE;
//#else
//				iResult = 0;
//#endif // _POSIX_THREAD_PROCESS_SHARED
//			}
//			else
//			{
//				iResult = 0;
//			}
//
//			(*pp_pthread_condattr)->pshared = iPShared;
//		}
//		else
//		{
//			iResult = EINVAL;
//		}
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::mutex_destroy( pthread_mutex_t* pp_pthreadmutex )
//	{
//		int iResult = 0;
//
//		//Let the system deal with invalid pointers.
//
//		//Check to see if we have something to delete.
//		if( *pp_pthreadmutex < PTHREAD_ERRORCHECK_MUTEX_INITIALIZER )
//		{			
//			/*FIXME!!!
//			* The mutex isn't held by another thread but we could still
//			* be too late invalidating the mutex below since another thread
//			* may already have entered mutex_lock and the check for a valid
//			* *mutex != NULL.
//			*
//			* Note that this would be an unusual situation because it is not
//			* common that mutexes are destroyed while they are still in
//			* use by other threads.
//			*/
//			
//			CMutex* pMutex = reinterpret_cast< CMutex* >( *pp_pthreadmutex );
//			*pp_pthreadmutex = 0;
//			iResult = pMutex->Destroy();
//
//			if( iResult != 0 )
//			{
//				//Restore the mutex before we return the error.
//				*pp_pthreadmutex = reinterpret_cast< pthread_mutex_t >( pMutex );
//			}
//		}
//		else
//		{
//			//See notes in ptw32_mutex_check_need_init() above also.
//			Cpthread::ptw32_mutex_test_init_lock.Enter();
//
//			//Check again.
//			if( *pp_pthreadmutex >= PTHREAD_ERRORCHECK_MUTEX_INITIALIZER )
//			{
//				/*This is all we need to do to destroy a statically
//				* initialised mutex that has not yet been used (initialised).
//				* If we get to here, another thread
//				* waiting to initialise this mutex will get an EINVAL.*/
//				*pp_pthreadmutex = 0;
//			}
//			else
//			{
//				//The mutex has been initialised while we were waiting so assume it's in use.
//				iResult = EBUSY;
//			}
//
//			Cpthread::ptw32_mutex_test_init_lock.Leave();
//		}
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::mutex_getprioceiling( const pthread_mutex_t* pp_pthreadmutex, int* pPrioCeiling )
//	{
//		int iResult = 0;
//		///TODO:
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::mutex_init( pthread_mutex_t* pp_pthreadmutex, const pthread_mutexattr_t* pp_pthreadmutexattr )
//	{
//		int iResult = 0;
//
//		if( pp_pthreadmutex == 0 )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			if( pp_pthreadmutexattr != 0 && *pp_pthreadmutexattr != 0 && (*pp_pthreadmutexattr)->pshared == PTHREAD_PROCESS_SHARED )
//			{
//				//Creating mutex that can be shared between processes.
//#if _POSIX_THREAD_PROCESS_SHARED >= 0
//				//Not implemented yet.
//#	error ERROR [__FILE__, line __LINE__]: Process shared mutexes are not supported yet.
//#else
//				iResult = ENOSYS;
//#endif /* _POSIX_THREAD_PROCESS_SHARED */
//			}
//			else
//			{
//				CMutex* pMutex = new CMutex();				
//
//				if( pMutex == 0 )
//				{
//					iResult = ENOMEM;
//				}
//				else
//				{
//					iResult = pMutex->Init( pp_pthreadmutexattr );
//
//					if( iResult == 0 )
//					{
//						*pp_pthreadmutex = pMutex;
//					}					
//					else
//					{
//						delete pMutex;
//					}
//				}
//			}
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::mutex_lock( pthread_mutex_t* pp_pthreadmutex )
//	{
//		int iResult = 0;
//
//		pthread_mutex_t mx;		
//		
//		if( pp_pthreadmutex == 0 || *pp_pthreadmutex == 0 )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			/*We do a quick check to see if we need to do more work
//			* to initialise a static mutex. We check
//			* again inside the guarded section of ptw32_mutex_check_need_init()
//			* to avoid race conditions.*/
//			if( *pp_pthreadmutex >= PTHREAD_ERRORCHECK_MUTEX_INITIALIZER )
//			{
//				iResult = CMutex::ptw32_mutex_check_need_init( pp_pthreadmutex );
//			}
//
//			if( iResult == 0 )
//			{
//				CMutex* pMutex = reinterpret_cast< CMutex* >( *pp_pthreadmutex );
//				iResult = pMutex->Lock();
//			}
//		}
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::mutex_setprioceiling( pthread_mutex_t* pp_pthreadmutex, int iPrioCeiling, int* pOldCieling )
//	{
//		int iResult = 0;
//		///TODO:
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::mutex_timedlock( pthread_mutex_t* pp_pthreadmutex, const struct timespec* ptimespec )
//	{
//		int iResult = 0;
//
//		pthread_mutex_t mx;
//
//		//Let the system deal with invalid pointers.		
//
//		/*We do a quick check to see if we need to do more work
//		* to initialise a static mutex. We check
//		* again inside the guarded section of ptw32_mutex_check_need_init()
//		* to avoid race conditions.
//		*/
//		if( *pp_pthreadmutex >= PTHREAD_ERRORCHECK_MUTEX_INITIALIZER )
//		{
//			if( ( iResult = CMutex::ptw32_mutex_check_need_init( pp_pthreadmutex ) ) != 0 )
//			{
//				return iResult;
//			}
//		}
//
//		CMutex* pMutex = reinterpret_cast< CMutex* >( *pp_pthreadmutex );
//		iResult = pMutex->TimedLock( ptimespec );
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::mutex_trylock( pthread_mutex_t* pp_pthreadmutex )
//	{
//		int iResult = 0;
//
//		pthread_mutex_t mx;
//
//		//Let the system deal with invalid pointers.
//
//		/*We do a quick check to see if we need to do more work
//		* to initialise a static mutex. We check
//		* again inside the guarded section of ptw32_mutex_check_need_init()
//		* to avoid race conditions.*/
//
//		if( *pp_pthreadmutex >= PTHREAD_ERRORCHECK_MUTEX_INITIALIZER )
//		{
//			iResult = CMutex::ptw32_mutex_check_need_init( pp_pthreadmutex );
//		}
//
//		if( iResult == 0 )
//		{
//			CMutex* pMutex = reinterpret_cast< CMutex* >( *pp_pthreadmutex );
//			iResult = pMutex->TryLock();
//		}
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::mutex_unlock( pthread_mutex_t* pp_pthreadmutex )
//	{
//		int iResult = 0;
//
//		if( pp_pthreadmutex == 0 || *pp_pthreadmutex == 0 )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			CMutex* pMutex = reinterpret_cast< CMutex* >( *pp_pthreadmutex );
//			iResult = pMutex->Unlock();
//		}
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::mutexattr_destroy( pthread_mutexattr_t* pp_pthreadmutexattr )
//	{
//		int iResult = 0;
//		if( pp_pthreadmutexattr == 0 || *pp_pthreadmutexattr == 0 )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			pthread_mutexattr_t ma = *pp_pthreadmutexattr;
//			*pp_pthreadmutexattr = 0;
//			free( ma );
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::mutexattr_getprioceiling( const pthread_mutexattr_t* pp_pthreadmutexattr, int* piPrioCeiling )
//	{
//		int iResult = 0;
//		///TODO:
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::mutexattr_getprotocol( const pthread_mutexattr_t* pp_pthreadmutexattr, int* piProtocol )
//	{
//		int iResult = 0;
//		///TODO:
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::mutexattr_getpshared( const pthread_mutexattr_t* pp_pthreadmutexattr, int* piPShared )
//	{
//		int iResult = 0;
//		if( ( pp_pthreadmutexattr != 0 && *pp_pthreadmutexattr != 0 ) && ( piPShared != 0 ) )
//		{
//			*piPShared = (*pp_pthreadmutexattr)->pshared;
//		}
//		else
//		{
//			iResult = EINVAL;
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::mutexattr_gettype( const pthread_mutexattr_t* pp_pthreadmutexattr, int* piType )
//	{
//		int iResult = 0;
//		if( pp_pthreadmutexattr != 0 && *pp_pthreadmutexattr != 0 && piType != 0 )
//		{
//			*piType = (*pp_pthreadmutexattr)->kind;
//		}
//		else
//		{
//			iResult = EINVAL;
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::mutexattr_init( pthread_mutexattr_t* pp_pthreadmutexattr )
//	{
//		int iResult = 0;
//		pthread_mutexattr_t ma;
//
//		ma = (pthread_mutexattr_t)calloc( 1, sizeof(*ma) );
//
//		if( ma == 0 )
//		{
//			iResult = ENOMEM;
//		}
//		else
//		{
//			ma->pshared = PTHREAD_PROCESS_PRIVATE;
//			ma->kind = PTHREAD_MUTEX_DEFAULT;
//		}
//
//		*pp_pthreadmutexattr = ma;
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::mutexattr_setprioceiling( pthread_mutexattr_t* pp_pthreadmutexattr, int iPrioCeiling )
//	{
//		int iResult = 0;
//		///TODO:
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::mutexattr_setprotocol( pthread_mutexattr_t* pp_pthreadmutexattr, int iProtocol )
//	{
//		int iResult = 0;
//		///TODO:
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::mutexattr_setpshared( pthread_mutexattr_t* pp_pthreadmutexattr, int iPShared )
//	{
//		int iResult = 0;
//
//		if( ( pp_pthreadmutexattr != 0 && *pp_pthreadmutexattr != 0 ) &&
//			( ( iPShared == PTHREAD_PROCESS_SHARED ) || ( iPShared == PTHREAD_PROCESS_PRIVATE ) ) )
//		{
//			if( iPShared == PTHREAD_PROCESS_SHARED )
//			{
//#if !defined( _POSIX_THREAD_PROCESS_SHARED )
//				iResult = ENOSYS;
//				iPShared = PTHREAD_PROCESS_PRIVATE;
//#endif//_POSIX_THREAD_PROCESS_SHARED
//			}
//			(*pp_pthreadmutexattr)->pshared = iPShared;
//		}
//		else
//		{
//			iResult = EINVAL;
//		}
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::mutexattr_settype( pthread_mutexattr_t* pp_pthreadmutexattr, int iType )
//	{
//		int iResult = EINVAL;
//
//		if( ( pp_pthreadmutexattr != 0 && *pp_pthreadmutexattr != 0 ) )
//		{
//			switch( iType )
//			{
//			case PTHREAD_MUTEX_FAST_NP:
//			case PTHREAD_MUTEX_RECURSIVE_NP:
//			case PTHREAD_MUTEX_ERRORCHECK_NP:
//				(*pp_pthreadmutexattr)->kind = iType;
//				iResult = 0;
//				break;
//			}
//		}
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::once( pthread_once_t* p_pthreadonce, void (*init_routine)( void ) )
//	{
//		int iResult = 0;
//
//		if( p_pthreadonce == 0 || init_routine == 0 )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			if( !ptw32_InterlockedHelper.ExchangeAdd( (long*)&p_pthreadonce->done, 0 ) ) // MBR fence
//			{
//				ptw32_mcs_local_node_t node;
//
//				ptw32_mcs_lock_acquire( (ptw32_mcs_lock_t*)&p_pthreadonce->lock, &node );
//
//				if( !p_pthreadonce->done )
//				{
//#ifdef _MSC_VER
//#	pragma inline_depth(0)
//#endif
//					pthread_cleanup_push( Cpthread::ptw32_once_on_init_cancel, (void*)&node );
//					(*init_routine)();
//					pthread_cleanup_pop( 0 );
//#ifdef _MSC_VER
//#	pragma inline_depth()
//#endif
//					p_pthreadonce->done = PTW32_TRUE;
//				}
//
//				ptw32_mcs_lock_release( &node );
//			}
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::rwlock_destroy( pthread_rwlock_t* pp_pthreadrwlock )
//	{
//		int iResult = 0;
//
//		pthread_rwlock_t rwl;
//		int iResult1 = 0;
//		int iResult2 = 0;
//
//		if( pp_pthreadrwlock == 0 || *pp_pthreadrwlock == 0 )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			if( *pp_pthreadrwlock != PTHREAD_RWLOCK_INITIALIZER )
//			{
//				CRWLock* pRWLock = reinterpret_cast< CRWLock* >( *pp_pthreadrwlock );				
//				*pp_pthreadrwlock = 0;// Invalidate rwlock before anything else
//				iResult = pRWLock->Destroy();
//				if( iResult != 0 )
//				{
//					//Restore rwlock if destroy failed
//					*pp_pthreadrwlock = reinterpret_cast< pthread_rwlock_t >( pRWLock );
//				}
//			}
//			else
//			{
//				//See notes in CheckNeedInit() above also.				
//				ptw32_rwlock_test_init_lock.Enter();
//
//				//Check again.
//				
//				if( *pp_pthreadrwlock == PTHREAD_RWLOCK_INITIALIZER )
//				{
//					/*This is all we need to do to destroy a statically
//					* initialised rwlock that has not yet been used (initialised).
//					* If we get to here, another thread
//					* waiting to initialise this rwlock will get an EINVAL.*/
//					*pp_pthreadrwlock = 0;
//				}
//				else
//				{
//					//The rwlock has been initialised while we were waiting so assume it's in use.					
//					iResult = EBUSY;
//				}
//
//				ptw32_rwlock_test_init_lock.Leave();
//			}
//
//			iResult = ( ( iResult != 0 ) ? iResult : ( ( iResult1 != 0 ) ? iResult1 : iResult2 ) );
//		}
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::rwlock_init( pthread_rwlock_t* pp_pthreadrwlock, const pthread_rwlockattr_t* pp_pthreadrwlockattr )
//	{
//		int iResult = 0;
//
//		pthread_rwlock_t rwl = 0;
//
//		if( pp_pthreadrwlock == 0 )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			if( pp_pthreadrwlockattr != 0 && *pp_pthreadrwlockattr != 0 )
//			{
//				iResult = EINVAL;		// Not supported				
//			}
//			else
//			{
//				CRWLock* pRWLock = new CRWLock();				
//
//				if( pRWLock == 0 )
//				{
//					iResult = ENOMEM;				
//				}
//				else
//				{
//					iResult = pRWLock->Init();
//
//					if( iResult == 0 )
//					{
//						*pp_pthreadrwlock = pRWLock;
//					}
//					else
//					{
//						delete pRWLock;
//					}
//				}
//			}			
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::rwlock_rdlock( pthread_rwlock_t* pp_pthreadrwlock )
//	{
//		int iResult = 0;
//
//		pthread_rwlock_t rwl;
//
//		if( pp_pthreadrwlock == 0 || *pp_pthreadrwlock == 0 )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			/*We do a quick check to see if we need to do more work
//			* to initialise a static rwlock. We check
//			* again inside the guarded section of CheckNeedInit()
//			* to avoid race conditions.*/
//
//			if( *pp_pthreadrwlock == PTHREAD_RWLOCK_INITIALIZER )
//			{
//				iResult = CRWLock::CheckNeedInit( pp_pthreadrwlock );
//			}
//
//			if( iResult == 0 || iResult == EBUSY )
//			{
//				CRWLock* pRWLock = reinterpret_cast< CRWLock* >( *pp_pthreadrwlock );
//				iResult = pRWLock->RdLock();
//			}
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::rwlock_timedrdlock( pthread_rwlock_t* pp_pthreadrwlock, const struct timespec* ptimespec )
//	{
//		int iResult = 0;
//
//		pthread_rwlock_t rwl;
//
//		if( pp_pthreadrwlock == 0 || *pp_pthreadrwlock == 0 )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			/*We do a quick check to see if we need to do more work
//			* to initialise a static rwlock. We check
//			* again inside the guarded section of CheckNeedInit()
//			* to avoid race conditions.
//			*/
//			if( *pp_pthreadrwlock == PTHREAD_RWLOCK_INITIALIZER )
//			{
//				iResult = CRWLock::CheckNeedInit( pp_pthreadrwlock );
//			}
//
//			if( iResult == 0 || iResult == EBUSY )
//			{
//				CRWLock* pRWLock = reinterpret_cast< CRWLock* >( *pp_pthreadrwlock );
//				pRWLock->TimedRdLock( ptimespec );
//			}
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::rwlock_timedwrlock( pthread_rwlock_t* pp_pthreadrwlock, const struct timespec* ptimespec )
//	{
//		int iResult = 0;
//		pthread_rwlock_t rwl;
//
//		if( pp_pthreadrwlock == 0 || *pp_pthreadrwlock == 0 )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			/*We do a quick check to see if we need to do more work
//			* to initialise a static rwlock. We check
//			* again inside the guarded section of CheckNeedInit()
//			* to avoid race conditions.
//			*/
//			if( *pp_pthreadrwlock == PTHREAD_RWLOCK_INITIALIZER )
//			{
//				iResult = CRWLock::CheckNeedInit( pp_pthreadrwlock );
//			}
//
//			if( iResult == 0 || iResult == EBUSY )
//			{
//				CRWLock* pRWLock = reinterpret_cast< CRWLock* >( *pp_pthreadrwlock );
//				iResult = pRWLock->TimedWRLock( ptimespec );
//			}
//		}
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::rwlock_tryrdlock( pthread_rwlock_t* pp_pthreadrwlock )
//	{
//		int iResult = 0;
//
//		pthread_rwlock_t rwl;
//
//		if( pp_pthreadrwlock == 0 || *pp_pthreadrwlock == 0 )
//		{
//			iResult = EINVAL;
//		}
//
//		/*We do a quick check to see if we need to do more work
//		* to initialise a static rwlock. We check
//		* again inside the guarded section of CheckNeedInit()
//		* to avoid race conditions.
//		*/
//		if( *pp_pthreadrwlock == PTHREAD_RWLOCK_INITIALIZER )
//		{
//			iResult = CRWLock::CheckNeedInit( pp_pthreadrwlock );
//		}
//
//		if( iResult == 0 || iResult == EBUSY )
//		{
//			CRWLock* pRWLock = reinterpret_cast< CRWLock* >( *pp_pthreadrwlock );
//			iResult = pRWLock->TryRdLock();
//		}
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::rwlock_trywrlock( pthread_rwlock_t* pp_pthreadrwlock )
//	{
//		int iResult = 0;
//		int iResult1 = 0;
//		pthread_rwlock_t rwl;
//
//		if( pp_pthreadrwlock == 0 || *pp_pthreadrwlock == 0 )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			/*We do a quick check to see if we need to do more work
//			* to initialise a static rwlock. We check
//			* again inside the guarded section of CheckNeedInit()
//			* to avoid race conditions.
//			*/
//			if( *pp_pthreadrwlock == PTHREAD_RWLOCK_INITIALIZER )
//			{
//				iResult = CRWLock::CheckNeedInit( pp_pthreadrwlock );
//			}
//
//			if( iResult == 0 && iResult == EBUSY )
//			{
//				CRWLock* pRWLock = reinterpret_cast< CRWLock* >( *pp_pthreadrwlock );
//				iResult = pRWLock->TryWRLock();			
//			}
//		}
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::rwlock_unlock( pthread_rwlock_t* pp_pthreadrwlock )
//	{
//		int iResult = 0;
//
//		if( pp_pthreadrwlock == 0 || *pp_pthreadrwlock == 0 )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			//Assume any race condition here is harmless.
//			if( *pp_pthreadrwlock != PTHREAD_RWLOCK_INITIALIZER )
//			{
//				CRWLock* pRWLock = reinterpret_cast< CRWLock* >( *pp_pthreadrwlock );
//				iResult = pRWLock->Unlock();
//			}
//		}
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::rwlock_wrlock( pthread_rwlock_t* pp_pthreadrwlock )
//	{
//		int iResult = 0;
//
//		if( pp_pthreadrwlock == 0 || *pp_pthreadrwlock == 0 )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			/*We do a quick check to see if we need to do more work
//			* to initialise a static rwlock. We check
//			* again inside the guarded section of CheckNeedInit()
//			* to avoid race conditions.
//			*/
//			if( *pp_pthreadrwlock == PTHREAD_RWLOCK_INITIALIZER )
//			{
//				iResult = CRWLock::CheckNeedInit( pp_pthreadrwlock );
//				if( iResult == EBUSY )
//				{
//					iResult = 0;
//				}
//			}
//		}
//
//		if( iResult == 0 )
//		{
//			CRWLock* pRWLock = reinterpret_cast< CRWLock* >( *pp_pthreadrwlock );
//			iResult = pRWLock->WRLock();
//		}
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::rwlockattr_destroy( pthread_rwlockattr_t* pp_pthreadrwlockattr )
//	{
//		int iResult = EINVAL;
//
//		if( pp_pthreadrwlockattr != 0 && *pp_pthreadrwlockattr != 0 )
//		{
//			CRWLock::CRWLockAttrib* pAttrib = reinterpret_cast< CRWLock::CRWLockAttrib* >( *pp_pthreadrwlockattr );
//			iResult = pAttrib->Destroy();
//			if( iResult == 0 )
//			{
//				*pp_pthreadrwlockattr = 0;
//			}
//		}
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::rwlockattr_getpshared( const pthread_rwlockattr_t* pp_pthreadrwlockattr, int* piPShared )
//	{
//		int iResult = EINVAL;
//
//		if( pp_pthreadrwlockattr != 0 && *pp_pthreadrwlockattr != 0 )
//		{
//			CRWLock::CRWLockAttrib* pAttrib = reinterpret_cast< CRWLock::CRWLockAttrib* >( *pp_pthreadrwlockattr );
//			iResult = pAttrib->GetPShared( piPShared );
//		}
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::rwlockattr_init( pthread_rwlockattr_t* pp_pthreadrwlockattr )
//	{
//		int iResult = 0;
//
//		if( pp_pthreadrwlockattr == 0 || *pp_pthreadrwlockattr != 0 )
//		{
//			iResult = EINVAL;
//		}
//		else
//		{
//			CRWLock::CRWLockAttrib* pRWA = new CRWLock::CRWLockAttrib();
//
//			if( pRWA == 0 )
//			{
//				iResult = ENOMEM;
//			}
//			else
//			{
//				pRWA->Init();				
//				*pp_pthreadrwlockattr = pRWA;
//			}
//		}
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::rwlockattr_setpshared( pthread_rwlockattr_t* pp_pthreadrwlockattr, int iPShared )
//	{
//		int iResult = EINVAL;
//
//		if( ( pp_pthreadrwlockattr != 0 && *pp_pthreadrwlockattr != 0 ) && 
//			( ( iPShared == PTHREAD_PROCESS_SHARED ) ||	( iPShared == PTHREAD_PROCESS_PRIVATE ) ) )
//		{
//			CRWLock::CRWLockAttrib* pAttrib = reinterpret_cast< CRWLock::CRWLockAttrib* >( *pp_pthreadrwlockattr );
//			iResult = pAttrib->SetPShared( iPShared );
//		}
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::spin_destroy( pthread_spinlock_t* pp_pthreadspinlock )
//	{
//		int iResult = 0;
//
//		if( pp_pthreadspinlock != 0 && *pp_pthreadspinlock != 0 )
//		{
//			CSpinLock* pSpinLock = reinterpret_cast< CSpinLock* >( *pp_pthreadspinlock );
//			*pp_pthreadspinlock = 0;
//			iResult = pSpinLock->Destroy();			
//			if( iResult != 0 )
//			{
//				*pp_pthreadspinlock = reinterpret_cast< pthread_spinlock_t >( pSpinLock );
//			}
//		}
//		else
//		{
//			iResult = EINVAL;
//		}
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::spin_init( pthread_spinlock_t* pp_pthreadspinlock, int iPShared )
//	{
//		int iResult = EINVAL;
//
//		if( pp_pthreadspinlock != 0 && *pp_pthreadspinlock == 0 )
//		{
//			CSpinLock* pSpinLock = new CSpinLock();
//			if( pSpinLock == 0 )
//			{
//				iResult = ENOMEM;
//			}
//			else
//			{
//				iResult = pSpinLock->Init( iPShared );
//				if( iResult == 0 )
//				{
//					*pp_pthreadspinlock = pSpinLock;
//				}
//				else
//				{
//					delete pSpinLock;
//				}
//			}
//		}
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::spin_lock( pthread_spinlock_t* pp_pthreadspinlock )
//	{
//		int iResult = EINVAL;
//		if( pp_pthreadspinlock != 0 && *pp_pthreadspinlock != 0 )
//		{
//			iResult = 0;
//			if( *pp_pthreadspinlock == PTHREAD_SPINLOCK_INITIALIZER )
//			{
//				iResult = CSpinLock::ptw32_spinlock_check_need_init( reinterpret_cast< CSpinLock* >( pp_pthreadspinlock ) );
//			}
//
//			if( iResult == 0 )
//			{
//				CSpinLock* pSpinLock = reinterpret_cast< CSpinLock* >( *pp_pthreadspinlock );
//				iResult = pSpinLock->Lock();
//			}
//		}
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::spin_trylock( pthread_spinlock_t* pp_pthreadspinlock )
//	{
//		int iResult = EINVAL;
//		if( pp_pthreadspinlock != 0 && *pp_pthreadspinlock != 0 )
//		{
//			iResult = 0;
//			if( *pp_pthreadspinlock == PTHREAD_SPINLOCK_INITIALIZER )
//			{
//				CSpinLock* pSpinLock = reinterpret_cast< CSpinLock* >( *pp_pthreadspinlock );
//				iResult = CSpinLock::ptw32_spinlock_check_need_init( pSpinLock );
//			}
//
//			if( iResult == 0 )
//			{
//				CSpinLock* pSpinLock = reinterpret_cast< CSpinLock* >( *pp_pthreadspinlock );
//				iResult = pSpinLock->TryLock();
//			}
//		}
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	int Cpthread::spin_unlock( pthread_spinlock_t* pp_pthreadspinlock )
//	{
//		int iResult = EINVAL;
//		if( pp_pthreadspinlock != 0 && *pp_pthreadspinlock != 0 )
//		{
//			if( *pp_pthreadspinlock == PTHREAD_SPINLOCK_INITIALIZER )
//			{
//				iResult = EPERM;
//			}
//			else
//			{
//				CSpinLock* pSpinLock = reinterpret_cast< CSpinLock* >( *pp_pthreadspinlock );
//				iResult = pSpinLock->Unlock();
//			}
//		}
//
//		return iResult;
//	}
//
//	//------------------------------------------------------------------------------
//	void Cpthread::ptw32_callUserDestroyRoutines( pthread_t thread )
//	{
//		ThreadKeyAssoc* assoc;
//
//		if( thread.p != 0 )
//		{
//			int assocsRemaining;
//			int iterations = 0;
//			ptw32_thread_t* sp = (ptw32_thread_t*)thread.p;
//
//			/*Run through all Thread<-->Key associations for the current thread.
//			*
//			* Do this process at most PTHREAD_DESTRUCTOR_ITERATIONS times.*/
//			do
//			{
//				assocsRemaining = 0;
//				iterations++;
//
//				pthread_mutex_lock( &(sp->threadLock) );
//				/*The pointer to the next assoc is stored in the thread struct so that
//				* the assoc destructor in pthread_key_delete can adjust it
//				* if it deletes this assoc. This can happen if we fail to acquire
//				* both locks below, and are forced to release all of our locks,
//				* leaving open the opportunity for pthread_key_delete to get in
//				* before us.*/
//				sp->nextAssoc = sp->keys;
//				pthread_mutex_unlock(&(sp->threadLock));
//
//				for(;;)
//				{
//					void * value;
//					pthread_key_t k;
//					void( *destructor )( void* );
//
//					/*First we need to serialise with pthread_key_delete by locking
//					* both assoc guards, but in the reverse order to our convention,
//					* so we must be careful to avoid deadlock.*/
//					pthread_mutex_lock( &(sp->threadLock) );
//
//					if( ( assoc = (ThreadKeyAssoc *)sp->nextAssoc ) == 0 )
//					{
//						// Finished
//						pthread_mutex_unlock( &(sp->threadLock) );
//						break;
//					}
//					else
//					{
//						/*assoc->key must be valid because assoc can't change or be
//						* removed from our chain while we hold at least one lock. If
//						* the assoc was on our key chain then the key has not been
//						* deleted yet.
//						* Now try to acquire the second lock without deadlocking.
//						* If we fail, we need to relinquish the first lock and the
//						* processor and then try to acquire them all again.*/
//						if( pthread_mutex_trylock( &(assoc->key->keyLock) ) == EBUSY )
//						{
//							pthread_mutex_unlock( &(sp->threadLock) );
//							ptw32_ThreadHelper.Sleep( 1 ); // Ugly but necessary to avoid priority effects.
//							/*Go around again.
//							* If pthread_key_delete has removed this assoc in the meantime,
//							* sp->nextAssoc will point to a new assoc.*/
//							continue;
//						}
//					}
//
//					// We now hold both locks
//
//					sp->nextAssoc = assoc->nextKey;
//
//					/*Key still active; pthread_key_delete
//					* will block on these same mutexes before
//					* it can release actual key; therefore,
//					* key is valid and we can call the destroy
//					* routine;*/
//					k = assoc->key;
//					destructor = k->destructor;
//					value = ptw32_TLSHelper.GetValue( k->key );
//					ptw32_TLSHelper.SetValue( k->key, 0 );
//
//					// Every assoc->key exists and has a destructor
//					if( value != 0 && iterations <= PTHREAD_DESTRUCTOR_ITERATIONS )
//					{
//						/*Unlock both locks before the destructor runs.
//						* POSIX says pthread_key_delete can be run from destructors,
//						* and that probably includes with this key as target.
//						* pthread_setspecific can also be run from destructors and
//						* also needs to be able to access the assocs.*/
//						pthread_mutex_unlock( &(sp->threadLock) );
//						pthread_mutex_unlock( &(k->keyLock) );
//
//						assocsRemaining++;
//
//						try
//						{
//							//Run the caller's cleanup routine.
//							destructor( value );
//						}
//						catch( ... )
//						{
//							/* A system unexpected exception has occurred
//							* running the user's destructor.
//							* We get control back within this block in case
//							* the application has set up it's own terminate
//							* handler. Since we are leaving the thread we
//							* should not get any internal pthreads
//							* exceptions.*/
//							std::terminate();
//						}
//					}
//					else
//					{
//						/*Remove association from both the key and thread chains
//						* and reclaim it's memory resources.*/
//						ptw32_tkAssocDestroy( assoc );
//						pthread_mutex_unlock( &(sp->threadLock) );
//						pthread_mutex_unlock( &(k->keyLock) );
//					}
//				}
//			}
//			while( assocsRemaining );
//		}
//	}
//
//	//------------------------------------------------------------------------------
//	/*Push a clean pthread_t struct onto the reuse stack.
//	* Must be re-initialised when reused.
//	* All object elements (mutexes, events etc) must have been either
//	* detroyed before this, or never initialised.*/
//	void Cpthread::ptw32_threadReusePush( pthread_t thread )
//	{
//		ptw32_thread_t* tp = (ptw32_thread_t*)thread.p;
//		pthread_t t;
//
//		ptw32_thread_reuse_lock.Enter();
//
//		t = tp->ptHandle;
//		memset( tp, 0, sizeof(ptw32_thread_t) );
//
//		// Must restore the original POSIX handle that we just wiped.
//		tp->ptHandle = t;
//
//		// Bump the reuse counter now
//#ifdef PTW32_THREAD_ID_REUSE_INCREMENT
//		tp->ptHandle.x += PTW32_THREAD_ID_REUSE_INCREMENT;
//#else
//		tp->ptHandle.x++;
//#endif
//
//		tp->prevReuse = PTW32_THREAD_REUSE_EMPTY;
//
//		if( PTW32_THREAD_REUSE_EMPTY != ptw32_threadReuseBottom )
//		{
//			ptw32_threadReuseBottom->prevReuse = tp;
//		}
//		else
//		{
//			ptw32_threadReuseTop = tp;
//		}
//
//		ptw32_threadReuseBottom = tp;
//
//		ptw32_thread_reuse_lock.Leave();
//	}


}//nsWin32

// The following are ordered for inlining

/*
#include "pthreads/attr.cpp"
#include "pthreads/barrier.cpp"
#include "pthreads/cancel.cpp"
#include "pthreads/cleanup.cpp"
#include "pthreads/condvar.cpp"
#include "pthreads/create.cpp"
#include "pthreads/dll.cpp"
#include "pthreads/errno.cpp"
#include "pthreads/exit.cpp"
#include "pthreads/fork.cpp"
#include "pthreads/global.cpp"
#include "pthreads/misc.cpp"
#include "pthreads/mutex.cpp"
#include "pthreads/nonportable.cpp"
#include "pthreads/rwlock.cpp"
#include "pthreads/sched.cpp"
#include "pthreads/semaphore.cpp"
#include "pthreads/signal.cpp"
#include "pthreads/spin.cpp"
#include "pthreads/sync.cpp"
#include "pthreads/tsd.cpp"
*/
#endif//(QOR_SYS_OS == QOR_SYS_MSW)

