//MSW_locale.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "SystemQOR.h"

#if		(QOR_SYS_OS == QOR_SYS_MSW)

#include "SystemQOR/MSWindows/MSW_locale.h"
#include "WinQL/WinQL.h"
#include "WinQL/System/WinQLSystem.h"
#include "WinQL/Application/ErrorSystem/WinQLError.h"
#include "WinQL/CodeServices/Locale/WinQLLCID.h"
#include "WinQL/CodeServices/Locale/WinQLLocale.h"
#include "WinQL/CodeServices/Locale/WinQLLocaleThreadData.h"
#include "WinQL/Application/Threading/WinQLThread.h"
#include "WinQL/Application/Threading/WinQLCriticalSection.h"
#include <string.h>

//--------------------------------------------------------------------------------
namespace nsWin32
{
	//--------------------------------------------------------------------------------
	const CThreadLocaleInfo::CLocaleCategory __lc_category [ CLocale::LCMAX - CLocale::LCMIN + 1 ] =
	{
        // code assumes locale initialization is "__clocalestr" 
        { "LC_ALL",     (char*)0, &CThreadLocaleInfo::__init_dummy, 0, 0, 0, 0 /* never called */ },
		{ "LC_COLLATE", (char*)CLocale::CLocaleStr(), &CThreadLocaleInfo::__init_collate, 0, 0, 0, 0  },
        { "LC_CTYPE",   (char*)CLocale::CLocaleStr(), &CThreadLocaleInfo::__init_ctype, 0, 0, 0, 0    },
        { "LC_MONETARY",(char*)CLocale::CLocaleStr(), &CThreadLocaleInfo::__init_monetary, 0, 0, 0, 0 },
        { "LC_NUMERIC", (char*)CLocale::CLocaleStr(), &CThreadLocaleInfo::__init_numeric, 0, 0, 0, 0  },
        { "LC_TIME",    (char*)CLocale::CLocaleStr(), &CThreadLocaleInfo::__init_time, 0, 0, 0, 0 }
	};

	const char Clocale::_first_127char[] = 
	{
			1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, 16, 17,
			18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,
			35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
			52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68,
			69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85,
			86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100,101,102,
			103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,
			120,121,122,123,124,125,126,127
	};

	//--------------------------------------------------------------------------------
	Clocale::Clocale()
	{
		__QCS_MEMBER_FCONTEXT( "Clocale::Clocale" );
	}

	//--------------------------------------------------------------------------------
	Clocale::~Clocale()
	{
		__QCS_MEMBER_FCONTEXT( "Clocale::~Clocale" );
	}

	//--------------------------------------------------------------------------------
	void Clocale::crtInit( void )
	{
		
	}

	//--------------------------------------------------------------------------------
	void Clocale::crtCleanup( void )
	{

	}

	//--------------------------------------------------------------------------------
	locale_t Clocale::duplocale( locale_t l )
	{
		//TODO:
		locale_t Result;
		return Result;
	}

	//--------------------------------------------------------------------------------
	void Clocale::freelocale( locale_t l )
	{
		//TODO:
	}

	//--------------------------------------------------------------------------------
	locale_t Clocale::newlocale( int, const char*, locale_t )
	{
		//TODO:
		locale_t Result;
		return Result;
	}

	//--------------------------------------------------------------------------------
	locale_t Clocale::uselocale( locale_t l )
	{
		//TODO:
		locale_t Result;
		return Result;
	}

	//--------------------------------------------------------------------------------
	char* Clocale::setlocale( int category, const char* locale )
	{
		_WINQ_FCONTEXT( "Clocale::setlocale" );
		char* szResult = NULL;

		nsWin32::CThreadLocaleInfo tloci;
		nsWin32::CThread* ptd;

		// Validate category
		//_VALIDATE_RETURN(LC_MIN <= _category && _category <= LC_MAX, EINVAL, NULL);

		ptd = nsWin32::GetCurrentWin32Thread();

		__updatetlocinfo();
		// Note here that we increment the _ownlocale for this thread. We need this
		// to make sure that the locale is not updated to some other locale by call to
		// stricmp().
		// Don't set any flag that aligns with N, P or G
		ptd->Data().OwnLocale() |= 0x10;

		try 
		{
			{
				nsWin32::CCriticalSectionLock Lock( m_SetLocaleSection );
				tloci = *(ptd->LocaleInfoPtr());
			}

			if ( ( szResult = _setlocale_nolock( &tloci, category, locale ) ) ) 
			{
				/*
				* What we are trying here is that if no call has been made to
				* setlocale to change locale from "C" locale to some other locale
				* we keep __locale_changed = 0. Other funcitons depending on locale
				* use this variable to optimize performance for C locale which is
				* normally the case in 90% of the applications.
				*/
				if( locale != 0 && strcmp( locale, nsWin32::CLocale::CLocaleStr() ) )
				{
					//TODO: nsWin32::System().Locale().SetLocaleChanged();					
				}

				{
					nsWin32::CCriticalSectionLock Lock( m_SetLocaleSection );
					(void)_updatetlocinfoEx_nolock( &ptd->LocaleInfoPtr(), &tloci );
					tloci.ReleaseAll();

					// Note that after incrementing _ownlocale, if this thread doesn't
					// have it's own locale, _ownlocale variable should be 1.
					if( !( ptd->Data().OwnLocale() & nsWin32::CThreadState::_Per_Thread_Locale_Bit ) && !( nsWin32::CLocale::GlobalLocaleStatus() & nsWin32::CThreadState::_Global_Locale_Bit ) ) 
					{
						nsWin32::CThreadLocaleInfo* ptr = &nsWin32::CLocaleThreadData::InitialLocInfo();
						(void)_updatetlocinfoEx_nolock( &ptr, ptd->LocaleInfoPtr() );

						// All these variables are for backward compatiblity.
						memcpy( nsWin32::CLocale::LocaleHandles(), nsWin32::CLocaleThreadData::InitialLocInfo().Handles(), sizeof(unsigned long)*( nsWin32::CLocale::LCMAX - nsWin32::CLocale::LCMIN + 1 ) );
						//CLocale::sync_legacy_variables_lk();
					}
				} 
			} 
			else 
			{
				tloci.ReleaseAll();
				//__freetlocinfo(ptloci);
			}
		} 
		catch( nsWin32::CError* pErr )
		{
			
		}
		ptd->Data().OwnLocale() &= ~0x10;

		return szResult;
	}

	//--------------------------------------------------------------------------------
	lconv* Clocale::localeconv(void)
	{
		_WINQ_FCONTEXT( "Clocale::localeconv" );
		//TODO:
		//Get the current thread object
		//Get the Locale conventions object from the thread
		//return the Locale Conventions object
		return 0;
	}

	//--------------------------------------------------------------------------------
	lconv* Clocale::localeconv_l( locale_t l )
	{
		_WINQ_FCONTEXT( "Clocale::localeconv_l" );
		return 0;
	}

	//--------------------------------------------------------------------------------
	nsWin32::CThreadLocaleInfo* Clocale::__updatetlocinfo(void)
	{
		_WINQ_FCONTEXT( "Clocale::__updatetlocinfo" );
		nsWin32::CThreadLocaleInfo* ptloci = 0;
		nsWin32::CThread* ptd = nsWin32::GetCurrentWin32Thread();

		if( !( ptd->Data().OwnLocale() & nsWin32::CLocale::GlobalLocaleStatus() ) || !ptd->LocaleInfoPtr() ) 
		{
			try
			{
				nsWin32::CLocaleThreadData OrigLocaleThreadData;
				nsWin32::CCriticalSectionLock Lock( m_SetLocaleSection );
				nsWin32::CThreadLocaleInfo* ptr = ptd->LocaleInfoPtr();
				ptloci = _updatetlocinfoEx_nolock( &ptr, OrigLocaleThreadData.LocaleInfoPtr() );
			}
			catch( nsWin32::CError* pErr )
			{
				
			}
		} 
		else 
		{
			ptloci = ptd->LocaleInfoPtr();
		}

		if( ptloci == 0 )
		{
			//TODO:: _amsg_exit(_RT_LOCALE);
		}

		return ptloci;
	}

	//--------------------------------------------------------------------------------
	nsWin32::CThreadLocaleInfo* Clocale::_updatetlocinfoEx_nolock( nsWin32::CThreadLocaleInfo** pptlocid, nsWin32::CThreadLocaleInfo* ptlocis )
	{
		_WINQ_FCONTEXT( "Clocale::_updatetlocinfoEx_nolock" );
		nsWin32::CThreadLocaleInfo* ptloci;

		if( ptlocis == 0 || pptlocid == 0 )
		{
			return 0;
		}

		ptloci = *pptlocid;
		if( ptloci != ptlocis )
		{
			// Update to the current locale info structure and increment the reference counts.
			 
			*pptlocid = ptlocis;
			ptlocis->AddRefAll();			

			// Decrement the reference counts in the old locale info structure.			 
			/*
			if ( ptloci != 0 )
			{
				__removelocaleref( 0 );
			}
			*/

			/* Free the old locale info structure, if necessary.  Must be done
			 * after incrementing reference counts in current locale in case
			 * any refcounts are shared with the old locale.
			 */
			if( ( ptloci != 0 ) && ( ptloci->RefCount() == 0 ) && ( ptloci != &nsWin32::CLocaleThreadData::InitialLocInfo() ) )
			{
				delete ptloci;
				ptloci = 0;
			}
		}

		return ptlocis;
	}

	//--------------------------------------------------------------------------------
	char* Clocale::_setlocale_nolock( nsWin32::CThreadLocaleInfo* ploci, int _category, const char* _locale )
	{
		_WINQ_FCONTEXT( "Clocale::_setlocale_nolock" );
		char* retval;
		// Interpret locale

		if( _category != nsWin32::CLocale::LCALL )
		{
			retval = ( _locale ) ? _setlocale_set_cat( ploci, _category, _locale ) : ploci->Category( _category ).Locale();
		} 
		else	// LC_ALL
		{
			char lctemp[ nsWin32::CLC_ID::MAX_LC_LEN ];
			int i;
			int same = 1;
			int fLocaleSet = 0; // flag to indicate if anything successfully set

			if( _locale != NULL )
			{
				if( ( _locale[ 0 ] == 'L') && ( _locale[ 1 ] == 'C' ) && ( _locale[ 2 ] == '_') )
				{
					// parse compound locale string
					size_t len;
					const char * p = _locale;  // start of string to parse
					const char * s;

					do 
					{
						s = strpbrk( p, "=;" );

						if( ( s == (char*) 0 ) || ( !( len = (size_t)( s - p ) ) ) || ( *s == ';' ) )
						{
							return 0;  // syntax error
						}

						// match with known LC_ strings, if possible, else ignore 
						for( i = CLocale::LCALL + 1; i <= CLocale::LCMAX; i++ )
						{
							if( ( !strncmp( __lc_category[ i ].m_CatName,p,len ) ) && ( len == strlen( __lc_category[ i ].m_CatName ) ) )
							{
								break;  // matched i
							}
						} // no match if (i>LC_MAX) -- just ignore

						if( ( !( len = strcspn( ++s,";" ) ) ) && ( *s != ';' ) )
						{
							return 0;  // syntax error
						}

						if( i <= nsWin32::CLocale::LCMAX )
						{
							strncpy/*_s*/( lctemp, /*_countof( lctemp ),*/ s, len );
							//TODO: _ERRCHECK( strncpy_s( lctemp, _countof( lctemp ), s, len ) );
							lctemp[ len ] = '\0';   // null terminate string

							// don't fail unless all categories fail
							if( _setlocale_set_cat( ploci, i,lctemp ) )
							{
								fLocaleSet++;       // record a success
							}
						}

						if( *( p = s + len ) != '\0' )
						{
							p++;  // skip ';', if present
						}

					}while (*p);

					retval = (fLocaleSet) ? ploci->SetLocale_GetAll() : NULL;

				}
				else 
				{	// simple LC_ALL locale string

					// confirm locale is supported, get expanded locale
					if( retval = _expandlocale( (char*)_locale, lctemp, _countof( lctemp ), NULL, NULL, _category ) )
					{
						for ( i = nsWin32::CLocale::LCMIN; i <= nsWin32::CLocale::LCMAX; i++ )
						{
							if( i != nsWin32::CLocale::LCALL )
							{
								if( strcmp( lctemp, ploci->Category( i ).Locale() ) )
								{
									if( _setlocale_set_cat( ploci, i, lctemp ) )
									{
										fLocaleSet++;   // record a success
									}
									else
									{
										same = 0;       // record a failure
									}
								}
								else
								{
									fLocaleSet++;   // trivial succcess
								}
							}
						}

						if( same ) // needn't call setlocale_get_all() if all the same
						{
							retval = ploci->SetLocale_GetAll();
							// retval set above
						}
						else
						{
							retval = ( fLocaleSet ) ? ploci->SetLocale_GetAll() : 0;
						}
					}
				}
			}
			else 
			{	// LC_ALL & NULL
				retval = ploci->SetLocale_GetAll();
			}
		}

		// common exit point
		return retval;
	}

	//--------------------------------------------------------------------------------
	char* Clocale::_setlocale_set_cat( nsWin32::CThreadLocaleInfo* ploci, int category, const char* locale )
	{
		_WINQ_FCONTEXT( "Clocale::_setlocale_set_cat" );
		char* oldlocale;
		unsigned long oldhandle;
		unsigned int oldcodepage;
		LC_ID oldid;

		LC_ID idtemp;
		unsigned int cptemp;
		char lctemp[ nsWin32::CLC_ID::MAX_LC_LEN ];
		char * pch = NULL;
		size_t cch = 0;
		short out[ sizeof( Clocale::_first_127char) ];
		int i;
		nsWin32::CThread* _ptd = nsWin32::CLocale::_getptd();
		nsWin32::CIsCtypeCompatible* _Lcid_c = _ptd->Data().SetLocData().m_aLCIDC; // __setloc_data._Lcid_c is array
		int _LOC_CCACHE = sizeof( _ptd->Data().SetLocData().m_aLCIDC ) / sizeof( nsWin32::CIsCtypeCompatible );
		nsWin32::CIsCtypeCompatible buf1, buf2;

		if( !_expandlocale( (char*)locale, lctemp, _countof( lctemp ), &idtemp, &cptemp, category ) )
		{
			return 0;            // unrecognized locale
		}

		if( !strcmp( lctemp, ploci->Category( category ).Locale() ) )
		{
			return ploci->Category( category ).Locale();
		}

		cch = sizeof( int ) + strlen( lctemp ) + 1;
		if( !( pch = new char[ cch ] ) )
		{
			return 0;  // error if malloc fails
		}

		oldlocale = ploci->Category( category ).Locale(); // save for possible restore
		oldhandle = ploci->Handle( category );
		memcpy( (void *)&oldid, (void *)&ploci->LocaleID( category ), sizeof( oldid ) );
		oldcodepage = ploci->CodePage();

		// update locale string
		//_ERRCHECK(strcpy_s(pch + sizeof(int), cch - sizeof(int), lctemp));
		strcpy( pch + sizeof(int)/*, cch - sizeof(int)*/, lctemp );
		ploci->Category( category ).Locale() = pch + sizeof( int );
		ploci->Handle( category ) = MakeLcId( idtemp.wLanguage, Clocale::Sort_Default );
		memcpy( (void *)&ploci->LocaleID( category ), (void*) &idtemp, sizeof( idtemp ) );

		/* To speedup locale based comparisions, we identify if the current
		 * local has first 127 character set same as CLOCALE. If yes then
		 * ploci->lc_clike = TRUE.
		 */

		if( category == nsWin32::CLocale::LCCTYPE )
		{
			ploci->CodePage() = cptemp;
			buf1 = _Lcid_c[ _LOC_CCACHE - 1 ];
			/* brings the recently used codepage to the top. or else shifts
			 * every thing down by one so that new _Lcid_c can be placed at
			 * the top.
			 */
			for ( i = 0; i < _LOC_CCACHE; i++)
			{
				if ( ploci->CodePage().ID() == _Lcid_c[ i ].m_ulID )
				{
					/* We don't really want to swap cache around in case what we are looking
					 *  for is the first element of the cache
					 */
					if( i != 0 )
					{
						_Lcid_c[ 0 ] = _Lcid_c[ i ];
						_Lcid_c[ i ] = buf1;
					}
					break;
				}
				else
				{
					buf2 = _Lcid_c[ i ];
					_Lcid_c[ i ] = buf1;
					buf1 = buf2;
				}
			}

			if( i == _LOC_CCACHE )
			{
				if( nsWin32::CSetLoc::__crtGetStringTypeA( NULL, nsWin32::CT_CType1, (const char*)_first_127char, sizeof( _first_127char ), (unsigned short*)out, ploci->CodePage(), ploci->Handle( nsWin32::CLocale::LCCTYPE ), true ) )
				{
					int j;
					for( j = 0; j < sizeof( _first_127char ); j++ )
					{
						out[ j ] = out[ j ]& ( Upper | Lower | Digit | Space| Punct| Control | Blank| Hex | Alpha );
					}

					if( !memcmp( out, nsWin32::CLocale::CTypeLocStyle()/*CharData::sc_usWCType + 2*/, ( sizeof( _first_127char ) / sizeof( char ) ) * sizeof( short ) ) )
					{
						_Lcid_c[ 0 ].m_bIsCLike = true;
					}
					else
					{
						_Lcid_c[ 0 ].m_bIsCLike = false;
					}
				}
				else
				{
					_Lcid_c[ 0 ].m_bIsCLike = false;
				}
				_Lcid_c[ 0 ].m_ulID = ploci->CodePage().ID();
			}
			ploci->CLike() = _Lcid_c[ 0 ].m_bIsCLike;
		}

		if( category == nsWin32::CLocale::LCCOLLATE )
		{
			ploci->CollationCodePage() = cptemp;
		}

		if( ploci->Category( category ).Init() )
		{
			// restore previous state!
			ploci->Category( category ).Locale() = oldlocale;
			//TODO:_free_crt(pch);
			ploci->Handle( category ) = oldhandle;
			ploci->CodePage() = oldcodepage;

			return 0; // error if non-zero return
		}

		// locale set up successfully
		// Cleanup
		if( ( oldlocale != nsWin32::CLocale::CLocaleStr() ) && ( ploci->Category( category ).Release() == 0 ) )
		{
			//TODO:_ASSERT(0);
			//_free_crt(ploci->lc_category[category].refcount);
			//_free_crt(ploci->lc_category[category].wrefcount);
			ploci->Category( category ).wLocale() = 0;
		}

		if( pch ) 
		{
			*(int *)pch = 1;
		}

		ploci->Category( category ).RefCount()->operator =( 1 );

		return ploci->Category( category ).Locale();
	}

	//--------------------------------------------------------------------------------
	char* Clocale::_expandlocale ( char* expr, char* output, size_t sizeInChars, LC_ID* id, unsigned int* cp, int category )
	{
		_WINQ_FCONTEXT( "Clocale::_expandlocale" );
		nsWin32::CSetLoc* _psetloc_data = &nsWin32::CLocale::_getptd()->Data().SetLocData();
		unsigned int *pcachecp = &_psetloc_data->m_uiCacheCodePage;
		nsWin32::CLC_ID *pcacheid = &_psetloc_data->CacheId;
		char *cachein = _psetloc_data->m_acCacheIn;
		size_t cacheinSize = _countof( _psetloc_data->m_acCacheIn );
		char *cacheout = _psetloc_data->m_acCacheOut;
		size_t cacheoutSize = _countof( _psetloc_data->m_acCacheOut );
		size_t charactersInExpression = 0;

		if( !expr )
		{
			return NULL; /* error if no input */
		}

		if( output == NULL || sizeInChars == 0 )
		{
			return NULL; /* error if no output */
		}


		if( ( ( *expr == 'C' ) && ( !expr[ 1 ] ) ) )  // for "C" locale, just return
		{
			//_ERRCHECK(strcpy_s(output, sizeInChars, "C"));
			strcpy( output, "C" );
			if (id)
			{
				id->wLanguage = 0;
				id->wCountry  = 0;
				id->wCodePage = 0;
			}
			if (cp)
			{
				*cp = CodePage_Ansi; /* return to ANSI code page */
			}
			return output; /* "C" */
		}

		// first, make sure we didn't just do this one
		charactersInExpression = strlen( expr );
		
		if( charactersInExpression >= nsWin32::CLC_ID::MAX_LC_LEN || ( strcmp( cacheout, expr ) && strcmp( cachein, expr ) ) )
		{			
			nsWin32::CLC_STRINGS names;
			const char* source = NULL;
			size_t charactersInSource = 0;

			if( __lc_strtolc( &names, expr ) )
			{
				return 0;  // syntax error
			}

			if( !_psetloc_data->GetQualifiedLocale( &names, pcacheid, &names ) )
			{
				return 0;    // locale not recognized/supported
			}

			// begin: cache atomic section

			*pcachecp = pcacheid->wCodePage;

			__lc_lctostr( cacheout, cacheoutSize, &names );

			if( *expr && charactersInExpression < nsWin32::CLC_ID::MAX_LC_LEN )
			{
				source = expr;
				charactersInSource = charactersInExpression;
			}
			else
			{
				// Don't cache "" empty string or over-long string
				source = "";
			}
			// Ensure that whatever we are about to copy in will be null terminated

			//_ERRCHECK(strncpy_s(cachein, cacheinSize, source, charactersInSource + 1));
			strncpy( cachein, source, charactersInSource + 1 );

			// end: cache atomic section
		}

		if( id )
		{
			memcpy( (void*)id, (void*)pcacheid, sizeof( *pcacheid ) );   // possibly return LC_ID
		}

		if( cp )
		{
			memcpy( (void*)cp, (void*)pcachecp, sizeof( *pcachecp ) );   // possibly return cp
		}

		//_ERRCHECK(strcpy_s(output, sizeInChars, cacheout));
		strcpy( output, cacheout );
		return cacheout; // return fully expanded locale string
	}

	//--------------------------------------------------------------------------------
	int Clocale::__lc_strtolc ( nsWin32::CLC_STRINGS* names, const char* locale )
	{
		_WINQ_FCONTEXT( "Clocale::__lc_strtolc" );
		int i;
		size_t len;
		char ch;

		memset( (void*)names, '\0', sizeof( nsWin32::CLC_STRINGS ) );  // clear out result

		if( *locale == '\0' )
		{
			return 0;
		}

		// only code page is given
		if( locale[ 0 ] == '.' && locale[ 1 ] != '\0' )
		{
			//_ERRCHECK(strncpy_s(names->szCodePage, _countof(names->szCodePage), &locale[1], MAX_CP_LEN-1));
			strcpy( names->m_szCodePage, &locale[ 1 ] );
			// Make sure to null terminate the string in case locale is > MAX_CP_LEN
			names->m_szCodePage[ nsWin32::CLC_ID::MAX_CP_LEN - 1 ] = 0;
			return 0;
		}

		for( i = 0; ; i++ )
		{
			if( ( len = strcspn( locale, "_.," ) ) ? false : true )
			{
				return -1;  // syntax error
			}

			ch = locale[ len ];

			if( ( i == 0 ) && ( len < nsWin32::CLC_ID::MAX_LANG_LEN ) && ( ch != '.' ) )
			{
				//_ERRCHECK(strncpy_s(names->szLanguage, _countof(names->szLanguage), locale, len));
				strncpy( names->m_szLanguage, locale, len );
			}
			else if( ( i == 1 ) && ( len < nsWin32::CLC_ID::MAX_CTRY_LEN ) && ( ch != '_' ) )
			{
				//_ERRCHECK(strncpy_s(names->szCountry, _countof(names->szCountry), locale, len));
				strncpy( names->m_szCountry, locale, len );
			}
			else if( ( i == 2 ) && ( len < nsWin32::CLC_ID::MAX_CP_LEN ) && ( ch == '\0' || ch == ',' ) )
			{
				//_ERRCHECK(strncpy_s(names->szCodePage, _countof(names->szCodePage), locale, len));
				strncpy( names->m_szCodePage, locale, len );
			}
			else
			{
				return -1;  // error parsing locale string
			}

			if( ch == ',' )
			{
				/* modifier not used in current implementation, but it
				   must be parsed to for POSIX/XOpen conformance */
				/*  strncpy(names->szModifier, locale, MAX_MODIFIER_LEN-1); */
				break;
			}

			if( !ch )
			{
				break;
			}
			locale += ( len + 1 );
		}
		return 0;
	}

	//--------------------------------------------------------------------------------
	void Clocale::__lc_lctostr( char* locale, size_t sizeInBytes, const nsWin32::CLC_STRINGS* names )
	{
		_WINQ_FCONTEXT( "Clocale::__lc_lctostr" );
		//_ERRCHECK(strcpy_s(locale, sizeInBytes, (char *)names->szLanguage));
		strcpy( locale, names->m_szLanguage );
		if( *( names->m_szCountry ) )
		{
			_strcats( locale, sizeInBytes, 2, "_", names->m_szCountry );
		}

		if( *( names->m_szCodePage ) )
		{
			_strcats( locale, sizeInBytes, 2, ".", names->m_szCodePage );
		}
	}

	//--------------------------------------------------------------------------------
	void Clocale::_strcats( char* outstr, size_t sizeInBytes, int n, ... )
	{
		_WINQ_FCONTEXT( "Clocale::_strcats" );
		int i;
		va_list substr;

		va_start( substr, n );

		for( i = 0; i < n; i++ )
		{
			//_ERRCHECK(strcat_s(outstr, sizeInBytes, va_arg(substr, char *)));
			strcat( outstr, va_arg( substr, char* ) );
		}
		va_end( substr );
	}	

}//nsWin32


#endif//(QOR_SYS_OS == QOR_SYS_MSW)
