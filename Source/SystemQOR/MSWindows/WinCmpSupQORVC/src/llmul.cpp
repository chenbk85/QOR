//llmul.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "CompilerQOR.h"
#include "CodeQOR/Macros/CodingMacros.h"
#include "ArchQOR/Common/Machine.h"
#include "ArchQOR/Common/HLAssembler/JITFunctor.h"

//To generate assembler function for allmul - long multiply

//------------------------------------------------------------------------------
class CJITallmul : public nsArch::CJITFunctor0< int >
{
public:

	//------------------------------------------------------------------------------
	CJITallmul( nsArch::CHighLevelAssemblerBase* pHLA, byte* pLaunchPad = 0 ) : CJITFunctor0( pHLA, pLaunchPad )
	{
		if( m_pLaunchPad != 0 )
		{
			Generate();
		}
	}

protected:

	//------------------------------------------------------------------------------
	virtual FP Generate()
	{
		nsArch::nsx86::Cx86HLAIntrinsics& HLA = (*(dynamic_cast< nsArch::nsx86::Cx86HLAIntrinsics* >(m_pHLA)));
		nsArch::nsx86::CCPU& CPU = *(dynamic_cast< nsArch::nsx86::CCPU* >(HLA.getAssembler()));

		CPU.clear();

		nsArch::nsx86::CLabel Label1 = CPU.newLabel();
		nsArch::nsx86::CLabel Label2 = CPU.newLabel();
		nsArch::nsx86::CLabel Label3 = CPU.newLabel();
		nsArch::nsx86::CLabel Label4 = CPU.newLabel();
		/*
		public  __allmul

		*/
		/*
		;
		; llmul - long multiply routine
		;
		; Purpose:
		;       Does a long multiply (same for signed/unsigned)
		;       Parameters are not changed.
		;
		; Entry:
		;       Parameters are passed on the stack:
		;               1st pushed: multiplier (QWORD)
		;               2nd pushed: multiplicand (QWORD)
		;
		; Exit:
		;       EDX:EAX - product of multiplier and multiplicand
		;       NOTE: parameters are removed from the stack
		;
		; Uses:
		;       ECX
		;
		*/
		/*
		__allmul        proc    near
		assume  cs:_TEXT
		*/
		//A       EQU     [esp + 4]       ; stack address of a
		nsArch::nsx86::CMem A(CPU.reg_esp(), 0);												//stack address of a
		nsArch::nsx86::CMem HiWordA(CPU.reg_esp(), 4);
		//B       EQU     [esp + 12]      ; stack address of b
		nsArch::nsx86::CMem B(CPU.reg_esp(), 8);												//stack address of b
		nsArch::nsx86::CMem HiWordB(CPU.reg_esp(), 12);
		/*
		;
		;       AHI, BHI : upper 32 bits of A and B
		;       ALO, BLO : lower 32 bits of A and B
		;
		;             ALO * BLO
		;       ALO * BHI
		; +     BLO * AHI
		; ---------------------
		*/

		//mov     eax,HIWORD(A)
		CPU.mov(CPU.reg_eax(), HiWordA);
		//mov     ecx,HIWORD(B)
		CPU.mov(CPU.reg_ecx(), HiWordB);
		//or      ecx,eax         ;test for both hiwords zero.
		CPU.or_(CPU.reg_ecx(), CPU.reg_eax());												//test for both hiwords zero.
		//mov     ecx,LOWORD(B)
		CPU.mov(CPU.reg_ecx(), B);
		//jnz     short hard      ;both are zero, just mult ALO and BLO
		CPU.short_jnz(Label1);																//both are zero, just mult ALO and BLO

		//mov     eax, LOWORD(A)
		CPU.mov(CPU.reg_eax(), A);
		//mul     ecx
		CPU.mul(CPU.reg_ecx());
		//ret     16; callee restores the stack
		CPU.ret(nsArch::nsx86::CImm(16));													//callee restores the stack

		//hard:
		CPU.bind(Label1);
		//push    ebx
		CPU.push(CPU.reg_ebx());

		//; must redefine A and B since esp has been altered

		//A2      EQU     [esp + 8]       ; stack address of a
		nsArch::nsx86::CMem A2(CPU.reg_esp(), 4);												//stack address of a
		nsArch::nsx86::CMem HiWordA2(CPU.reg_esp(), 8);

		//B2      EQU     [esp + 16]      ; stack address of b
		nsArch::nsx86::CMem B2(CPU.reg_esp(), 12);												//stack address of b
		nsArch::nsx86::CMem HiWordB2(CPU.reg_esp(), 16);

		//mul     ecx             ;eax has AHI, ecx has BLO, so AHI * BLO
		CPU.mul(CPU.reg_ecx());																	//eax has AHI, ecx has BLO, so AHI * BLO
		//mov     ebx,eax         ;save result
		CPU.mov(CPU.reg_ebx(), CPU.reg_eax());													//save result

		//mov     eax,LOWORD(A2)
		CPU.mov(CPU.reg_eax(), A2);
		//mul     dword ptr HIWORD(B2) ;ALO * BHI
		CPU.mul(HiWordB2);																		//ALO * BHI
		//add     ebx,eax         ;ebx = ((ALO * BHI) + (AHI * BLO))
		CPU.add(CPU.reg_ebx(), CPU.reg_eax());													//ebx = ((ALO * BHI) + (AHI * BLO))

		//mov     eax,LOWORD(A2)  ;ecx = BLO
		CPU.mov(CPU.reg_eax(), A2);																//ecx = BLO
		//mul     ecx             ;so edx:eax = ALO*BLO
		CPU.mul(CPU.reg_ecx());																	//so edx : eax = ALO*BLO
		//add     edx,ebx         ;now edx has all the LO*HI stuff
		CPU.add(CPU.reg_edx(), CPU.reg_ebx());													//now edx has all the LO*HI stuff

		//pop     ebx
		CPU.pop(CPU.reg_ebx());

		//ret     16              ; callee restores the stack
		CPU.ret(nsArch::nsx86::CImm(16));														//callee restores the stack

		// Make JIT function.
		FP fn = reinterpret_cast< FP >(CPU.make());

		// Ensure that everything is ok and write the launchpad
		if (fn)
		{
			m_bGenerated = true;
			if (m_pLaunchPad)
			{
				HLA.WriteLaunchPad((byte*)fn, m_pLaunchPad);
			}
		}

		return fn;
	}
};

__QCMP_STARTLINKAGE_C

#pragma section( ".jit", execute )

__declspec( allocate( ".jit" ) ) byte _allmul[ 16 ];

#pragma comment( linker, "/SECTION:.jit,ERW" )

__QCMP_ENDLINKAGE_C

CJITallmul allmulJIT( &TheMachine()->HLAssembler(), _allmul );

