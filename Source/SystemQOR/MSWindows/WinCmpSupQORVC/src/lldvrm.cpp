//lldvrm.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "CompilerQOR.h"
#include "CodeQOR/Macros/CodingMacros.h"
#include "ArchQOR/Common/Machine.h"
#include "ArchQOR/Common/HLAssembler/JITFunctor.h"

//To generate assembler function for lldvrm - signed long divide and remainder

//------------------------------------------------------------------------------
class CJITalldvrm : public nsArch::CJITFunctor0< int >
{
public:

	//------------------------------------------------------------------------------
	CJITalldvrm( nsArch::CHighLevelAssemblerBase* pHLA, byte* pLaunchPad = 0 ) : CJITFunctor0( pHLA, pLaunchPad )
	{
		if (m_pLaunchPad != 0)
		{
			Generate();
		}
	}

protected:

	//------------------------------------------------------------------------------
	virtual FP Generate()
	{
		nsArch::nsx86::Cx86HLAIntrinsics& HLA = (*(dynamic_cast< nsArch::nsx86::Cx86HLAIntrinsics* >(m_pHLA)));
		nsArch::nsx86::CCPU& CPU = *(dynamic_cast< nsArch::nsx86::CCPU* >(HLA.getAssembler()));

		CPU.clear();

		nsArch::nsx86::CLabel Label1 = CPU.newLabel();
		nsArch::nsx86::CLabel Label2 = CPU.newLabel();
		nsArch::nsx86::CLabel Label3 = CPU.newLabel();
		nsArch::nsx86::CLabel Label4 = CPU.newLabel();
		nsArch::nsx86::CLabel Label5 = CPU.newLabel();
		nsArch::nsx86::CLabel Label6 = CPU.newLabel();
		nsArch::nsx86::CLabel Label7 = CPU.newLabel();
		nsArch::nsx86::CLabel Label8 = CPU.newLabel();
		nsArch::nsx86::CLabel Label9 = CPU.newLabel();

		/*
		; Purpose:
		;       Does a signed long divide and remainder of the arguments.  Arguments are
		;       not changed.
		;
		; Entry:
		;       Arguments are passed on the stack:
		;               1st pushed: divisor (QWORD)
		;               2nd pushed: dividend (QWORD)
		;
		; Exit:
		;       EDX:EAX contains the quotient (dividend/divisor)
		;       EBX:ECX contains the remainder (divided % divisor)
		;       NOTE: this routine removes the parameters from the stack.
		;
		; Uses:
		;       ECX
		;
		*/

		//push    edi
		CPU.push(CPU.reg_edi());
		//push    esi
		CPU.push(CPU.reg_esi());
		//push    ebp
		CPU.push(CPU.reg_ebp());

		//DVND    equ     [esp + 16]      ; stack address of dividend (a)
		nsArch::nsx86::CMem Dividend(CPU.reg_esp(), 12);									//stack address of dividend (a)
		nsArch::nsx86::CMem HiWordDividend(CPU.reg_esp(), 16);
		//DVSR    equ     [esp + 24]      ; stack address of divisor (b)
		nsArch::nsx86::CMem Divisor(CPU.reg_esp(), 20);										//stack address of divisor (b)
		nsArch::nsx86::CMem HiWordDivisor(CPU.reg_esp(), 24);
		/*
		; Determine sign of the quotient (edi = 0 if result is positive, non-zero
		; otherwise) and make operands positive.
		; Sign of the remainder is kept in ebp.
		*/

		//xor     edi,edi         ; result sign assumed positive
		CPU.xor_(CPU.reg_edi(), CPU.reg_edi());												//result sign assumed positive
		//xor     ebp,ebp         ; result sign assumed positive
		CPU.xor_(CPU.reg_ebp(), CPU.reg_ebp());												//result sign assumed positive
		//mov     eax,HIWORD(DVND) ; hi word of a
		CPU.mov(CPU.reg_eax(), HiWordDividend);												//hi word of a
		//or      eax,eax         ; test to see if signed
		CPU.or_(CPU.reg_eax(), CPU.reg_eax());												//test to see if signed
		//jge     short L1        ; skip rest if a is already positive
		CPU.short_jge(Label1);																//skip rest if a is already positive
		//inc     edi             ; complement result sign flag
		CPU.inc(CPU.reg_edi());																//complement result sign flag
		//inc     ebp; complement result sign flag
		CPU.inc(CPU.reg_ebp());																//complement result sign flag
		//mov     edx,LOWORD(DVND) ; lo word of a
		CPU.mov(CPU.reg_edx(), Dividend);													//lo word of a
		//neg     eax             ; make a positive
		CPU.neg(CPU.reg_eax());																//make a positive
		//neg     edx
		CPU.neg(CPU.reg_edx());
		//sbb     eax,0
		CPU.sbb(CPU.reg_eax(), nsArch::nsx86::CImm(0));
		//mov     HIWORD(DVND),eax ; save positive value
		CPU.mov(HiWordDividend, CPU.reg_eax());												//save positive value
		//mov     LOWORD(DVND), edx
		CPU.mov(Dividend, CPU.reg_edx());
		//L1:
		CPU.bind(Label1);
		//mov     eax,HIWORD(DVSR) ; hi word of b
		CPU.mov(CPU.reg_eax(), HiWordDivisor);												//hi word of b
		//or      eax,eax         ; test to see if signed
		CPU.or_(CPU.reg_eax(), CPU.reg_eax());												//test to see if signed
		//jge     short L2        ; skip rest if b is already positive
		CPU.short_jge(Label2);																//skip rest if b is already positive
		//inc     edi             ; complement the result sign flag
		CPU.inc(CPU.reg_edi());																//complement the result sign flag
		//mov     edx,LOWORD(DVSR) ; lo word of b
		CPU.mov(CPU.reg_edx(), Divisor);													//lo word of b
		//neg     eax             ; make b positive
		CPU.neg(CPU.reg_eax());																//make b positive
		//neg     edx
		CPU.neg(CPU.reg_edx());
		//sbb     eax,0
		CPU.sbb(CPU.reg_eax(), nsArch::nsx86::CImm(0));
		//mov     HIWORD(DVSR),eax ; save positive value
		CPU.mov(HiWordDivisor, CPU.reg_eax());												//save positive value
		//mov     LOWORD(DVSR),edx
		CPU.mov(Divisor, CPU.reg_edx());
		//L2:
		CPU.bind(Label2);
		/*
		; Now do the divide.  First look to see if the divisor is less than 4194304K.
		; If so, then we can use a simple algorithm with word divides, otherwise
		; things get a little more complex.
		;
		; NOTE - eax currently contains the high order word of DVSR
		*/
		
		//or      eax, eax; check to see if divisor < 4194304K
		CPU.or_(CPU.reg_eax(), CPU.reg_eax());												//check to see if divisor < 4194304K
		//jnz     short L3        ; nope, gotta do this the hard way
		CPU.short_jnz(Label3);																//nope, gotta do this the hard way
		//mov     ecx,LOWORD(DVSR) ; load divisor
		CPU.mov(CPU.reg_ecx(), Divisor);													//load divisor
		//mov     eax,HIWORD(DVND) ; load high word of dividend
		CPU.mov(CPU.reg_eax(), HiWordDividend);												//load high word of dividend
		//xor     edx,edx
		CPU.xor_(CPU.reg_edx(), CPU.reg_edx());
		//div     ecx             ; eax <- high order bits of quotient
		CPU.div(CPU.reg_ecx());																//eax <- high order bits of quotient
		//mov     ebx,eax         ; save high bits of quotient
		CPU.mov(CPU.reg_ebx(), CPU.reg_eax());												//save high bits of quotient
		//mov     eax,LOWORD(DVND) ; edx:eax <- remainder:lo word of dividend
		CPU.mov(CPU.reg_eax(), Dividend);													//edx:eax <- remainder:lo word of dividend
		//div     ecx             ; eax <- low order bits of quotient
		CPU.div(CPU.reg_ecx());																//eax <- low order bits of quotient
		//mov     esi,eax         ; ebx:esi <- quotient
		CPU.mov(CPU.reg_esi(), CPU.reg_eax());												//ebx:esi <- quotient
		/*						
		; Now we need to do a multiply so that we can compute the remainder.
		*/
		//mov     eax, ebx; set up high word of quotient
		CPU.mov(CPU.reg_eax(), CPU.reg_ebx());												//set up high word of quotient
		//mul     dword ptr LOWORD(DVSR) ; HIWORD(QUOT) * DVSR
		CPU.mul(Divisor);																	//HIWORD(QUOT) * DVSR
		//mov     ecx,eax         ; save the result in ecx
		CPU.mov(CPU.reg_ecx(), CPU.reg_eax());												//save the result in ecx
		//mov     eax,esi         ; set up low word of quotient
		CPU.mov(CPU.reg_eax(), CPU.reg_esi());												//set up low word of quotient
		//mul     dword ptr LOWORD(DVSR) ; LOWORD(QUOT) * DVSR
		CPU.mul(Divisor);																	//LOWORD(QUOT) * DVSR
		//add     edx,ecx         ; EDX:EAX = QUOT * DVSR
		CPU.add(CPU.reg_edx(), CPU.reg_eax());												//EDX:EAX = QUOT * DVSR
		//jmp     short L4        ; complete remainder calculation
		CPU.short_jmp(Label4);																//complete remainder calculation
		/*		
		; Here we do it the hard way.  Remember, eax contains the high word of DVSR
		*/
		//L3:
		CPU.bind(Label3);
		//mov     ebx,eax         ; ebx:ecx <- divisor
		CPU.mov(CPU.reg_ebx(), CPU.reg_eax());												//ebx:ecx <- divisor
		//mov     ecx,LOWORD(DVSR)
		CPU.mov(CPU.reg_ecx(), Divisor);
		//mov     edx,HIWORD(DVND) ; edx:eax <- dividend
		CPU.mov(CPU.reg_edx(), HiWordDividend);												//edx:eax <- dividend
		//mov     eax,LOWORD(DVND)
		CPU.mov(CPU.reg_eax(), Dividend);
		//L5:
		CPU.bind(Label5);
		//shr     ebx,1           ; shift divisor right one bit
		CPU.shr(CPU.reg_ebx(), nsArch::nsx86::CImm(1));										//shift divisor right one bit
		//rcr     ecx,1
		CPU.rcr(CPU.reg_ecx(), nsArch::nsx86::CImm(1));
		//shr     edx,1           ; shift dividend right one bit
		CPU.shr(CPU.reg_edx(), nsArch::nsx86::CImm(1));										//shift dividend right one bit
		//rcr     eax,1
		CPU.rcr(CPU.reg_eax(), nsArch::nsx86::CImm(1));
		//or      ebx,ebx
		CPU.or_(CPU.reg_ebx(), CPU.reg_ebx());
		//jnz     short L5        ; loop until divisor < 4194304K
		CPU.short_jnz(Label5);																//loop until divisor < 4194304K
		//div     ecx             ; now divide, ignore remainder
		CPU.div(CPU.reg_ecx());																//now divide, ignore remainder
		//mov     esi,eax         ; save quotient
		CPU.mov(CPU.reg_esi(), CPU.reg_eax());												//save quotient
		/*
		; We may be off by one, so to check, we will multiply the quotient
		; by the divisor and check the result against the orignal dividend
		; Note that we must also check for overflow, which can occur if the
		; dividend is close to 2**64 and the quotient is off by 1.
		*/

		//mul     dword ptr HIWORD(DVSR) ; QUOT * HIWORD(DVSR)
		CPU.mul(HiWordDivisor);																//QUOT * HIWORD(DVSR)
		//mov     ecx,eax
		CPU.mov(CPU.reg_ecx(), CPU.reg_eax());
		//mov     eax,LOWORD(DVSR)
		CPU.mov(CPU.reg_eax(), Divisor);
		//mul     esi             ; QUOT * LOWORD(DVSR)
		CPU.mul(CPU.reg_esi());																//QUOT * LOWORD(DVSR)
		//add     edx,ecx         ; EDX:EAX = QUOT * DVSR
		CPU.add(CPU.reg_edx(), CPU.reg_ecx());												//EDX:EAX = QUOT * DVSR
		//jc      short L6        ; carry means Quotient is off by 1
		CPU.short_jc(Label6);																//carry means Quotient is off by 1
		/*
		; do long compare here between original dividend and the result of the
		; multiply in edx:eax.  If original is larger or equal, we are ok, otherwise
		; subtract one (1) from the quotient.
		*/
		//cmp     edx,HIWORD(DVND) ; compare hi words of result and original
		CPU.cmp(CPU.reg_edx(), HiWordDividend);												//compare hi words of result and original
		//ja      short L6        ; if result > original, do subtract
		CPU.short_ja(Label6);																//if result > original, do subtract
		//jb      short L7        ; if result < original, we are ok
		CPU.short_jb(Label7);																//if result < original, we are ok
		//cmp     eax,LOWORD(DVND) ; hi words are equal, compare lo words
		CPU.cmp(CPU.reg_eax(), Dividend);													//hi words are equal, compare lo words
		//jbe     short L7        ; if less or equal we are ok, else subtract
		CPU.short_jbe(Label7);																//if less or equal we are ok, else subtract
		//L6:
		CPU.bind(Label6);
		//dec     esi             ; subtract 1 from quotient
		CPU.dec(CPU.reg_esi());																//subtract 1 from quotient
		//sub     eax,LOWORD(DVSR) ; subtract divisor from result
		CPU.sub(CPU.reg_eax(), Divisor);													//subtract divisor from result
		//sbb     edx,HIWORD(DVSR)
		CPU.sbb(CPU.reg_edx(), HiWordDivisor);
		//L7:
		CPU.bind(Label7);
		//xor     ebx,ebx         ; ebx:esi <- quotient
		CPU.xor_(CPU.reg_ebx(), CPU.reg_ebx());												//ebx:esi <- quotient

		//L4:
		CPU.bind(Label4);
		/*
		; Calculate remainder by subtracting the result from the original dividend.
		; Since the result is already in a register, we will do the subtract in the
		; opposite direction and negate the result if necessary.
		*/

		//sub     eax,LOWORD(DVND) ; subtract dividend from result
		CPU.sub(CPU.reg_eax(), Dividend);													//subtract dividend from result
		//sbb     edx,HIWORD(DVND)
		CPU.sbb(CPU.reg_edx(), HiWordDividend);

		/*
		; Now check the result sign flag to see if the result is supposed to be positive
		; or negative.  It is currently negated (because we subtracted in the 'wrong'
		; direction), so if the sign flag is set we are done, otherwise we must negate
		; the result to make it positive again.
		*/

		//dec     ebp             ; check result sign flag
		CPU.dec(CPU.reg_ebp());																//check result sign flag
		//jns     short L9        ; result is ok, set up the quotient
		CPU.short_jns(Label9);																//result is ok, set up the quotient		
		//neg     edx             ; otherwise, negate the result
		CPU.neg(CPU.reg_edx());																//otherwise, negate the result
		//neg     eax
		CPU.neg(CPU.reg_eax());
		//sbb     edx,0
		CPU.sbb(CPU.reg_edx(), nsArch::nsx86::CImm(0));

		/*
		; Now we need to get the quotient into edx:eax and the remainder into ebx:ecx.
		*/
		//L9:
		CPU.bind(Label9);
		//mov     ecx,edx
		CPU.mov(CPU.reg_ecx(), CPU.reg_edx());
		//mov     edx,ebx
		CPU.mov(CPU.reg_edx(), CPU.reg_ebx());
		//mov     ebx,ecx
		CPU.mov(CPU.reg_ebx(), CPU.reg_ecx());
		//mov     ecx,eax
		CPU.mov(CPU.reg_ecx(), CPU.reg_eax());
		//mov     eax,esi
		CPU.mov(CPU.reg_eax(), CPU.reg_esi());

		/*
		; Just the cleanup left to do.  edx:eax contains the quotient.  Set the sign
		; according to the save value, cleanup the stack, and return.
		*/

		//dec     edi             ; check to see if result is negative
		CPU.dec(CPU.reg_edi());																//check to see if result is negative
		//jnz     short L8        ; if EDI == 0, result should be negative
		CPU.short_jnz(Label8);																//if EDI == 0, result should be negative
		//neg     edx             ; otherwise, negate the result
		CPU.neg(CPU.reg_edx());																//otherwise, negate the result
		//neg     eax
		CPU.neg(CPU.reg_eax());
		//sbb     edx,0
		CPU.sbb(CPU.reg_edx(), nsArch::nsx86::CImm(0));

		/*
		; Restore the saved registers and return.
		*/

		//L8:
		CPU.bind(Label8);
		//pop     ebp
		CPU.pop(CPU.reg_ebp());
		//pop     esi
		CPU.pop(CPU.reg_esi());
		//pop     edi
		CPU.pop(CPU.reg_edi());

		//ret     16
		CPU.ret(nsArch::nsx86::CImm(16));

		// Make JIT function.
		FP fn = reinterpret_cast< FP >(CPU.make());

		// Ensure that everything is ok and write the launchpad
		if (fn)
		{
			m_bGenerated = true;
			if (m_pLaunchPad)
			{
				HLA.WriteLaunchPad((byte*)fn, m_pLaunchPad);
			}
		}

		return fn;

	}
};

__QCMP_STARTLINKAGE_C

#pragma section( ".jit", execute )

__declspec(allocate(".jit")) byte _alldvrm[16];

#pragma comment( linker, "/SECTION:.jit,ERW" )

__QCMP_ENDLINKAGE_C

CJITalldvrm alldvrmJIT( &TheMachine()->HLAssembler(), _alldvrm );

