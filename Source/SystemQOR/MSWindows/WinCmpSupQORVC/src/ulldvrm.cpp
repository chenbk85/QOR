//ulldvrm.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "CompilerQOR.h"
#include "CodeQOR/Macros/CodingMacros.h"
#include "ArchQOR/Common/Machine.h"
#include "ArchQOR/Common/HLAssembler/JITFunctor.h"

//To generate assembler function for aulldvrm - unsigned long division with remainder

//------------------------------------------------------------------------------
class CJITaulldvrm : public nsArch::CJITFunctor0< int >
{
public:

	//------------------------------------------------------------------------------
	CJITaulldvrm( nsArch::CHighLevelAssemblerBase* pHLA, byte* pLaunchPad = 0 ) : CJITFunctor0(pHLA, pLaunchPad)
	{
		if (m_pLaunchPad != 0)
		{
			Generate();
		}
	}

protected:

	//------------------------------------------------------------------------------
	virtual FP Generate()
	{
		nsArch::nsx86::Cx86HLAIntrinsics& HLA = (*(dynamic_cast< nsArch::nsx86::Cx86HLAIntrinsics* >(m_pHLA)));
		nsArch::nsx86::CCPU& CPU = *(dynamic_cast< nsArch::nsx86::CCPU* >(HLA.getAssembler()));

		CPU.clear();

		nsArch::nsx86::CLabel Label1 = CPU.newLabel();
		nsArch::nsx86::CLabel Label2 = CPU.newLabel();
		nsArch::nsx86::CLabel Label3 = CPU.newLabel();
		nsArch::nsx86::CLabel Label4 = CPU.newLabel();
		nsArch::nsx86::CLabel Label5 = CPU.newLabel();

		/*
		; Purpose:
		;       Does a unsigned long divide and remainder of the arguments.  Arguments
		;       are not changed.
		;
		; Entry:
		;       Arguments are passed on the stack:
		;               1st pushed: divisor (QWORD)
		;               2nd pushed: dividend (QWORD)
		;
		; Exit:
		;       EDX:EAX contains the quotient (dividend/divisor)
		;       EBX:ECX contains the remainder (divided % divisor)
		;       NOTE: this routine removes the parameters from the stack.
		;
		; Uses:
		;       ECX
		*/

		//push    esi
		CPU.push(CPU.reg_esi());

		/*
		; Set up the local stack and save the index registers.  When this is done
		; the stack frame will look as follows (assuming that the expression a/b will
		; generate a call to aulldvrm(a, b)):
		;
		;               -----------------
		;               |               |
		;               |---------------|
		;               |               |
		;               |--divisor (b)--|
		;               |               |
		;               |---------------|
		;               |               |
		;               |--dividend (a)-|
		;               |               |
		;               |---------------|
		;               | return addr** |
		;               |---------------|
		;       ESP---->|      ESI      |
		;               -----------------
		*/

		//DVND    equ     [esp + 8]       ; stack address of dividend (a)
		nsArch::nsx86::CMem Dividend(CPU.reg_esp(), 4);										//stack address of dividend (a)
		nsArch::nsx86::CMem HiWordDividend(CPU.reg_esp(), 8);
		
		//DVSR    equ     [esp + 16]      ; stack address of divisor (b)
		nsArch::nsx86::CMem Divisor(CPU.reg_esp(), 12);										//stack address of divisor (b)
		nsArch::nsx86::CMem HiWordDivisor(CPU.reg_esp(), 16);

		/*
		; Now do the divide.  First look to see if the divisor is less than 4194304K.
		; If so, then we can use a simple algorithm with word divides, otherwise
		; things get a little more complex.
		*/

		//mov     eax,HIWORD(DVSR) ; check to see if divisor < 4194304K
		CPU.mov(CPU.reg_eax(), HiWordDivisor);												//check to see if divisor < 4194304K
		//or      eax,eax
		CPU.or_(CPU.reg_eax(), CPU.reg_eax());
		//jnz     short L1        ; nope, gotta do this the hard way
		CPU.short_jnz(Label1);																//nope, gotta do this the hard way

		//mov     ecx,LOWORD(DVSR) ; load divisor
		CPU.mov(CPU.reg_ecx(), Divisor);													//load divisor
		//mov     eax,HIWORD(DVND) ; load high word of dividend
		CPU.mov(CPU.reg_eax(), HiWordDividend);												//load high word of dividend
		//xor     edx,edx
		CPU.xor_(CPU.reg_edx(), CPU.reg_edx());
		//div     ecx             ; get high order bits of quotient
		CPU.div(CPU.reg_ecx());																//get high order bits of quotient
		//mov     ebx,eax         ; save high bits of quotient
		CPU.mov(CPU.reg_ebx(), CPU.reg_eax());												//save high bits of quotient
		//mov     eax,LOWORD(DVND) ; edx:eax <- remainder:lo word of dividend
		CPU.mov(CPU.reg_eax(), Dividend);													//edx:eax <- remainder:lo word of dividend
		//div     ecx             ; get low order bits of quotient
		CPU.div(CPU.reg_ecx());																//get low order bits of quotient
		//mov     esi,eax         ; ebx:esi <- quotient
		CPU.mov(CPU.reg_esi(), CPU.reg_eax());												//ebx:esi <- quotient

		/*
		; Now we need to do a multiply so that we can compute the remainder.
		*/
		//mov     eax,ebx         ; set up high word of quotient
		CPU.mov(CPU.reg_eax(), CPU.reg_ebx());												//set up high word of quotient
		//mul     dword ptr LOWORD(DVSR) ; HIWORD(QUOT) * DVSR
		CPU.mul(Divisor);																	//HIWORD(QUOT) * DVSR
		//mov     ecx,eax         ; save the result in ecx
		CPU.mov(CPU.reg_ecx(), CPU.reg_eax());												//save the result in ecx
		//mov     eax,esi         ; set up low word of quotient
		CPU.mov(CPU.reg_eax(), CPU.reg_eax());												//set up low word of quotient
		//mul     dword ptr LOWORD(DVSR) ; LOWORD(QUOT) * DVSR
		CPU.mul(Divisor);																	//LOWORD(QUOT) * DVSR
		//add     edx,ecx         ; EDX:EAX = QUOT * DVSR
		CPU.add(CPU.reg_edx(), CPU.reg_ecx());												//EDX:EAX = QUOT * DVSR
		//jmp     short L2        ; complete remainder calculation
		CPU.short_jmp(Label2);																//complete remainder calculation

		/*
		; Here we do it the hard way.  Remember, eax contains DVSRHI
		*/

		//L1:
		CPU.bind(Label1);
		//mov     ecx,eax         ; ecx:ebx <- divisor
		CPU.mov(CPU.reg_ecx(), CPU.reg_eax());												//ecx:ebx <- divisor
		//mov     ebx,LOWORD(DVSR)
		CPU.mov(CPU.reg_ebx(), Divisor);
		//mov     edx,HIWORD(DVND) ; edx:eax <- dividend
		CPU.mov(CPU.reg_edx(), HiWordDividend);												//edx:eax <- dividend
		//mov     eax,LOWORD(DVND)
		CPU.mov(CPU.reg_eax(), Dividend);
		//L3:
		CPU.bind(Label3);
		//shr     ecx,1           ; shift divisor right one bit; hi bit <- 0
		CPU.shr(CPU.reg_ecx(), nsArch::nsx86::CImm(1));										//shift divisor right one bit; hi bit <- 0
		//rcr     ebx,1
		CPU.rcr(CPU.reg_ebx(), nsArch::nsx86::CImm(1));
		//shr     edx,1           ; shift dividend right one bit; hi bit <- 0
		CPU.shr(CPU.reg_edx(), nsArch::nsx86::CImm(1));										//shift dividend right one bit; hi bit <- 0
		//rcr     eax,1
		CPU.rcr(CPU.reg_eax(), nsArch::nsx86::CImm(1));
		//or      ecx,ecx
		CPU.or_(CPU.reg_ecx(), CPU.reg_ecx());
		//jnz     short L3        ; loop until divisor < 4194304K
		CPU.short_jnz(Label3);																//loop until divisor < 4194304K

		//div     ebx             ; now divide, ignore remainder
		CPU.div(CPU.reg_ebx());																//now divide, ignore remainder
		//mov     esi,eax         ; save quotient
		CPU.mov(CPU.reg_esi(), CPU.reg_eax());												// save quotient

		/*
		; We may be off by one, so to check, we will multiply the quotient
		; by the divisor and check the result against the orignal dividend
		; Note that we must also check for overflow, which can occur if the
		; dividend is close to 2**64 and the quotient is off by 1.
		*/

		//mul     dword ptr HIWORD(DVSR) ; QUOT * HIWORD(DVSR)
		CPU.mul(HiWordDivisor);																//QUOT * HIWORD(DVSR)
		//mov     ecx,eax
		CPU.mov(CPU.reg_ecx(), CPU.reg_eax());
		//mov     eax,LOWORD(DVSR)
		CPU.mov(CPU.reg_eax(), Divisor);
		//mul     esi             ; QUOT * LOWORD(DVSR)
		CPU.mul(CPU.reg_esi());																//QUOT * LOWORD(DVSR)
		//add     edx,ecx         ; EDX:EAX = QUOT * DVSR
		CPU.add(CPU.reg_edx(), CPU.reg_ecx());												//EDX:EAX = QUOT * DVSR
		//jc      short L4        ; carry means Quotient is off by 1
		CPU.short_jc(Label4);																//carry means Quotient is off by 1

		/*
		; do long compare here between original dividend and the result of the
		; multiply in edx:eax.  If original is larger or equal, we are ok, otherwise
		; subtract one (1) from the quotient.
		*/

		//cmp     edx, HIWORD(DVND); compare hi words of result and original
		CPU.cmp(CPU.reg_edx(), HiWordDividend);												//compare hi words of result and original
		//ja      short L4; if result > original, do subtract
		CPU.short_ja(Label4);																//if result > original, do subtract
		//jb      short L5; if result < original, we are ok
		CPU.short_jb(Label5);																//if result < original, we are ok
		//cmp     eax, LOWORD(DVND); hi words are equal, compare lo words
		CPU.cmp(CPU.reg_eax(), Dividend);													//hi words are equal, compare lo words
		//jbe     short L5; if less or equal we are ok, else subtract
		CPU.short_jbe(Label5);																//if less or equal we are ok, else subtract
		//L4:
		CPU.bind(Label4);
		//dec     esi; subtract 1 from quotient
		CPU.dec(CPU.reg_esi());																//subtract 1 from quotient
		//sub     eax, LOWORD(DVSR); subtract divisor from result
		CPU.sub(CPU.reg_eax(), Divisor);													//subtract divisor from result
		//sbb     edx, HIWORD(DVSR)
		CPU.sbb(CPU.reg_edx(), HiWordDivisor);
		//L5:
		CPU.bind(Label5);
		//xor     ebx, ebx; ebx:esi < -quotient
		CPU.xor_(CPU.reg_ebx(), CPU.reg_ebx());												//ebx:esi < -quotient

		//L2:
		CPU.bind(Label2);
		/*
		; Calculate remainder by subtracting the result from the original dividend.
		; Since the result is already in a register, we will do the subtract in the
		; opposite direction and negate the result.
		*/

		//sub     eax,LOWORD(DVND) ; subtract dividend from result
		CPU.sub(CPU.reg_eax(), Dividend);													//subtract dividend from result
		//sbb     edx,HIWORD(DVND)
		CPU.sbb(CPU.reg_edx(), HiWordDividend);
		//neg     edx             ; otherwise, negate the result
		CPU.neg(CPU.reg_edx());																//otherwise, negate the result
		//neg     eax
		CPU.neg(CPU.reg_eax());
		//sbb     edx,0
		CPU.sbb(CPU.reg_edx(), nsArch::nsx86::CImm(0));

		/*
		; Now we need to get the quotient into edx:eax and the remainder into ebx:ecx.
		*/
		//mov     ecx,edx
		CPU.mov(CPU.reg_ecx(), CPU.reg_edx());
		//mov     edx,ebx
		CPU.mov(CPU.reg_edx(), CPU.reg_ebx());
		//mov     ebx,ecx
		CPU.mov(CPU.reg_ebx(), CPU.reg_ecx());
		//mov     ecx,eax
		CPU.mov(CPU.reg_ecx(), CPU.reg_eax());
		//mov     eax,esi
		CPU.mov(CPU.reg_eax(), CPU.reg_esi());
		/*
		; Just the cleanup left to do.  edx:eax contains the quotient.
		; Restore the saved registers and return.
		*/

		//pop     esi
		CPU.pop(CPU.reg_esi());

		//ret     16
		CPU.ret(nsArch::nsx86::CImm(16));

		// Make JIT function.
		FP fn = reinterpret_cast< FP >(CPU.make());

		// Ensure that everything is ok and write the launchpad
		if (fn)
		{
			m_bGenerated = true;
			if (m_pLaunchPad)
			{
				HLA.WriteLaunchPad((byte*)fn, m_pLaunchPad);
			}
		}

		return fn;
	}
};

__QCMP_STARTLINKAGE_C

#pragma section( ".jit", execute )

__declspec(allocate(".jit")) byte _aulldvrm[16];

#pragma comment( linker, "/SECTION:.jit,ERW" )

__QCMP_ENDLINKAGE_C

CJITaulldvrm aulldvrmJIT( &TheMachine()->HLAssembler(), _aulldvrm );

