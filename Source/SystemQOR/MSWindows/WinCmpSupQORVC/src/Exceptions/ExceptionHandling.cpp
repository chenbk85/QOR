//ExceptionHandling.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQL/WinQL.h"
#include "SystemQOR.h"
#include "WinQL/Application/Threading/WinQLCriticalSection.h"
#include "../SystemQOR/MSWindows/WinCmpSupQORVC/include/Exceptions/ExceptionHandling.h"
#include "../SystemQOR/MSWindows/WinCmpSupQORVC/include/Exceptions/Call.h"
#include "../SystemQOR/MSWindows/WinCmpSupQORVC/include/RTTI/RTTI.h"
#include <string.h>
#include <exception>

//--------------------------------------------------------------------------------
namespace nsCompiler
{
	//--------------------------------------------------------------------------------
	namespace EH
	{
		const unsigned int CPP_EXCEPTION	= 0xE06D7363;
		const unsigned int MS_MAGIC			= 0x19930520;//CCompilerBase::EH_MAGIC;//0x19930520 ... 0x19930522;
		const unsigned int MS_MAGIC_MASK	= 0xFFFFFFF0;

		//typedef ::_PMD PMD;
		//typedef ::_TypeDescriptor TypeDescriptor;
		/*
		//--------------------------------------------------------------------------------
		void* AdjustPointer( void* _pThis, const PMD& pmd )
		{
			unsigned char* pThis = ( unsigned char* )_pThis;
			unsigned char* pRet = pThis + pmd.mdisp;
			if (pmd.pdisp >= 0)
			{
				pRet += *(unsigned int*)(*(unsigned char**)(pThis+pmd.pdisp) + pmd.vdisp);
				pRet += pmd.pdisp;
			}
			return pRet;
		}
		*/
		//--------------------------------------------------------------------------------
		void ThrownObject::Destruct( int fThrowNotAllowed )
		{
			if ( m_pObjectInfo && m_pObjectInfo->pmfnUnwind )
			{
				__try
				{
					CallMemberFunction( m_pObject, reinterpret_cast< void* >( m_pObjectInfo->pmfnUnwind ) );
				}
				__except( fThrowNotAllowed ? nsWin32::Exception_Execute_Handler : nsWin32::Exception_Continue_Search )
				{
					std::terminate();
				}
			}
		}

		//--------------------------------------------------------------------------------
		void ThrownObject::Copy( void** pCatchBuffer, const HandlerType* pCatch, const CatchableType* pConv )
		{
			if ( pCatch->adjectives & 8 )    //catch by reference
			{
				/*if (!ValidateRead(pObject(), 1) || !ValidateWrite(pCatchBuffer, 1))
					inconsistency();*/
				*pCatchBuffer = m_pObject;
				*pCatchBuffer = AdjustPointer( *pCatchBuffer, pConv->thisDisplacement );
			}
			else if (pConv->properties & 1)  //catch by pointer
			{
				/*if (!ValidateRead(pObject(), 1) || !ValidateWrite(pCatchBuffer,1))
						inconsistency(); */
				*pCatchBuffer = *( ( unsigned char** )m_pObject );
				if ( pConv->sizeOrOffset == 4 && *pCatchBuffer != 0 )
				{
					*pCatchBuffer = AdjustPointer( *pCatchBuffer, pConv->thisDisplacement );
				}
			}
			else if ( pConv->copyFunction == 0 )
			{
				/*if (!ValidateRead(pObject(), 1) || !ValidateWrite(pCatchBuffer, 1))
					inconsistency(); */
				memmove( pCatchBuffer, AdjustPointer( m_pObject, pConv->thisDisplacement ), pConv->sizeOrOffset );
			}
			else
			{
				/*if (!ValidateRead(pObject(), 1) || !ValidateWrite(pCatchBuffer, 1) || !ValidateExecute(pConv->copyFunction))
						inconsistency(); */
				if ( pConv->properties & 4 ) //array member - ?
				{
					CallMemberFunction( pCatchBuffer, reinterpret_cast< void* >( pConv->copyFunction ), AdjustPointer( m_pObject, pConv->thisDisplacement ), 1 );
				}
				else
				{
					CallMemberFunction( pCatchBuffer, reinterpret_cast< void* >( pConv->copyFunction ), AdjustPointer( m_pObject, pConv->thisDisplacement ) );
				}
			}
		}

		//--------------------------------------------------------------------------------
		const CatchableType * ThrownObject::FindMatch( const HandlerType* pCatch )
		{
			const CatchableTypeArray* const pCatchableTypeArray = m_pObjectInfo->pCatchableTypeArray;

			const CatchableType* const* ppCatchable = (const CatchableType* const*)(pCatchableTypeArray->arrayOfCatchableTypes);

			for( int catchables = pCatchableTypeArray->nCatchableTypes ;  catchables > 0;  --catchables, ++ppCatchable )
			{
				const CatchableType* pCatchable = *ppCatchable;
				if ( TypeMatch( pCatch, pCatchable, m_pObjectInfo ) )
				{
					return pCatchable;
				}
			}

			return 0;
		}

		//--------------------------------------------------------------------------------
		int ThrownObject::TypeMatch( const HandlerType* pCatch, const CatchableType* pCatchable, const ThrowInfo* pThrow )
		{
			//if this is a catch(...) it matches everything
			if ( pCatch->pType == 0 || pCatch->pType->name[1] == 0 )
			{
				return true;
			}

			//At the very least type names have to match
			if ( pCatch->pType != pCatchable->pType && strcmp( pCatch->pType->name, pCatchable->pType->name ) != 0 )
			{
				return false;
			}

			if ( ( pCatchable->properties & 2 ) != 0 && ( pCatch->adjectives & 8 ) == 0 )
			{
				return false;
			}

			if ( ( pThrow->attributes & 1 ) != 0 && ( pCatch->adjectives & 1 ) == 0 )
			{
				return false;
			}

			if ( ( pThrow->attributes & 2 ) != 0 && ( pCatch->adjectives & 2 ) == 0 )
			{
				return false;
			}

			return true;
		}

		//--------------------------------------------------------------------------------
		ExceptionRecord::ExceptionRecord( ThrownObject& object, void* pExceptionAddress )
		{
			ExceptionCode = CPP_EXCEPTION;
			ExceptionFlags = EXCEPTION_NONCONTINUABLE;
			EXCEPTION_RECORD::ExceptionRecord = 0;
			ExceptionAddress = pExceptionAddress;
			NumberParameters = 3;
			ExceptionInformation[0] = MS_MAGIC;
			Object() = object;
		}

		//--------------------------------------------------------------------------------
		void ExceptionRecord::CopyObject( RegistrationNode* pRN, const HandlerType* pCatch, const CatchableType* pConv )
		{
			if ( pCatch->pType != 0 && pCatch->pType->name[0] != 0 && ( pCatch->dispCatchObj != 0 || ( pCatch->adjectives & 0x80000000 ) != 0 ) )
			{
				void** pCatchBuffer = ( void ** )( ( pCatch->adjectives & 0x80000000 ) == 0 ? ( unsigned char* )( pRN->GetStackFrame() ) + pCatch->dispCatchObj : ( unsigned char* )pRN );
				__try
				{
					Object().Copy( pCatchBuffer, pCatch, pConv );
				}
				__except( nsWin32::Exception_Execute_Handler )
				{
					std::terminate();
				}
			}
		}

		//--------------------------------------------------------------------------------
		__QCMP_NORETURN void inconsistency()
		{
			std::terminate();
		}

	}//EH

}//nsCompiler
