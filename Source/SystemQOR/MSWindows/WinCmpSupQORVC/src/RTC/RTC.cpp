//RTC.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Implentations of the RunTime Check API
//Mostly stubs at the moment until we can work out how to do these and JIT assemble the code where required for compiler portability



#include "SystemQOR.h"
#include "CodeQOR/Macros/codingmacros.h"
#include "../Source/SystemQOR/MSWindows/WinCmpSupQORVC/include/RTC/RTC.h"

//--------------------------------------------------------------------------------
int _RTC_ErrorLevels[ 6 ] = { 1,1,1,1,1 };
char* _RTC_ErrorMessages[ 6 ] = 
{
	"Error1",
	"Error2",
	"Error3",
	"Error4",
	"Error5",
	"Error6", 
};
	
#ifndef _WIN64		//This doesn't apply to 64bit Windows

//--------------------------------------------------------------------------------
__QCMP_LINKAGE_C void __QCMP_DECLARE_NAKED _RTC_CheckEsp()
{
	_asm
	{
        /*
		jne	esp_error
		ret
esp_error:

		push        ebp  
		mov         ebp,esp 
		sub         esp,0 
		push        eax  
		push        edx  
		push        ebx  
		push        esi  
		push        edi  
		mov         eax,dword ptr [ebp+4] 
		push        0    
		push        eax  
		call        _RTC_Failure 
		add         esp,8 
		pop         edi  
		pop         esi  
		pop         ebx  
		pop         edx  
		pop         eax  
		mov         esp,ebp 
		pop         ebp
        */
		ret              
	};
}

#endif //_WIN64

//--------------------------------------------------------------------------------
__QCMP_LINKAGE_C _RTC_error_fn __cdecl _CRT_RTC_INIT( void* _Res0, void** _Res1, int _Res2, int _Res3, int _Res4 )
{
	return 0;
}

//--------------------------------------------------------------------------------
__QCMP_LINKAGE_C _RTC_error_fnW __cdecl _CRT_RTC_INITW( void* _Res0, void** _Res1, int _Res2, int _Res3, int _Res4 )
{
	return 0;
}

//--------------------------------------------------------------------------------
__QCMP_LINKAGE_C void __cdecl _RTC_InitBase(void)
{

}

//--------------------------------------------------------------------------------
__QCMP_LINKAGE_C void __cdecl _RTC_Shutdown(void)
{

}

//--------------------------------------------------------------------------------
__QCMP_LINKAGE_C void __cdecl _RTC_UninitUse( const char* _Varname)
{

}

#ifndef _WIN64		//This doesn't apply to 64bit Windows

//--------------------------------------------------------------------------------
__QCMP_LINKAGE_C char __fastcall _RTC_Check_2_to_1(short __QCS_UNUSED( _Src ) )
{
	__asm mov al, byte ptr [ebp - 4];
}

//--------------------------------------------------------------------------------
__QCMP_LINKAGE_C char __fastcall _RTC_Check_4_to_1(int __QCS_UNUSED( _Src ) )
{
	__asm mov al, byte ptr [ebp - 4];
}

//--------------------------------------------------------------------------------
__QCMP_LINKAGE_C char __fastcall _RTC_Check_8_to_1(__int64 __QCS_UNUSED( _Src ) )
{
	__asm mov al, byte ptr [ebp - 4];
}

//--------------------------------------------------------------------------------
__QCMP_LINKAGE_C short __fastcall _RTC_Check_4_to_2(int __QCS_UNUSED( _Src ) )
{
	__asm mov ax, word ptr [ebp - 4];
}

//--------------------------------------------------------------------------------
__QCMP_LINKAGE_C short __fastcall _RTC_Check_8_to_2(__int64 __QCS_UNUSED( _Src ) )
{
	__asm mov ax, word ptr [ebp - 4];
}

//--------------------------------------------------------------------------------
__QCMP_LINKAGE_C int __fastcall _RTC_Check_8_to_4(__int64 __QCS_UNUSED( _Src ) )
{
	__asm mov eax, dword ptr [ebp - 4];
}

#endif//_WIN64

//--------------------------------------------------------------------------------
__QCMP_LINKAGE_C void __fastcall _RTC_CheckStackVars( void *_Esp, _RTC_framedesc* _Fd)
{
	//Check the Stack
}

//--------------------------------------------------------------------------------
__QCMP_LINKAGE_C void __fastcall _RTC_CheckStackVars2( void *_Esp, _RTC_framedesc* _Fd, _RTC_ALLOCA_NODE* _AllocaList )
{

}

//--------------------------------------------------------------------------------
//This is called after an alloca has occured
__QCMP_LINKAGE_C void __fastcall _RTC_AllocaHelper( _RTC_ALLOCA_NODE* _PAllocaBase, size_t _CbSize, _RTC_ALLOCA_NODE** _PAllocaInfoList )
{
	if( ( _PAllocaBase == 0 ) || ( _CbSize == 0 ) || ( *_PAllocaInfoList == 0 ) )
	{
		return;
	}
	//Write lots of (0xcc) onto the stack blanking the alloca region
}

