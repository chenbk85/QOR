//WinQLAsyncIOBuffer.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQL/IO/AsyncIOBuffer.h"
#include "WinQL/CodeServices/ErrorSystem/FunctionContext.h"

//--------------------------------------------------------------------------------
namespace nsWin32
{
	//__QOR_IMPLEMENT_CUSTOM_FACTORY( CAsyncIOBuffer, CAsyncIOBuffer::factoryType );
	__QOR_IMPLEMENT_OCLASS_LUID( CAsyncIOBuffer );

	//--------------------------------------------------------------------------------
	CAsyncIOBuffer::CAsyncIOBuffer( CBaseIOBufferPool* pPool ) : CIOSource(), CIOSink()
	,	m_pPool( pPool )
	,	m_ulReadBufferCapacity( 4096 )
	,	m_ReadCursor( m_ReadBuffer() )
	,	m_ulWriteBufferCapacity( 4096 )
	,	m_WriteCursor( m_WriteBuffer() )
	,	m_bError( false )
	{
		_WINQ_FCONTEXT( "CAsyncIOBuffer::CAsyncIOBuffer" );
	}

	//--------------------------------------------------------------------------------
	CAsyncIOBuffer::CAsyncIOBuffer( const CAsyncIOBuffer& src ) : m_ReadCursor( m_ReadBuffer() ), m_WriteCursor( m_WriteBuffer() )
	{
		_WINQ_FCONTEXT( "CAsyncIOBuffer::CAsyncIOBuffer" );
		*this = src;
	}

	//--------------------------------------------------------------------------------
	CAsyncIOBuffer& CAsyncIOBuffer::operator = ( const CAsyncIOBuffer& src )
	{
		_WINQ_FCONTEXT( "CAsyncIOBuffer::operator =" );
		if( &src != this )
		{
			m_pPool = src.m_pPool;
			m_refSourceFilter = src.m_refSourceFilter;
			m_refSinkFilter = src.m_refSinkFilter;
			m_refSource = src.m_refSource;
			m_refSink = src.m_refSink;
			//m_ReadBuffer() = src.m_ReadBuffer();
			/*m_pReadBuffer = src.m_pReadBuffer;
			m_pWriteBuffer = src.m_pWriteBuffer;
			m_ulReadCursorIndex = src.m_ulReadCursorIndex;
			m_ulWriteCursorIndex = src.m_ulWriteCursorIndex;*/
			m_bError = m_bError;
		}
		return *this;
	}

	//--------------------------------------------------------------------------------
	CAsyncIOBuffer::~CAsyncIOBuffer()
	{
		_WINQ_FCONTEXT( "CAsyncIOBuffer::~CAsyncIOBuffer" );
	}

	//--------------------------------------------------------------------------------
	void CAsyncIOBuffer::SetError( void )
	{
		_WINQ_FCONTEXT( "CAsyncIOBuffer::SetError" );
		m_bError = true;
	}

	//--------------------------------------------------------------------------------
	void CAsyncIOBuffer::ClearError( void )
	{
		_WINQ_FCONTEXT( "CAsyncIOBuffer::ClearError" );
		m_bError = false;
	}

	//--------------------------------------------------------------------------------
	bool CAsyncIOBuffer::IsError( void )
	{
		_WINQ_FCONTEXT( "CAsyncIOBuffer::IsError" );
		return m_bError;
	}

	//--------------------------------------------------------------------------------
	void CAsyncIOBuffer::SetSource( CIOSource::refSourceType refSource )
	{
		_WINQ_FCONTEXT( "CAsyncIOBuffer::SetSource" );
		m_refSource = refSource;
	}

	//--------------------------------------------------------------------------------
	void CAsyncIOBuffer::SetSink( CIOSink::refSinkType refSink )
	{
		_WINQ_FCONTEXT( "CAsyncIOBuffer::SetSink" );
		m_refSink = refSink;
	}

	/*
	//--------------------------------------------------------------------------------
	void CAsyncIOBuffer::SetBufferPool( CIOBufferPool::refType refPool )
	{
		_WINQ_FCONTEXT( "CAsyncIOBuffer::SetBufferPool" );
		m_refBufferPool = refPool;
	}
	*/

	//--------------------------------------------------------------------------------
	//nsCodeQOR::CTArray< byte, nsCodeQOR::CPolicy >* CAsyncIOBuffer::TakeBuffer()
	//{
	//	_WINQ_FCONTEXT( "CAsyncIOBuffer::TakeBuffer" );
	//	nsCodeQOR::CTArray< byte, nsCodeQOR::CPolicy >* pBuffer = m_pReadBuffer;
	//	m_pReadBuffer = 0;
	//	return pBuffer;
	//}

	//--------------------------------------------------------------------------------
	bool CAsyncIOBuffer::IsAtEnd( void )
	{
		_WINQ_FCONTEXT( "CAsyncIOBuffer::IsAtEnd" );
		bool bResult = true;
		if( !m_refSource.IsNull() )
		{
			bResult = m_refSource->IsAtEnd();
		}
		return bResult;
	}

	//--------------------------------------------------------------------------------
	void CAsyncIOBuffer::SetSourceFilter( CIOFilter::refFilterType refSourceFilter )
	{
		m_refSourceFilter = refSourceFilter;
	}

	//--------------------------------------------------------------------------------
	void CAsyncIOBuffer::SetSinkFilter( CIOFilter::refFilterType refSinkFilter )
	{
		m_refSinkFilter = refSinkFilter;
	}

	//--------------------------------------------------------------------------------
	unsigned long CAsyncIOBuffer::MoveBytesFrom( const byte* pClientBuffer, unsigned long ulBytesToMove )
	{
		_WINQ_FCONTEXT( "CAsyncIOBuffer::MoveBytesFrom" );
		unsigned long ulBytesMoved = 0;
		/*
		if( !m_pWriteBuffer && m_pPool )
		{
			m_pWriteBuffer = m_pPool->Get();
		}*/
		//if( m_WriteBuffer() )
		{
			if( ulBytesToMove > ( m_WriteBuffer().Capacity() - m_WriteBuffer().Len() ) )
			{
				ulBytesToMove = ( m_WriteBuffer().Capacity() - m_WriteBuffer().Len() );
			}

			if( m_refSinkFilter.IsNull() )
			{
				memcpy( m_WriteBuffer().GetBuffer() + m_WriteBuffer().Len(), pClientBuffer, ulBytesToMove );
				m_WriteBuffer().ValidateBuffer( m_WriteBuffer().Len() + ulBytesToMove );
				ulBytesMoved = ulBytesToMove;
			}
			else
			{
				unsigned long ulBytesWritten = 0;
				unsigned long ulBytesRead = 0;
				ulBytesWritten = m_refSinkFilter->Process( pClientBuffer, m_WriteBuffer().GetBuffer() + m_WriteBuffer().Len(), ulBytesToMove, ulBytesRead );
				m_WriteBuffer().ValidateBuffer( m_WriteBuffer().Len() + ulBytesWritten );
				ulBytesMoved = ulBytesRead;
			}
		}
		return ulBytesMoved;
	}

	//--------------------------------------------------------------------------------
	unsigned long CAsyncIOBuffer::MoveBytesTo( byte* pClientBuffer, unsigned long ulBytesToMove )
	{
		_WINQ_FCONTEXT( "CAsyncIOBuffer::MoveBytesTo" );
		unsigned long ulBytesMoved = 0;
		//if( m_pReadBuffer )
		{
			if( ulBytesToMove > ( m_ReadBuffer().Len() - m_ReadCursor.Index() ) )
			{
				ulBytesToMove = ( m_ReadBuffer().Len() - m_ReadCursor.Index() );
			}

			if( m_refSourceFilter.IsNull() )
			{
				memcpy( pClientBuffer, m_ReadBuffer().GetBuffer() + m_ReadCursor.Index(), ulBytesToMove );
				m_ReadCursor += nsCodeQOR::CByteBuffer::CCursor( m_ReadBuffer(), ulBytesToMove );
				ulBytesMoved = ulBytesToMove;
			}
			else
			{
				unsigned long ulBytesRead = 0;
				unsigned long ulBytesWritten = m_refSourceFilter->Process( m_ReadBuffer().GetBuffer() + m_ReadCursor.Index(), pClientBuffer, ulBytesToMove, ulBytesRead );
				m_ReadCursor += nsCodeQOR::CByteBuffer::CCursor( m_ReadBuffer(), ulBytesRead );
				ulBytesMoved = ulBytesRead;
			}
			

			//When cursor reaches the end of the data, reset it to the begining, all data has been consumed
			if( m_ReadCursor >= m_ReadBuffer().end() )
			{
				m_ReadCursor = m_ReadBuffer().begin();
				m_ReadBuffer().ValidateBuffer( 0 );
			}
		}
		return ulBytesMoved;
	}

	//--------------------------------------------------------------------------------
	bool CAsyncIOBuffer::Read( byte* pBuffer, unsigned long ulNumberOfBytesToRead, unsigned long& ulNumberOfBytesRead  )
	{
		_WINQ_FCONTEXT( "CAsyncIOBuffer::Read" );
		
		bool bResult = false;
		unsigned long ulBytesStillToRead = ulNumberOfBytesToRead;

		if( ulNumberOfBytesToRead == 0 )
		{
			bResult = true;
		}
		else
		{
			//Move anything we have in the Memory Buffer already
			ulNumberOfBytesRead = MoveBytesTo( pBuffer, ulNumberOfBytesToRead );

			ulBytesStillToRead -= ulNumberOfBytesRead;

			if( ulBytesStillToRead > 0 )
			{
				bResult = ReadSource( ulBytesStillToRead );
			}
			else
			{
				bResult = true;
			}
		}

		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CAsyncIOBuffer::ReadSource( unsigned long ulNumberOfBytesToRead )
	{
		_WINQ_FCONTEXT( "CAsyncIOBuffer::ReadSource" );
		bool bResult = false;
		if( !m_refSource.IsNull() )
		{
			if( !m_refSource->IsAtEnd() )
			{
				/*
				if( m_pReadBuffer == 0 && m_pPool )
				{
					m_pReadBuffer = m_pPool->Get();
				}
				*/
				/*if( m_ReadBuffer == 0 )
				{
					SetError();					//Error no Buffer available
				}
				else*/
				{
					byte* pBufferCurrent = m_ReadBuffer().GetBuffer() + m_ReadBuffer().Len();
					unsigned long ulBufferSpaceByteCount = m_ReadBuffer().Capacity() - m_ReadBuffer().Len();
					if( ulBufferSpaceByteCount > ulNumberOfBytesToRead )
					{
						ulBufferSpaceByteCount = ulNumberOfBytesToRead;
					}
					
					if( m_refSource->Read( /*pBufferCurrent,*/ ulBufferSpaceByteCount, ulNumberOfBytesToRead ) )
					{
						bResult = true;
					}
					else
					{
						SetError();				//Read error from source						
					}
				}
			}
		}
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CAsyncIOBuffer::Write( const byte* pBuffer, unsigned long ulNumberOfBytesToWrite, unsigned long& ulNumberOfBytesWritten )
	{
		bool bResult = false;

		if( ulNumberOfBytesToWrite > 0 )
		{
			//Move to the memory buffer
			ulNumberOfBytesWritten = MoveBytesFrom( pBuffer, ulNumberOfBytesToWrite );
								
			if( ulNumberOfBytesWritten > 0 )
			{
				bResult = WriteSink( ulNumberOfBytesWritten );
			}
		}

		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CAsyncIOBuffer::Flush()
	{
		_WINQ_FCONTEXT( "CAsyncIOBuffer::Flush" );
		bool bResult = false;
		if( !m_refSink.IsNull() /*&& ( m_WriteBuffer != 0 )*/ )
		{
			unsigned long ulBytesAvailable = m_WriteBuffer().Len() - m_WriteCursor.Index();

			if( ulBytesAvailable > 0 )
			{
				bResult = WriteSink( ulBytesAvailable );
			}
			else
			{
				bResult = true;
			}
		}
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CAsyncIOBuffer::WriteSink( unsigned long ulNumberOfBytesToWrite )
	{
		_WINQ_FCONTEXT( "CAsyncIOBuffer::Write" );
		bool bResult = false;
		/*if( m_WriteBuffer() == 0 && m_pPool  )
		{
			m_pWriteBuffer = m_pPool->Get();
		}
		*/
		if( !m_refSink.IsNull() /*&& ( m_pWriteBuffer != 0 )*/ )
		{
			unsigned long ulBytesAvailable = m_WriteBuffer().Len() - m_WriteCursor.Index();//m_ulWriteCursorIndex;
			if( ulBytesAvailable > 0 )
			{
				if( ulNumberOfBytesToWrite > ulBytesAvailable )
				{
					ulNumberOfBytesToWrite = ulBytesAvailable;
				}

				byte* pBufferCurrent = m_WriteBuffer().GetBuffer() + m_WriteCursor.Index();
				if( m_refSink->Write( ulNumberOfBytesToWrite, ulNumberOfBytesToWrite, pBufferCurrent ) )
				{
					bResult = true;
				}
				else
				{
					SetError();				//Write error on sink
				}
			}
			else
			{
				bResult = true;
			}
		}
		return bResult;
	}

	//--------------------------------------------------------------------------------
	void CAsyncIOBuffer::OnWriteCompleted( unsigned long ulError, unsigned long ulCountBytesWritten )
	{
		_WINQ_FCONTEXT( "CAsyncIOBuffer::OnWriteCompleted" );
		if( ulError == 0 )
		{
			m_WriteCursor += nsCodeQOR::CByteBuffer::CCursor( m_WriteBuffer(), ulCountBytesWritten );
			if( m_WriteCursor >= m_WriteBuffer().end() )
			{
				m_WriteCursor = m_WriteBuffer().begin();
				m_WriteBuffer().ValidateBuffer( 0 );
			}			
		}
	}

	//--------------------------------------------------------------------------------
	void CAsyncIOBuffer::OnWriteSuccess()
	{
		_WINQ_FCONTEXT( "CAsyncIOBuffer::OnWriteSuccess" );
	}

	//--------------------------------------------------------------------------------
	void CAsyncIOBuffer::OnReadCompleted( unsigned long ulError, unsigned long ulCountBytesRead )
	{
		_WINQ_FCONTEXT( "CAsyncIOBuffer::OnReadCompleted" );
		if( ulError == 0 && ( m_ReadBuffer().Capacity() >= m_ReadBuffer().Len() + ulCountBytesRead ) )
		{
			m_ReadBuffer().ValidateBuffer( m_ReadBuffer().Len() + ulCountBytesRead );
		}
	}

	//--------------------------------------------------------------------------------
	void CAsyncIOBuffer::OnReadSuccess()
	{
		_WINQ_FCONTEXT( "CAsyncIOBuffer::OnReadSuccess" );
	}

}//nsWin32
