//WinQLError.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Implements the CError class representing an error or other out-of-flow condition

#include "CodeQOR/ErrorSystem/DefaultHandler.h"
#include "CodeQOR/Instancing/TInstancePtr.h"
#include "WinQL/Application/ErrorSystem/WinQLErrDomain.h"
#include "WinQL/Application/ErrorSystem/WinQLError.h"
#include "WinQL/Application/Threading/WinQLThread.h"
#include "WinQL/Application/Process/WinQLProcess.h"
#include "WinQAPI/Kernel32.h"

//------------------------------------------------------------------------------
namespace nsWin32
{
	//------------------------------------------------------------------------------
	//Raise an error using the Thread Context to determine all the Where? data
	void CError::Raise( unsigned int uiErrCode, nsCodeQOR::CBaseErrorDomain* pDomain, CError::Level eLevel )
	{
		if( t_pCurrentWin32Thread )
		{
			nsWinQAPI::CFunctionContext* pFContext = dynamic_cast< nsWinQAPI::CFunctionContext* >( t_pCurrentWin32Thread->FunctionContext() );

			const char* szClassFunc = pFContext->Name();
			CBaseErrorParams Params( uiErrCode, szClassFunc, 0 );
			Raise( pFContext->File(), 0, szClassFunc, Params, pDomain, eLevel );
		}
	}

	//------------------------------------------------------------------------------
	void CError::Raise( const char* szFile, int iLine, const char* szClassFunc, CBaseErrorParams Params, nsCodeQOR::CBaseErrorDomain* pDomain, CError::Level eLevel )
	{
		if( !t_pCurrentWin32Thread || !t_pCurrentWin32Thread->InErrorSystem() )
		{
			nsWinQAPI::CFunctionContext* pFContext = t_pCurrentWin32Thread ? dynamic_cast< nsWinQAPI::CFunctionContext* >( t_pCurrentWin32Thread->FunctionContext() ): 0;

			if( t_pCurrentWin32Thread )
			{
				t_pCurrentWin32Thread->EnterErrorSystem();
			}

			CError* pError = new CError;
			pError->m_What.Configure(new CWhat() );
			pError->m_Where.Configure( new nsCodeQOR::CWhere() );

			//Construct the parts of the error

			pError->What().SetParams( Params );
			pError->What().SetCode( Params.Code() );
			if( pFContext )
			{
				pError->What().SetOSErrorCode( pFContext->LastOSError() );
			}
			pError->What().SetLevel( eLevel );

			pError->Where().SetLine( static_cast< unsigned int >( iLine ) );
			if( pFContext != 0 )
			{
				pError->Where().SetFunction( pFContext->Name() );
			}
			pError->Where().SetFile( szFile );
			pError->Where().SetDomain( pDomain );
			pError->Where().SetThreadContext( t_pCurrentWin32Thread );
			pError->Where().SetModuleContext( 0 );
			pError->Where().SetProcessContext( CProcess::ThisProcess() );

			//Attempt to resolve the error
			pError->Resolved( pError->Handle() );
		}
	}

	//------------------------------------------------------------------------------
	void CError::Raise( const char* szFile, int iLine, const char* szClassFunc, unsigned int uiCode, CError::Level eLevel )
	{
		if( !t_pCurrentWin32Thread->InErrorSystem() )
		{
			CError* pError = new CError;

			//Construct the parts of the error

			pError->Where().SetProcessContext( CProcess::ThisProcess() );
			pError->Where().SetModuleContext( 0 );
			pError->Where().SetThreadContext( t_pCurrentWin32Thread );
			pError->Where().SetFile( szFile );
			nsWinQAPI::CFunctionContext* pFContext = dynamic_cast< nsWinQAPI::CFunctionContext* >( t_pCurrentWin32Thread->FunctionContext() );
			if( pFContext != 0 )
			{
				pError->Where().SetFunction( pFContext->Name() );
				pError->What().SetOSErrorCode( pFContext->LastOSError() );
			}
			pError->Where().SetLine( static_cast< unsigned int >( iLine ) );
			pError->What().SetCode( uiCode );

			pError->Resolved( pError->Handle() );
		}
	}


	//------------------------------------------------------------------------------
	bool CError::Raise( _EXCEPTION_POINTERS* ep, CBaseErrorParams Params, nsCodeQOR::CBaseErrorDomain* pDomain, CError::Level eLevel )
	{
		nsWinQAPI::CFunctionContext* pFContext = t_pCurrentWin32Thread ? dynamic_cast< nsWinQAPI::CFunctionContext* >( t_pCurrentWin32Thread->FunctionContext() ): 0;

		CError* pError = new CError();
		pError->m_What.Configure( new CWhat() );
		pError->m_Where.Configure( new nsCodeQOR::CWhere() );

		//Construct the parts of the error

		pError->What().SetParams( Params );
		pError->What().SetCode( nsWinQAPI::SEH_ERROR );
		pError->What().SetLevel( eLevel );

		if( pFContext != 0 )
		{
			pError->Where().SetLine( pFContext->Line() );
			pError->Where().SetFunction( pFContext->Name() );
		}

		pError->Where().SetDomain( pDomain );
		pError->Where().SetProcessContext( CProcess::ThisProcess() );
		pError->Where().SetModuleContext( 0 );
		pError->Where().SetThreadContext( t_pCurrentWin32Thread );

		return pError->Handle();
	}

	//------------------------------------------------------------------------------
	void CError::Resolved( bool bResolved )
	{
		if( !bResolved )
		{
#ifdef __EXCEPTIONS
			throw( this );
#else
            abort();
#endif
		}
		else
		{
			delete this;

            if( t_pCurrentWin32Thread )
            {
                t_pCurrentWin32Thread->LeaveErrorSystem();
            }
		}
	}

	//--------------------------------------------------------------------------------
	__QCMP_NORETURN void CError::RaiseException( const void* prec )
	{
		::_EXCEPTION_RECORD* pRec = reinterpret_cast< ::_EXCEPTION_RECORD* >( const_cast< void* >( prec ) );
		nsWinQAPI::CKernel32::RaiseException( pRec->ExceptionCode, pRec->ExceptionFlags, pRec->NumberParameters, pRec->ExceptionInformation );
	}

	//------------------------------------------------------------------------------
	int CError::FilterExcept( unsigned int iCode, _EXCEPTION_POINTERS* ep )
	{
		int iResult = eEXCEPTION_EXECUTE_HANDLER;
		iResult = Raise( ep, CBaseErrorParams( nsWinQAPI::SEH_ERROR, iCode, 0 ), &ErrorDomain, nsCodeQOR::CError::ERR_LVL_SERIOUS ) ?
			eEXCEPTION_CONTINUE_EXECUTION : eEXCEPTION_EXECUTE_HANDLER;
		return iResult;
	}

	//------------------------------------------------------------------------------
	void CError::SEHandle( unsigned int iCode )
	{
		/*
		if( t_pCurrentWin32Thread != 0 )
		{
			CError* pError = reinterpret_cast< CError* >( t_pCurrentWin32Thread->m_pCurrentException );
			throw pError;
		}
		*/
	}

}//nsWin32
