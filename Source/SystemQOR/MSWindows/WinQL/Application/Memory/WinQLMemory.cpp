//WinQLMemory.cpp

// Copyright Querysoft Limited 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQL/Application/ErrorSystem/WinQLError.h"
#include "WinQL/Application/Memory/WinQLMemory.h"
#include "WinQAPI/Kernel32.h"

//--------------------------------------------------------------------------------
namespace nsWin32
{
	using namespace nsWinQAPI;

	__QOR_IMPLEMENT_OCLASS_LUID( CMemoryManager );

	//--------------------------------------------------------------------------------
	CMemoryManager::CMemoryManager()
	{
		_WINQ_FCONTEXT( "CMemoryManager::CMemoryManager" );
	}

	//--------------------------------------------------------------------------------
	CMemoryManager::~CMemoryManager()
	{
		_WINQ_FCONTEXT( "CMemoryManager::~CMemoryManager" );
	}
		
	//--------------------------------------------------------------------------------
	void CMemoryManager::Copy( void* pDest, const void* pSource, Cmp_ulong_ptr Length )
	{
		_WINQ_FCONTEXT( "CMemoryManager::Copy" );
		__QOR_PROTECT
		{
			CKernel32::mxRtlCopyMemory( pDest, pSource, Length );
		}__QOR_ENDPROTECT
	}

	//--------------------------------------------------------------------------------
	void CMemoryManager::Fill( void* pDest, Cmp_ulong_ptr Length, unsigned char Fill )
	{
		_WINQ_FCONTEXT( "CMemoryManager::Fill" );
		__QOR_PROTECT
		{
			CKernel32::mxFillMemory( pDest, Length, Fill );
		}__QOR_ENDPROTECT
	}

	//--------------------------------------------------------------------------------
	void CMemoryManager::Move( void* pDest, const void* pSource, Cmp_ulong_ptr Length )
	{
		_WINQ_FCONTEXT( "CMemoryManager::Move" );
		__QOR_PROTECT
		{
			CKernel32::mxMoveMemory( pDest, pSource, Length );
		}__QOR_ENDPROTECT
	}

	//--------------------------------------------------------------------------------
	void* CMemoryManager::SecureZero( void* pDest, Cmp_ulong_ptr Length )
	{
		_WINQ_FCONTEXT( "CMemoryManager::Move" );
		void* pResult = 0;
		__QOR_PROTECT
		{
			pResult = CKernel32::mxSecureZeroMemory( pDest, Length );
		}__QOR_ENDPROTECT
		return pResult;
	}

	//--------------------------------------------------------------------------------
	void CMemoryManager::Zero( void* pDest, Cmp_ulong_ptr Length )
	{
		_WINQ_FCONTEXT( "CMemoryManager::Zero" );
		__QOR_PROTECT
		{
			CKernel32::mxZeroMemory( pDest, Length );
		}__QOR_ENDPROTECT
	}

	//--------------------------------------------------------------------------------
	Cmp_ulong_ptr CMemoryManager::Compare( const void* pSource1, const void* pSource2, Cmp_ulong_ptr Length )
	{
		_WINQ_FCONTEXT( "CMemoryManager::Compare" );
		SIZE_T Result = 0;
		__QOR_PROTECT
		{
			Result = CKernel32::RtlCompareMemory( pSource1, pSource2, Length );
		}__QOR_ENDPROTECT
		return Result;
	}

	//--------------------------------------------------------------------------------
	Cmp_ulong_ptr CMemoryManager::GetLargePageMinimum( void )
	{
		_WINQ_FCONTEXT( "CMemoryManager::GetLargePageMinimum" );
		SIZE_T Result = 0;
		__QOR_PROTECT
		{
			Result = CKernel32::GetLargePageMinimum();
		}__QOR_ENDPROTECT
		return Result;
	}

	//--------------------------------------------------------------------------------
	bool CMemoryManager::GetPhysicallyInstalledSystemMemory( Cmp_unsigned_long_long* pTotalMemoryInKilobytes )
	{
		_WINQ_FCONTEXT( "CMemoryManager::GetPhysicallyInstalledSystemMemory" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::GetPhysicallyInstalledSystemMemory( pTotalMemoryInKilobytes ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	unsigned int CMemoryManager::GetWriteWatch( unsigned long dwFlags, void* pBaseAddress, Cmp_ulong_ptr RegionSize, void** pAddresses, Cmp_ulong_ptr* pdwCount, unsigned long* pdwGranularity )
	{
		_WINQ_FCONTEXT( "CMemoryManager::GetWriteWatch" );
		UINT uiResult = 0;
		__QOR_PROTECT
		{
			uiResult = CKernel32::GetWriteWatch( dwFlags, pBaseAddress, RegionSize, pAddresses, pdwCount, pdwGranularity );
		}__QOR_ENDPROTECT
		return uiResult;
	}

	//--------------------------------------------------------------------------------
	unsigned int CMemoryManager::ResetWriteWatch( void* pBaseAddress, Cmp_ulong_ptr RegionSize )
	{
		_WINQ_FCONTEXT( "CMemoryManager::GetWriteWatch" );
		UINT uiResult = 0;
		__QOR_PROTECT
		{
			uiResult = CKernel32::ResetWriteWatch( pBaseAddress, RegionSize );
		}__QOR_ENDPROTECT
		return uiResult;
	}

	//--------------------------------------------------------------------------------
	bool CMemoryManager::GetGlobalMemoryStatus( nsWin32::LPMEMORYSTATUSEX lpBuffer )
	{
		_WINQ_FCONTEXT( "CMemoryManager::GetGlobalMemoryStatus" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::GlobalMemoryStatusEx( reinterpret_cast< ::LPMEMORYSTATUSEX >( lpBuffer ) ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}
		
	//--------------------------------------------------------------------------------
	bool CMemoryManager::GetSystemFileCacheSize( Cmp_ulong_ptr* pMinimumFileCacheSize, Cmp_ulong_ptr* pMaximumFileCacheSize, unsigned long* pFlags )
	{
		_WINQ_FCONTEXT( "CMemoryManager::GetSystemFileCacheSize" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::GetSystemFileCacheSize( pMinimumFileCacheSize, pMaximumFileCacheSize, pFlags ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CMemoryManager::SetSystemFileCacheSize( Cmp_ulong_ptr MinimumFileCacheSize, Cmp_ulong_ptr MaximumFileCacheSize, unsigned long dwFlags )
	{
		_WINQ_FCONTEXT( "CMemoryManager::SetSystemFileCacheSize" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::SetSystemFileCacheSize( MinimumFileCacheSize, MaximumFileCacheSize, dwFlags ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}


	//--Secure emory Cache Callback---------------------------------------------------

	__QOR_IMPLEMENT_OCLASS_LUID( CSecureMemoryCacheCallback );

	//--------------------------------------------------------------------------------
	CSecureMemoryCacheCallback::CSecureMemoryCacheCallback( nsWin32::fpSecureMemoryCacheCallback pfnCallBack ) : m_pCallBack( pfnCallBack )
	{
		_WINQ_FCONTEXT( "CSecureMemoryCacheCallback::CSecureMemoryCacheCallback" );
		__QOR_PROTECT
		{
			m_bConstructed = CKernel32::AddSecureMemoryCacheCallback( reinterpret_cast< ::PSECURE_MEMORY_CACHE_CALLBACK >( m_pCallBack ) ) ? true : false;
		}__QOR_ENDPROTECT
	}

	//--------------------------------------------------------------------------------
	CSecureMemoryCacheCallback::~CSecureMemoryCacheCallback()
	{
		_WINQ_FCONTEXT( "CSecureMemoryCacheCallback::~CSecureMemoryCacheCallback" );
		__QOR_PROTECT
		{
			m_bConstructed = !CKernel32::RemoveSecureMemoryCacheCallback( m_pCallBack ) ? true : false;
		}__QOR_ENDPROTECT
	}

	//--Memory Resource Notification

	__QOR_IMPLEMENT_OCLASS_LUID( CMemoryResourceNotification );

	//--------------------------------------------------------------------------------
	CMemoryResourceNotification::CMemoryResourceNotification( nsWin32::MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType )
	{
		_WINQ_FCONTEXT( "CMemoryResourceNotification::CMemoryResourceNotification" );
		__QOR_PROTECT
		{
			m_h = CKernel32::CreateMemoryResourceNotification( static_cast< ::MEMORY_RESOURCE_NOTIFICATION_TYPE >( NotificationType ) );
		}__QOR_ENDPROTECT
	}

	//--------------------------------------------------------------------------------
	CMemoryResourceNotification::~CMemoryResourceNotification()
	{
		_WINQ_FCONTEXT( "CMemoryResourceNotification::~CMemoryResourceNotification" );
		__QOR_PROTECT
		{
			CKernel32::CloseHandle( m_h );
		}__QOR_ENDPROTECT
	}

	//--------------------------------------------------------------------------------
	bool CMemoryResourceNotification::Query( int* ResourceState )
	{
		_WINQ_FCONTEXT( "CMemoryResourceNotification::Query" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::QueryMemoryResourceNotification( m_h, ResourceState ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--Physical Pages

	__QOR_IMPLEMENT_OCLASS_LUID( CUserPhysicalPages );

	//--------------------------------------------------------------------------------
	CUserPhysicalPages::CUserPhysicalPages()
	{
		_WINQ_FCONTEXT( "CUserPhysicalPages::CUserPhysicalPages" );
	}

	//--------------------------------------------------------------------------------
	CUserPhysicalPages::~CUserPhysicalPages()
	{
		_WINQ_FCONTEXT( "CUserPhysicalPages::~CUserPhysicalPages" );
	}

	//--------------------------------------------------------------------------------
	bool CUserPhysicalPages::Allocate( void* hProcess, Cmp_ulong_ptr* NumberOfPages, Cmp_ulong_ptr* UserPfnArray )
	{
		_WINQ_FCONTEXT( "CUserPhysicalPages::Allocate" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::AllocateUserPhysicalPages( hProcess, NumberOfPages, UserPfnArray ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CUserPhysicalPages::Free( void* hProcess, Cmp_ulong_ptr* NumberOfPages, Cmp_ulong_ptr* UserPfnArray )
	{
		_WINQ_FCONTEXT( "CUserPhysicalPages::Free" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::FreeUserPhysicalPages( hProcess, NumberOfPages, UserPfnArray ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CUserPhysicalPages::Map( void* lpAddress, Cmp_ulong_ptr NumberOfPages, Cmp_ulong_ptr* UserPfnArray )
	{
		_WINQ_FCONTEXT( "CUserPhysicalPages::Map" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::MapUserPhysicalPages( lpAddress, NumberOfPages, UserPfnArray ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CUserPhysicalPages::MapScatter( void** VirtualAddresses, Cmp_ulong_ptr NumberOfPages, Cmp_ulong_ptr* PageArray )
	{
		_WINQ_FCONTEXT( "CUserPhysicalPages::MapScatter" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::MapUserPhysicalPagesScatter( VirtualAddresses, NumberOfPages, PageArray ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

}//nsWin32
