//WinQLConsole.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQL/Application/ErrorSystem/WinQLError.h"
#include "WinQL/Application/ErrorSystem/WinQLErrDomain.h"
__QCMP_WARNING_PUSH
__QCMP_WARNING_DISABLE( __QCMP_WARN_THIS_USED_IN_BASE_INIT_LIST, "Safe usage: saved in member for later use" );
#include "WinQL/Application/Console/WinQLConsole.h"
__QCMP_WARNING_POP
#include "WinQAPI/Kernel32.h"

#include "../SystemQOR/MSWindows/WinCmpSupQORVC/include/PE/Sections.h"

_CRTALLOC(".CRT$XPX") static nsWin32::_PVFV pterm = nsWin32::CConsole::__termcon;

//--------------------------------------------------------------------------------
namespace 
{
	nsWin32::CConsole* g_pConsole = 0;

}//anonymous

//--------------------------------------------------------------------------------
namespace nsWin32
{
	CCRTFile* CConsole::s_pConsoleInput = (CCRTFile*)(-2);	// console input
	CCRTFile* CConsole::s_pConsoleOutput = (CCRTFile*)(-2);	// console output

	using namespace nsWinQAPI;

	//------------------------------------------------------------------------------	
	bool CConsStartContHandler::Handle( nsCodeQOR::CError* pError )
	{
		_WINQ_FCONTEXT( "CConsStartContHandler::Handle" );
		bool bResolved = nsCodeQOR::CDefaultContinuableHandler::Handle( *pError );

		if( pError->What().Code() == NO_STANDARD_HANDLE )
		{
			bResolved = true;//silence 'no standard handle' error during Console Initialization
		}

		return bResolved;
	}

	//--------------------------------------------------------------------------------
	CConsole::CConsole() : m_Win32DefaultScreenBuffer( 0,0 )
	{	
#ifndef _CONSOLE
		CConsole::__initconin();
		CConsole::__initconout();
#endif
		m_Win32DefaultScreenBuffer.SetInputHandle( m_Helper.GetStdHandle( Std_Input_Handle ) );
		m_Win32DefaultScreenBuffer.SetOutputHandle( m_Helper.GetStdHandle( Std_Output_Handle ) );
		__QCS_ATTACH_REF_PROP( CConsole, DisplayMode, GetDisplayMode, SetDisplayMode );

		__QCS_ATTACH_REF_PROP( CConsole, Title, GetTitleText, SetTitleText );
		__QCS_ATTACH_REF_PROP( CConsole, OutputCodePage, GetOutputCodePage, SetOutputCodePage );
		__QCS_ATTACH_REF_PROP( CConsole, InputCodePage, GetInputCodePage, SetInputCodePage );
		__QCS_ATTACH_REF_PROP_RO( CConsole, OriginalTitle, GetOriginalTitle );
		__QCS_ATTACH_REF_PROP( CConsole, HistoryInfo, GetHistoryInfo, SetHistoryInfo );
		__QCS_ATTACH_REF_PROP_RO( CConsole, SelectionInfo, GetSelectionInfo );
		__QCS_ATTACH_REF_PROP_RO( CConsole, Window, GetWindow );
		__QCS_ATTACH_REF_PROP_RO( CConsole, NumberOfMouseButtons, GetNumberOfMouseButtons );
		__QCS_ATTACH_REF_PROP_RO( CConsole, ScreenBuffer, GetScreenBuffer );
		/*
		__QCS_REF_PROP( CConsole, CFileHandle,				InputStdHandle			);
		__QCS_REF_PROP( CConsole, CFileHandle,				OutputStdHandle			);
		__QCS_REF_PROP( CConsole, CFileHandle,				ErrorStdHandle			);		
		*/
		g_pConsole = this;
	}

	//------------------------------------------------------------------------------
	CConsole::~CConsole()
	{
#ifndef _CONSOLE
		CConsole::__termcon();
#endif
		g_pConsole = 0;
	}

	//------------------------------------------------------------------------------
	CConsole::refType CConsole::TheWin32Console()
	{
		CConsole::refType Ref;
		if( g_pConsole == 0 )
		{
			Ref.Attach( new CConsole(), true );
		}
		else
		{
			Ref.Attach( g_pConsole, false );
		}
		return Ref;
	}
	
	//--------------------------------------------------------------------------------
	nsWin32::CCRTFile* CConsole::ConsoleInputFile()
	{
		return CConsole::s_pConsoleInput;
	}

	//--------------------------------------------------------------------------------
	nsWin32::CCRTFile* CConsole::ConsoleOutputFile()
	{
		return CConsole::s_pConsoleOutput;
	}

	//--------------------------------------------------------------------------------
	CConsole::eConsoleDisplayMode CConsole::GetDisplayMode( void )
	{
		unsigned long ulDisplayMode = 0;
		m_Helper.GetDisplayMode( ulDisplayMode );
		return static_cast< eConsoleDisplayMode >( ulDisplayMode );
	}

	//--------------------------------------------------------------------------------
	bool CConsole::SetDisplayMode( const eConsoleDisplayMode& Mode )
	{
		bool bResult = false;
		Coord NewScreenBufferDimensions;
		NewScreenBufferDimensions.X = 0;
		NewScreenBufferDimensions.Y = 0;
		unsigned long ulDisplayMode = static_cast< unsigned long >( Mode );
		bResult = m_Win32DefaultScreenBuffer.SetDisplayMode( ulDisplayMode, NewScreenBufferDimensions ) ? true : false;
		return bResult;
	}
/*
	//------------------------------------------------------------------------------
	void* CConsole::GetInputHandle( void )
	{
		return m_Win32DefaultScreenBuffer.
	}

	//------------------------------------------------------------------------------
	bool CConsole::SetInputHandle( void* const& InputHandle )
	{
		bool bResult = false;
		return bResult;
	}

	//------------------------------------------------------------------------------
	void* CConsole::GetOutputHandle( void )
	{
		return 0;//
	}

	//------------------------------------------------------------------------------
	bool CConsole::SetOutputHandle( void* const& OutputHandle )
	{
		bool bResult = false;
		return bResult;
	}

	//------------------------------------------------------------------------------
	void* CConsole::GetErrHandle( void )
	{
		return 0;//
	}

	//------------------------------------------------------------------------------
	bool CConsole::SetErrHandle( void* const& ErrHandle )
	{
		bool bResult = false;
		return bResult;
	}
*/
	
	//------------------------------------------------------------------------------
	CTString CConsole::GetTitleText( void )
	{
		CTString strTitle;
		strTitle.Reserve( 255 );
		m_Helper.GetTitle( strTitle );
		return strTitle;
	}

	//------------------------------------------------------------------------------
	bool CConsole::SetTitleText( const CTString& Title )
	{
		return m_Helper.SetTitle( Title );
	}
	
	//------------------------------------------------------------------------------
	CCodePage CConsole::GetOutputCodePage( void )
	{
		return m_Helper.GetOutputCP();
	}
	
	//------------------------------------------------------------------------------
	bool CConsole::SetOutputCodePage( const CCodePage& OutputCP )
	{
		bool bResult = false;// m_Helper.SetOutputCP(OutputCP);
		return bResult;
	}
	
	//------------------------------------------------------------------------------
	CCodePage CConsole::GetInputCodePage( void )
	{
		return m_Helper.GetCP();
	}

	//------------------------------------------------------------------------------
	bool CConsole::SetInputCodePage( const CCodePage& InputCP )
	{
		bool bResult = m_Helper.SetCP( InputCP );
		return bResult;
	}

	//------------------------------------------------------------------------------
	CTString CConsole::GetOriginalTitle( void )
	{
		CTString strTitle;
		strTitle.Reserve( 255 );
		unsigned long ulLen = m_Helper.GetOriginalTitle( strTitle() );
		strTitle.ValidateBuffer( static_cast< unsigned short >( ulLen ) );
		return strTitle;
	}

	//------------------------------------------------------------------------------
	ConsoleHistoryInfo CConsole::GetHistoryInfo( void )
	{
		ConsoleHistoryInfo Info;
		m_Helper.GetHistoryInfo( Info );
		return Info;
	}

	//------------------------------------------------------------------------------
	bool CConsole::SetHistoryInfo( const ConsoleHistoryInfo& HistoryInfo )
	{
		bool bResult = m_Helper.SetHistoryInfo( HistoryInfo );
		return bResult;
	}

	//------------------------------------------------------------------------------
	ConsoleSelectionInfo CConsole::GetSelectionInfo( void )
	{
		ConsoleSelectionInfo Info;
		m_Helper.GetSelectionInfo( Info );
		return Info;
	}
	
	//------------------------------------------------------------------------------
	COSWindow::refType CConsole::GetWindow( void )
	{
		return m_Helper.GetWindow();
	}
	
	//------------------------------------------------------------------------------
	unsigned long CConsole::GetNumberOfMouseButtons( void )
	{
		unsigned long ulResult = 0;
		m_Helper.GetNumberOfMouseButtons( ulResult );
		return ulResult;
	}
	
	//------------------------------------------------------------------------------
	CConsoleScreenBuffer::refType CConsole::GetScreenBuffer()
	{
		return m_Win32DefaultScreenBuffer.Ref();
	}
	
	//--------------------------------------------------------------------------------
	void CConsole::__initconin()
	{
		_WINQ_SFCONTEXT( "CConsole::__initconin" );
		if( s_pConsoleInput == (nsWin32::CFile*)(-2) )
		{
			CConsStartContHandler ErrHandler;
			nsWin32::CConsoleHelper ConsoleHelper;
			CFileHandle hstdin = ConsoleHelper.GetStdHandle( nsWin32::Std_Input_Handle );
			if( hstdin.IsNull() || hstdin.IsInvalid() )
			{
				ConsoleHelper.Alloc();
				s_pConsoleInput = new nsWin32::CCRTFile( "CONIN$", Generic_Read | Generic_Write, File_Share_Read| File_Share_Write, 0, Open_Existing, 0, 0 );
			}
			else
			{
				s_pConsoleInput = new nsWin32::CCRTFile( hstdin );
			}
		}
	}

	//--------------------------------------------------------------------------------
	void CConsole::__initconout()
	{
		_WINQ_SFCONTEXT( "CConsole::__initconout" );
		if( s_pConsoleOutput == (nsWin32::CFile*)(-2) )
		{
			CConsStartContHandler ErrHandler;
			nsWin32::CConsoleHelper ConsoleHelper;
			CFileHandle hstdout = ConsoleHelper.GetStdHandle( nsWin32::Std_Output_Handle );
			if( hstdout.IsNull() || hstdout.IsInvalid() )
			{
				ConsoleHelper.Alloc();					
				s_pConsoleOutput = new nsWin32::CCRTFile( "CONOUT$", Generic_Write, File_Share_Read | File_Share_Write, 0, Open_Existing, 0, 0 );
			}
			else
			{
				s_pConsoleOutput = new nsWin32::CCRTFile( hstdout );
			}				
		}
	}

	//--------------------------------------------------------------------------------
	void CConsole::__termcon()
	{
		_WINQ_SFCONTEXT( "CConsole::__termcon" );
		if( s_pConsoleOutput > 0 ) 
		{
			delete s_pConsoleOutput;
			s_pConsoleOutput = 0;
		}

		if( s_pConsoleInput > 0 )
		{
			delete s_pConsoleInput;
			s_pConsoleInput = 0;
		}

	}

}//nsWin32
