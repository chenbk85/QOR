//WinQLProcess.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Implements the CProcess class representing the executing Windows process

#include <limits.h>
#include "CodeQOR/ErrorSystem/Error.h"
#include "WinQL/Application/ErrorSystem/WinQLError.h"
#include "WinQL/Application/Process/WinQLProcess.h"
#include "WinQL/Application/Threading/WinQLThread.h"
#include "../SystemQOR/MSWindows/WinQAPI/include/ErrorDomain.h"
#include "../SystemQOR/MSWindows/WinQAPI/include/DynamicLibrary.h"
#include "WinQAPI/Kernel32.h"
#include "WinQAPI/User32.h"
#include "WinQAPI/PSAPI.h"

//------------------------------------------------------------------------------
namespace nsWin32
{
	using namespace nsWinQAPI;

	nsCodeQOR::sTOB< CProcess > theWindowsProcess;

	__QOR_IMPLEMENT_OCLASS_GUID( CProcess, 0x9c8a6e9, 0x7b0b, 0x428f, 0xae, 0x88, 0x99, 0xa9, 0xc8, 0x58, 0x14, 0x3e )	// {09C8A6E9-7B0B-428F-AE88-99A9C858143E}

	//--------------------------------------------------------------------------------
	CProcessModuleInitializer::CProcessModuleInitializer()
	{			
		theWindowsProcess->GetId();
	}

	//--------------------------------------------------------------------------------
	CProcessModuleInitializer::~CProcessModuleInitializer()
	{
		
	}

	//--------------------------------------------------------------------------------
	CProcess* CProcess::ThisProcess()
	{
		_WINQ_SFCONTEXT( "CProcess::ThisProcess" );
		return dynamic_cast< CProcess* >( nsCodeQOR::CProcessBase::ThisProcess() );
	}

	// {B581519C-9BA8-442B-AF56-56D25E9ACAB2}
	__QOR_IMPLEMENT_OCLASS_GUID( CProcessHelper, 0xb581519c, 0x9ba8, 0x442b, 0xaf, 0x56, 0x56, 0xd2, 0x5e, 0x9a, 0xca, 0xb2 )

	//--------------------------------------------------------------------------------
	CProcessHelper::CProcessHelper() : m_PSAPI( CPSAPI::Instance() )
	{
		_WINQ_FCONTEXT( "CProcessHelper::CProcessHelper" );
	}

	//--------------------------------------------------------------------------------
	CProcessHelper::CProcessHelper( const CProcessHelper& ) : m_PSAPI( CPSAPI::Instance() )
	{
	}

	//--------------------------------------------------------------------------------
	CProcessHelper& CProcessHelper::operator=( const CProcessHelper& )
	{
		return *this;
	}

	//--------------------------------------------------------------------------------
	CProcessHelper::~CProcessHelper()
	{
		_WINQ_FCONTEXT( "CProcessHelper::~CProcessHelper" );
	}

	//------------------------------------------------------------------------------
	TCHAR* CProcessHelper::GetCommandLineT()
	{
		_WINQ_FCONTEXT( "CProcessHelper::GetCommandLine" );
		LPTSTR pResult = 0;
		__QOR_PROTECT
		{
			pResult = CKernel32::GetCommandLine();
		}__QOR_ENDPROTECT
		return pResult;
	}

	//------------------------------------------------------------------------------
	void CProcessHelper::GetStartupInfoT( nsWin32::LPSTARTUPINFO lpStartupInfo )
	{
		_WINQ_FCONTEXT( "CProcessHelper::GetStartupInfo" );
		CKernel32::GetStartupInfo( reinterpret_cast< ::LPSTARTUPINFO >( lpStartupInfo ) );
	}

	//--------------------------------------------------------------------------------
	unsigned long CProcessHelper::LoadModule( const char* lpModuleName, void* lpParameterBlock )
	{
		_WINQ_FCONTEXT( "CProcessHelper::LoadModule" );
		unsigned long ulResult = 0;
		__QOR_PROTECT
		{
			ulResult = nsWinQAPI::CKernel32::Instance().LoadModule( lpModuleName, lpParameterBlock );
		}__QOR_ENDPROTECT
		return ulResult;
	}

	//--------------------------------------------------------------------------------
	bool CProcessHelper::EnumProcessModulesEx( ModuleHandle hProcess, ModuleHandle* lphModule, unsigned long cb, unsigned long* lpcbNeeded, unsigned long dwFilterFlag )
	{
		_WINQ_FCONTEXT( "CProcessHelper::EnumProcessModulesEx" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = m_PSAPI.EnumProcessModulesEx( hProcess, reinterpret_cast< HMODULE* >( lphModule ), cb, lpcbNeeded, dwFilterFlag ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	nsCodeQOR::CThreadContextBase* CProcess::ThreadContext( void )
	{
		//Can't have function context here because this is required by function context initialisation
		return t_pCurrentWin32Thread;
	}

	//--------------------------------------------------------------------------------
	CProcess::CProcess() : CWinModule( CProcess::GetCurrentHandle().Use() )
	{
		_WINQ_FCONTEXT( "CProcess::CProcess" );
		m_hProcess = m_Handle.ptr();
		m_hInstance = ( InstanceHandle )&__ImageBase;
		m_Name = 0;
	}

	//------------------------------------------------------------------------------
	CProcess::CProcess( void* hProcess ) : CWinModule( hProcess )
	{
		_WINQ_FCONTEXT( "CProcess::CProcess" );
		m_hProcess = hProcess;
		m_hInstance = ( InstanceHandle )&__ImageBase;
		m_Name = 0;
		//t_pCurrentWin32Thread = 0;
	}

	//------------------------------------------------------------------------------
	CProcess::CProcess( unsigned long dwDesiredAccess, bool bInheritHandle, unsigned long dwProcessId ) //: m_Initializer( 0 )
	{			
		_WINQ_FCONTEXT( "CProcess::CProcess" );
		__QOR_PROTECT
		{
			m_hProcess = CKernel32::OpenProcess( dwDesiredAccess, bInheritHandle ? TRUE : FALSE, dwProcessId );
			m_Name = 0;

		}__QOR_ENDPROTECT
	}

	//------------------------------------------------------------------------------
	CProcess::CProcess( const TCHAR* lpApplicationName, TCHAR* lpCommandLine, nsWin32::LPSECURITY_ATTRIBUTES lpProcessAttributes, nsWin32::LPSECURITY_ATTRIBUTES lpThreadAttributes, bool bInheritHandles, unsigned long dwCreationFlags, void* lpEnvironment, const TCHAR* lpCurrentDirectory, nsWin32::LPSTARTUPINFO lpStartupInfo, nsWin32::ProcessInformation* lpProcessInformation ) //: m_Initializer( 0 )
	{
		_WINQ_FCONTEXT( "CProcess::CProcess" );
		__QOR_PROTECT
		{
			CKernel32::CreateProcess( lpApplicationName, lpCommandLine, reinterpret_cast< ::LPSECURITY_ATTRIBUTES >( lpProcessAttributes ), reinterpret_cast< ::LPSECURITY_ATTRIBUTES >( lpThreadAttributes ), bInheritHandles ? TRUE : FALSE, dwCreationFlags, lpEnvironment, lpCurrentDirectory, reinterpret_cast< ::LPSTARTUPINFO >( lpStartupInfo ), reinterpret_cast< ::LPPROCESS_INFORMATION >( lpProcessInformation ) );
			if( lpProcessInformation != 0 )
			{
				m_hProcess = lpProcessInformation->hProcess;
				m_Name = const_cast< TCHAR* >( lpApplicationName );
			}
			else
			{
				//TODO: Raise an error
			}
		}__QOR_ENDPROTECT
	}

	//------------------------------------------------------------------------------
	CProcess::~CProcess()
	{
		_WINQ_FCONTEXT( "CProcess::~CProcess" );
	}

	//------------------------------------------------------------------------------
	void CProcess::Exit( unsigned int uExitCode )
	{
		_WINQ_SFCONTEXT( "CProcess::Exit" );
		__QOR_PROTECT
		{
			CKernel32::ExitProcess( uExitCode );
		}__QOR_ENDPROTECT
	}

	//------------------------------------------------------------------------------
	CProcess* CProcess::GetCurrent()
	{
		_WINQ_SFCONTEXT( "CProcess::GetCurrent" );
		CHandle hProcess = CKernel32::GetCurrentProcess();
		CWinModule* pModule = CWinModule::FromHandle( hProcess );
		return dynamic_cast< CProcess* >( pModule );
	}

	//------------------------------------------------------------------------------
	unsigned long CProcess::GetCurrentId()
	{
		_WINQ_SFCONTEXT( "CProcess::GetCurrentId" );
		return CKernel32::GetCurrentProcessId();
	}

	//------------------------------------------------------------------------------
	CHandle CProcess::GetCurrentHandle()
	{
		CHandle hProcess = CKernel32::GetCurrentProcess();
		return hProcess;
	}

	//------------------------------------------------------------------------------
	bool CProcess::GetExitCode( unsigned long* lpExitCode )
	{
		_WINQ_FCONTEXT( "CProcess::GetExitCode" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::GetExitCodeProcess( m_hProcess, lpExitCode ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//------------------------------------------------------------------------------
	void* CProcess::Handle() const
	{
		_WINQ_FCONTEXT( "CProcess::Handle" );
		return m_hProcess;
	}

	//------------------------------------------------------------------------------
	void* CProcess::Instance() const
	{
		_WINQ_FCONTEXT( "CProcess::Instance" );
		return m_hInstance;
	}

	//--------------------------------------------------------------------------------
	mxTCHAR* CProcess::Name( void )
	{
		if( m_Name != 0 )
		{
			return m_Name;
		}
		else
		{
			return _CTXT( "unnamed" );
		}
	}

	//--------------------------------------------------------------------------------
	int CProcess::ProcessCommandLine( int& argc, TCHAR**& argv )
	{
		int iArgumentCount= 0;
		int iCharacterCount = 0;
			
		ParseCommandLine( NULL, NULL, &iArgumentCount, &iCharacterCount);//Determine space requirements

		// allocate space for argv[] vector and strings */
		if( iArgumentCount >= ( UINT_MAX / sizeof( TCHAR* ) ) || iCharacterCount >= ( UINT_MAX / sizeof( TCHAR ) ) )
		{
			return -1;
		}

		if( ( iArgumentCount * sizeof( TCHAR* ) + iCharacterCount * sizeof( TCHAR ) ) < ( iCharacterCount * sizeof( TCHAR ) ) )
		{
			return -1;
		}

		TCHAR* pArgs = new TCHAR[ ( iArgumentCount * ( sizeof( TCHAR* ) / sizeof( TCHAR ) ) ) + iCharacterCount ];
        
		if( pArgs == 0 )
		{
			return -1;
		}

		argc = iArgumentCount - 1;
		argv = (TCHAR**)pArgs;

		ParseCommandLine( (TCHAR**)pArgs, pArgs + ( iArgumentCount * ( sizeof( TCHAR* ) / sizeof( TCHAR ) ) ), &iArgumentCount, &iCharacterCount );//Store the arguments

#ifdef WILDCARD
    // call _[w]cwild to expand wildcards in arg vector
#	ifdef WPRFLAG
    if (_wcwild())
#	else
    if (_cwild())
#	endif
        return -1;                  /* out of space */
#endif

		return 0;

	}

	//--------------------------------------------------------------------------------
	void CProcess::ParseCommandLine( TCHAR** argv,  TCHAR* args, int* piArgumentCount, int* piCharacterCount )
	{
		TCHAR* p;
		TCHAR c;
		bool bInQuote;				//Inside quotes 
		bool bCopyChar;                   /* 1 = copy char to *args */
		unsigned int numslash;              /* num of backslashes seen */

		*piCharacterCount = 0;
		*piArgumentCount = 1;                   /* the program name at least */

		TCHAR* cmdstart = GetCommandLine();

		// first scan the program name, copy it, and count the bytes
		p = cmdstart;
		if( argv )
		{
			*argv++ = args;
		}

#ifdef WILDCARD
		/* To handle later wild card expansion, we prefix each entry by
		it's first character before quote handling.  This is done
		so _[w]cwild() knows whether to expand an entry or not. */
		if( args )
		{
			*args++ = *p;
		}
		++*piCharacterCount;

#endif  /* WILDCARD */

		/* A quoted program name is handled here. The handling is much
        simpler than for other arguments. Basically, whatever lies
        between the leading double-quote and next one, or a terminal null
        character is simply accepted. Fancier handling is not required
        because the program name must be a legal NTFS/HPFS file name.
        Note that the double-quote characters are not copied, nor do they
        contribute to numchars. */
        
		bInQuote = false;
		do 
		{
			if( *p == DQUOTECHAR )
			{
				bInQuote = !bInQuote;
				c = (TCHAR) *p++;
				continue;
			}
			++*piCharacterCount;
			if (args)
			{
				*args++ = *p;
			}

			c = (TCHAR) *p++;
#ifdef _MBCS
			if( _ismbblead( c ) ) 
			{
				++*numchars;
				if( args )
				{
					*args++ = *p;   // copy 2nd byte too 
				}
				p++;  // skip over trail byte
			}
#endif  /* _MBCS */

		} while( ( c != NULCHAR && ( bInQuote || ( c != SPACECHAR && c != TABCHAR ) ) ) );

		if( c == NULCHAR ) 
		{
			p--;
		} 
		else 
		{
			if( args )
			{
				*(args-1) = NULCHAR;
			}
		}

		bInQuote = false;

		// loop on each argument
		for(;;) 
		{
			if( ! ParseArgument( argv, args, piArgumentCount, piCharacterCount, p, bInQuote, bCopyChar, numslash ) )
			{
				break;
			}
		}

		// We put one last argument in -- a null ptr
		if( argv )
		{
			*argv++ = NULL;
		}
		++*piArgumentCount;
	}

	//--------------------------------------------------------------------------------
	bool CProcess::ParseArgument( TCHAR** argv, TCHAR* args, int* piArgumentCount, int* piCharacterCount, TCHAR* p, bool& bInQuote, bool& bCopyChar, unsigned int& numslash )
	{
        if ( *p ) 
		{
            while ( *p == SPACECHAR || *p == TABCHAR )
			{
                ++p;
			}
        }

        if( *p == NULCHAR )
		{
            return false;				// end of args
		}

        // scan an argument
        if( argv )
		{
            *argv++ = args;     // store ptr to arg
		}

        ++*piArgumentCount;

#ifdef WILDCARD
		/* To handle later wild card expansion, we prefix each entry by it's first character before quote handling.  This is done so _[w]cwild() knows whether to expand an entry or not. */
		if( args )
		{
			*args++ = *p;
		}
		++*piCharacterCount;

#endif  /* WILDCARD */

		// loop through scanning one argument
		for (;;) 
		{
			if( !ParseOneArgument( args, piCharacterCount, bInQuote, bCopyChar, numslash, p ) )
			{
				break;
			}
        }

        // null-terminate the argument
        if( args )
		{
            *args++ = NULCHAR;          // terminate string
		}
        ++*piCharacterCount;
		return true;
	}

	//--------------------------------------------------------------------------------
	bool CProcess::ParseOneArgument( TCHAR* args, int* piCharacterCount, bool& bInQuote, bool& bCopyChar, unsigned int& numslash, TCHAR* p )
	{
        bCopyChar = true;
        /* Rules: 2N backslashes + " ==> N backslashes and begin/end quote 
		2N+1 backslashes + " ==> N backslashes + literal "
        N backslashes ==> N backslashes */
        numslash = 0;

        while( *p == SLASHCHAR ) 
		{
            // count number of backslashes for use below
            ++p;
            ++numslash;
        }

        if( *p == DQUOTECHAR ) 
		{
            // if 2N backslashes before, start/end quote, otherwise copy literally
            if( numslash % 2 == 0 ) 
			{
                if( bInQuote && p[ 1 ] == DQUOTECHAR ) 
				{
                    p++;    // Double quote inside quoted string
                } 
				else 
				{	// skip first quote char and copy second
                    bCopyChar = 0;       /* don't copy quote */
                    bInQuote = !bInQuote;
                }
            }
            numslash /= 2;          // divide numslash by two
        }

        // copy slashes
        while( numslash-- ) 
		{
            if( args )
			{
                *args++ = SLASHCHAR;
			}
            ++*piCharacterCount;
        }

        // if at end of arg, break loop
        if( *p == NULCHAR || ( !bInQuote && ( *p == SPACECHAR || *p == TABCHAR ) ) )
		{
            return false;//break;
		}

        // copy character into argument
#ifdef _MBCS
        if (bCopyChar) 
		{
            if( args ) 
			{
                if( _ismbblead( *p ) ) 
				{
                    *args++ = *p++;
                    ++*piCharacterCount;
                }
                *args++ = *p;
            } 
			else 
			{
                if( _ismbblead( *p ) ) 
				{
                    ++p;
                    ++*piCharacterCount;
                }
            }
            ++*piCharacterCount;
        }
        ++p;
#else
        if( bCopyChar ) 
		{
            if( args )
			{
                *args++ = *p;
			}
            ++*piCharacterCount;
        }
        ++p;
#endif
		return true;

	}

	//------------------------------------------------------------------------------
	bool CProcess::SetWorkingSetSize( Cmp_ulong_ptr dwMinimumWorkingSetSize, Cmp_ulong_ptr dwMaximumWorkingSetSize )
	{
		_WINQ_FCONTEXT( "CProcess::SetWorkingSetSize" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::SetProcessWorkingSetSize( m_hProcess, dwMinimumWorkingSetSize, dwMaximumWorkingSetSize ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	
	bool CProcess::SetWorkingSetSizeEx( Cmp_ulong_ptr dwMinimumWorkingSetSize, Cmp_ulong_ptr dwMaximumWorkingSetSize, unsigned long Flags )
	{
		_WINQ_FCONTEXT( "CProcess::SetWorkingSetSizeEx" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::SetProcessWorkingSetSizeEx( m_hProcess, dwMinimumWorkingSetSize, dwMaximumWorkingSetSize, Flags ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//------------------------------------------------------------------------------	
	bool CProcess::Terminate( unsigned int uExitCode )
	{			
		_WINQ_FCONTEXT( "CProcess::Terminate" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::TerminateProcess( m_hProcess, uExitCode ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CProcess::SetAffinityUpdateMode( unsigned long dwFlags )
	{
		_WINQ_FCONTEXT( "CProcess::SetAffinityUpdateMode" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::SetProcessAffinityUpdateMode( m_hProcess, dwFlags ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//------------------------------------------------------------------------------
	bool CProcess::SetPriorityBoost( bool DisablePriorityBoost )
	{			
		_WINQ_FCONTEXT( "CProcess::SetPriorityBoost" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::SetProcessPriorityBoost( m_hProcess, DisablePriorityBoost ? TRUE : FALSE ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CProcess::QueryAffinityUpdateMode( unsigned long* lpdwFlags )
	{
		_WINQ_FCONTEXT( "CProcess::QueryAffinityUpdateMode" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::QueryProcessAffinityUpdateMode( m_hProcess, lpdwFlags ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CProcess::QueryCycleTime( Cmp_unsigned__int64* CycleTime )
	{
		_WINQ_FCONTEXT( "CProcess::QueryCycleTime" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::QueryProcessCycleTime( m_hProcess, CycleTime ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CProcess::QueryFullImageName( unsigned long dwFlags, TCHAR* lpExeName, unsigned long* lpdwSize )
	{
		_WINQ_FCONTEXT( "CProcess::QueryFullImageName" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::QueryFullProcessImageName( m_hProcess, dwFlags, lpExeName, lpdwSize ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//------------------------------------------------------------------------------
	unsigned long CProcess::GetVersion( unsigned long ProcessId )
	{
		_WINQ_SFCONTEXT( "CProcess::GetVersion" );
		unsigned long dwResult = 0;
		__QOR_PROTECT
		{
			dwResult = CKernel32::GetProcessVersion( ProcessId );
		}__QOR_ENDPROTECT
		return dwResult;
	}

	//------------------------------------------------------------------------------
	bool CProcess::GetWorkingSetSize( Cmp_ulong_ptr* lpMinimumWorkingSetSize, Cmp_ulong_ptr* lpMaximumWorkingSetSize )
	{
		_WINQ_FCONTEXT( "CProcess::GetWorkingSetSize" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::GetProcessWorkingSetSize( m_hProcess, lpMinimumWorkingSetSize, lpMaximumWorkingSetSize ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CProcess::GetWorkingSetSizeEx( Cmp_ulong_ptr* lpMinimumWorkingSetSize, Cmp_ulong_ptr* lpMaximumWorkingSetSize, unsigned long* Flags )
	{
		_WINQ_FCONTEXT( "CProcess::GetWorkingSetSizeEx" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::GetProcessWorkingSetSizeEx( m_hProcess, lpMinimumWorkingSetSize, lpMaximumWorkingSetSize, Flags ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CProcess::IsInJob( void* JobHandle, int* Result )
	{
		_WINQ_FCONTEXT( "CProcess::IsInJob" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::IsProcessInJob( m_hProcess, JobHandle, Result ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CProcess::IsWow64( int* Wow64Process )
	{
		_WINQ_FCONTEXT( "CProcess::IsWow64" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::IsWow64Process( m_hProcess, Wow64Process ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CProcess::GetHandleCount( unsigned long* pdwHandleCount )
	{
		_WINQ_FCONTEXT( "CProcess::GetHandleCount" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::GetProcessHandleCount( m_hProcess, pdwHandleCount ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	unsigned long CProcess::GetId()
	{
		_WINQ_FCONTEXT( "CProcess::GetId" );
		unsigned long dwResult = 0;
		__QOR_PROTECT
		{
			dwResult = CKernel32::GetProcessId( m_hProcess );
		}__QOR_ENDPROTECT
		return dwResult;
	}

	//------------------------------------------------------------------------------
	bool CProcess::GetIoCounters( nsWin32::IOCounters* lpIoCounters )
	{
		_WINQ_FCONTEXT( "CProcess::GetIoCounters" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::GetProcessIoCounters( m_hProcess, reinterpret_cast< ::PIO_COUNTERS >( lpIoCounters ) ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//------------------------------------------------------------------------------
	bool CProcess::GetTimes( nsWin32::LPFILETIME lpCreationTime, nsWin32::LPFILETIME lpExitTime, nsWin32::LPFILETIME lpKernelTime, nsWin32::LPFILETIME lpUserTime )
	{
		_WINQ_FCONTEXT( "CProcess::GetTimes" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::GetProcessTimes( m_hProcess, reinterpret_cast< ::LPFILETIME >( lpCreationTime ), reinterpret_cast< ::LPFILETIME >( lpExitTime ), reinterpret_cast< ::LPFILETIME >( lpKernelTime ), reinterpret_cast< ::LPFILETIME >( lpUserTime ) ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//------------------------------------------------------------------------------
	bool CProcess::GetAffinityMask( Cmp_ulong_ptr* lpProcessAffinityMask, Cmp_ulong_ptr* lpSystemAffinityMask )
	{
		_WINQ_FCONTEXT( "CProcess::GetAffinityMask" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::GetProcessAffinityMask( m_hProcess, lpProcessAffinityMask, lpSystemAffinityMask ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//------------------------------------------------------------------------------
	bool CProcess::SetAffinityMask( Cmp_ulong_ptr dwProcessAffinityMask )
	{
		_WINQ_FCONTEXT( "CProcess::SetAffinityMask" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::SetProcessAffinityMask( m_hProcess, dwProcessAffinityMask ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//------------------------------------------------------------------------------
	unsigned long CProcess::GetPriorityClass()
	{
		_WINQ_FCONTEXT( "CProcess::GetPriorityClass" );
		unsigned long dwResult = 0;
		__QOR_PROTECT
		{
			dwResult = CKernel32::GetPriorityClass( m_hProcess );
		}__QOR_ENDPROTECT
		return dwResult;
	}

	//------------------------------------------------------------------------------
	bool CProcess::SetPriorityClass( unsigned long dwPriorityClass )
	{
		_WINQ_FCONTEXT( "CProcess::SetPriorityClass" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::SetPriorityClass( m_hProcess, dwPriorityClass ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//------------------------------------------------------------------------------
	bool CProcess::GetPriorityBoost( int* pDisablePriorityBoost )
	{
		_WINQ_FCONTEXT( "CProcess::GetPriorityBoost" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::GetProcessPriorityBoost( m_hProcess, pDisablePriorityBoost ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

}//nsWin32

