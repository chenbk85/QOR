//WinQLRowView.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "SystemQOR.h"
__QCMP_WARNING_PUSH
__QCMP_WARNING_DISABLE( __QCMP_WARN_THIS_USED_IN_BASE_INIT_LIST, "Safe usage: saved in member for later use" );
#include "WinQL/Application/Graphics/WinQLRectangle.h"
__QCMP_WARNING_POP

//--------------------------------------------------------------------------------
namespace nsWin32
{
		/*
		//--------------------------------------------------------------------------------
		CRowView::CRowView( CView* pContainer ) : CView( pContainer )
		{
		}

		//--------------------------------------------------------------------------------
		CRowView::~CRowView()
		{
		}

		//--------------------------------------------------------------------------------
		//Arrange contents in a row either RTL or LTR
		void CRowView::Layout( nsWin32::nsGraphics::CRectRgn& LayoutRgn )
		{
			nsWin32::nsGraphics::CRectangle rcLayout;
			LayoutRgn.GetBox( rcLayout );

			unsigned int uiContainerWidth = rcLayout.Width();
			unsigned int uiContainerHeight = rcLayout.Height();

			unsigned int uiWidth = Width();
			unsigned int uiHeight = Height();

			unsigned int uiMinWidth = MinWidth();
			unsigned int uiMinHeight = MinHeight();

			unsigned int uiBaseWidth = uiWidth;
			unsigned int uiBaseHeight = uiHeight;

			bool bUseMinWidth = false;

			if( uiWidth > uiContainerWidth )
			{
				uiBaseWidth = uiMinWidth;
				bUseMinWidth = true;
			}

			bool bUseMinHeight = true;

			if( uiHeight > uiContainerHeight )
			{
				uiBaseHeight = uiMinHeight;
				bUseMinHeight = true;
			}

			int iExcessWidth = uiBaseWidth - uiWidth;
			int iExcessHeight = uiBaseHeight - uiHeight;

			int iElement = 0;

			unsigned int uiXElasticCount = 0;

			while( iElement < m_apContents.Size() )
			{
				if( m_apContents[ iElement ]->IsXElastic() )
				{
					uiXElasticCount++;
				}
				iElement ++;
			}

			iElement = 0;

			unsigned int uiYPos = rcLayout.Top();

			if( m_Alignment | E_AlignVCenter == E_AlignVCenter )
			{
				uiYPos += iExcessHeight / 2;
			}
			else if( m_Alignment | E_AlignBottom == E_AlignBottom )
			{
				uiYPos += iExcessHeight;
			}

			if( m_Direction = CView::LtR )
			{
				unsigned int uiXPos = rcLayout.Left();
				if( m_Alignment | E_AlignRight == E_AlignRight )
				{
					uiXPos + 0;//TODO: Need to precalc final excess width before positions
				}
				while( iElement < m_apContents.Size() )
				{
					float fElementBaseWidth = bUseMinWidth ? m_apContents[ iElement ]->MinWidth() : m_apContents[ iElement ]->Width();
					float fElementProportion = fElementBaseWidth / uiContainerWidth;
					float fExcessWidth = fElementProportion * iExcessWidth;
					unsigned int uiElementWidth = static_cast< unsigned int >( fElementBaseWidth ) + static_cast< unsigned int >( fExcessWidth );
					if( uiElementWidth > m_apContents[ iElement ]->MaxWidth() )
					{
						uiElementWidth = m_apContents[ iElement ]->MaxWidth();
					}
					nsWin32::nsGraphics::CRectangle rcElement( uiXPos, uiYPos, uiXPos + uiElementWidth, uiYPos + uiHeight );
					nsWin32::nsGraphics::CRectRgn rgnElement( &rcElement );
					m_apContents[ iElement ]->Layout( rgnElement );
					uiXPos += uiElementWidth;
				}
			}
			else
			{
				unsigned int uiXPos = rcLayout.Right();
			}			
		}

		//--------------------------------------------------------------------------------
		unsigned int CRowView::Width()
		{
			return CalcWidth();
		}

		//--------------------------------------------------------------------------------
		unsigned int CRowView::Height()
		{
			return CalcHeight();
		}

		//--------------------------------------------------------------------------------
		unsigned int CRowView::MinWidth()
		{
			return CalcMinWidth();
		}

		//--------------------------------------------------------------------------------
		unsigned int CRowView::MaxWidth()
		{
			return CalcMaxWidth();
		}

		//--------------------------------------------------------------------------------
		unsigned int CRowView::MinHeight()
		{
			return CalcMinHeight();
		}

		//--------------------------------------------------------------------------------
		unsigned int CRowView::MaxHeight()
		{
			return CalcMaxHeight();
		}

		//--------------------------------------------------------------------------------
		unsigned int CRowView::CalcWidth()
		{
			unsigned int uiWidth = 0;
			int iElement = 0;
			while( iElement < m_apContents.Size() )
			{
				uiWidth += m_apContents[ iElement ]->Width();
				iElement++;
			}
			return uiWidth;
		}

		//--------------------------------------------------------------------------------
		unsigned int CRowView::CalcHeight()
		{
			unsigned int uiHeight = 0;
			int iElement = 0;
			while( iElement < m_apContents.Size() )
			{
				uiHeight += m_apContents[ iElement ]->Height();
				iElement++;
			}
			return uiHeight;
		}

		//--------------------------------------------------------------------------------
		//Sum of min widths of contents
		unsigned int CRowView::CalcMinWidth()
		{
			unsigned int uiMin = 0;
			int iElement = 0;
			while( iElement < m_apContents.Size() )
			{
				uiMin += m_apContents[ iElement ]->MinWidth();
				iElement++;
			}
			return uiMin;
		}

		//--------------------------------------------------------------------------------
		//Max element min Height
		unsigned int CRowView::CalcMinHeight()
		{
			unsigned int uiMin = 0;
			int iElement = 0;
			while( iElement < m_apContents.Size() )
			{
				unsigned int uiMinElement = m_apContents[ iElement ]->MinHeight();
				if( uiMinElement > uiMin )
				{
					uiMin = uiMinElement;
				}
				iElement++;
			}
			return uiMin;
		}

		//--------------------------------------------------------------------------------
		unsigned int CRowView::CalcMaxWidth()
		{
			unsigned int uiMax = 0;
			int iElement = 0;
			while( iElement < m_apContents.Size() )
			{
				uiMax += m_apContents[ iElement ]->MaxWidth();
				iElement++;
			}
			return uiMax;
		}

		//--------------------------------------------------------------------------------
		unsigned int CRowView::CalcMaxHeight()
		{
			unsigned int uiMax = 0;
			int iElement = 0;
			while( iElement < m_apContents.Size() )
			{
				unsigned int uiMaxElement = m_apContents[ iElement ]->MaxHeight();
				if( uiMaxElement > uiMax )
				{
					uiMax = uiMaxElement;
				}
				iElement++;
			}
			return uiMax;
		}
		*/

}//nsWin32
