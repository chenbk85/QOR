//WinQLProcessBootStrap.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Implements .exe startup and shutdown code for Windows processes

#include "WinQL/WinQL.h"
#include "WinQL/Application/Threading/WinQLCriticalSection.h"
#include "WinQAPI/Kernel32.h"
#include "../SystemQOR/MSWindows/WinQAPI/include/ErrorDomain.h"
#include "../SystemQOR/MSWindows/WinQAPI/include/DynamicLibrary.h"
#include "WinQAPI/PSAPI.h"
#include "WinQL/Bootstrap/WinQLProcessBootStrap.h"
#include "WinQL/Definitions/IO.h"
#include "WinQL/System/Performance/WinQLPerformanceHelper.h"
//#include "CodeQOR/ErrorSystem/ExpectedHandler.h"
#include "WinQL/Application/ErrorSystem/WinQLErrDomain.h"
#include "WinQL/System/Clock/WinQLTime.h"
#include "WinQL/Application/Process/Module/WinQLDll.h"
#include <limits.h>


__QCMP_LINKAGE_C void InitThread( void );

//--------------------------------------------------------------------------------
namespace nsWin32
{
	static unsigned long __vcrt_flsindex = FLS_OUT_OF_INDEXES;

	// In order to avoid dynamic allocation during CRT startup, the PTD for the startup thread is statically allocated:
	static __vcrt_ptd __vcrt_startup_thread_ptd;

	// This function is called by the operating system when a thread is being
	// destroyed, to allow us the opportunity to clean up.
	extern "C" void WINAPI __vcrt_freefls(_Inout_opt_ void* const pfd)
	{
		if (pfd == nullptr || pfd == &__vcrt_startup_thread_ptd)
			return;

		delete pfd;
	}

	//--------------------------------------------------------------------------------
	CProcessBootStrap::CProcessBootStrap() : CModuleBootStrap(), m_szCommandLine( 0 )
	{

		__vcrt_flsindex = ::FlsAlloc(&__vcrt_freefls);

		FlsSetValue(__vcrt_flsindex, &__vcrt_startup_thread_ptd);

		InitStatic();//Initialise the process object and QOR library statics.
		nsWin32::CProcessHelper ProcessHelper;
		m_StartupInfo.cb = sizeof( nsWin32::STARTUPINFO );
		ProcessHelper.GetStartupInfoT( &m_StartupInfo );		
	}

	//--------------------------------------------------------------------------------
	CProcessBootStrap::~CProcessBootStrap()
	{

	}

	//--------------------------------------------------------------------------------
	void* CProcessBootStrap::GetEnvironmentA( void )
	{
		wchar_t *wEnv;
		wchar_t *wTmp;
		char *aEnv = NULL;
		int nSizeW;
		int nSizeA;

		// obtain wide environment block

		if ( NULL == (wEnv = GetEnvironmentStringsW()) )
		{
			return NULL;
		}

		// look for double null that indicates end of block
		wTmp = wEnv;
		while ( *wTmp != L'\0' ) 
		{
			if ( *++wTmp == L'\0' )
				wTmp++;
		}

		// calculate total size of block, including all nulls
		nSizeW = (int)(wTmp - wEnv + 1);

		// find out how much space needed for multi-byte environment
		nSizeA = WideCharToMultiByte( CP_ACP, 0, wEnv, nSizeW, NULL, 0, NULL, NULL );

		// allocate space for multi-byte string 
		if ( (nSizeA == 0) || ((aEnv = (char *)malloc(nSizeA)) == NULL) )
		{
			FreeEnvironmentStringsW( wEnv );
			return NULL;
		}

		/* do the conversion */
		if ( !WideCharToMultiByte(  CP_ACP,
									0,
									wEnv,
									nSizeW,
									aEnv,
									nSizeA,
									NULL,
									NULL ) )
		{
			free( aEnv );
			aEnv = NULL;
		}

		FreeEnvironmentStringsW( wEnv );
		return aEnv;
	}

	//--------------------------------------------------------------------------------
	void CProcessBootStrap::ParseCommandLine()
	{
		nsWin32::CProcessHelper ProcessHelper;
		m_szCommandLine = ProcessHelper.GetCommandLineT();
		m_iArgCount = 0;
		m_pArgsList = 0;
		int dowildcard = 0;

		//_aenvptr = (char *)GetEnvironmentA();

		//_acmdln = GetCommandLineA();
		//_wcmdln = GetCommandLineW();

		GetMainArgs( dowildcard );

		setenvp();
	}

	//--------------------------------------------------------------------------------
	int CProcessBootStrap::setenvp( void )
	{
		return 0;
	}



	//--------------------------------------------------------------------------------
	void CProcessBootStrap::parse_cmdline( TCHAR* cmdstart, TCHAR** argv, TCHAR* args, int* numargs, int* numchars )
	{
        TCHAR* p;
        TCHAR c;
        int inquote;                    /* 1 = inside quotes */
        int copychar;                   /* 1 = copy char to *args */
        unsigned numslash;              /* num of backslashes seen */

        *numchars = 0;
        *numargs = 1;                   /* the program name at least */

        /* first scan the program name, copy it, and count the bytes */
        p = cmdstart;
        if( argv )
		{
            *argv++ = args;
		}

#ifdef WILDCARD
        /* To handle later wild card expansion, we prefix each entry by it's first character before quote handling.  This is done so _[w]cwild() knows whether to expand an entry or not. */
        if( args )
		{
            *args++ = *p;
		}
        ++*numchars;

#endif  /* WILDCARD */

        /* A quoted program name is handled here. The handling is much simpler than for other arguments. Basically, whatever lies
           between the leading double-quote and next one, or a terminal null character is simply accepted. Fancier handling is not required
           because the program name must be a legal NTFS/HPFS file name. Note that the double-quote characters are not copied, nor do they
           contribute to numchars. */
        inquote = FALSE;
        do 
		{
            if( *p == DQUOTECHAR )
            {
                inquote = !inquote;
                c = (TCHAR) *p++;
                continue;
            }

            ++*numchars;
            if( args )
			{
                *args++ = *p;
			}

            c = (TCHAR) *p++;
#ifdef _MBCS
            if( _ismbblead( c ) ) 
			{
                ++*numchars;
                if( args )
				{
                    *args++ = *p;   /* copy 2nd byte too */
				}
                p++;  /* skip over trail byte */
            }
#endif  /* _MBCS */

        } while ( ( c != NULCHAR && ( inquote || ( c !=SPACECHAR && c != TABCHAR ) ) ) );

        if( c == NULCHAR ) 
		{
            p--;
        } 
		else 
		{
            if( args )
			{
                *(args-1) = NULCHAR;
			}
        }

        inquote = 0;

        //Loop through arguments
        for(;;) 
		{

            if( *p ) 
			{
                while( *p == SPACECHAR || *p == TABCHAR )
				{
                    ++p;
				}
            }

            if( *p == NULCHAR )
			{
                break;              //End of arguments
			}

            // Scan argument
            if( argv )
			{
                *argv++ = args;     // Store pointer to argument
			}
            ++*numargs;

#ifdef WILDCARD
			/* To handle later wild card expansion, we prefix each entry by it's first character before quote handling.  This is done
			so _[w]cwild() knows whether to expand an entry or not. */
			if( args )
			{
				*args++ = *p;
			}
			++*numchars;

#endif//WILDCARD

			/* loop through scanning one argument */
			for (;;) 
			{
				copychar = 1;
				/* Rules: 2N backslashes + " ==> N backslashes and begin/end quote
				   2N+1 backslashes + " ==> N backslashes + literal "
				   N backslashes ==> N backslashes */
				numslash = 0;
				while( *p == SLASHCHAR ) 
				{
					/* count number of backslashes for use below */
					++p;
					++numslash;
				}

				if( *p == DQUOTECHAR ) 
				{
					/* if 2N backslashes before, start/end quote, otherwise
						copy literally */
					if( numslash % 2 == 0 ) 
					{
						if( inquote && p[ 1 ] == DQUOTECHAR ) 
						{
							p++;    // Double quote inside quoted string
						} 
						else 
						{    
							// skip first quote char and copy second 
							copychar = 0;       // don't copy quote
							inquote = !inquote;
						}
					}
					numslash /= 2;          // divide numslash by two 
				}

				// copy slashes 
				while (numslash--) 
				{
					if( args )
					{
						*args++ = SLASHCHAR;
					}
					++*numchars;
				}

				// if at end of arg, break loop
				if( *p == NULCHAR || ( !inquote && ( *p == SPACECHAR || *p == TABCHAR ) ) )
				{
					break;
				}

	            // copy character into argument
#ifdef _MBCS
				if( copychar ) 
				{
					if( args ) 
					{
						if( _ismbblead( *p ) ) 
						{
							*args++ = *p++;
							++*numchars;
						}
						*args++ = *p;
					} 
					else 
					{
						if( _ismbblead( *p ) ) 
						{
							++p;
							++*numchars;
						}
					}
					++*numchars;
				}
				++p;
#else// _MBCS
				if( copychar ) 
				{
					if( args )
					{
						*args++ = *p;
					}
					++*numchars;
				}
				++p;
#endif //_MBCS
			}

			// null-terminate the argument

            if (args)
			{
                *args++ = NULCHAR;          // terminate string
			}
            ++*numchars;
		}

        // We put one last argument in -- a null ptr
        if( argv )
		{
            *argv++ = NULL;
		}

        ++*numargs;
	}


	//No wildcard narrow char
	int CProcessBootStrap::_setargv( void )
	{
        return 0;
	}


	//--------------------------------------------------------------------------------
	int CProcessBootStrap::GetMainArgs( int dowildcard )
	{
		int ret = 0;

		// set global new mode flag
		//_newmode = m_StartupInfo.newmode;

		if( dowildcard )
		{
			//ret = __setargv();  /* do wildcard expansion after parsing args */
		}
		else
		{
			ret = _setargv();   /* NO wildcard expansion; just parse args */
		}

		return ret;
	}

	//--------------------------------------------------------------------------------
	nsCodeQOR::CTLinkedList< nsWin32::CDll > CProcessBootStrap::GetModuleList( void )
	{
		nsWinQAPI::CPSAPI PSAPIHelper;
		nsCodeQOR::CTLinkedList< nsWin32::CDll > ModuleList;
		ModuleHandle nHandle;
		ModuleHandle* pHandles = 0;
		unsigned long ulByteCount = 0;
		PSAPIHelper.EnumProcessModules( reinterpret_cast< InstanceHandle >( nsWinQAPI::CKernel32::GetCurrentProcess() ), (HMODULE*)&nHandle, 1, &ulByteCount );
		unsigned long ulModuleCount = ( ulByteCount / sizeof( nsWin32::InstanceHandle ) );

		if( ulModuleCount > 0 )
		{
			pHandles = new ModuleHandle[ ulModuleCount ];
			memset( pHandles, 0, ulModuleCount * sizeof( nsWin32::InstanceHandle ) );
			PSAPIHelper.EnumProcessModules( reinterpret_cast< InstanceHandle >( nsWinQAPI::CKernel32::GetCurrentProcess() ), (HMODULE*)pHandles, ulByteCount, &ulByteCount );

			while( ulModuleCount > 0 )
			{
				if( pHandles[ --ulModuleCount ] != 0 )
				{
					nsWin32::CDll* pModule = new nsWin32::CDll( reinterpret_cast< void* >( pHandles[ ulModuleCount ] ), true );
					ModuleList.Append( pModule );
				}
			};
			delete [] pHandles;
		}

		return ModuleList;
	}

	//--------------------------------------------------------------------------------
	void CProcessBootStrap::InitStatic()
	{
		//InitWindowsProcess();//Create the Windows Process Object

		nsCodeQOR::mxGUID nullGUID = { 0x00000000, 0x0000, 0x0000, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } };
		nsCodeQOR::mxGUID aDependencies[][5] =
		{
			{
				{ 0xdb51fb8c, 0x4bef, 0x43f2, { 0xa4, 0x61, 0x7e, 0x49, 0x4f, 0xaf, 0xad, 0x75 } },
					{ 0x2c101426, 0x4e38, 0x49c0, { 0x91, 0xc8, 0x0c, 0xea, 0xf5, 0x14, 0xbc, 0x02 } }, nullGUID, nullGUID, nullGUID
			},

			{
				{ 0xa2250e96, 0xd07d, 0x4440, { 0xb3, 0xd7, 0xbd, 0x1, 0xc0, 0xc7, 0x7c, 0xef } },//WinQL is dependent on
					{ 0xdd8152fd, 0xcdd8, 0x4c26, { 0xb3, 0x55, 0x00, 0xd5, 0x79, 0x55, 0xb8, 0x7a } }, //ArchQOR
					nullGUID, nullGUID, nullGUID
			},

			{
				{ 0x74346fa1, 0xab39, 0x48b7, { 0xbe, 0x13, 0xe1, 0xdf, 0x5b, 0x7b, 0x22, 0xe6 } }, //SystemQOR  is dependent on
					{ 0xdd8152fd, 0xcdd8, 0x4c26, { 0xb3, 0x55, 0x0, 0xd5, 0x79, 0x55, 0xb8, 0x7a } }, //ArchQOR
					nullGUID, nullGUID, nullGUID
			},

			{
				{ 0xc20a868d, 0x9678, 0x4c61, { 0xa2, 0x5c, 0xb3, 0x1e, 0x89, 0xb8, 0xa8, 0xad } }, //Qurses  is dependent on
					{ 0xdd8152fd, 0xcdd8, 0x4c26, { 0xb3, 0x55, 0x0, 0xd5, 0x79, 0x55, 0xb8, 0x7a } }, //ArchQOR
					nullGUID, nullGUID, nullGUID
			},

			{
				{ 0xa2c43bf9, 0xc341, 0x447a, { 0xbe, 0xf5, 0xe0, 0xcf, 0x66, 0x3f, 0x3a, 0x31 } }, //stdQOR is dependent on
					{ 0xdd8152fd, 0xcdd8, 0x4c26, { 0xb3, 0x55, 0x0, 0xd5, 0x79, 0x55, 0xb8, 0x7a } }, //ArchQOR
					nullGUID, nullGUID, nullGUID
			},
			nullGUID,
		};

		//Get the Module list
		nsCodeQOR::CTLinkedList< nsWin32::CDll > ModuleList( GetModuleList() );
		//nsCodeQOR::CExpectedHandler ExpectingError( nsWinQAPI::GENERAL_API_ERROR );

		nsCodeQOR::CTLinkedList< nsCodeQOR::CTPair< nsCodeQOR::__mxGUID, nsWinQAPI::CLibrary::DefProc > > InitFuncList;

		//Strip out non QOR libraries and collect ids and entry points for the QOR libraries
		int iModule = 1;
		while( iModule <= static_cast< int >( ModuleList.GetCount() ) )
		{
			nsWin32::CDll* pModule = ModuleList.GetItem( iModule );
			nsWinQAPI::CLibrary::DefProc pIdentity = reinterpret_cast< nsWinQAPI::CLibrary::DefProc >( pModule->GetProcAddress( "QORidentity" ) );
			if( pIdentity == 0 )
			{
				ModuleList.Remove( iModule );
			}
			else
			{
				nsCodeQOR::CTPair< nsCodeQOR::__mxGUID, nsWinQAPI::CLibrary::DefProc >* pInitEntryPoint = new nsCodeQOR::CTPair< nsCodeQOR::__mxGUID, nsWinQAPI::CLibrary::DefProc >(
					*( ( pModule->Call< nsCodeQOR::mxGUID* >( pIdentity ) ) ),
					reinterpret_cast< nsWinQAPI::CLibrary::DefProc >( pModule->GetProcAddress( "QORinit" ) ) );
				InitFuncList.Append( pInitEntryPoint );
				iModule++;
			}
		};

#ifndef	QOR_MONOLITHIC
		//For each remaining library ensure all its static dependencies are higher up the list than it is by moving it to just after the last one

		bool bFinished = false;
		while( !bFinished )
		{
			bFinished = true;
			int iEntry = 1;
			while( iEntry <= static_cast< int >( InitFuncList.GetCount() ) )
			{
				//Find any static dependencies for the module
				int iMain = 0;
				nsCodeQOR::mxGUID* pMainGUID = aDependencies[iMain++];
				while( pMainGUID[0] != nullGUID && pMainGUID[ 0 ] != InitFuncList.GetItem(iEntry)->First() )
				{
					pMainGUID = aDependencies[iMain++];
				}

				if( pMainGUID != 0 && pMainGUID[0] != nullGUID )
				{
					int iDependency = 1;
					nsCodeQOR::__mxGUID DependentGUID = pMainGUID[iDependency++];
					while( DependentGUID != nullGUID )
					{
						//ensure MainGUID occurs after DependentGUID in InitFuncList;
						int iMainIndex = 1;
						int iSearchIndex = 1;
						int iDependsIndex = 1;
						int iTargetMainIndex = 1;
						while( iSearchIndex <= static_cast< int > ( InitFuncList.GetCount() ) )
						{
							if( InitFuncList.GetItem( iSearchIndex )->First() == pMainGUID[ 0 ] )
							{
								iMainIndex = iSearchIndex;
							}
							if( InitFuncList.GetItem( iSearchIndex )->First() == DependentGUID )
							{
								iDependsIndex = iSearchIndex;
							}
							iSearchIndex++;
						}
						if( iDependsIndex > iMainIndex )
						{
							iTargetMainIndex = iDependsIndex;
						}
						if( iTargetMainIndex > iMainIndex )
						{
							nsCodeQOR::CTPair< nsCodeQOR::__mxGUID, nsWinQAPI::CLibrary::DefProc >* pMainEntry = InitFuncList.GetItem( iMainIndex );
							InitFuncList.Drop( iMainIndex );
							InitFuncList.Insert( iTargetMainIndex, pMainEntry );
							bFinished = false;
						}

						DependentGUID = pMainGUID[iDependency++];
					}
				}
				if( !bFinished )
				{
					break;
				}
				iEntry++;
			};
		};

#endif//QOR_MONOLITHIC

		InitWindowsProcess();//Create the Windows Process Object

		int iEntry = 1;
		while( iEntry <= static_cast< int >( InitFuncList.GetCount() ) )
		{
			nsCodeQOR::CTPair< nsCodeQOR::__mxGUID, nsWinQAPI::CLibrary::DefProc >* pEntry = InitFuncList.GetItem( iEntry++ );
			( pEntry->Second() )();
		}
		
	}

}//nsWin32
