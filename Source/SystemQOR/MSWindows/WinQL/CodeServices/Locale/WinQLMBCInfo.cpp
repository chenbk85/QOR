//WinQLMBCInfo.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQL/CodeServices/Locale/WinQLMBCInfo.h"

//--------------------------------------------------------------------------------
unsigned short nsWin32::CMBCInfo::sMBULInfo[ 6 ] = { 0, 0, 0, 0, 0, 0 };

//------------------------------------------------------------------------------
unsigned char nsWin32::CMBCInfo::sMBCType[ 257 ] = 
{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
	0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00 // rest is zero
};

//------------------------------------------------------------------------------
unsigned char nsWin32::CMBCInfo::sMBCaseMap[ 256 ] = 
{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
	0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,
	0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b,
	0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
	0x58, 0x59, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00 // rest is zero
};

//------------------------------------------------------------------------------
nsWin32::CMBCInfo::CCodePageInfo nsWin32::CMBCInfo::s_CodePageinfoArray[] =
{
	{
	  _KANJI_CP,			// Kanji (Japanese) Code Page
	  { 0x8260, 0x8279,		// Full-Width Latin Upper Range 1
		0x8281 - 0x8260,	// Full-Width Latin Case Difference 1

		0x0000, 0x0000,		// Full-Width Latin Upper Range 2
		0x0000				// Full-Width Latin Case Difference 2
		,
		0x8281, 0x829A,		// Full-Width Latin Lower Range 1

		0x0000, 0x0000,		// Full-Width Latin Lower Range 2

		0x824F, 0x8258		// Full-Width Latin Digit Range
	  },
	  {
		{ 0xA6, 0xDF, 0,    0,    0,    0,    0, 0, }, // Single Byte Ranges
		{ 0xA1, 0xA5, 0,    0,    0,    0,    0, 0, }, // Punctuation Ranges
		{ 0x81, 0x9F, 0xE0, 0xFC, 0,    0,    0, 0, }, // Lead Byte Ranges
		{ 0x40, 0x7E, 0x80, 0xFC, 0,    0,    0, 0, }, // Trail Byte Ranges
	  }
	},
	{
	  _CHINESE_SIMP_CP, // Chinese Simplified (PRC) Code Page
	  { 0xA3C1, 0xA3DA,   // Full-Width Latin Upper Range 1
		0xA3E1 - 0xA3C1,  // Full-Width Latin Case Difference 1

		0x0000, 0x0000,   // Full-Width Latin Upper Range 2
		0x0000            // Full-Width Latin Case Difference 2
		,
		0xA3E1, 0xA3FA,   // Full-Width Latin Lower Range 1

		0x0000, 0x0000,   // Full-Width Latin Lower Range 2

		0xA3B0, 0xA3B9    // Full-Width Latin Digit Range
	  },
	  {
		{ 0,    0,    0,    0,    0,    0,    0, 0, }, // Single Byte Ranges
		{ 0,    0,    0,    0,    0,    0,    0, 0, }, // Punctuation Ranges
		{ 0x81, 0xFE, 0,    0,    0,    0,    0, 0, }, // Lead Byte Ranges
		{ 0x40, 0xFE, 0,    0,    0,    0,    0, 0, }, // Trail Byte Ranges
	  }
	},
	{
	  _KOREAN_WANGSUNG_CP, // Wangsung (Korean) Code Page
	  { 0xA3C1, 0xA3DA,   // Full-Width Latin Upper Range 1
		0xA3E1 - 0xA3C1,  // Full-Width Latin Case Difference 1

		0x0000, 0x0000,   // Full-Width Latin Upper Range 2
		0x0000            // Full-Width Latin Case Difference 2
		,
		0xA3E1, 0xA3FA,   // Full-Width Latin Lower Range 1

		0x0000, 0x0000,   // Full-Width Latin Lower Range 2

		0xA3B0, 0xA3B9    // Full-Width Latin Digit Range
	  },
	  {
		{ 0,    0,    0,    0,    0,    0,    0, 0, }, // Single Byte Ranges
		{ 0,    0,    0,    0,    0,    0,    0, 0, }, // Punctuation Ranges
		{ 0x81, 0xFE, 0,    0,    0,    0,    0, 0, }, // Lead Byte Ranges
		{ 0x41, 0xFE, 0,    0,    0,    0,    0, 0, }, // Trail Byte Ranges
	  }
	},
	{
	  _CHINESE_TRAD_CP, // Chinese Traditional (Taiwan) Code Page
	  { 0xA2CF, 0xA2E4,   // Full-Width Latin Upper Range 1
		0xA2E9 - 0xA2CF,  // Full-Width Latin Case Difference 1

		0xA2E5, 0xA2E8,   // Full-Width Latin Upper Range 2
		0xA340 - 0XA2E5   // Full-Width Latin Case Difference 2
		,
		0xA2E9, 0xA2FE,   // Full-Width Latin Lower Range 1

		0xA340, 0xA343,   // Full-Width Latin Lower Range 2

		0xA2AF, 0xA2B8    // Full-Width Latin Digit Range
	  },
	  {
		{ 0,    0,    0,    0,    0,    0,    0, 0, }, // Single Byte Ranges
		{ 0,    0,    0,    0,    0,    0,    0, 0, }, // Punctuation Ranges
		{ 0x81, 0xFE, 0,    0,    0,    0,    0, 0, }, // Lead Byte Ranges
		{ 0x40, 0x7E, 0xA1, 0xFE, 0,    0,    0, 0, }, // Trail Byte Ranges
	  }
	},
	{
	  _KOREAN_JOHAB_CP, // Johab (Korean) Code Page
	  { 0xDA51, 0xDA5E,   // Full-Width Latin Upper Range 1
		0xDA71 - 0xDA51,  // Full-Width Latin Case Difference 1

		0xDA5F, 0xDA6A,   // Full-Width Latin Upper Range 2
		0xDA91 - 0xDA5F   // Full-Width Latin Case Difference 2
		,
		0xDA71, 0xDA7E,   // Full-Width Latin Lower Range 1

		0xDA91, 0xDA9C,   // Full-Width Latin Lower Range 2

		0xDA40, 0xDA49    // Full-Width Latin Digit Range
	  },
	  {
		{ 0,    0,    0,    0,    0,    0,    0, 0, }, // Single Byte Ranges
		{ 0,    0,    0,    0,    0,    0,    0, 0, }, // Punctuation Ranges
		{ 0x81, 0xD3, 0xD8, 0xDE, 0xE0, 0xF9, 0, 0, }, // Lead Byte Ranges
		{ 0x31, 0x7E, 0x81, 0xFE, 0,    0,    0, 0, }, // Trail Byte Ranges
	  }
	}
};

//------------------------------------------------------------------------------
namespace nsWin32
{
	//--------------------------------------------------------------------------------
	CMBCInfo::CMBCInfo()
	{
		m_RefCount.Reset();
		m_MBCodePage = _CLOCALECP;
		m_bIsMBCodePage = false;
		m_MBLcId = 0;
		memcpy( m_MBULInfo, sMBULInfo, sizeof(unsigned short) * 6 );
		memcpy( m_MBCType, sMBCType, sizeof(unsigned char) * 257 );
		memcpy( m_MBCaseMap, sMBCaseMap, sizeof(unsigned char) * 256 );
	};

	//------------------------------------------------------------------------------
	//Set Single Byte Character Set
	void CMBCInfo::setSBCS ()
	{
		/*
		int i;
		// set for single-byte code page
		for ( i = 0; i < NUM_CHARS; i++ )
		{
			m_MBCType[ i ] = 0;
		}

		// code page has changed, set global flag
		m_MBCodePage = 0;

		// clear flag to indicate single-byte code
		m_bIsMBCodePage = false;

		m_MBLcId = 0;

		for ( i = 0; i < NUM_ULINFO; i++ )
		{
			m_MBULInfo[ i ] = 0;
		}

		for ( i = 0 ; i < 257 ; i++ )
		{
			m_MBCType[ i ] = CLocaleThreadData::sInitialMBCInfo.m_MBCType[ i ];
		}

		for ( i = 0 ; i < 256 ; i++ )
		{
			m_MBCaseMap[ i ] = CLocaleThreadData::sInitialMBCInfo.m_MBCaseMap[ i ];
		}
		*/
	}

	//------------------------------------------------------------------------------
	//Set Multi Byte Character Set - no locking
	int CMBCInfo::SetMBCPNoLock( int codepage )
	{
		/*
		unsigned int icp;
		unsigned int irg;
		unsigned int ich;
		unsigned char* rgptr;
		CPInfo cpinfo;

		codepage = CLocale::GetSystemCP(codepage);

		// user wants 'single-byte' MB code page
		if (codepage == _MB_CP_SBCS)
		{
			setSBCS();
			return 0;
		}

		// check for CRT code page info
		for (icp = 0; icp < ( sizeof( s_CodePageinfoArray ) / sizeof( CCodePageInfo ) ); icp++)
		{
			// see if we have info for this code page
			if ( s_CodePageinfoArray[icp].m_iCodePage == codepage )
			{
				// clear the table
				for (ich = 0; ich < NUM_CHARS; ich++)
				{
					m_MBCType[ich] = 0;
				}

				// for each type of info, load table
				for ( irg = 0; irg < NUM_CTYPES; irg++ )
				{
					// go through all the ranges for each type of info
					for ( rgptr = (unsigned char *)s_CodePageinfoArray[icp].m_ucaRange[irg]; rgptr[0] && rgptr[1]; rgptr += 2 )
					{
						// set the type for every character in range
						for (ich = rgptr[0]; ich <= rgptr[1]; ich++)
						{
							m_MBCType[ich + 1] |= CLocale::CTypeFlag(irg);
						}
					}
				}

				// code page has changed
				m_MBCodePage = codepage;
				// all the code pages we keep info for are truly multibyte
				m_bIsMBCodePage = 1;
				m_MBLcId = CPtoLCID(m_MBCodePage);
				for (irg = 0; irg < NUM_ULINFO; irg++)
				{
					m_MBULInfo[irg] = s_CodePageinfoArray[icp].m_usMBULInfo[irg];
				}

				// return success
				setSBUpperLower();
				return 0;
			}
		}


		// code page not supported by CRT, try the OS
		if ( GetCPInfo(codepage, &cpinfo) != 0 ) //TODO:API
		{
			BYTE *lbptr;

			// clear the table
			for (ich = 0; ich < NUM_CHARS; ich++)
			{
				m_MBCType[ich] = 0;
			}

			m_MBCodePage = codepage;
			m_MBLcId = 0;

			if (cpinfo.MaxCharSize > 1)
			{
				// LeadByte range always terminated by two 0's
				for (lbptr = cpinfo.LeadByte; *lbptr && *(lbptr + 1); lbptr += 2)
				{
					for (ich = *lbptr; ich <= *(lbptr + 1); ich++)
					{
						m_MBCType[ich + 1] |= 0x04;
					}
				}

				// All chars > 1 must be considered valid trail bytes
				for (ich = 0x01; ich < 0xFF; ich++)
				{
					m_MBCType[ich + 1] |= 0x08;
				}

				// code page has changed
				m_MBLcId = CPtoLCID(m_MBCodePage);

				// really a multibyte code page
				m_bIsMBCodePage = 1;
			}
			else
			{
				// single-byte code page
				m_bIsMBCodePage = 0;
			}

			for (irg = 0; irg < NUM_ULINFO; irg++)
			{
				m_MBULInfo[irg] = 0;
			}

			setSBUpperLower();
			// return success
			return 0;
		}


		// If system default call, don't fail - set to SBCS
		if ( CLocale::IsSystemCodePageSet() )
		{
			setSBCS();
			return 0;
		}
		*/
		// return failure, code page not changed
		return -1;
	}

	//------------------------------------------------------------------------------
	//Set single byte Upper and Lower
	void CMBCInfo::setSBUpperLower ()
	{
		/*
		BYTE*	pbPair;
		unsigned int    ich;
		CPInfo  cpinfo;
		UCHAR   sbVector[256];
		UCHAR   upVector[256];
		UCHAR   lowVector[256];
		USHORT  wVector[256];

		//    test if codepage exists
		if ( GetCPInfo( m_MBCodePage, &cpinfo ) != 0 ) //TODO:API
		{
			//  if so, create vector 0-255
			for (ich = 0; ich < 256; ich++)
			{
				sbVector[ich] = (UCHAR) ich;
			}

			//  set byte 0 and any leading byte value to non-alpha char ' '
			sbVector[0] = (UCHAR)' ';

			for (pbPair = &cpinfo.LeadByte[0]; *pbPair; pbPair += 2)
			{
				for (ich = *pbPair; ich <= *(pbPair + 1); ich++)
				{
					sbVector[ich] = (UCHAR)' ';
				}
			}

			//  get char type for character vector

			CLocale::GetStringTypeA(NULL, CT_CTYPE1, (LPCSTR)sbVector, 256, wVector, m_MBCodePage, m_MBLcId, FALSE);

			//  get lower case mappings for character vector

			CLocale::__crtLCMapStringA(NULL, m_MBLcId, LCMAP_LOWERCASE, (LPCSTR)sbVector, 256, (LPSTR)lowVector, 256, m_MBCodePage, FALSE);

			//  get upper case mappings for character vector

			CLocale::__crtLCMapStringA(NULL, m_MBLcId, LCMAP_UPPERCASE, (LPCSTR)sbVector, 256, (LPSTR)upVector, 256, m_MBCodePage, FALSE);

			//  set _SBUP, _SBLOW in mbctype if type is upper. lower
			//  set mapping array with lower or upper mapping value

			for (ich = 0; ich < 256; ich++)
			{
				if (wVector[ich] & _UPPER)
				{
					m_MBCType[ich + 1] |= _SBUP;
					m_MBCaseMap[ich] = lowVector[ich];
				}
				else if (wVector[ich] & _LOWER)
				{
					m_MBCType[ich + 1] |= _SBLOW;
					m_MBCaseMap[ich] = upVector[ich];
				}
				else
				{
					m_MBCaseMap[ich] = 0;
				}
			}
		}
		else
		{
			//  if no codepage, set 'A'-'Z' as upper, 'a'-'z' as lower

			for (ich = 0; ich < 256; ich++)
			{
				if (ich >= (unsigned int)'A' && ich <= (unsigned int)'Z')
				{
					m_MBCType[ich + 1] |= _SBUP;
					m_MBCaseMap[ich] = ich + ('a' - 'A');
				}
				else if (ich >= (unsigned int)'a' && ich <= (unsigned int)'z')
				{
					m_MBCType[ich + 1] |= _SBLOW;
					m_MBCaseMap[ich] = ich - ('a' - 'A');
				}
				else
				{
					m_MBCaseMap[ich] = 0;
				}
			}
		}
		*/
	}

	//------------------------------------------------------------------------------
	int CMBCInfo::CPtoLCID ( int iCodePage )
	{
		/*
		switch ( iCodePage ) 
		{
		case _KANJI_CP:
			{
				return MakeLcId( MAKELANGID( LANG_JAPANESE, SUBLANG_DEFAULT ), SORT_DEFAULT );
			}
		case _CHINESE_SIMP_CP:
			{
				return MakeLcId( MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED ), SORT_DEFAULT );
			}
		case _KOREAN_WANGSUNG_CP:
			{
				return MakeLcId( MAKELANGID( LANG_KOREAN, SUBLANG_DEFAULT ), SORT_DEFAULT );
			}
		case _CHINESE_TRAD_CP:
			{
				return MakeLcId( MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL ), SORT_DEFAULT );
			}
		}
		*/
		return 0;
	}

}//nsWin32
