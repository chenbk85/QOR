//WinQLLocale.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQL/Application/ErrorSystem/WinQLErrorHandling.h"
#include "WinQL/CodeServices/Locale/WinQLLocale.h"
#include "WinQL/CodeServices/Locale/WinQLLocaleThreadData.h"
#include "WinQL/CodeServices/Locale/WinQLLocaleUpdate.h"
#include "WinQL/Application/Threading/WinQLThread.h"
#include <string.h>
#include <ctype.h>
#include <limits.h>

//------------------------------------------------------------------------------
__QCMP_STARTLINKAGE_C

	int nsWin32::CLocale::s_GlobalLocaleStatus = -1;

	//Locale handles.
	unsigned long nsWin32::CLocale::s_aLocaleHandle[] =
	{   
		nsWin32::CLocale::_CLOCALEHANDLE,                       /* lc_handle[_ALL]          */
		nsWin32::CLocale::_CLOCALEHANDLE,                       /* lc_handle[_COLLATE]      */
		nsWin32::CLocale::_CLOCALEHANDLE,                       /* lc_handle[_CTYPE]        */
		nsWin32::CLocale::_CLOCALEHANDLE,                       /* lc_handle[_MONETARY]     */
		nsWin32::CLocale::_CLOCALEHANDLE,                       /* lc_handle[_NUMERIC]      */
		nsWin32::CLocale::_CLOCALEHANDLE                        /* lc_handle[_TIME]         */
	};

__QCMP_ENDLINKAGE_C

//------------------------------------------------------------------------------
namespace nsWin32
{
	CODEPAGE_ENUMCALLBACK CLocale::spEnumProc;
	CThreadLocaleInfo* CLocale::s_pThreadLocaleInfo = &CLocaleThreadData::sInitialLocInfo;
	CMBCInfo* CLocale::s_pGlobalMBCInfo = &CLocaleThreadData::sInitialMBCInfo;	

	const char* CLocale::_clocalestr = "C";

	const unsigned short* CLocale::_ctype_loc_style = CharData::sc_usWCType + 2;

	//------------------------------------------------------------------------------
	const char* CLocale::CLocaleStr()
	{
		return CLocale::_clocalestr;
	}

	//------------------------------------------------------------------------------
	const unsigned short* CLocale::CTypeLocStyle()
	{
		return CLocale::_ctype_loc_style;
	}

	//------------------------------------------------------------------------------
	// pointer to original static to avoid freeing
	char __lconv_static_decimal[] = ".";
	char __lconv_static_null[] = "";

	// lconv settings for "C" locale
	CLocaleConv CLocale::s_ConvC = 
	{
		__lconv_static_decimal,		// decimal_point
		__lconv_static_null,		// thousands_sep
		__lconv_static_null,		// grouping
		__lconv_static_null,		// int_curr_symbol
		__lconv_static_null,		// currency_symbol
		__lconv_static_null,		// mon_decimal_point
		__lconv_static_null,		// mon_thousands_sep
		__lconv_static_null,		// mon_grouping
		__lconv_static_null,		// positive_sign
		__lconv_static_null,		// negative_sign
		CHAR_MAX,					// int_frac_digits
		CHAR_MAX,					// frac_digits
		CHAR_MAX,					// p_cs_precedes
		CHAR_MAX,					// p_sep_by_space
		CHAR_MAX,					// n_cs_precedes
		CHAR_MAX,					// n_sep_by_space
		CHAR_MAX,					// p_sign_posn
		CHAR_MAX					// n_sign_posn
	};

	CLocaleDateTime CLocale::s_TimeC;

	//  non-NLS language string table
	const CLocale::CLOCALETAB CLocale::s_aLanguage[] =
	{
		{"american",                    "ENU"},
		{"american english",            "ENU"},
		{"american-english",            "ENU"},
		{"australian",                  "ENA"},
		{"belgian",                     "NLB"},
		{"canadian",                    "ENC"},
		{"chh",                         "ZHH"},
		{"chi",                         "ZHI"},
		{"chinese",                     "CHS"},
		{"chinese-hongkong",            "ZHH"},
		{"chinese-simplified",          "CHS"},
		{"chinese-singapore",           "ZHI"},
		{"chinese-traditional",         "CHT"},
		{"dutch-belgian",               "NLB"},
		{"english-american",            "ENU"},
		{"english-aus",                 "ENA"},
		{"english-belize",              "ENL"},
		{"english-can",                 "ENC"},
		{"english-caribbean",           "ENB"},
		{"english-ire",                 "ENI"},
		{"english-jamaica",             "ENJ"},
		{"english-nz",                  "ENZ"},
		{"english-south africa",        "ENS"},
		{"english-trinidad y tobago",   "ENT"},
		{"english-uk",                  "ENG"},
		{"english-us",                  "ENU"},
		{"english-usa",                 "ENU"},
		{"french-belgian",              "FRB"},
		{"french-canadian",             "FRC"},
		{"french-luxembourg",           "FRL"},
		{"french-swiss",                "FRS"},
		{"german-austrian",             "DEA"},
		{"german-lichtenstein",         "DEC"},
		{"german-luxembourg",           "DEL"},
		{"german-swiss",                "DES"},
		{"irish-english",               "ENI"},
		{"italian-swiss",               "ITS"},
		{"norwegian",                   "NOR"},
		{"norwegian-bokmal",            "NOR"},
		{"norwegian-nynorsk",           "NON"},
		{"portuguese-brazilian",        "PTB"},
		{"spanish-argentina",           "ESS"},
		{"spanish-bolivia",             "ESB"},
		{"spanish-chile",               "ESL"},
		{"spanish-colombia",            "ESO"},
		{"spanish-costa rica",          "ESC"},
		{"spanish-dominican republic",  "ESD"},
		{"spanish-ecuador",             "ESF"},
		{"spanish-el salvador",         "ESE"},
		{"spanish-guatemala",           "ESG"},
		{"spanish-honduras",            "ESH"},
		{"spanish-mexican",             "ESM"},
		{"spanish-modern",              "ESN"},
		{"spanish-nicaragua",           "ESI"},
		{"spanish-panama",              "ESA"},
		{"spanish-paraguay",            "ESZ"},
		{"spanish-peru",                "ESR"},
		{"spanish-puerto rico",         "ESU"},
		{"spanish-uruguay",             "ESY"},
		{"spanish-venezuela",           "ESV"},
		{"swedish-finland",             "SVF"},
		{"swiss",                       "DES"},
		{"uk",                          "ENG"},
		{"us",                          "ENU"},
		{"usa",                         "ENU"}
	};
	const unsigned int CLocale::s_NumLangs = 64;

	//  non-NLS country/region string table
	const CLocale::CLOCALETAB CLocale::s_aCountry[] =
	{
		{"america",                     "USA"},
		{"britain",                     "GBR"},
		{"china",                       "CHN"},
		{"czech",                       "CZE"},
		{"england",                     "GBR"},
		{"great britain",               "GBR"},
		{"holland",                     "NLD"},
		{"hong-kong",                   "HKG"},
		{"new-zealand",                 "NZL"},
		{"nz",                          "NZL"},
		{"pr china",                    "CHN"},
		{"pr-china",                    "CHN"},
		{"puerto-rico",                 "PRI"},
		{"slovak",                      "SVK"},
		{"south africa",                "ZAF"},
		{"south korea",                 "KOR"},
		{"south-africa",                "ZAF"},
		{"south-korea",                 "KOR"},
		{"trinidad & tobago",           "TTO"},
		{"uk",                          "GBR"},
		{"united-kingdom",              "GBR"},
		{"united-states",               "USA"},
		{"us",                          "USA"},
	};

	const unsigned int CLocale::s_NumCountries = 22;

	//--------------------------------------------------------------------------------
	CLocaleConv& CLocale::ConvC()
	{
		return s_ConvC;
	}

	//--------------------------------------------------------------------------------
	CLocaleDateTime& CLocale::TimeC()
	{
		return s_TimeC;
	}

	//------------------------------------------------------------------------------
	CThread* CLocale::_getptd()
	{
		return t_pCurrentWin32Thread;
	}

	//--------------------------------------------------------------------------------
	int CLocale::__crtLCMapStringAA( CLocaleThreadData* plocinfo, unsigned long Locale, unsigned long dwMapFlags, const char* lpSrcStr, int cchSrc, CAStringRef lpDestStr, CCodePage& code_page, bool bError )
	{
		CLocaleHelper LocaleHelper;
		char* cbuffer = 0;
		CAString cbuffer1;
		char* cbuffer2 = 0;
		int ret;
		CCodePage AnsiCP( 0 );
		int buff_size;

		if ( 0 == Locale )
		{
			Locale = plocinfo->LocaleInfoPtr()->Handle( CLocale::LCCTYPE );
		}

		if ( 0 == code_page )
		{
			code_page = plocinfo->LocaleInfoPtr()->CodePage();
		}

		if ( -1 == ( AnsiCP = CLocale::ANSI_CodePage( Locale ) ) )
		{
			return 0;
		}

		/* LCMapStringA uses ANSI code page to map the string. Check if
			* codepage is ansi, if not convert the input string to ansi
			* codepage then map to a temporary string and then convert temp
			* string to DestStr.
			*/

		if ( AnsiCP != code_page )
		{
			cbuffer = code_page.Convert( AnsiCP, lpSrcStr, &cchSrc, NULL, 0 );

			if (cbuffer == NULL)
			{
				return 0;
			}

			lpSrcStr = cbuffer;
			if (0 == ( buff_size = LocaleHelper.LCMapStringA( Locale, dwMapFlags, lpSrcStr, cchSrc, 0 ) ) )
			{
				ret = 0;
			}
			else
			{
				cbuffer1.Reserve( static_cast< unsigned short >( buff_size ) );

				if (0 == ( buff_size = LocaleHelper.LCMapStringA( Locale, dwMapFlags, lpSrcStr, cchSrc, cbuffer1() ) ) )
				{
					ret = 0;
				}
				else 
				{
					if ( 0 == ( cbuffer2 = AnsiCP.Convert( code_page, cbuffer1, &buff_size, lpDestStr->GetBuffer(), lpDestStr->Allocation() ) ) )
					{
						ret = 0;
					}
					else
					{
						ret = buff_size;
					}
				}
			}
		}
		else
		{
			ret = LocaleHelper.LCMapStringA( Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr );
		}
		if ( cbuffer != 0)
		{
			delete [] cbuffer;
		}
		if ( ( cbuffer2 != 0 ) && ( lpDestStr->operator const char *() != cbuffer2 ) )
		{
				delete [] cbuffer2;
		}
		return ret;
	}

	//--------------------------------------------------------------------------------
	int CLocale::__crtLCMapStringAW( CLocaleThreadData* plocinfo, unsigned long Locale, unsigned long dwMapFlags, const char* lpSrcStr, int cchSrc, CAStringRef lpDestStr, CCodePage& code_page, bool bError )
	{
		CLocaleHelper LocaleHelper;
		int retval = 0;
		int inbuff_size;
		int outbuff_size;
		CWString inwbuffer;
		CWString outwbuffer;

		/* Convert string and return the requested information. Note that
			* we are converting to a wide string so there is not a
			* one-to-one correspondence between number of wide chars in the
			* input string and the number of *bytes* in the buffer. However,
			* there had *better be* a one-to-one correspondence between the
			* number of wide characters and the number of multibyte characters
			* or the resulting mapped string will be worthless to the user.
			*/

		//Use __lc_codepage for conversion if code_page not specified

		if ( 0 == code_page.ID() )
		{
			code_page = plocinfo->LocaleInfoPtr()->CodePage();
		}

		// find out how big a buffer we need (includes NULL if any)
		if ( 0 == ( inbuff_size = code_page.MultiByteToWideChar( bError ? MB_Precomposed | MB_Err_Invalid_Chars : MB_Precomposed, lpSrcStr, cchSrc, 0, 0 ) ) )
		{
			return 0;
		}

		// allocate enough space for wide chars
		inwbuffer.Reserve( static_cast< unsigned short >( inbuff_size ) );

		// do the conversion
		if ( 0 == code_page.MultiByteToWideChar( MB_Precomposed, lpSrcStr, cchSrc, inwbuffer.GetBuffer(), inbuff_size) )
		{
			goto error_cleanup;
		}

		// get size required for string mapping
		if ( 0 == ( retval = LocaleHelper.LCMapStringW( Locale, dwMapFlags, inwbuffer, inbuff_size, 0 ) ) )
		{
			goto error_cleanup;
		}

		if ( dwMapFlags & LCMap_SortKey ) 
		{
			// retval is size in BYTES
			/*TODO:
			if ( 0 != lpDestStr->Allocation() ) 
			{
				if ( retval > lpDestStr->Allocation() )
				{
					goto error_cleanup;
				}

				// do string mapping 
				if ( 0 == LocaleHelper.LCMapStringW( Locale, dwMapFlags, inwbuffer, inbuff_size, lpDestStr ) )
				{
					goto error_cleanup;
				}
			}
			*/
		}
		else 
		{
			// retval is size in wide chars

			outbuff_size = retval;

			// allocate enough space for wide chars (includes NULL if any)			
			outwbuffer.Reserve( static_cast< unsigned short >( outbuff_size ) );

			if ( 0 == LocaleHelper.LCMapStringW( Locale, dwMapFlags, inwbuffer, inbuff_size, outwbuffer() ) )
			{
				goto error_cleanup;
			}

			if ( 0 == outwbuffer.Allocation() ) 
			{
				// get size required 
				if ( 0 == ( retval = code_page.WideCharToMultiByte( 0, outwbuffer, outbuff_size, NULL, 0, NULL, NULL ) ) )
				{
					goto error_cleanup;
				}
			}
			else 
			{
				// convert mapping
				if ( 0 == (retval = code_page.WideCharToMultiByte( 0, outwbuffer, outbuff_size, lpDestStr->GetBuffer(), lpDestStr->Allocation(), NULL, NULL ) ) )
				{
					goto error_cleanup;
				}
			}
		}

error_cleanup:

		return retval;
	}

	//--------------------------------------------------------------------------------
	int CLocale::__crtLCMapStringA( CLocaleThreadData* plocinfo, unsigned long Locale, unsigned long dwMapFlags, const char* lpSrcStr, int cchSrc, CAStringRef lpDestStr, CCodePage& code_page, bool bError )
	{
		nsWin32::CErrorHelper ErrorHelper;
		CLocaleHelper LocaleHelper;

		CLocaleUpdate _loc_update( plocinfo );

		static int f_use = 0;

		// Look for unstubbed 'preferred' flavor. Otherwise use available flavor.
		// Must actually call the function to ensure it's not a stub.
		// (Always try wide version first so WinNT can process codepage correctly.)

		if ( 0 == f_use )
		{
			if (0 != LocaleHelper.LCMapStringW( 0, LCMap_LowerCase, L"\0", 1, NULL ) )
			{
				f_use = USE_W;
			}
			else if ( ErrorHelper.GetLastError() == ErrorCallNotImplemented )
			{
				f_use = USE_A;
			}
		}

		//LCMapString will map past NULL. Must find NULL if in string before cchSrc characters.

		if ( cchSrc > 0 ) 
		{
			int cchSrcCnt = strncnt( lpSrcStr, cchSrc );
			//Include NULL in cchSrc if lpSrcStr terminated within cchSrc bytes.
	         
			if ( cchSrcCnt < cchSrc ) 
			{
				cchSrc = cchSrcCnt + 1;
			} 
			else 
			{
				cchSrc = cchSrcCnt;
			}
		}

		int iResult = 0;

		if( USE_A == f_use || f_use == 0 )
		{
			// Use "A" version
			iResult = __crtLCMapStringAA( plocinfo, Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, code_page, bError );
		}
		else if( USE_W == f_use )
		{
			// Use "W" version
			iResult = __crtLCMapStringAW( plocinfo, Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, code_page, bError );
		}

		return iResult;

	}

	//--------------------------------------------------------------------------------
	bool CLocale::GetStringTypeT( CLocaleThreadData* plocinfo, unsigned long dwInfoType, const char* lpSrcStr, int cchSrc, unsigned short* lpCharType, CCodePage& code_page, int lcid, bool bError )
	{
		nsWin32::CErrorHelper ErrorHelper;
		nsWin32::CStringHelper StringHelper;
		CLocaleUpdate _loc_update( plocinfo );

		static int f_use = 0;

		/* Look for unstubbed 'preferred' flavor. Otherwise use available
		 * flavor. Must actually call the function to ensure it's not a stub.
		 * (Always try wide version first so WinNT can process codepage correctly.)
		 */

		if ( 0 == f_use )
		{
			unsigned short dummy;

			if (0 != StringHelper.GetStringTypeW( CT_CType1, L"\0", 1, &dummy ) )
			{
				f_use = USE_W;
			}

			else if ( ErrorHelper.GetLastError() == ErrorCallNotImplemented )
			{
				f_use = USE_A;
			}
		}

		// Use "A" version

		if ( USE_A == f_use || f_use == 0 )
		{
			char *cbuffer = 0;
			int ret;
			CCodePage AnsiCP(0);

			if (0 == lcid)
			{
				lcid = plocinfo->LocaleInfoPtr()->Handle( CLocale::LCCTYPE);
			}

			if (0 == code_page)
			{
				code_page = plocinfo->LocaleInfoPtr()->CodePage();
			}

			if ( -1 == ( AnsiCP = ANSI_CodePage(lcid) ) )
			{
				return false;
			}

			// If current code-page is not ansi code page, convert it to ansi code page
			// as GetStringTypeA uses ansi code page to find the string type.

			if ( AnsiCP != code_page )
			{
				cbuffer = code_page.Convert( AnsiCP, lpSrcStr, &cchSrc, NULL, 0 );
				if (cbuffer == 0)
				{
					return false;
				}
				lpSrcStr = cbuffer;
			}

			ret = StringHelper.GetStringTypeA( lcid, dwInfoType, lpSrcStr, cchSrc, lpCharType );

			if ( cbuffer != 0 )
			{
				delete [] cbuffer;            
			}

			return (ret > 0 ) ? true : false;
		}

		// Use "W" version

		if ( USE_W == f_use )
		{
			int retval1;
			int buff_size;
			wchar_t* wbuffer;
			bool retval2 = false;

			/* Convert string and return the requested information. Note that
			 * we are converting to a wide character string so there is not a
			 * one-to-one correspondence between number of multibyte chars in the
			 * input string and the number of wide chars in the buffer. However,
			 * there had *better be* a one-to-one correspondence between the
			 * number of multibyte characters and the number of WORDs in the
			 * return buffer.
			 */

			//Use __lc_codepage for conversion if code_page not specified

			if ( 0 == code_page.ID() )
			{
				code_page = plocinfo->LocaleInfoPtr()->CodePage();
			}

			// find out how big a buffer we need
			if ( 0 == ( buff_size = code_page.MultiByteToWideChar( bError ? MB_Precomposed | MB_Err_Invalid_Chars : MB_Precomposed, lpSrcStr, cchSrc, 0, 0 ) ) )
			{
				return false;
			}

			// allocate enough space for wide chars
			wbuffer = new wchar_t[ buff_size ];        

			if ( wbuffer == 0 ) 
			{
				return false;
			}

			(void)memset( wbuffer, 0, sizeof(wchar_t) * buff_size );

			// do the conversion
			if ( 0 != ( retval1 = code_page.MultiByteToWideChar( MB_Precomposed, lpSrcStr, cchSrc, wbuffer, buff_size ) ) )
			{
				// obtain result
				retval2 = StringHelper.GetStringTypeW( dwInfoType, wbuffer, retval1, lpCharType );
			}

			delete [] wbuffer;

			return retval2;
		}
		else   // f_use is neither USE_A nor USE_W
		{
			return false;
		}
	}

	//--------------------------------------------------------------------------------
	int CLocale::__crtGetLocaleInfoW( CLocaleThreadData* plocinfo, unsigned long Locale, unsigned long LCType, CWStringRef lpLCData, CCodePage& code_page )
	{
		nsWin32::CErrorHelper ErrorHelper;
		CLocaleHelper LocaleHelper;
		CLocaleUpdate _loc_update(plocinfo);

		static int f_use = 0;

		// Look for unstubbed 'preferred' flavor. Otherwise use available flavor.
		// Must actually call the function to ensure it's not a stub.

		if (0 == f_use)
		{
			if ( 0 != LocaleHelper.GetLocaleInfoW(0, CLocale::Locale_ILanguage, 0 ) )
			{
				f_use = USE_W;
			}
			else if ( ErrorHelper.GetLastError() == ErrorCallNotImplemented )
			{
				f_use = USE_A;
			}
		}

		// Use "W" version

		if ( USE_W == f_use )
		{
			return LocaleHelper.GetLocaleInfoW( Locale, LCType, lpLCData );
		}

		// Use "A" version

		if ( USE_A == f_use || f_use == 0 )
		{
			int retval = 0;
			int buff_size;
			CAString buffer;

			//Use __lc_codepage for conversion if code_page not specified

			if ( 0 == code_page.ID() )
			{
				code_page = plocinfo->LocaleInfoPtr()->CodePage();
			}

			// find out how big buffer needs to be
			if ( 0 == ( buff_size = LocaleHelper.GetLocaleInfoA( Locale, LCType, NULL ) ) )
			{
				return 0;
			}

			// allocate buffer			
			buffer.Reserve( static_cast< unsigned short >( buff_size ) );

			// get the info in ANSI format
			if ( 0 == LocaleHelper.GetLocaleInfoA( Locale, LCType, buffer() ) )
			{
				goto error_cleanup;
			}

			if (0 == lpLCData->Len())
			{
				// find out how much space needed
				retval = code_page.MultiByteToWideChar( MB_Precomposed, (const char *)buffer, -1, NULL, 0 );
			}
			else 
			{
				// convert into user buffer
				retval = code_page.MultiByteToWideChar( MB_Precomposed, (const char *)buffer, -1, lpLCData->GetBuffer(), lpLCData->Len() );
			}

	error_cleanup:

			delete [] buffer;

			return retval;

		}
		else   // f_use is neither USE_A nor USE_W
		{
			return 0;
		}
	}

	//--------------------------------------------------------------------------------
	int CLocale::GetLocaleInfoT( CLocaleThreadData* plocinfo, unsigned long Locale, unsigned long LCType, CAString lpLCData, CCodePage& code_page )
	{
		CLocaleUpdate _loc_update(plocinfo);
		CLocaleHelper LocaleHelper;

		static int f_use = 0;

		// Look for unstubbed 'preferred' flavor. Otherwise use available flavor.
		// Must actually call the function to ensure it's not a stub.

		if ( 0 == f_use )
		{
			nsWin32::CErrorHelper ErrorHelper;
			if (0 != LocaleHelper.GetLocaleInfoW( 0, CLocale::Locale_ILanguage, NULL ) )
			{
				f_use = USE_W;
			}
			else if ( ErrorHelper.GetLastError() == ErrorCallNotImplemented )
			{
				f_use = USE_A;
			}
		}

		// Use "A" version

		if ( USE_A == f_use || f_use == 0 )
		{
			return LocaleHelper.GetLocaleInfoA( Locale, LCType, lpLCData() );
		}

		// Use "W" version

		if ( USE_W == f_use )
		{
			int retval = 0;
			int buff_size;
			CWString wbuffer;

			//Use __lc_codepage for conversion if code_page not specified
	         
			if ( code_page.ID() == 0 )
			{
				code_page = plocinfo->LocaleInfoPtr()->CodePage();
			}

			// find out how big buffer needs to be
			if ( 0 == ( buff_size = LocaleHelper.GetLocaleInfoW( Locale, LCType, 0 ) ) )
			{
				return 0;
			}

			// allocate buffer
			
			wbuffer.Reserve( static_cast< unsigned short >( buff_size ) );

			// get the info in wide format
			if ( 0 == LocaleHelper.GetLocaleInfoW( Locale, LCType, wbuffer() ) )
			{
				goto error_cleanup;
			}

			// convert from Wide Char to ANSI
			if ( 0 == lpLCData.Len() )
			{
				// convert into local buffer				
				retval = code_page.WideCharToMultiByte( 0, wbuffer, -1, 0, 0, 0, 0 );
			}
			else 
			{
				// convert into user buffer
				retval = code_page.WideCharToMultiByte( 0, wbuffer, -1, lpLCData.GetBuffer(), lpLCData.Len(), 0, 0 );
			}

	error_cleanup:

			delete [] wbuffer;

			return retval;
		}
		else   // f_use is neither USE_A nor USE_W
		{
			return 0;
		}
	}

	//------------------------------------------------------------------------------
	int CLocale::GetLocaleString( CLocaleThreadData* plocinfo, unsigned long localehandle, unsigned long fieldtype, void* address )
	{
		nsWin32::CErrorHelper ErrorHelper;
		char** straddress = (char**)address;

		CAString strBuffer;
		strBuffer.Reserve( Str_Char_Cnt );
		unsigned char cbuffer[ Str_Char_Cnt ];
		unsigned char* pcbuffer = cbuffer;
		
		int bufferused = 0; // 1 indicates buffer points to malloc'ed memory
		//int buffersize = Str_Char_Cnt;
		int outsize;
		CCodePage code_page( 0 );

		if ( ( outsize = CLocale::GetLocaleInfoT( plocinfo, localehandle, fieldtype, strBuffer, code_page ) ) == 0 )
		{
			if( ErrorHelper.GetLastError() != ErrorInsufficientBuffer )
			{
				goto error;
			}

			strBuffer.Reserve( static_cast< unsigned short >( outsize ) );// buffersize too small, get required size buffer

			if ( ( outsize = CLocale::GetLocaleInfoT( plocinfo, localehandle, fieldtype, strBuffer, code_page ) ) == 0 )
			{
				goto error;
			}
		}

		*straddress = new char[ outsize ];

		if( *straddress == 0 )
		{
			//TODO:Error
			goto error;
		}

		//TODO:_ERRCHECK(strncpy_s(*straddress, outsize, const_cast<const char*>( (char*)(pcbuffer) ), outsize - 1));
		strncpy( *straddress, const_cast<const char*>( (char*)(pcbuffer) ), outsize - 1);

		if ( bufferused )
		{
			delete [] pcbuffer;
		}

		return 0;

		error:

		if ( bufferused )
		{
			delete [] pcbuffer;
		}
		return -1;
	}

	//--------------------------------------------------------------------------------
	int CLocale::GetLocaleInt ( CLocaleThreadData* plocinfo, unsigned long localehandle, unsigned long fieldtype, void* address )
	{
		int i;
		unsigned char c;
		CWString strBuffer;
		strBuffer.Reserve( Str_Char_Int );

		static wchar_t wcbuffer[ Str_Char_Int ];
		//const int buffersize = Str_Char_Int;
		char* charaddress = (char*)address;
		CCodePage code_page(0);

		if ( CLocale::__crtGetLocaleInfoW ( plocinfo, localehandle, fieldtype, strBuffer(), code_page ) == 0 )
		{
			return -1;
		}

		*(char*)charaddress = 0;

		// assume GetLocaleInfoW returns valid ASCII integer in wcstr format
		for (i = 0; i < Str_Char_Int; i++)
		{			
			if ( isdigit( ( c = (unsigned char)wcbuffer[i] ) ) )
			{
				*(unsigned char *)charaddress = (unsigned char)(10 * (int)(*charaddress) + (c - '0'));
			}
			else
			{
				break;
			}
		}
		return 0;
	}

	//--------------------------------------------------------------------------------
	int CLocale::mb_cur_max(void)
	{
		CThread* pThread = t_pCurrentWin32Thread;
		
        if( pThread )
        {
			if( ( pThread->Data().LocaleData().LocaleInfoPtr() != s_pThreadLocaleInfo ) && !( pThread->Data().OwnLocale() & CLocale::GlobalLocaleStatus() ) )
		    {
			    pThread->UpdateLocaleInfo();
		    }			

			return pThread->Data().LocaleData().LocaleInfoPtr()->MBCurMax();
        }
        return 1;
	}

	//--------------------------------------------------------------------------------
	//Returns ansi codepage for a given Locale
    //static
	CCodePage CLocale::ANSI_CodePage( unsigned long id )
	{
		CAString ch;
		ch.Reserve( 7 );
		unsigned int uiResult = 0;
		//ch[ 6 ] = 0;
		CLocaleHelper LocaleHelper;

		if ( LocaleHelper.GetLocaleInfoA( id, Locale_IDefaultANSICodePage, ch() ) == 0 )
		{
			//TODO:Error
			uiResult = (unsigned int)-1;
		}
		else
		{
			uiResult = atol( ch );
		}

		CCodePage code_page( uiResult );
		return code_page;
	}

	//--------------------------------------------------------------------------------
	size_t CLocale::strncnt( const char* _String, size_t _Cnt )
	{
			size_t n = _Cnt;
			char *cp = (char *)_String;
			while ( n-- && *cp )
			{
					cp++;
			}
			return _Cnt - n - 1;
	}

	//--------------------------------------------------------------------------------
	CThreadLocaleInfo*& CLocale::PtrThreadLocaleInfo()
	{
		return s_pThreadLocaleInfo;
	}

	//--------------------------------------------------------------------------------
	int CLocale::GlobalLocaleStatus()
	{
		return s_GlobalLocaleStatus;
	}

	//--------------------------------------------------------------------------------
	void CLocale::GlobalLocaleStatus(int iStatus)
	{
		s_GlobalLocaleStatus = iStatus;
	}

	//--------------------------------------------------------------------------------
	CMBCInfo* CLocale::GlobalMBCInfoPtr()
	{
		return s_pGlobalMBCInfo;
	}

	//--------------------------------------------------------------------------------
	void CLocale::GlobalMBCInfoPtr( CMBCInfo* pMBCInfo )
	{
		s_pGlobalMBCInfo = pMBCInfo;
	}

	//--------------------------------------------------------------------------------
	unsigned long* CLocale::LocaleHandles()
	{
		return s_aLocaleHandle;
	}

	//--------------------------------------------------------------------------------
	void CLocale::SetCPEnumCallback( CODEPAGE_ENUMCALLBACK pCallback )
	{
		m_CSCodePageProc.Enter();
		spEnumProc = pCallback;
	}

	//--------------------------------------------------------------------------------
	void CLocale::ClearCPEnumProc()
	{			
		spEnumProc = 0;
		m_CSCodePageProc.Leave();
	}

	//--------------------------------------------------------------------------------
	int __QCMP_STDCALLCONVENTION CLocale::CodePageEnumProc( TCHAR* /*strCodePage*/ )
	{
		//TODO: Convert strCodePage to an ID to construct the CodePage object with
		CCodePage CodePage( 65000 );
		int bResult = (spEnumProc)( &CodePage ) ? 1 : 0;
		return bResult;
	}		

}//nsWin32
