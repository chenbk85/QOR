//WinQLThreadLocaleInfo.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Win32 Thread Locale Information
#include "WinQL/CodeServices/Locale/WinQLThreadLocaleInfo.h"
#include "WinQL/CodeServices/Locale/WinQLLocale.h"
#include "WinQL/CodeServices/Locale/WinQLMBCInfo.h"
#include "WinQL/CodeServices/Locale/WinQLLocaleThreadData.h"
#include "WinQL/CodeServices/Locale/WinQLLCID.h"
#include "WinQL/Application/Threading/WinQLThread.h"
#include <string.h>
#include <ctype.h>
#include <limits.h>

namespace nsWin32
{

	//--------------------------------------------------------------------------------
	static const char _first_127char[] = 
	{
			1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, 16, 17,
			18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,
			35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
			52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68,
			69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85,
			86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100,101,102,
			103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,
			120,121,122,123,124,125,126,127
	};

	//--------------------------------------------------------------------------------
	CThreadLocaleInfo::CLocaleCategory CThreadLocaleInfo::m_sDefaultCategory[] = 
	{
		{ "LC_ALL",			"",	 &CThreadLocaleInfo::__init_dummy,		0, 0, 0, 0 	},//never called
		{ "LC_COLLATE",		"C", &CThreadLocaleInfo::__init_collate,	0, 0, 0, 0 	},
		{ "LC_CTYPE",		"C", &CThreadLocaleInfo::__init_ctype,		0, 0, 0, 0 	},
		{ "LC_MONETARY",	"C", &CThreadLocaleInfo::__init_monetary,	0, 0, 0, 0 	},
		{ "LC_NUMERIC",		"C", &CThreadLocaleInfo::__init_monetary,	0, 0, 0, 0 	},
		{ "LC_TIME",		"C", &CThreadLocaleInfo::__init_time,		0, 0, 0, 0 	},
	};

	//--------------------------------------------------------------------------------
	CThreadLocaleInfo::CThreadLocaleInfo() : m_CodePage( CMBCInfo::_CLOCALECP )
	{
		for(int iLoop = 0; iLoop < 6; iLoop++ )
		{
			Category(iLoop) = m_sDefaultCategory[iLoop];
			m_Handles[iLoop] = CLocale::_CLOCALEHANDLE;
			m_LocaleIDs[iLoop].wLanguage = 0;
			m_LocaleIDs[iLoop].wCountry = 0;
			m_LocaleIDs[iLoop].wCodePage = 0;
		}
		
		m_RefCount = 1;

		//m_uiCodePage = CMBCInfo::_CLOCALECP;
		m_uiCollationCodePage = CMBCInfo::_CLOCALECP;
							
		m_CLike = 1;
		m_MBCurMax = 1;

		m_pConvIntlRefCount = 0;
		m_pConvNumRefCount = 0;
		m_pConvMonRefCount = 0;

		m_pConv = &(CLocale::ConvC());

		m_pCType1RefCount = 0;
		m_pCType1 = 0;

		m_pCType = CharData::sc_usCType + 128;
		m_pCLMap = CharData::sc_ucnewclmap + 128;
		m_pCUMap = CharData::sc_ucnewcumap + 128;
		m_pTimeDate = &( CLocale::TimeC() );
	}

	//--------------------------------------------------------------------------------
	CThreadLocaleInfo::~CThreadLocaleInfo()
	{
	}

	//--------------------------------------------------------------------------------
	CThreadLocaleInfo& CThreadLocaleInfo::operator=( const CThreadLocaleInfo& Src )
	{
		if( &Src == this )
		{
			return *this;
		}

		ResetRefCount();
		m_CodePage = Src.m_CodePage;
		m_uiCollationCodePage = Src.m_uiCollationCodePage;
		for(int iLoop = 0; iLoop < 6; iLoop ++ )
		{
			m_Handles[iLoop] = Src.m_Handles[iLoop];
			m_LocaleIDs[iLoop] = Src.m_LocaleIDs[iLoop];
			m_Categories[iLoop] = Src.m_Categories[iLoop];
		}
		m_CLike = Src.m_CLike;
		m_MBCurMax = Src.m_MBCurMax;
		m_pConvIntlRefCount = Src.m_pConvIntlRefCount;
		m_pConvNumRefCount = Src.m_pConvNumRefCount;
		m_pConvMonRefCount = Src.m_pConvMonRefCount;
		m_pConv = Src.m_pConv;
		m_pCType1RefCount = Src.m_pCType1RefCount;
		m_pCType1 = Src.m_pCType1;
		m_pCType = Src.m_pCType;
		m_pCLMap = Src.m_pCLMap;
		m_pCUMap = Src.m_pCUMap;
		m_pTimeDate = Src.m_pTimeDate;
		AddLocaleRef();

		return *this;
	}

	//--------------------------------------------------------------------------------
	int CThreadLocaleInfo::__init_collate()
	{
		//Nothing to do
		return 0;
	}

	//--------------------------------------------------------------------------------
	int CThreadLocaleInfo::__init_ctype()
	{
		int* pRefCount = 0;

		CAString strA;
		CAString strB;
		// non-C locale table for char's
		unsigned short* newctype1 = 0;          // temp new table
		unsigned char* newclmap = 0;            // temp new map table
		unsigned char* newcumap = 0;            // temp new map table

		// non-C locale table for wchar_t's
		unsigned char* cbuffer = 0;				// char working buffer
		int i;									// general purpose counter
		unsigned char* cp;						// char pointer
		//CPInfo lpCPInfo;						// struct for use with GetCPInfo
		nsCodeQOR::CTLRef< CPInfo > CPInfoRef;

		int mb_cur_max;
		CLocaleThreadData locinfo;
		CLocaleHelper LocaleHelper;

		locinfo.LocaleInfoPtr() = this;
		locinfo.MBCInfoPtr() = 0;

		// allocate and set up buffers before destroying old ones
		// codepage will be restored by setlocale if error

		if ( Handle( CLocale::LCCTYPE ) != CLocale::_CLOCALEHANDLE )
		{
			if ( CodePage() == 0 )
			{ 
				// code page was not specified 
				if ( CLocale::GetLocaleInt( &locinfo, MakeLcId( LocaleID(CLocale::LCCTYPE).wLanguage, CLocale::Sort_Default), CLocale::Locale_IDefaultANSICodePage, (char**)&(CodePage()) ) )
				{
					goto error_cleanup;
				}
			}

			// allocate a new (thread) reference counter
			pRefCount = new int[1];

			// allocate new buffers for tables
			newctype1 = new unsigned short[ (CLocale::_COFFSET+ CTabSize ) ];//(unsigned short *) _calloc_crt((_COFFSET+_CTABSIZE), sizeof(unsigned short));
			newclmap = new unsigned char[ (CLocale::_COFFSET+ CTabSize ) ];//(char *) _calloc_crt((_COFFSET+_CTABSIZE), sizeof(char));
			newcumap = new unsigned char[ (CLocale::_COFFSET+ CTabSize ) ];//(char *) _calloc_crt((_COFFSET+_CTABSIZE), sizeof(char));
			cbuffer = new unsigned char[ CTabSize ];//(unsigned char *) _calloc_crt (_CTABSIZE, sizeof(char));

			if (!pRefCount || !newctype1 || !cbuffer || !newclmap || !newcumap)
			{
				goto error_cleanup;
			}

			*pRefCount = 0;

			// construct string composed of first 256 chars in sequence
			for (cp = cbuffer, i = 0; i < CTabSize - 1; i++)
			{
				*cp++ = (unsigned char)i;
			}

			CPInfoRef = LocaleHelper.GetCPInfo( CodePage() );

			if( CPInfoRef.IsNull() )
			{
				goto error_cleanup;
			}

			if( CPInfoRef->MaxCharSize > MB_LEN_MAX )
			{
				goto error_cleanup;
			}

			mb_cur_max = (unsigned short) CPInfoRef->MaxCharSize;

			// zero out leadbytes so GetStringType doesn't interpret as multi-byte chars
			if (mb_cur_max > 1)
			{
				for (cp = (unsigned char *)CPInfoRef->LeadByte; cp[0] && cp[1]; cp += 2)
				{
					for (i = cp[0]; i <= cp[1]; i++)
					{
						cbuffer[i] = ' ';
					}
				}
			}

			// convert to newctype1 table - ignore invalid char errors
			if ( CLocale::GetStringTypeT( 0, CT_CType1, const_cast< const char* >( (char*)( cbuffer ) ), CTabSize - 1, newctype1 + 1 + CLocale::_COFFSET, CodePage(), 0, false ) == false )
			{
				goto error_cleanup;
			}

			//LCMapString will map past 0. Must find 0 if in string before cchSrc characters.
	         			
			strA.Append( reinterpret_cast< char* >( newclmap + 2 + CLocale::_COFFSET ), CTabSize - 2 );
			if ( CLocale::__crtLCMapStringA( 0, Handle( CLocale::LCCTYPE ), LCMap_LowerCase, const_cast< const char* >( (char*)( cbuffer + 1 ) ), CTabSize - 2, strA(), CodePage(), false ) == false )
			{
				goto error_cleanup;
			}

			strB.Append( reinterpret_cast< char* >( newcumap + 2 + CLocale::_COFFSET ), CTabSize - 2 );
			if ( CLocale::__crtLCMapStringA(0, Handle( CLocale::LCCTYPE ), LCMap_UpperCase, const_cast< const char* >( (char*)( cbuffer + 1 ) ), CTabSize - 2, strB(), CodePage(), false ) == false )
			{
				goto error_cleanup;
			}

			newctype1[CLocale::_COFFSET] = 0; // entry for EOF
			newclmap[CLocale::_COFFSET] = 0;
			newcumap[CLocale::_COFFSET] = 0;
			newclmap[CLocale::_COFFSET+1] = 0; // entry for null
			newcumap[CLocale::_COFFSET+1] = 0; // entry for null

			// ignore DefaultChar

			// mark lead-byte entries in newctype1 table
			if (mb_cur_max > 1)
			{
				for (cp = (unsigned char *)CPInfoRef->LeadByte; cp[0] && cp[1]; cp += 2)
				{
					for (i = cp[0]; i <= cp[1]; i++)
					{
						newctype1[CLocale::_COFFSET+i+1] = nsWin32::LeadByte;
					}
				}
			}

			//copy last-1 _COFFSET unsigned short to front note -1, we don't really want to copy 0xff
	         
			memcpy( newctype1, newctype1 + CTabSize - 1, CLocale::_COFFSET * sizeof(unsigned short) );
			memcpy( newclmap, newclmap + CTabSize - 1, CLocale::_COFFSET * sizeof(char) );
			memcpy( newcumap, newcumap + CTabSize - 1, CLocale::_COFFSET * sizeof(char) );

			// free old tables
			if ( ( CType1_RefCount() ) && ( Release_CType1_RefCount() == 0) )
			{
				/*
				_ASSERT(0);
				free( ctype1 - _COFFSET);
				free((char *)( pclmap - _COFFSET - 1));
				free((char *)( pcumap - _COFFSET - 1));
				free( ctype1_refcount);
				*/
			}

			(*pRefCount) = 1;
			CType1_RefCount() = (nsWin32::shared_long*)pRefCount;
			// set pointers to point to entry 0 of tables
			CType() = newctype1 + 1 + CLocale::_COFFSET;
			CType1() = newctype1 + CLocale::_COFFSET;
			CLMap() = newclmap + 1 + CLocale::_COFFSET;
			CUMap() = newcumap + 1 + CLocale::_COFFSET;
			mb_cur_max = mb_cur_max;

			// cleanup and return success
			delete [] cbuffer;
			return 0;

	error_cleanup:
			delete [] pRefCount;
			delete [] newctype1;
			delete [] newclmap;
			delete [] newcumap;
			delete [] cbuffer;
			return 1;

		} 
		else 
		{

			if ( ( CType1_RefCount() != 0) && ( Release_CType1_RefCount() == 0) )
			{
				//TODO:_ASSERTE( ctype1_refcount > 0);
			}
			CType1_RefCount() = 0;
			CType1() = 0;
			CType() = CharData::sc_usCType + 1 + CLocale::_COFFSET;
			CLMap() = CharData::sc_ucnewclmap + 1 + CLocale::_COFFSET;
			CUMap() = CharData::sc_ucnewcumap + 1 + CLocale::_COFFSET;
			mb_cur_max = 1;

			return 0;
		}
	}

	//--------------------------------------------------------------------------------
	int CThreadLocaleInfo::__init_monetary()
	{
		CLocaleConv* lc;
		int ret;
		unsigned long ctryid;
		int* lc_refcount;
		int* lconv_mon_refcount = 0;
		CLocaleThreadData locinfo;

		locinfo.LocaleInfoPtr() = this;
		locinfo.MBCInfoPtr() = 0;

		if ( ( Handle(CLocale::LCMONETARY) != CLocale::_CLOCALEHANDLE) || ( Handle(CLocale::LCNUMERIC) != CLocale::_CLOCALEHANDLE) )
		{
			//Allocate structure filled with 0 pointers
			lc = new CLocaleConv;
			if ( lc == 0 )
			{
				return 1;
			}

			//Allocate a new reference counter for the lconv structure
			lc_refcount = new int;
			if ( lc_refcount == 0 )
			{
				delete lc;
				return 1;
			}

			*lc_refcount = 0;

			if (  Handle(CLocale::LCMONETARY) != CLocale::_CLOCALEHANDLE )
			{
				//Allocate a new reference counter for the numeric info
				lconv_mon_refcount = new int;
				if ( lconv_mon_refcount == 0 )
				{
					delete lc;
					delete lc_refcount;
					return 1;
				}

				*lconv_mon_refcount = 0;

				//Currency is country--not language--dependent. NT work-around.
	             
				ctryid = MakeLcId( LocaleID(CLocale::LCMONETARY).wCountry, CLocale::Sort_Default);

				ret = 0;

				ret |= CLocale::GetLocaleString(&locinfo, ctryid, CLocale::Locale_SIntlSymbol, (void *)&lc->int_curr_symbol );
				ret |= CLocale::GetLocaleString(&locinfo, ctryid, CLocale::Locale_SCurrency, (void *)&lc->currency_symbol );
				ret |= CLocale::GetLocaleString(&locinfo, ctryid, CLocale::Locale_SMonDecimalSep, (void *)&lc->mon_decimal_point );
				ret |= CLocale::GetLocaleString(&locinfo, ctryid, CLocale::Locale_SMonThousandSep, (void *)&lc->mon_thousands_sep );
				ret |= CLocale::GetLocaleString(&locinfo, ctryid, CLocale::Locale_SMonGrouping, (void *)&lc->mon_grouping );

				ret |= CLocale::GetLocaleString(&locinfo, ctryid, CLocale::Locale_SPositiveSign, (void *)&lc->positive_sign);
				ret |= CLocale::GetLocaleString(&locinfo, ctryid, CLocale::Locale_SNegativeSign, (void *)&lc->negative_sign);

				ret |= CLocale::GetLocaleInt(&locinfo, ctryid, CLocale::Locale_IIntlCurrDigits, (void *)&lc->int_frac_digits);
				ret |= CLocale::GetLocaleInt(&locinfo, ctryid, CLocale::Locale_ICurrDigits, (void *)&lc->frac_digits);
				ret |= CLocale::GetLocaleInt(&locinfo, ctryid, CLocale::Locale_IPosSyMPrecedes, (void *)&lc->p_cs_precedes);
				ret |= CLocale::GetLocaleInt(&locinfo, ctryid, CLocale::Locale_IPosSepBySpace, (void *)&lc->p_sep_by_space);
				ret |= CLocale::GetLocaleInt(&locinfo, ctryid, CLocale::Locale_INegSymPrecedes, (void *)&lc->n_cs_precedes);
				ret |= CLocale::GetLocaleInt(&locinfo, ctryid, CLocale::Locale_INegSepBySpace, (void *)&lc->n_sep_by_space);
				ret |= CLocale::GetLocaleInt(&locinfo, ctryid, CLocale::Locale_IPosSignPosn, (void *)&lc->p_sign_posn);
				ret |= CLocale::GetLocaleInt(&locinfo, ctryid, CLocale::Locale_INegSignPosn, (void *)&lc->n_sign_posn);

				if ( ret != 0 ) 
				{
					lc->FreeMon();
					delete lc;                
					delete lc_refcount;
					delete lconv_mon_refcount;
					return 1;
				}

				FixGrouping(lc->mon_grouping);
			}
			else 
			{
				/* C locale for monetary category (the numeric category fields,
				 * which are NOT of the C locale, get fixed up below). Note
				 * that ConvC() is copied, rather than directly assigning
				 * the fields of lc because of the uncertainty of the values of
				 * the int_frac_digits,..., n_sign_posn fields (SCHAR_MAX or
				 * UCHAR_MAX, depending on whether or a compliand was built
				 * with -J.
				 */
				*lc = CLocale::ConvC();
			}

			//Copy the numeric locale fields from the old struct
	         
			lc->decimal_point = Conv()->decimal_point;
			lc->thousands_sep = Conv()->thousands_sep;
			lc->grouping = Conv()->grouping;

			*lc_refcount = 1;
			if (lconv_mon_refcount)
			{
				*lconv_mon_refcount = 1;
			}
		}
		else 
		{
			//C locale for BOTH monetary and numeric categories.
	         
			lconv_mon_refcount = 0;
			lc_refcount = 0;
			lc = &(CLocale::ConvC());           // point to new one 

		}

		if( ( lconv_mon_refcount != 0 ) && ( m_InterlockedHelper.Decrement( (volatile long*)(lconv_mon_refcount) ) == 0) )
		{
			//TODO:_ASSERTE(lconv_mon_refcount > 0);
		}

		if ( ( Conv_Intl_RefCount() != 0 ) && ( Release_Conv_IntlRefCount() == 0) )
		{
			delete Conv();
			delete Conv_Intl_RefCount();        
		}

		lconv_mon_refcount = lconv_mon_refcount;
		Conv_Intl_RefCount() = (nsWin32::shared_long*)lc_refcount;
		Conv() = lc;                       // point to new one

		return 0;
	}

	//--------------------------------------------------------------------------------
	int CThreadLocaleInfo::__init_numeric()
	{
		CLocaleConv* lc;
		int ret = 0;
		unsigned long ctryid;
		int* lc_refcount;
		int* lconv_num_refcount = 0;
		CLocaleThreadData locinfo;

		locinfo.LocaleInfoPtr() = this;
		locinfo.MBCInfoPtr() = 0;

		if ( ( Handle(CLocale::LCNUMERIC) != CLocale::_CLOCALEHANDLE) || ( Handle(CLocale::LCMONETARY) != CLocale::_CLOCALEHANDLE) )
		{
			//Allocate structure filled with 0 pointers

			lc = new CLocaleConv;
			if ( lc == 0 )
			{
				return 1;
			}

			//Copy over all fields (esp., the monetary category)
	         
			*lc = *Conv();

			//Allocate a new reference counter for the lconv structure
			lc_refcount = new int;
			if ( lc_refcount == 0 )
			{
				delete lc;            
				return 1;
			}

			*lc_refcount = 0;

			if ( Handle(CLocale::LCNUMERIC) != CLocale::_CLOCALEHANDLE )
			{
				//Allocate a new reference counter for the numeric info
	             
				lconv_num_refcount = new int;
				if ( lconv_num_refcount == 0 )
				{
					delete lc;
					delete lc_refcount;
					return 1;
				}
				*lconv_num_refcount = 0;

				//Numeric data is country--not language--dependent. NT work-around.
	             
				ctryid = MakeLcId( LocaleID(CLocale::LCNUMERIC).wCountry, CLocale::Sort_Default);

				ret |= CLocale::GetLocaleString(&locinfo, ctryid, CLocale::Locale_SDecimal, (void *)&lc->decimal_point);
				ret |= CLocale::GetLocaleString(&locinfo, ctryid, CLocale::Locale_SThousand, (void *)&lc->thousands_sep);
				ret |= CLocale::GetLocaleString(&locinfo, ctryid, CLocale::Locale_SGrouping, (void *)&lc->grouping);

				if (ret) 
				{
					// Clean up before returning failure
					lc->FreeNum();
					delete lconv_num_refcount;
					delete lc;
					delete lc_refcount;
					return -1;
				}

				FixGrouping(lc->grouping);
			}
			else 
			{
				//C locale for just the numeric category.
	             
				//0 out the reference count pointer
	             
				lconv_num_refcount = 0;
				lc->decimal_point = CLocale::ConvC().decimal_point;
				lc->thousands_sep = CLocale::ConvC().thousands_sep;
				lc->grouping = CLocale::ConvC().grouping;
			}

			(*lc_refcount) = 1;

			if (lconv_num_refcount)
			{
				(*lconv_num_refcount) = 1;
			}
		}
		else 
		{
			//C locale for BOTH numeric and monetary categories.
	         
			lconv_num_refcount = 0;
			lc_refcount = 0;
			lc = &(CLocale::ConvC());           // point to new one
		}

		//If this is part of LC_ALL, then we need to free the old lconv
		// set up in init_monetary() before this.
	     
		if( ( lconv_num_refcount != 0) && ( m_InterlockedHelper.Decrement( (volatile long*)( lconv_num_refcount) ) == 0 ) )
		{
			//TODO:_ASSERTE( lconv_num_refcount > 0);
		}
		if ( ( Conv_Intl_RefCount() != 0) && ( Release_Conv_IntlRefCount() == 0) )
		{
			delete Conv_Intl_RefCount();
			delete Conv();
		}

		lconv_num_refcount = lconv_num_refcount;
		Conv_Intl_RefCount() = (nsWin32::shared_long*)lc_refcount;

		Conv() = lc;
		return 0;
	}

	//--------------------------------------------------------------------------------
	int CThreadLocaleInfo::__init_time()
	{
		// Temporary date/time strings
		CLocaleDateTime* lc_time;
		CLocaleThreadData ThreadData;
		ThreadData.LocaleInfoPtr() = this;

		if ( Handle(CLocale::LCTIME) != CLocale::_CLOCALEHANDLE )
		{
			// Allocate structure filled with 0 pointers
			lc_time = new CLocaleDateTime;
			if ( lc_time == 0 )// (struct __lc_time_data *) _calloc_crt(1, sizeof(struct __lc_time_data))) == 0 )
			{
				return 1;
			}

			if ( ThreadData.GetLocaleTime(lc_time, this) )
			{
				delete lc_time;						
				return 1;
			}
			lc_time->refcount = 1;
		}
		else 
		{
			lc_time = &( CLocale::TimeC() );      // point to new one
		}

		if ( TimeDatePtr() != &( CLocale::TimeC() ) && m_InterlockedHelper.Decrement( (volatile long*) ( &( TimeDatePtr()->refcount) ) ) == 0 )
		{
			//TODO: _ASSERTE( lc_time_curr->refcount > 0);
		}

		TimeDatePtr() = lc_time;	// point to new one
		return 0;
	}

	//--------------------------------------------------------------------------------
	int CThreadLocaleInfo::__init_dummy()
	{
		return 0;
	}

	//--------------------------------------------------------------------------------
	void CThreadLocaleInfo::AddLocaleRef()
	{
		int category;
		AddRef();    
		if ( Conv_Intl_RefCount() != 0 )
		{
			AddRef_Conv_IntlRefCount();
		}

		if ( Conv_Mon_RefCount() != 0 )
		{
			AddRef_Conv_MonRefCount();        
		}

		if ( Conv_Num_RefCount() != 0 )
		{
			AddRef_Conv_NumRefCount();        
		}

		if ( CType1_RefCount() != 0 )
		{
			AddRef_CType1_RefCount();        
		}

		for (category = CLocale::LCMIN; category <= CLocale::LCMAX; ++category) 
		{
			if ( Category(category).Locale() != CLocale::_clocalestr && Category(category).RefCount() != 0 )
			{
				Category(category).AddRef();
				//InterlockedIncrement((volatile long*)Category(category).refcount);
			}

			if (Category(category).wLocale() != 0 && Category(category).wRefCount() != 0)
			{
				Category(category).wAddRef();            
			}
		}

		m_InterlockedHelper.Increment( (volatile long*) &( TimeDatePtr()->refcount ) );

	}

	//--------------------------------------------------------------------------------
	void* CThreadLocaleInfo::RemoveLocaleRef()
	{
		int category;
		if ( this != 0 )
		{
			Release();        

			if ( Conv_Intl_RefCount() != 0 )
			{
				Release_Conv_IntlRefCount();            
			}

			if ( Conv_Mon_RefCount() != 0 )
			{
				Release_Conv_MonRefCount();            
			}

			if ( Conv_Num_RefCount() != 0 )
			{
				Release_Conv_NumRefCount();            
			}

			if ( CType1_RefCount() != 0 )
			{
				Release_CType1_RefCount();            
			}

			for (category = CLocale::LCMIN; category <= CLocale::LCMAX; ++category) 
			{
				if (Category(category).Locale() != CLocale::_clocalestr && Category(category).RefCount() != 0 )
				{
					Category(category).Release();                
				}
				if (Category(category).wLocale() != 0 && Category(category).wRefCount() != 0)
				{
					Category(category).wRelease();                
				}
			}
			m_InterlockedHelper.Decrement( (volatile long*) &( TimeDatePtr()->refcount ) );
		}
		return this;
	}

	//--------------------------------------------------------------------------------
	char* CThreadLocaleInfo::SetLocale_SetCat( int category, const char* locale )
	{
		char* oldlocale;
		unsigned long oldhandle;
		unsigned int oldcodepage;
		CLC_ID oldid;
		CLC_ID idtemp;
		unsigned int cptemp;
		char lctemp[ CLC_ID::MAX_LC_LEN ];
		char* pch = 0;
		size_t cch = 0;
		short out[ sizeof(_first_127char) ];
		int i;
		nsWin32::CThread* _ptd = nsWin32::t_pCurrentWin32Thread;
		CIsCtypeCompatible* _Lcid_c = _ptd->Data().SetLocData().m_aLCIDC; // __setloc_data._Lcid_c is array
		int _LOC_CCACHE = sizeof( _ptd->Data().SetLocData().m_aLCIDC ) / sizeof( CIsCtypeCompatible );
		CIsCtypeCompatible buf1, buf2;

		if ( !ExpandLocale( (char*)locale, lctemp, _countof(lctemp), &idtemp, &cptemp, category ) )
		{
			//TODO:Error
			return 0;            // unrecognized locale
		}

		if (!strcmp(lctemp, Category(category).Locale()))
		{
			return Category(category).Locale();
		}

		cch = sizeof(int) + strlen(lctemp) + 1;
		if ( !(pch = (char *) new char[cch] ) )
		{
			//TODO:Error
			return 0;
		}

		oldlocale = Category(category).Locale(); // save for possible restore
		oldhandle = Handle(category);
		memcpy( (void *)&oldid, (void *)&LocaleID(category), sizeof(oldid) );
		oldcodepage = CodePage();

		// update locale string
		//TODO: _ERRCHECK(strcpy_s(pch + sizeof(int), cch - sizeof(int), lctemp));
		strcpy/*_s*/( pch + sizeof(int)/*, cch - sizeof(int)*/, lctemp );
		Category(category).Locale() = pch + sizeof(int);
		Handle(category) = MakeLcId(idtemp.wLanguage, CLocale::Sort_Default);
		memcpy( (void *)&LocaleID(category), (void *)&idtemp, sizeof(idtemp) );

		/* To speedup locale based comparisions, we identify if the current
		 * local has first 127 character set same as CLOCALE. If yes then
		 * lc_clike = TRUE.
		 */

		if( category == CLocale::LCCTYPE )
		{
			CodePage() = cptemp;
			buf1 = _Lcid_c[ _LOC_CCACHE - 1 ];
			/* brings the recently used codepage to the top. or else shifts
			 * every thing down by one so that new _Lcid_c can be placed at
			 * the top.
			 */
			for ( i = 0; i < _LOC_CCACHE; i++ )
			{
				if ( CodePage() == _Lcid_c[i].m_ulID )
				{
					// We don't really want to swap cache around in case what we are looking for is the first element of the cache
	                 
					if (i != 0)
					{
						_Lcid_c[0] = _Lcid_c[i];
						_Lcid_c[i] = buf1;
					}
					break;
				}
				else
				{
					buf2 = _Lcid_c[i];
					_Lcid_c[i] = buf1;
					buf1 = buf2;
				}
			}

			if ( i == _LOC_CCACHE)
			{
				if ( CLocale::GetStringTypeT(0, CT_CType1, _first_127char, sizeof(_first_127char), (unsigned short*)out, CodePage(), Handle(CLocale::LCCTYPE), 1 ) )
				{
					int j;
					for ( j = 0; j < sizeof(_first_127char); j++)
					{
						out[j] = out[j] & (Upper|Lower|Digit|Space|Punct|Control|Blank|Hex|Alpha);
					}

					if ( ! ::memcmp(out, CLocale::_ctype_loc_style, (sizeof(_first_127char)/sizeof(char))*sizeof(short)))
					{
						_Lcid_c[0].m_bIsCLike = true;
					}
					else
					{
						_Lcid_c[0].m_bIsCLike = false;
					}
				}
				else
				{
					_Lcid_c[0].m_bIsCLike = false;
				}
				_Lcid_c[0].m_ulID = CodePage();
			}

			CLike() = _Lcid_c[0].m_bIsCLike;
		}

		if ( category == CLocale::LCCOLLATE )
		{
			CollationCodePage() = cptemp;
		}
		

		if ( ( this->*(Category(category).Init() ) ) () )
		{
			// restore previous state!
			Category(category).Locale() = oldlocale;        
			delete [] pch;
			Handle(category) = oldhandle;
			CodePage() = oldcodepage;
			return 0; // error if non-zero return
		}

		// locale set up successfully
		// Cleanup
		if ( (oldlocale != CLocale::_clocalestr) && ( Category(category).Release() == 0 ) )
		{
			//TODO: _ASSERT(0);        
			delete [] Category(category).RefCount();
			delete [] Category(category).wRefCount();
			Category(category).wLocale() = 0;
		}

		if (pch) 
		{
			*(int*)pch = 1;
		}

		Category(category).RefCount() = (nsWin32::shared_long*)pch;

		return Category(category).Locale();
	}

	//--------------------------------------------------------------------------------
	void CThreadLocaleInfo::Free()
	{
		int category;

		//Free up lconv struct
	     
		if ( (Conv() != 0 ) && (Conv() != &( CLocale::ConvC() ) ) && ((Conv_Intl_RefCount() != 0 ) && ((long)*(Conv_Intl_RefCount() ) == 0)))
		{
			if ( (Conv_Mon_RefCount() != 0 ) && ((long)*( Conv_Mon_RefCount() ) == 0))
			{
				delete Conv_Mon_RefCount();            
				Conv()->FreeMon();
			}

			if ( (Conv_Num_RefCount() != 0 ) && ((long)*( Conv_Num_RefCount() ) == 0))
			{
				delete Conv_Num_RefCount();            
				Conv()->FreeNum();
			}

			delete Conv_Intl_RefCount();        
			delete Conv();
		}

		//Free up ctype tables
	     
		if ( (CType1_RefCount() != 0) && ((long)*( CType1_RefCount() ) == 0) )
		{
			free(CType1()-CLocale::_COFFSET);
			free((char *)(CLMap() - CLocale::_COFFSET - 1));
			free((char *)(CUMap() - CLocale::_COFFSET - 1));
			delete CType1_RefCount();        
		}

		//Free up the __lc_time_data struct
	     
		if ( TimeDatePtr() != &( CLocale::TimeC() ) && ( ( TimeDatePtr()->refcount ) == 0 ) )
		{        
			delete TimeDatePtr();
		}

		for (category = CLocale::LCMIN; category <= CLocale::LCMAX; ++category) 
		{
			if ((Category(category).Locale() != CLocale::_clocalestr) && (Category(category).RefCount() != 0) && ((long)*Category(category).RefCount() == 0) )
			{
				delete Category(category).RefCount();            
			}

			//TODO: _ASSERTE(((lc_category[category].wlocale != 0) && (lc_category[category].wrefcount != 0)) || ((lc_category[category].wlocale == 0) && (lc_category[category].wrefcount == 0)));

			if ((Category(category).wLocale() != 0 ) && ( Category(category).wRefCount() != 0 ) && ((long)*Category(category).wRefCount() == 0) )
			{
				delete [] Category(category).wRefCount();            
			}
		}

		//Free up the threadlocinfo struct
	   
		delete this;

	}

	//--------------------------------------------------------------------------------
	char* CThreadLocaleInfo::SetLocale_GetAll()
	{
		int i;
		int same = 1;
		char* pch = 0;
		size_t cch = 0;
		int* refcount = 0;
		size_t refcountSize = 0;

		// allocate memory if necessary
		refcountSize = sizeof(int)+(CLC_ID::MAX_LC_LEN+1) * (CLocale::LCMAX-CLocale::LCMIN+1) + CLocale::CATNAMES_LEN;

		refcount = (int*)(new unsigned char[refcountSize]);
		if ( refcount == 0 )
		{
			return 0;
		}

		pch = (char *)(refcount + 1);
		cch = refcountSize - sizeof(int);
		*pch = '\0';
		*refcount = 1;

		for (i = CLocale::LCMIN + 1; ; i++)
		{
			_strcats(pch, cch, 3, Category(i).Name(),"=",Category(i).Locale());

			if (i < CLocale::LCMAX)
			{
				//TODO: _ERRCHECK(strcat_s(pch, cch, ";"));
				strcat/*_s*/(pch/*, cch*/, ";");
				if (strcmp(Category(i).Locale(), Category(i+1).Locale()))
				{
					same=0;
				}
			}
			else
			{
				if (!same) 
				{
					if ( Category(CLocale::LCALL).RefCount() != 0 && Category(CLocale::LCALL).Release() == 0 ) 
					{
						//TODO: _ASSERT(0);                    
						delete [] Category(CLocale::LCALL).RefCount();
					}

					if ( Category(CLocale::LCALL).wRefCount() != 0 && Category(CLocale::LCALL).wRelease() == 0 ) 
					{
						//TODO: _ASSERT(0);                    
						delete [] Category(CLocale::LCALL).wRefCount();
					}

					Category(CLocale::LCALL).wRefCount() = 0;
					Category(CLocale::LCALL).wLocale() = 0;
					Category(CLocale::LCALL).RefCount() = (nsWin32::shared_long*)refcount;
					return Category(CLocale::LCALL).Locale() = pch;

				} 
				else 
				{                
					delete [] refcount;

					if ( Category(CLocale::LCALL).RefCount() != 0 && Category(CLocale::LCALL).Release() == 0 ) 
					{
						//TODO: _ASSERT(0);                    
						delete [] Category(CLocale::LCALL).RefCount();
					}

					if ( Category(CLocale::LCALL).wRefCount() != 0 && Category(CLocale::LCALL).wRelease() == 0 ) 
					{
						//TODO: _ASSERT(0);                    
						delete [] Category(CLocale::LCALL).wRefCount();
					}

					Category(CLocale::LCALL).wRefCount() = 0;
					Category(CLocale::LCALL).wLocale() = 0;
					Category(CLocale::LCALL).RefCount() = 0;
					Category(CLocale::LCALL).Locale() = 0;
					return Category(CLocale::LCCTYPE).Locale();
				}
			}
		}
	}

	//--------------------------------------------------------------------------------
	char* CThreadLocaleInfo::SetLocaleNoLock( int iCategory, const char* pchLocale )
	{
		char* pchResult = 0;
		// Interpret locale

		if (iCategory != CLocale::LCALL)
		{
			pchResult = (pchLocale) ? SetLocale_SetCat( iCategory,pchLocale ) : Category(iCategory).Locale();

		} 
		else 
		{
			// LC_ALL
			char lctemp[CLC_ID::MAX_LC_LEN];
			int i;
			int same = 1;
			int fLocaleSet = 0; // flag to indicate if anything successfully set

			if ( pchLocale != 0 )
			{
				if ( ( pchLocale[0]=='L') && ( pchLocale[1]=='C') && ( pchLocale[2]=='_') )
				{
					// parse compound locale string
					size_t len;
					const char * p = pchLocale;  // start of string to parse
					const char * s;

					do 
					{
						s = strpbrk(p,"=;");

						if ((s==(char *)0) || (!(len=(size_t)(s-p))) || (*s==';'))
						{
							return 0;  // syntax error
						}

						// match with known LC_ strings, if possible, else ignore
						for (i=CLocale::LCALL+1; i<=CLocale::LCMAX; i++)
						{
							if ( ( !::strncmp(Category(i).Name(),p,len) ) && ( len==strlen( Category(i).Name() ) ) )
							{
								break;  // matched i
							}
						} // no match if (i>LC_MAX) -- just ignore

						if ((!(len = strcspn(++s,";"))) && (*s!=';'))
						{
							return 0;  // syntax error
						}

						if (i<=CLocale::LCMAX)
						{
							//TODO:_ERRCHECK(strncpy_s(lctemp, _countof(lctemp), s, len));
							::strncpy/*_s*/(lctemp/*, _countof(lctemp)*/, s, len);
							lctemp[len]='\0';   // null terminate string

							// don't fail unless all categories fail
							if (SetLocale_SetCat( i,lctemp))
							{
								fLocaleSet++;       // record a success
							}
						}

						if (*(p = s+len)!='\0')
						{
							p++;  // skip ';', if present
						}

					} while (*p);

					pchResult = (fLocaleSet) ? SetLocale_GetAll() : 0;

				} 
				else 
				{
					// simple LC_ALL locale string
					// confirm locale is supported, get expanded locale
					if ( pchResult = ExpandLocale( (char *)pchLocale, lctemp, _countof(lctemp), 0, 0, iCategory ) )
					{
						for (i=CLocale::LCMIN; i<=CLocale::LCMAX; i++)
						{
							if (i!=CLocale::LCALL)
							{
								if (strcmp(lctemp, Category(i).Locale()))
								{
									if (SetLocale_SetCat( i, lctemp))
									{
										fLocaleSet++;   // record a success
									}
									else
									{
										same = 0;       // record a failure
									}
								}
								else
								{
									fLocaleSet++;   // trivial succcess
								}
							}
						}

						if (same) // needn't call setlocale_get_all() if all the same
						{
							pchResult = SetLocale_GetAll();
							// pchResult set above
						}
						else
						{
							pchResult = (fLocaleSet) ? SetLocale_GetAll() : 0;
						}
					}
				}
			} 
			else 
			{ 
				// LC_ALL & 0
				pchResult = SetLocale_GetAll ();
			}
		}

		// common exit point
		return pchResult;
	}

	//--------------------------------------------------------------------------------
	void CThreadLocaleInfo::FixGrouping( char* pchGrouping )
	{
		/* ANSI specifies that the fields should contain "\3" [\3\0] to indicate
		 * thousands groupings (100,000,000.00 for example).
		 * NT uses "3;0"; ASCII 3 instead of value 3 and the ';' is extra.
		 * So here we convert the NT version to the ANSI version.
		 */

		while ( *pchGrouping )
		{
			// convert '3' to '\3'
			if ( *pchGrouping >= '0' && *pchGrouping <= '9')
			{
				*pchGrouping = *pchGrouping - '0';
				pchGrouping++;
			}
			// remove ';'
			else if ( *pchGrouping == ';' )
			{
				char *tmp = pchGrouping;

				do
				{
					*tmp = *(tmp+1);
				}while (*++tmp);
			}
			// unknown (illegal) character, ignore
			else
			{
				pchGrouping++;
			}
		}
	}


	//--------------------------------------------------------------------------------
	CThreadLocaleInfo* CThreadLocaleInfo::UpdateExNoLock( CThreadLocaleInfo* pptlocid )
	{
		CThreadLocaleInfo* pThreadLocaleInfo;

		if ( this == 0 || pptlocid == 0 )
		{
			return 0;
		}

		pThreadLocaleInfo = pptlocid;

		if ( pThreadLocaleInfo != this )
		{
			//Update to the current locale info structure and increment the reference counts.
	         
			pptlocid = this;
			AddLocaleRef();
	        
			//Decrement the reference counts in the old locale info structure.
	         
			if ( pThreadLocaleInfo != 0 )
			{
				pThreadLocaleInfo->RemoveLocaleRef();
			}

			/* Free the old locale info structure, if necessary.  Must be done
			 * after incrementing reference counts in current locale in case
			 * any refcounts are shared with the old locale.
			 */
			if ( ( pThreadLocaleInfo != 0 ) && ( pThreadLocaleInfo->RefCount() == 0 ) && ( pThreadLocaleInfo != &CLocaleThreadData::sInitialLocInfo ) )
			{
				pThreadLocaleInfo->Free();
			}

		}

		return this;
	}

	//--------------------------------------------------------------------------------
	void CThreadLocaleInfo::_strcats( char* pchOutStr, size_t sizeInBytes, int n, ... )
	{
		int i;
		va_list substr;

		va_start( substr, n );

		for ( i = 0; i < n; i++ )
		{
			//_ERRCHECK(strcat_s(pchOutStr, sizeInBytes, va_arg(substr, char *)));
			strcat/*_s*/( pchOutStr/*, sizeInBytes*/, va_arg( substr, char* ) );
		}
		va_end( substr );
	}

	//--------------------------------------------------------------------------------
	int CThreadLocaleInfo::StrToLocale( CLC_STRINGS* names, const char* locale )
	{
		int i;
		size_t len;
		char ch;

		memset( (void *)names, '\0', sizeof(CLC_STRINGS) );  // clear out result

		if ( *locale=='\0' )
		{
			return 0; // trivial case
		}

		// only code page is given
		if ( locale[0] == '.' && locale[1] != '\0' )
		{
			//TODO: _ERRCHECK(strncpy_s(names->szCodePage, _countof(names->szCodePage), &locale[1], MAX_CP_LEN-1));
			strncpy/*_s*/( names->m_szCodePage/*, _countof(names->m_szCodePage)*/, &locale[1], CLC_ID::MAX_CP_LEN - 1 );

			// Make sure to null terminate the string in case locale is > MAX_CP_LEN
			names->m_szCodePage[ CLC_ID::MAX_CP_LEN -1 ] = 0;
			return 0;
		}

		for ( i = 0; ; i++ )
		{
			if ( !( len = ::strcspn( locale,"_.," ) ) )
			{
				return -1;  // syntax error
			}

			ch = locale[len];

			if( ( i == 0 ) && ( len < CLC_ID::MAX_LANG_LEN ) && ( ch != '.' ) )
			{
				//TODO: _ERRCHECK(strncpy_s(names->szLanguage, _countof(names->szLanguage), locale, len));
				strncpy/*_s*/( names->m_szLanguage/*, _countof(names->m_szLanguage)*/, locale, len );
			}
			else if( ( i == 1 ) && ( len < CLC_ID::MAX_CTRY_LEN ) && ( ch != '_' ) )
			{
				//TODO: _ERRCHECK(strncpy_s(names->szCountry, _countof(names->szCountry), locale, len));
				strncpy/*_s*/( names->m_szCountry/*, _countof(names->m_szCountry)*/, locale, len );
			}
			else if ( (i==2) && (len<CLC_ID::MAX_CP_LEN) && (ch=='\0' || ch==',') )
			{
				//TODO: _ERRCHECK(strncpy_s(names->szCodePage, _countof(names->szCodePage), locale, len));
				strncpy/*_s*/( names->m_szCodePage/*, _countof(names->m_szCodePage)*/, locale, len );
			}
			else
			{
				//TODO:Error
				return -1;  // error parsing locale string
			}

			if (ch==',')
			{
				// modifier not used in current implementation, but it
				// must be parsed to for POSIX/XOpen conformance
				//  strncpy(names->szModifier, locale, MAX_MODIFIER_LEN-1);
				break;
			}

			if (!ch)
			{
				break;
			}
			locale+=(len+1);
		}
		return 0;
	}

	//--------------------------------------------------------------------------------
	void CThreadLocaleInfo::LocaleToStr( char* pchLocale, size_t sizeInBytes, const CLC_STRINGS* pLC_Names )
	{
		//TODO: _ERRCHECK(strcpy_s(pchLocale, sizeInBytes, (char *)pLC_Names->szLanguage));
		strcpy/*_s*/( pchLocale/*, sizeInBytes*/, (char *)pLC_Names->m_szLanguage );

		if ( *( pLC_Names->m_szCountry ) )
		{
			_strcats( pchLocale, sizeInBytes, 2, "_", pLC_Names->m_szCountry );
		}

		if (*(pLC_Names->m_szCodePage))
		{
			_strcats( pchLocale, sizeInBytes, 2, ".", pLC_Names->m_szCodePage );
		}
	}

	//--------------------------------------------------------------------------------
	char* CThreadLocaleInfo::ExpandLocale( char* szExpr, char* pchOutput, size_t sizeInChars, CLC_ID* pLocaleID, unsigned int* puiCodePage, int iCategory )
	{
		CSetLoc*	pSetLocData				= &( CLocale::_getptd()->Data().SetLocData() );
		unsigned int*		puiCacheCodePage		= &pSetLocData->m_uiCacheCodePage;
		CLC_ID*		pCacheId				= &pSetLocData->CacheId;
		char*		pchCacheIn				= pSetLocData->m_acCacheIn;
		size_t		cacheinSize				= _countof(pSetLocData->m_acCacheIn);
		char*		pchCacheOut				= pSetLocData->m_acCacheOut;
		size_t		cacheoutSize			= _countof(pSetLocData->m_acCacheOut);
		size_t		charactersInExpression	= 0;
		char*		pchResult				= 0;

		if ( szExpr != 0 ) // error if no input
		{
			if ( pchOutput != 0 && sizeInChars != 0 ) // error if no output
			{
				if ( ( ( *szExpr == 'C' ) && ( !szExpr[ 1 ] ) ) )  // for "C" locale, just return
				{

					//TODO: _ERRCHECK(strcpy_s(pchOutput, sizeInChars, "C"));
					strcpy/*_s*/( pchOutput/*, sizeInChars*/, "C" );

					if( pLocaleID )
					{
						pLocaleID->wLanguage = 0;
						pLocaleID->wCountry  = 0;
						pLocaleID->wCodePage = 0;
					}
					if ( puiCodePage )
					{
						*puiCodePage = CCodePage::ACP; // return to ANSI code page
					}
					pchResult = pchOutput; //"C"        
				}
				else
				{
					// first, make sure we didn't just do this one
					charactersInExpression = strlen( szExpr );
					bool bSuccess = true;

					// we would never have cached this
					if ( charactersInExpression >= CLC_ID::MAX_LC_LEN || ( strcmp( pchCacheOut, szExpr ) && strcmp( pchCacheIn, szExpr ) ) )
					{
						bSuccess = false;
						// do some real work
						CLC_STRINGS names;
						const char* source = 0;
						size_t charactersInSource = 0;

						if ( StrToLocale( &names, szExpr ) == 0 )
						{

							if ( pSetLocData->GetQualifiedLocale( &names, pCacheId, &names ) )// locale recognized/supported
							{
								// begin: cache atomic section

								*puiCacheCodePage = pCacheId->wCodePage;

								LocaleToStr(pchCacheOut, cacheoutSize, &names);

								if (*szExpr && charactersInExpression < CLC_ID::MAX_LC_LEN)
								{
									source = szExpr;
									charactersInSource = charactersInExpression;
								}
								else
								{
									// Don't cache "" empty string or over-long string
									source = "";
								}

								// Ensure that whatever we are about to copy in will be null terminated

								//TODO: _ERRCHECK(strncpy_s(pchCacheIn, cacheinSize, source, charactersInSource + 1));
								strncpy/*_s*/( pchCacheIn/*, cacheinSize*/, source, charactersInSource + 1 );

								// end: cache atomic section
								bSuccess = true;
							}
						}
					}

					if( bSuccess )
					{
						if ( pLocaleID )
						{
							memcpy( (void*)pLocaleID, (void*)pCacheId, sizeof(*pCacheId) );   // possibly return LC_ID
						}

						if ( puiCodePage )
						{
							memcpy( (void*)puiCodePage, (void*)puiCacheCodePage, sizeof(*puiCacheCodePage) );   // possibly return puiCodePage
						}

						//TODO: _ERRCHECK(strcpy_s(pchOutput, sizeInChars, pchCacheOut));
						strcpy/*_s*/( pchOutput/*, sizeInChars*/, pchCacheOut );

						pchResult = pchCacheOut; // return fully expanded locale string
					}
				}   
			}
		}

		return pchResult; 
	}

	//--------------------------------------------------------------------------------
	void CThreadLocaleInfo::AddRefAll()
	{
		int category;

		AddRef();
		AddRef_Conv_IntlRefCount();
		AddRef_Conv_MonRefCount();
		AddRef_Conv_NumRefCount();
		AddRef_CType1_RefCount();

		for ( category = CLocale::LCMIN; category <= CLocale::LCMAX; ++category ) 
		{
			if ( m_Categories[ category ].CatLocale() != CLocale::_clocalestr && m_Categories[ category ].RefCount() != 0 )
			{
				m_Categories[ category ].AddRef();
			}

			if ( m_Categories[ category ].wLocale() != 0 && m_Categories[ category ].wRefCount() != 0 )
			{
				m_Categories[ category ].wAddRef();					
			}
		}

		//TODO:InterlockedIncrement(&(ptloci->lc_time_curr->refcount));
	}

	//--------------------------------------------------------------------------------
	void CThreadLocaleInfo::ReleaseAll()
	{
		int category;

		Release();
		Release_Conv_IntlRefCount();
		Release_Conv_MonRefCount();
		Release_Conv_NumRefCount();
		Release_CType1_RefCount();

		for ( category = CLocale::LCMIN; category <= CLocale::LCMAX; ++category )
		{
			if( m_Categories[ category ].CatLocale() != CLocale::_clocalestr && m_Categories[ category ].RefCount() != 0 )
			{
				m_Categories[ category ].Release();
			}

			if( m_Categories[ category ].wLocale() != 0 && m_Categories[ category ].wRefCount() != 0 )
			{
				m_Categories[ category ].wRelease();
			}
		}

		//TODO:InterlockedDecrement(&(ptloci->lc_time_curr->refcount));
	}

}//nsWin32
