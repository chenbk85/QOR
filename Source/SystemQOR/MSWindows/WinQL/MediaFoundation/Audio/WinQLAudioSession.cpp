//WinQLAudioSession.cpp

// Copyright Querysoft Limited 2013, 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "SystemQOR.h"
#include "WinQL/CodeServices/WinQLPolicy.h"
#include "WinQL/Application/Threading/WinQLCriticalSection.h"
#include "WinQL/MediaFoundation/Audio/WinQLAudioSession.h"
#include "WinQL/GUI/MessageHandler.h"
#include "WinQAPI/OLE32.h"
#include <new>

//--------------------------------------------------------------------------------
namespace nsWin32
{

	const GUID IAudioSessionControl::_IID = { 0xF4B1A599, 0x7266, 0x4319, 0xA8, 0xCA, 0xE7, 0x0A, 0xCB, 0x11, 0xE8, 0xCD };
	const GUID ISimpleAudioVolume::_IID =	{ 0x87CE5498, 0x68D6, 0x44E5, 0x92, 0x15, 0x6D, 0xA4, 0x7E, 0xF8, 0x83, 0xD8 };
	const GUID IAudioSessionEvents::_IID =	{ 0x24918ACC, 0x64B3, 0x37C1, 0x8C, 0xA9, 0x74, 0xA6, 0x6E, 0x99, 0x57, 0xA8 };
	const GUID IAudioSessionManager::_IID = { 0xBFA971F1, 0x4D5E, 0x40BB, 0x93, 0x5E, 0x96, 0x70, 0x39, 0xBF, 0xBE, 0xE4 };


	const GUID CLASS_MMDEVICEENUMERATOR = { 0xBCDE0395, 0xE52F, 0x467C, { 0x8E, 0x3D, 0xC4, 0x57, 0x92, 0x91, 0x69, 0x2E } };//BCDE0395-E52F-467C-8E3D-C4579291692E

	//// {2715279F-4139-4ba0-9CB1-B351F1B58A4A}
	static const GUID AudioSessionVolumeCtx = { 0x2715279f, 0x4139, 0x4ba0, { 0x9c, 0xb1, 0xb3, 0x51, 0xf1, 0xb5, 0x8a, 0x4a } };

	__QOR_IMPLEMENT_OCLASS_LUID( CAudioSessionEventHandler );

	//--------------------------------------------------------------------------------
	CAudioSessionEventHandler::CAudioSessionEventHandler( unsigned int uNotificationMessage, COSWindow::refType hwndNotification ) : CIUnknownImplBase< IAudioSessionEvents >()
	,	m_uNotificationMessage(uNotificationMessage)
	,	m_hwndNotification(hwndNotification)
	,	m_bNotificationsEnabled( false )
	,	m_pAudioSession( 0 )
	,	m_pSimpleAudioVolume( 0 )
	{
		_WINQ_FCONTEXT( "CAudioSessionEventHandler::CAudioSessionEventHandler" );
	}

	//--------------------------------------------------------------------------------
	CAudioSessionEventHandler::~CAudioSessionEventHandler()
	{
		_WINQ_FCONTEXT( "CAudioSessionEventHandler::~CAudioSessionEventHandler" );
		EnableNotifications( false );

		m_pAudioSession->Release();
		m_pSimpleAudioVolume->Release();
	};


	//-------------------------------------------------------------------
	//  CreateInstance
	//
	//  Creates an instance of the CAudioSessionEventHandler object.
	//-------------------------------------------------------------------
	long CAudioSessionEventHandler::CreateInstance( unsigned int uNotificationMessage, COSWindow::refType hwndNotification, CAudioSessionEventHandler** ppAudioSessionEventHandler )
	{
		_WINQ_SFCONTEXT( "CAudioSessionEventHandler::CreateInstance" );
		long hr = 0;
   
		CAudioSessionEventHandler* pAudioSessionEventHandler = 0;

		pAudioSessionEventHandler = new /*(std::nothrow)*/ CAudioSessionEventHandler( uNotificationMessage, hwndNotification );

		if( pAudioSessionEventHandler == 0 )
		{
			hr = nsWin32::E_OutOfMemory;
		}
		else
		{
			hr = pAudioSessionEventHandler->Initialize();
			if( hr >= 0 )
			{
				*ppAudioSessionEventHandler = pAudioSessionEventHandler;
				(*ppAudioSessionEventHandler)->AddRef();
			}
		}

		pAudioSessionEventHandler->Release();
		return hr;
	}


	//-------------------------------------------------------------------
	//  Initializes the CAudioSessionEventHandler object.
	long CAudioSessionEventHandler::Initialize()
	{
		_WINQ_FCONTEXT( "CAudioSessionEventHandler::Initialize" );
		long hr = 0;

		IMMDeviceEnumerator* pDeviceEnumerator = 0;
		IMMDevice* pDevice = 0;
		IAudioSessionManager* pAudioSessionManager = 0;

		// Get the enumerator for the audio endpoint devices.
		hr = nsWinQAPI::COLE32::Instance().CoCreateInstance( reinterpret_cast< const ::IID& >( CLASS_MMDEVICEENUMERATOR ), 0, CLSCTX_INPROC_SERVER, reinterpret_cast< const ::IID& >( IMMDeviceEnumerator::_IID ), reinterpret_cast< void** >( &pDeviceEnumerator ) );

		if( hr < 0 ) { goto done; }

		// Get the default audio endpoint that the SAR will use.
		hr = pDeviceEnumerator->GetDefaultAudioEndpoint( eRender, eConsole,   // The SAR uses 'eConsole' by default.
			&pDevice
			);

		if( hr < 0 ) { goto done; }

		// Get the session manager for this device.
		hr = pDevice->Activate(  IAudioSessionManager::_IID,  CLSCTX_INPROC_SERVER, 0, (void**) &pAudioSessionManager );
		if( hr < 0 ) { goto done; }

		// Get the audio session. 
		hr = pAudioSessionManager->GetAudioSessionControl(reinterpret_cast< const nsWin32::GUID* >(&NULL_GUID),     // Get the default audio session. 
			0,          // The session is not cross-process.
			&m_pAudioSession 
			);

		if( hr < 0 ) { goto done; }

		hr = pAudioSessionManager->GetSimpleAudioVolume(reinterpret_cast< const nsWin32::GUID* >(&NULL_GUID), 0, &m_pSimpleAudioVolume);

done:

		pDeviceEnumerator->Release();
		pDevice->Release();
		pAudioSessionManager->Release();
		return hr;
	}

	//-------------------------------------------------------------------
	//  Enables or disables notifications from the audio session. For
	//  example, if the user mutes the audio through the system volume-
	//  control program (Sndvol), the application will be notified.
	long CAudioSessionEventHandler::EnableNotifications( bool bEnable )
	{
		_WINQ_FCONTEXT( "CAudioSessionEventHandler::EnableNotifications" );
		long hr = 0;

		if( m_hwndNotification.IsNull() || m_pAudioSession == 0 )
		{
			nsWin32::E_Fail;
		}

		if( m_bNotificationsEnabled == bEnable )
		{
			// No change.
			return 0;
		}

		if (bEnable)
		{
			hr = m_pAudioSession->RegisterAudioSessionNotification( this );
		}
		else
		{
			hr = m_pAudioSession->UnregisterAudioSessionNotification( this );
		}

		if( hr >= 0 )
		{
			m_bNotificationsEnabled = bEnable;
		}

		return hr;
	}


	//-------------------------------------------------------------------
	//  Gets the session volume level.
	long CAudioSessionEventHandler::GetVolume( float* pflVolume )
	{
		_WINQ_FCONTEXT( "CAudioSessionEventHandler::GetVolume" );
		long hr = 0;

		if ( m_pSimpleAudioVolume == 0 )
		{
			hr = nsWin32::E_Fail;
		}
		else
		{
			hr = m_pSimpleAudioVolume->GetMasterVolume( pflVolume );
		}
		return hr;
	}


	//-------------------------------------------------------------------
	//  Sets the session volume level.
	//  flVolume: Ranges from 0 (silent) to 1 (full volume)
	//-------------------------------------------------------------------
	long CAudioSessionEventHandler::SetVolume( float flVolume )
	{
		_WINQ_FCONTEXT( "CAudioSessionEventHandler::SetVolume" );
		long hr = 0;

		if( m_pSimpleAudioVolume == 0 )
		{
			hr = nsWin32::E_Fail;
		}
		else
		{
			hr = m_pSimpleAudioVolume->SetMasterVolume( flVolume, &AudioSessionVolumeCtx  // Event context.
				);
		}
		return hr;
	}


	//-------------------------------------------------------------------
	//  Gets the muting state of the session.
	long CAudioSessionEventHandler::GetMute( int* pbMute )
	{
		_WINQ_FCONTEXT( "CAudioSessionEventHandler::GetMute" );
		long hr = S_OK;

		if( m_pSimpleAudioVolume == 0 )
		{
			hr = nsWin32::E_Fail;
		}
		else
		{
			hr = m_pSimpleAudioVolume->GetMute( pbMute );
		}
		return hr;
	}

	//-------------------------------------------------------------------
	//  Mutes or unmutes the session audio.
	long CAudioSessionEventHandler::SetMute( bool bMute )
	{
		_WINQ_FCONTEXT( "CAudioSessionEventHandler::SetMute" );
		long hr = 0;

		if( m_pSimpleAudioVolume == 0 )
		{
			hr = nsWin32::E_Fail;
		}
		else
		{
			hr = m_pSimpleAudioVolume->SetMute( bMute ? 1 : 0, &AudioSessionVolumeCtx  // Event context.
				);
		}
		return hr;
	}

	//-------------------------------------------------------------------
	//  Sets the display name for the session audio.
	long CAudioSessionEventHandler::SetDisplayName( const wchar_t* wszName )
	{
		_WINQ_FCONTEXT( "CAudioSessionEventHandler::SetDisplayName" );
		long hr = 0;

		if( m_pAudioSession == 0 )
		{
			hr = nsWin32::E_Fail;
		}
		else
		{
			hr = m_pAudioSession->SetDisplayName( wszName, 0 );
		}
		return hr;
	}


	//-------------------------------------------------------------------
	//  Callback when the session volume level or muting state changes.
	//  (Implements IAudioSessionEvents::OnSimpleVolumeChanged.)
	long CAudioSessionEventHandler::OnSimpleVolumeChanged( float NewVolume, int NewMute, const GUID* EventContext )
	{
		_WINQ_FCONTEXT( "CAudioSessionEventHandler::OnSimpleVolumeChanged" );
		// Check if we should post a message to the application.

		if( m_bNotificationsEnabled && ( !( *EventContext == AudioSessionVolumeCtx ) ) &&  ( !m_hwndNotification.IsNull() ) )
		{
			// Notifications are enabled, AND
			// We did not trigger the event ourselves, AND
			// We have a valid window handle.

			CMessageHandler MessageHandler;

			MessageHandler.Post( m_hwndNotification, m_uNotificationMessage, *((WPARAM*)(&NewVolume)),  // Coerce the float.
				(LPARAM)NewMute );
		}
		return S_OK;
	}

}//nsWin32

