//WinQLDeviceClassCollection.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQL/CodeServices/WinQLPolicy.h"
#include "WinQL/Application/Threading/WinQLCriticalSection.h"
#include "WinQL/Application/ErrorSystem/WinQLError.h"
#include "WinQL/CodeServices/Text/WinString.h"
#include "WinQL/System/Devices/SetupClasses/WinQLDeviceClassCollection.h"
#include "WinQL/System/Devices/SetupClasses/WinQLDeviceList.h"
#include "WinQL/System/Devices/SetupClasses/WinQLDeviceSetupClass.h"
#include "WinQL/Definitions/Constants.h"
#include "WinQL/GUI/Window.h"
#include "WinQL/System/WinQLSystem.h"
#include "WinQAPI/Kernel32.h"
#include "WinQAPI/SetupAPI.h"

//--------------------------------------------------------------------------------
namespace nsWin32
{
	using namespace nsWinQAPI;

	//--------------------------------------------------------------------------------
	__QOR_IMPLEMENT_OCLASS_LUID(CDeviceInstanceCM);

	//--------------------------------------------------------------------------------
	CDeviceInstanceCM::CDeviceInstanceCM( const mxTCHAR* szMachineName ) : CTDeviceCollection< nsCodeQOR::mxGUID, nsMammut::CModelItem >( szMachineName )
	{

	}

	//--------------------------------------------------------------------------------
	CDeviceInstanceCM::CDeviceInstanceCM(const CDeviceInstanceCM& src) : CTDeviceCollection< nsCodeQOR::mxGUID, nsMammut::CModelItem >( src )
	{
		*this = src;
	}

	//--------------------------------------------------------------------------------
	CDeviceInstanceCM& CDeviceInstanceCM::operator = (const CDeviceInstanceCM& src)
	{
		CTDeviceCollection< nsCodeQOR::mxGUID, nsMammut::CModelItem >::operator = (src);
		if (&src != this)
		{

		}
		return *this;
	}

	//--------------------------------------------------------------------------------
	CDeviceInstanceCM::~CDeviceInstanceCM()
	{

	}

	//--------------------------------------------------------------------------------
	__QOR_IMPLEMENT_OCLASS_LUID( CDeviceSetupClassCM );

	//--------------------------------------------------------------------------------
	CDeviceSetupClassCM::CDeviceSetupClassCM( unsigned long uFlags, const mxTCHAR* szMachineName ) : CTDeviceCollection< nsCodeQOR::mxGUID, CDeviceSetupClass >( szMachineName )
	{

	}

	//--------------------------------------------------------------------------------
	CDeviceSetupClassCM::CDeviceSetupClassCM( const CDeviceSetupClassCM& src ) :  CTDeviceCollection< nsCodeQOR::mxGUID, CDeviceSetupClass >( src )
	{
	}

	//--------------------------------------------------------------------------------
	CDeviceSetupClassCM& CDeviceSetupClassCM::operator = ( const CDeviceSetupClassCM& src )
	{
		if( &src != this )
		{
			CTDeviceCollection< nsCodeQOR::mxGUID, CDeviceSetupClass >::operator= ( src );
		}
		return *this;
	}

	//--------------------------------------------------------------------------------
	CDeviceSetupClassCM::~CDeviceSetupClassCM()
	{
	}




	//--------------------------------------------------------------------------------
	__QOR_IMPLEMENT_OCLASS_LUID( CDeviceClassCollection );

	//--------------------------------------------------------------------------------
	CDeviceClassCollection::CDeviceClassCollection( unsigned long ulFlags, const mxTCHAR* szMachineName ) : m_Library( CSetupAPI::Instance() )
	,	m_szMachineName( szMachineName )
	{
		_WINQ_FCONTEXT( "CDeviceClassCollection::CDeviceClassCollection" );
		unsigned long ulRequiredSize = 0;
		m_bRemote = ( m_szMachineName == 0 ) ? false : true;

		m_Library.SetupDiBuildClassInfoListEx( 0, 0, 0, &ulRequiredSize, 0, 0 );
		m_ArrayGuids.SetCapacity( ulRequiredSize );
		m_Library.SetupDiBuildClassInfoListEx( ulFlags, reinterpret_cast< ::LPGUID >( m_ArrayGuids.GetAddressOfData() ), ulRequiredSize, &ulRequiredSize, szMachineName, 0 );
		m_ArrayGuids.Validate( ulRequiredSize );
	}

	//--------------------------------------------------------------------------------
	CDeviceClassCollection::CDeviceClassCollection( const CDeviceClassCollection& src ) : m_Library( CSetupAPI::Instance() )
	{
		_WINQ_FCONTEXT( "CDeviceClassCollection::CDeviceClassCollection" );
		*this = src;
	}

	//--------------------------------------------------------------------------------
	CDeviceClassCollection& CDeviceClassCollection::operator = ( const CDeviceClassCollection& src )
	{
		_WINQ_FCONTEXT( "CDeviceClassCollection::operator = " );
		if( &src != this )
		{
			m_ArrayGuids = src.m_ArrayGuids;
		}
		return *this;
	}

	//--------------------------------------------------------------------------------
	CDeviceClassCollection::~CDeviceClassCollection()
	{
		_WINQ_FCONTEXT( "CDeviceClassCollection::~CDeviceClassCollection" );

		for( unsigned int uiDeviceClass = 0; uiDeviceClass < m_MapClasses.Size(); uiDeviceClass++ )
		{
			delete m_MapClasses[ uiDeviceClass].Second();
		}
	}

	//--------------------------------------------------------------------------------
	unsigned long CDeviceClassCollection::Size( void )
	{
		_WINQ_FCONTEXT( "CDeviceClassCollection::Size" );
		return m_ArrayGuids.Size();
	}

	//--------------------------------------------------------------------------------
	bool CDeviceClassCollection::IsRemote( void )
	{
		_WINQ_FCONTEXT( "CDeviceClassCollection::IsRemote" );
		return m_bRemote;
	}

	//--------------------------------------------------------------------------------
	bool CDeviceClassCollection::IsLocal( void )
	{
		_WINQ_FCONTEXT( "CDeviceClassCollection::IsLocal" );
		return !m_bRemote;
	}

	//--------------------------------------------------------------------------------
	void CDeviceClassCollection::RegisterAClass( nsCodeQOR::__mxGUID GUID, CDeviceClass* pDeviceClass )
	{
		m_MapClasses.Insert( GUID, pDeviceClass );
	}

	//--------------------------------------------------------------------------------
	CDeviceClass::refType CDeviceClassCollection::FindClass( nsCodeQOR::__mxGUID GUID )
	{
		CDeviceClass::refType Ref( m_MapClasses.Find( GUID ), false );
		return Ref;
	}

	//--------------------------------------------------------------------------------
	nsCodeQOR::CTLRef< CDeviceClass > CDeviceClassCollection::operator[]( const CTString& strClass )
	{
		_WINQ_FCONTEXT( "CDeviceClassCollection::operator[]" );
		nsCodeQOR::CTLRef< CDeviceClass > RefResult;

		CTString strCmpClassName;
		for( unsigned long ulIndex = 0; ulIndex < m_ArrayGuids.Size(); ulIndex++ )
		{
			unsigned long ulNameLength = 0;
			m_Library.SetupDiClassNameFromGuidEx( reinterpret_cast< const ::GUID* >(&( m_ArrayGuids[ ulIndex ] )), strCmpClassName.GetBufferSetLength( CDeviceClass::MaxNameLength ), CDeviceClass::MaxNameLength, &ulNameLength, m_szMachineName, 0 );
			strCmpClassName.ValidateBuffer( static_cast< unsigned short >( ulNameLength ) );

			if( strClass == strCmpClassName )
			{
				nsCodeQOR::CTLRef< CDeviceClass > Ref = FindClass( m_ArrayGuids[ ulIndex ] );
				RefResult = Ref;
				if( Ref.IsNull() )
				{
					//The DeviceClass must register itself appropriately so we return a non owning reference
					CDeviceClass* pDeviceClass = new CDeviceClass( &( m_ArrayGuids[ ulIndex ] ), m_szMachineName );
					nsCodeQOR::CTLRef< CDeviceClass > NewRef( pDeviceClass, false );					
					RefResult = NewRef;
				}
				break;
			}
		}
		return RefResult;
	}

	//--------------------------------------------------------------------------------
	nsCodeQOR::CTLRef< CDeviceClass > CDeviceClassCollection::operator[]( nsCodeQOR::mxGUID* pGUID )
	{
		_WINQ_FCONTEXT( "CDeviceClassCollection::operator[]" );
		nsCodeQOR::CTLRef< CDeviceClass > RefResult;

		for( unsigned long ulIndex = 0; ulIndex < m_ArrayGuids.Size(); ulIndex++ )
		{
			if( nsCodeQOR::IsEqualmxGUID( *pGUID, m_ArrayGuids[ ulIndex ] ) )
			{
				nsCodeQOR::CTLRef< CDeviceClass > Ref = FindClass( m_ArrayGuids[ ulIndex ] );
				RefResult = Ref;
				if( Ref.IsNull() )
				{
					//The DeviceClass must register itself appropriately so we return a non owning reference
					CDeviceClass* pDeviceClass = new CDeviceClass( pGUID, m_szMachineName );
					nsCodeQOR::CTLRef< CDeviceClass > NewRef( pDeviceClass, false );
					RefResult = NewRef;
				}				
				break;
			}
		}

		return RefResult;
	}

	//--------------------------------------------------------------------------------
	nsCodeQOR::CTLRef< CDeviceClass > CDeviceClassCollection::operator[]( unsigned long ulIndex )
	{
		_WINQ_FCONTEXT( "CDeviceClassCollection::operator[]" );
		nsCodeQOR::CTLRef< CDeviceClass > RefResult;

		if( ulIndex < m_ArrayGuids.Size() )
		{
			nsCodeQOR::CTLRef< CDeviceClass > Ref = FindClass( m_ArrayGuids[ ulIndex ] );
			RefResult = Ref;
			if( Ref.IsNull() )
			{
				//The DeviceClass must register itself appropriately so we return a non owning reference
				CDeviceClass* pDeviceClass = new CDeviceClass( &( m_ArrayGuids[ ulIndex ] ), m_szMachineName );
				nsCodeQOR::CTLRef< CDeviceClass > NewRef( pDeviceClass, false );
				RefResult = NewRef;
			}
		}

		return RefResult;
	}

}//nsWin32
