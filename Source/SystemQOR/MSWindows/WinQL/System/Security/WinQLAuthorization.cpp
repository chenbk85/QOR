//WinQLAuthorization.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQL/Application/ErrorSystem/WinQLError.h"
#include "WinQL/System/Security/WinQLAuthorization.h"
#include "CodeQOR/ErrorSystem/ExpectedHandler.h"
#include "WinQAPI/AdvAPI32.h"

//--------------------------------------------------------------------------------
namespace nsWin32
{
	using namespace ::nsWinQAPI;

	__QOR_IMPLEMENT_OCLASS_LUID( CSIDIdentifierAuthority );

	//--------------------------------------------------------------------------------
	CSIDIdentifierAuthority::CSIDIdentifierAuthority()
	{
		_WINQ_FCONTEXT( "CSIDIdentifierAuthority::CSIDIdentifierAuthority" );
	}

	//--------------------------------------------------------------------------------
	CSIDIdentifierAuthority::~CSIDIdentifierAuthority()
	{
		_WINQ_FCONTEXT( "CSIDIdentifierAuthority::~CSIDIdentifierAuthority" );
	}


	//-- SID

	__QOR_IMPLEMENT_OCLASS_LUID( CSID );

	//--------------------------------------------------------------------------------
    //Copy the source SID. This is not efficient but creates a free standing object rather than a pointer to someone elses memory block
	CSID::CSID( void* pSid ) : m_AdvAPI32Library( CAdvAPI32::Instance() )
	{
		_WINQ_FCONTEXT( "CSID::CSID" );
		m_bFreeSid = false;
		m_bLocalFree = false;
		m_bHeapFree = true;
		DWORD dwSrcLength = m_AdvAPI32Library.GetLengthSid( pSid );
		m_pSID = reinterpret_cast< PSID >( CKernel32::HeapAlloc( CKernel32::GetProcessHeap(), HEAP_ZERO_MEMORY, dwSrcLength ) );
		m_AdvAPI32Library.CopySid( dwSrcLength, m_pSID, pSid );
	}

	//--------------------------------------------------------------------------------
	CSID::CSID( const TCHAR* lpSystemName, const TCHAR* lpAccountName, nsWin32::PSID_NAME_USE peUse ): m_AdvAPI32Library( CAdvAPI32::Instance() )
	{					
		_WINQ_FCONTEXT( "CSID::CSID" );
		DWORD cchReferencedDomainName = 0;					
		m_pSID = 0;
		m_bFreeSid = false;
		m_bLocalFree = false;					
		DWORD dwSizeRequired = 0;	
        __QOR_PROTECT
        {
			{
				nsCodeQOR::CExpectedHandler ExpectError( nsWinQAPI::GENERAL_API_ERROR );
				m_AdvAPI32Library.LookupAccountName( lpSystemName, lpAccountName, 0, &dwSizeRequired, 
					0, &cchReferencedDomainName, reinterpret_cast< ::PSID_NAME_USE >( peUse ) );
			}
			LPTSTR szDomainName = new TCHAR[ cchReferencedDomainName + 1 ];
			szDomainName[ 0 ] = 0;
			m_bHeapFree = true;
			m_pSID = reinterpret_cast< PSID >( CKernel32::HeapAlloc( CKernel32::GetProcessHeap(), HEAP_ZERO_MEMORY, dwSizeRequired ) );
			m_AdvAPI32Library.LookupAccountName( lpSystemName, lpAccountName, m_pSID, &dwSizeRequired, 
				szDomainName, &cchReferencedDomainName, reinterpret_cast< ::PSID_NAME_USE >( peUse ) );					
			delete [] szDomainName;
        }__QOR_ENDPROTECT
	}
			

	//--------------------------------------------------------------------------------
	CSID::CSID( nsWin32::PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, unsigned char nSubAuthorityCount, unsigned long dwSubAuthority0, unsigned long dwSubAuthority1, unsigned long dwSubAuthority2, unsigned long dwSubAuthority3, unsigned long dwSubAuthority4, unsigned long dwSubAuthority5, unsigned long dwSubAuthority6, unsigned long dwSubAuthority7 ): m_AdvAPI32Library( CAdvAPI32::Instance() )
	{
		_WINQ_FCONTEXT( "CSID::CSID" );
		m_pSID = 0;					
		m_bFreeSid = true;
		m_bLocalFree = false;
		m_bHeapFree = false;
		m_AdvAPI32Library.AllocateAndInitializeSid( reinterpret_cast< ::PSID_IDENTIFIER_AUTHORITY >( pIdentifierAuthority ), nSubAuthorityCount, dwSubAuthority0, dwSubAuthority1, dwSubAuthority2, dwSubAuthority3, dwSubAuthority4, dwSubAuthority5, dwSubAuthority6, dwSubAuthority7, &m_pSID );
	}

	//--------------------------------------------------------------------------------
	CSID::CSID( const TCHAR* StrSID ): m_AdvAPI32Library( CAdvAPI32::Instance() )
	{
		_WINQ_FCONTEXT( "CSID::CSID" );
		m_pSID = 0;
		m_bFreeSid = false;
		m_bLocalFree = true;
		m_bHeapFree = false;
		m_AdvAPI32Library.ConvertStringSidToSid( StrSID, &m_pSID );
	}

	//--------------------------------------------------------------------------------
	CSID::CSID( const CSID& Src ): m_AdvAPI32Library( CAdvAPI32::Instance() )
	{
		_WINQ_FCONTEXT( "CSID::CSID" );
		m_bFreeSid = false;
		m_bLocalFree = false;
		m_bHeapFree = true;
		DWORD dwSrcLength = m_AdvAPI32Library.GetLengthSid( Src.m_pSID );
		m_pSID = reinterpret_cast< PSID >( CKernel32::HeapAlloc( CKernel32::GetProcessHeap(), HEAP_ZERO_MEMORY, dwSrcLength ) );
		m_AdvAPI32Library.CopySid( dwSrcLength, m_pSID, Src.m_pSID );
	}

	//--------------------------------------------------------------------------------
	CSID::CSID( nsWin32::WELL_KNOWN_SID_TYPE WellKnownSidType, void* DomainSid ) : m_AdvAPI32Library( CAdvAPI32::Instance() )
	{
		_WINQ_FCONTEXT( "CSID::CSID" );
		m_bFreeSid = false;
		m_bLocalFree = true;
		m_bHeapFree = false;
		DWORD dwSidSize = SECURITY_MAX_SID_SIZE;
		m_pSID = reinterpret_cast< PSID >( CKernel32::LocalAlloc( LMEM_FIXED, dwSidSize ) );
		DWORD dwTrueSize = 0;
		m_AdvAPI32Library.CreateWellKnownSid( static_cast< ::WELL_KNOWN_SID_TYPE >( WellKnownSidType ), DomainSid, m_pSID, &dwTrueSize );
	}
			
	//--------------------------------------------------------------------------------
	CSID& CSID::operator = ( void* pSid )
	{
		_WINQ_FCONTEXT( "CSID::operator =" );
		if( m_bFreeSid )
		{
			m_AdvAPI32Library.FreeSid( m_pSID );
		}
		else if( m_bLocalFree )
		{
			CKernel32::LocalFree( reinterpret_cast< HLOCAL >( m_pSID ) );
		}
		else if( m_bHeapFree )
		{
			CKernel32::HeapFree( CKernel32::GetProcessHeap(), 0, reinterpret_cast< void* >( m_pSID ) );
		}

		m_bFreeSid = false;
		m_bLocalFree = false;
		m_bHeapFree = true;
		DWORD dwSrcLength = m_AdvAPI32Library.GetLengthSid( pSid );
		m_pSID = reinterpret_cast< PSID >( CKernel32::HeapAlloc( CKernel32::GetProcessHeap(), HEAP_ZERO_MEMORY, dwSrcLength ) );
		m_AdvAPI32Library.CopySid( dwSrcLength, m_pSID, pSid );
		return *this;
	}

	//--------------------------------------------------------------------------------
	CSID::~CSID()
	{
		_WINQ_FCONTEXT( "CSID::~CSID" );
		if( m_bFreeSid )
		{
			m_AdvAPI32Library.FreeSid( m_pSID );
		}
		else if( m_bLocalFree )
		{
			CKernel32::LocalFree( reinterpret_cast< HLOCAL >( m_pSID ) );
		}
		else if( m_bHeapFree )
		{
			CKernel32::HeapFree( CKernel32::GetProcessHeap(), 0, reinterpret_cast< void* >( m_pSID ) );
		}
	}

	//--------------------------------------------------------------------------------
	bool CSID::mxConvertSidToStringSid( TCHAR** StringSid ) const
	{
		_WINQ_FCONTEXT( "CSID::ConvertSidToStringSid" );
		bool bResult = false;
        __QOR_PROTECT
        {
			bResult = m_AdvAPI32Library.ConvertSidToStringSid( m_pSID, StringSid ) ? true : false;
        }__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CSID::DomainEqual( CSID& CompareSID )
	{
		_WINQ_FCONTEXT( "CSID::DomainEqual" );
		int Result = 0;
        __QOR_PROTECT
        {
			m_AdvAPI32Library.EqualDomainSid( m_pSID, CompareSID.m_pSID, &Result );
        }__QOR_ENDPROTECT
		return Result ? true : false;
	}

	//--------------------------------------------------------------------------------
	bool CSID::PrefixEqual( CSID& CompareSID )
	{
		_WINQ_FCONTEXT( "CSID::PrefixEqual" );
		bool bResult = false;
        __QOR_PROTECT
        {
			bResult = m_AdvAPI32Library.EqualPrefixSid( m_pSID, CompareSID.m_pSID ) ? true : false;
        }__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CSID::operator == ( CSID& CompareSID )
	{
		_WINQ_FCONTEXT( "CSID::operator == " );
		bool bResult = false;
        __QOR_PROTECT
        {
			bResult = m_AdvAPI32Library.EqualSid( m_pSID, CompareSID.m_pSID ) ? true : false;
        }__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	unsigned long CSID::Length()
	{
		_WINQ_FCONTEXT( "CSID::Length" );
		DWORD dwLength = 0;
        __QOR_PROTECT
        {
			dwLength = m_AdvAPI32Library.GetLengthSid( m_pSID );
        }__QOR_ENDPROTECT
		return dwLength;
	}

	//--------------------------------------------------------------------------------
	CSIDIdentifierAuthority* CSID::GetIdentifierAuthority()
	{
		_WINQ_FCONTEXT( "CSID::GetIdentifierAuthority" );
		CSIDIdentifierAuthority* pResult = 0;
        __QOR_PROTECT
        {
			pResult = reinterpret_cast< CSIDIdentifierAuthority* >( m_AdvAPI32Library.GetSidIdentifierAuthority( m_pSID ) );
        }__QOR_ENDPROTECT
		return pResult;
	}

	//--------------------------------------------------------------------------------
	unsigned long CSID::GetLengthRequired( unsigned char nSubAuthorityCount )
	{
		_WINQ_SFCONTEXT( "CSID::GetLengthRequired" );
		DWORD dwResult = 0;
        __QOR_PROTECT
        {
			CAdvAPI32 AdvAPI32Library;
			dwResult = AdvAPI32Library.GetSidLengthRequired( nSubAuthorityCount );
        }__QOR_ENDPROTECT
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	unsigned long* CSID::GetSubAuthority( unsigned long nSubAuthority )
	{
		_WINQ_FCONTEXT( "CSID::GetSubAuthority" );
		PDWORD pResult = 0;
        __QOR_PROTECT
        {
			pResult = m_AdvAPI32Library.GetSidSubAuthority( m_pSID, nSubAuthority );
        }__QOR_ENDPROTECT
		return pResult;
	}

	//--------------------------------------------------------------------------------
	unsigned char* CSID::GetSubAuthorityCount()
	{
		_WINQ_FCONTEXT( "CSID::GetSubAuthorityCount" );
		PUCHAR Result = 0;
        __QOR_PROTECT
        {
			Result = m_AdvAPI32Library.GetSidSubAuthorityCount( m_pSID );
        }__QOR_ENDPROTECT
		return Result;
	}

	//--------------------------------------------------------------------------------
	bool CSID::IsValid()
	{
		_WINQ_FCONTEXT( "CSID::IsValid" );
		bool bResult = false;
        __QOR_PROTECT
        {
			bResult = m_AdvAPI32Library.IsValidSid( m_pSID ) ? true : false;
        }__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CSID::IsWellKnown( nsWin32::WELL_KNOWN_SID_TYPE WellKnownSidType )
	{
		_WINQ_FCONTEXT( "CSID::IsWellKnown" );
		bool bResult = false;
        __QOR_PROTECT
        {
			bResult = m_AdvAPI32Library.IsWellKnownSid( m_pSID, static_cast< ::WELL_KNOWN_SID_TYPE >( WellKnownSidType ) ) ? true : false;
        }__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CSID::LookupAccount( const TCHAR* lpSystemName, TCHAR* lpName, unsigned long* cchName, TCHAR* lpReferencedDomainName, unsigned long* cchReferencedDomainName, nsWin32::PSID_NAME_USE peUse )
	{
		_WINQ_FCONTEXT( "CSID::LookupAccount" );
		bool bResult = false;
        __QOR_PROTECT
        {
			bResult = m_AdvAPI32Library.LookupAccountSid( lpSystemName, m_pSID, lpName, cchName, lpReferencedDomainName, cchReferencedDomainName, reinterpret_cast< ::PSID_NAME_USE >( peUse ) ) ? true : false;
        }__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	void* CSID::Data() const
	{
		_WINQ_FCONTEXT( "CSID::Data" );
		return m_pSID;
	}

	//protected:

	//--------------------------------------------------------------------------------
	//Default constructor only accesible by derived classes
	CSID::CSID() : m_AdvAPI32Library( CAdvAPI32::Instance() )
	{
		_WINQ_FCONTEXT( "CSID::CSID" );
		m_pSID = 0;
		m_bFreeSid = false;
		m_bLocalFree = false;
		m_bHeapFree = false;
	}

	//--------------------------------------------------------------------------------
	bool CSID::Initialize( CSIDIdentifierAuthority* pIdentifierAuthority, unsigned char nSubAuthorityCount )
	{
		_WINQ_FCONTEXT( "CSID::Initialize" );
		bool bResult = false;
        __QOR_PROTECT
        {
			bResult = m_AdvAPI32Library.InitializeSid( m_pSID, reinterpret_cast< ::PSID_IDENTIFIER_AUTHORITY >( dynamic_cast< nsWin32::PSID_IDENTIFIER_AUTHORITY >( pIdentifierAuthority ) ), nSubAuthorityCount ) ? true : false;
        }__QOR_ENDPROTECT
		return bResult;
	}



	//-- Windows Account Domain SID

	__QOR_IMPLEMENT_OCLASS_LUID( CWindowsAccountDomainSID );

	//--------------------------------------------------------------------------------
	CWindowsAccountDomainSID::CWindowsAccountDomainSID( CSID* pSID ) : CSID()
	{
		_WINQ_FCONTEXT( "CWindowsAccountDomainSID::CWindowsAccountDomainSID" );				
		DWORD dwSize = 0;
		m_AdvAPI32Library.GetWindowsAccountDomainSid( pSID->Data(), &m_pSID, &dwSize );
	}

	//--------------------------------------------------------------------------------
	CWindowsAccountDomainSID::~CWindowsAccountDomainSID()
	{
		_WINQ_FCONTEXT( "CWindowsAccountDomainSID::~CWindowsAccountDomainSID" );
	}

}//nsWin32
