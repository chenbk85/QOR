//WinQLClassicProviderSession.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQL/System/EventLogging/WinQLClassicProviderSession.h"
#include "WinQAPI/AdvAPI32.h"

//--------------------------------------------------------------------------------
namespace nsWin32
{
	using namespace nsWinQAPI;

	//--------------------------------------------------------------------------------
	CClassicEventProviderSession::CClassicEventProviderSession( WMIDPRequest RequestAddress, GUID const* ControlGuid, unsigned long GuidCount, Trace_GUID_Registration* TraceGuidReg, const TCHAR* MofImagePath, const TCHAR* MofResourceName ) : m_AdvAPI32Library( CAdvAPI32::Instance() )
	{
		m_Session = 0;
		m_ulEnableFlags = 0;
		m_ucEnableLevel = 0;
		m_bTrace = false;
		m_ulStatus = m_AdvAPI32Library.RegisterTraceGuids( reinterpret_cast< WMIDPREQUEST >( RequestAddress ), this, reinterpret_cast< LPCGUID >( ControlGuid ), GuidCount, reinterpret_cast< ::PTRACE_GUID_REGISTRATION >( TraceGuidReg ), MofImagePath, MofResourceName, ( &m_Registration ) );
	}

	//--------------------------------------------------------------------------------
	CClassicEventProviderSession::~CClassicEventProviderSession()
	{
		m_AdvAPI32Library.UnregisterTraceGuids( m_Registration );
	}

	//--------------------------------------------------------------------------------
	unsigned long CClassicEventProviderSession::Callback( WMIDPRequestCode RequestCode, void* pRequestContext, unsigned long* pBufferSize, void* pBuffer )
	{
		unsigned long ulResult = 0;
		CClassicEventProviderSession* pSession = reinterpret_cast< CClassicEventProviderSession* >( pRequestContext );
		ulResult = pSession->HandleCallback( RequestCode, pBufferSize, pBuffer );
		return ulResult;
	}

	//--------------------------------------------------------------------------------
	unsigned long CClassicEventProviderSession::EnableEvents( void* pHeader )
    {
		unsigned long ulStatus = (unsigned long)(-1);
		Cmp_unsigned__int64 TempSessionHandle = 0;
		CKernel32::SetLastError( 0 );

        // The session could be enabling the provider or it could be
        // updating the level and enable flags.

        TempSessionHandle = m_AdvAPI32Library.GetTraceLoggerHandle( pHeader );

        if( INVALID_HANDLE_VALUE == (HANDLE)TempSessionHandle )
        {
            //TODO: Raise Error wprintf(L"GetTraceLoggerHandle failed. Error code is %lu.\n", status = GetLastError());
            return ulStatus;
        }

        if( 0 == m_Session )
        {
            m_Session = TempSessionHandle;
        }
        else if( m_Session != TempSessionHandle )
        {
            return ulStatus;
        }

        //Get the severity level of the events that the session wants you to log.

        m_ucEnableLevel = m_AdvAPI32Library.GetTraceEnableLevel( m_Session ); 
        if( 0 == m_ucEnableLevel )
        {
            // If zero, determine whether the session passed zero or an error occurred.
            if( ERROR_SUCCESS == ( ulStatus = CKernel32::GetLastError() ) )
            {
                // Decide what a zero enable level means to your provider.
                // For this example, it means log all events.
                ; 
            }
            else
            {
                //TODO: Raise Error wprintf(L"GetTraceEnableLevel failed with, %lu.\n", status);
                return ulStatus;
            } 
        }

        // Get the enable flags that indicate the events that the
        // session wants you to log. The provider determines the
        // flags values. How it articulates the flag values and 
        // meanings to perspective sessions is up to it.

        m_ulEnableFlags = m_AdvAPI32Library.GetTraceEnableFlags( m_Session );
        if( 0 == m_ulEnableFlags )
        {
            // If zero, determine whether the session passed zero or an error occurred.
            if( ERROR_SUCCESS == ( ulStatus = CKernel32::GetLastError() ) )
            {
                // Decide what a zero enable flags value means to your provider.
                ; 
            }
            else
            {
                //TODO: Raise Error wprintf(L"GetTraceEnableFlags failed with, %lu.\n", status);
                return ulStatus;
            }
        }

        m_bTrace = true;
		ulStatus = 0;
        return ulStatus;
    }
 
	//--------------------------------------------------------------------------------
	unsigned long CClassicEventProviderSession::DisableEvents( void* pHeader )
	{
		unsigned long ulStatus = (unsigned long)(-1);
		// Disable the provider only if the request is coming from the session that enabled the provider.

		Cmp_unsigned__int64 TempSessionHandle = m_AdvAPI32Library.GetTraceLoggerHandle( pHeader );
		if( INVALID_PROCESSTRACE_HANDLE == TempSessionHandle )
		{
			//TODO: Error wprintf(L"GetTraceLoggerHandle failed. Error code is %lu.\n", status = GetLastError());
			return ulStatus;
		}

		if( m_Session == TempSessionHandle )
		{
			m_bTrace = false;
			m_Session = 0;
			ulStatus = 0;
		}
		return ulStatus;
	}

	//--------------------------------------------------------------------------------
	unsigned long CClassicEventProviderSession::HandleCallback( WMIDPRequestCode RequestCode, unsigned long* pBufferSize, void* pBuffer )
	{
		QOR_PP_UNREF( pBufferSize );
		unsigned long ulStatus = ERROR_SUCCESS;

		switch( RequestCode )
		{
		case WMI_Enable_Events:		//Enable the provider
			ulStatus = EnableEvents( pBuffer );
			break;
		case WMI_Disable_Events:	//Disable the provider
			ulStatus = DisableEvents( pBuffer );
			break;
		default:
			ulStatus = ERROR_INVALID_PARAMETER;
			break;
		}
		return ulStatus;
	}

}//nsWin32
