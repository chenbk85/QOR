//MinGWin32Ext.h

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//This file is an internal header included automatically as needed from public headers of WinQAPI. Don't include this directly
//This patch up header brings the MinGW open source Windows headers closer into line with the Microsoft Windows SDK 7 headers
//Adjustments will be needed here if changes are made to or a different version is used of MinGW Windows headers.

#ifndef WINQAPI_MINGW32_H_2
#define WINQAPI_MINGW32_H_2

BOOL __QCMP_STDCALLCONVENTION AddConsoleAliasA( LPSTR Source, LPSTR Target, LPSTR ExeName);
BOOL __QCMP_STDCALLCONVENTION AddConsoleAliasW( LPWSTR Source, LPWSTR Target, LPWSTR ExeName);

#ifdef UNICODE
#define AddConsoleAlias  AddConsoleAliasW
#else
#define AddConsoleAlias  AddConsoleAliasA
#endif // !UNICODE

typedef enum _STREAM_INFO_LEVELS
{
    FindStreamInfoStandard,
    FindStreamInfoMaxInfoLevel
} STREAM_INFO_LEVELS;

typedef struct _RTL_CONDITION_VARIABLE
{
	void* Ptr;
} RTL_CONDITION_VARIABLE, *PRTL_CONDITION_VARIABLE;

typedef RTL_CONDITION_VARIABLE CONDITION_VARIABLE, *PCONDITION_VARIABLE;

#if _WIN32_WINNT >= 0x0600
typedef enum _FILE_ID_TYPE
{
      FileIdType,
      ObjectIdType,
      MaximumFileIdType
} FILE_ID_TYPE, *PFILE_ID_TYPE;


typedef struct FILE_ID_DESCRIPTOR
{
    DWORD dwSize;  // Size of the struct
    FILE_ID_TYPE Type; // Describes the type of identifier passed in.
    union
    {
        LARGE_INTEGER FileId;
        GUID ObjectId;
    } DUMMYUNIONNAME;
} FILE_ID_DESCRIPTOR, *LPFILE_ID_DESCRIPTOR;
#endif

typedef struct _nlsversioninfoex
{
    DWORD dwNLSVersionInfoSize;     // sizeof(NLSVERSIONINFOEX) == 32 bytes
    DWORD dwNLSVersion;
    DWORD dwDefinedVersion;
    DWORD dwEffectiveId;            // Use NLSVERSIONINFO instead
    GUID  guidCustomVersion;
} NLSVERSIONINFOEX, *LPNLSVERSIONINFOEX;

typedef struct _OVERLAPPED_ENTRY
{
    ULONG_PTR lpCompletionKey;
    LPOVERLAPPED lpOverlapped;
    ULONG_PTR Internal;
    DWORD dwNumberOfBytesTransferred;
} OVERLAPPED_ENTRY, *LPOVERLAPPED_ENTRY;

typedef struct _PROC_THREAD_ATTRIBUTE_LIST *PPROC_THREAD_ATTRIBUTE_LIST, *LPPROC_THREAD_ATTRIBUTE_LIST;

#if _WIN32_WINNT >= 0x0600
typedef enum _NORM_FORM {
    NormalizationOther  = 0,       // Not supported
    NormalizationC      = 0x1,     // Each base plus combining characters to the canonical precomposed equivalent.
    NormalizationD      = 0x2,     // Each precomposed character to its canonical decomposed equivalent.
    NormalizationKC     = 0x5,     // Each base plus combining characters to the canonical precomposed
                                   //   equivalents and all compatibility characters to their equivalents.
    NormalizationKD     = 0x6      // Each precomposed character to its canonical decomposed equivalent
                                   //   and all compatibility characters to their equivalents.
} NORM_FORM;
#endif

#ifndef NOGDI
typedef struct _CONSOLE_FONT_INFOEX
{
    ULONG cbSize;
    DWORD nFont;
    COORD dwFontSize;
    UINT FontFamily;
    UINT FontWeight;
    WCHAR FaceName[LF_FACESIZE];
} CONSOLE_FONT_INFOEX, *PCONSOLE_FONT_INFOEX;
#endif

typedef struct _CONSOLE_HISTORY_INFO
{
    UINT cbSize;
    UINT HistoryBufferSize;
    UINT NumberOfHistoryBuffers;
    DWORD dwFlags;
} CONSOLE_HISTORY_INFO, *PCONSOLE_HISTORY_INFO;

BOOL __QCMP_STDCALLCONVENTION GetVolumeInformationByHandleW( HANDLE hFile, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize );

typedef struct _CONSOLE_READCONSOLE_CONTROL
{
    ULONG nLength;
    ULONG nInitialChars;
    ULONG dwCtrlWakeupMask;
    ULONG dwControlKeyState;
} CONSOLE_READCONSOLE_CONTROL, *PCONSOLE_READCONSOLE_CONTROL;
#define WOW64_SIZE_OF_80387_REGISTERS      80

#define WOW64_MAXIMUM_SUPPORTED_EXTENSION     512

typedef struct _WOW64_FLOATING_SAVE_AREA
{
    DWORD   ControlWord;
    DWORD   StatusWord;
    DWORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    BYTE    RegisterArea[WOW64_SIZE_OF_80387_REGISTERS];
    DWORD   Cr0NpxState;
} WOW64_FLOATING_SAVE_AREA;

typedef WOW64_FLOATING_SAVE_AREA *PWOW64_FLOATING_SAVE_AREA;

typedef struct _WOW64_CONTEXT
{

    DWORD ContextFlags;

    DWORD   Dr0;
    DWORD   Dr1;
    DWORD   Dr2;
    DWORD   Dr3;
    DWORD   Dr6;
    DWORD   Dr7;

    WOW64_FLOATING_SAVE_AREA FloatSave;

    DWORD   SegGs;
    DWORD   SegFs;
    DWORD   SegEs;
    DWORD   SegDs;

    DWORD   Edi;
    DWORD   Esi;
    DWORD   Ebx;
    DWORD   Edx;
    DWORD   Ecx;
    DWORD   Eax;

    DWORD   Ebp;
    DWORD   Eip;
    DWORD   SegCs;
    DWORD   EFlags;
    DWORD   Esp;
    DWORD   SegSs;

    BYTE    ExtendedRegisters[WOW64_MAXIMUM_SUPPORTED_EXTENSION];

} WOW64_CONTEXT;

typedef WOW64_CONTEXT *PWOW64_CONTEXT;

BOOL __QCMP_STDCALLCONVENTION EnumResourceLanguagesExA(
    HMODULE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    ENUMRESLANGPROCA lpEnumFunc,
    LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );

BOOL __QCMP_STDCALLCONVENTION EnumResourceLanguagesExW(
    HMODULE hModule,
    LPCWSTR lpType,
    LPCWSTR lpName,
    ENUMRESLANGPROCW lpEnumFunc,
    LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );

#ifdef UNICODE
#define EnumResourceLanguagesEx  EnumResourceLanguagesExW
#else
#define EnumResourceLanguagesEx  EnumResourceLanguagesExA
#endif // !UNICODE

typedef long HRESULT;

typedef VOID ( WINAPI *PFIBER_START_ROUTINE)( void* lpFiberParameter );
typedef PFIBER_START_ROUTINE LPFIBER_START_ROUTINE;

WORD NTAPI RtlCaptureStackBackTrace(
    DWORD FramesToSkip,
    DWORD FramesToCapture,
    void** BackTrace,
    PDWORD BackTraceHash
   );

#define CaptureStackBackTrace RtlCaptureStackBackTrace

typedef DWORD ( WINAPI *LPTHREAD_START_ROUTINE )( void* lpThreadParameter);

BOOL WINAPI BindIoCompletionCallback (
    HANDLE FileHandle,
    LPOVERLAPPED_COMPLETION_ROUTINE Function,
    ULONG Flags
    );

typedef struct _CONSOLE_SCREEN_BUFFER_INFOEX
{
    ULONG cbSize;
    COORD dwSize;
    COORD dwCursorPosition;
    WORD wAttributes;
    SMALL_RECT srWindow;
    COORD dwMaximumWindowSize;
    WORD wPopupAttributes;
    BOOL bFullscreenSupported;
    COLORREF ColorTable[16];
} CONSOLE_SCREEN_BUFFER_INFOEX, *PCONSOLE_SCREEN_BUFFER_INFOEX;

BOOL WINAPI QueryActCtxSettingsW(
	DWORD dwFlags,
	HANDLE hActCtx,
	PCWSTR settingsNameSpace,
	PCWSTR settingName,
	PWSTR pvBuffer,
	SIZE_T dwBuffer,
	SIZE_T *pdwWrittenOrRequired
	);

typedef struct _CONSOLE_SELECTION_INFO
{
    DWORD dwFlags;
    COORD dwSelectionAnchor;
    SMALL_RECT srSelection;
} CONSOLE_SELECTION_INFO, *PCONSOLE_SELECTION_INFO;

typedef struct _TIME_DYNAMIC_ZONE_INFORMATION
{
    LONG Bias;
    WCHAR StandardName[ 32 ];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
    WCHAR TimeZoneKeyName[ 128 ];
    BOOLEAN DynamicDaylightTimeDisabled;
} DYNAMIC_TIME_ZONE_INFORMATION, *PDYNAMIC_TIME_ZONE_INFORMATION;

typedef struct _RTL_SRWLOCK {
        PVOID Ptr;
} RTL_SRWLOCK, *PRTL_SRWLOCK;
#define RTL_SRWLOCK_INIT {0}
#define RTL_CONDITION_VARIABLE_INIT {0}
#define RTL_CONDITION_VARIABLE_LOCKMODE_SHARED  0x1

typedef RTL_SRWLOCK SRWLOCK, *PSRWLOCK;

#define SRWLOCK_INIT RTL_SRWLOCK_INIT

#if _WIN32_WINNT >= 0x0600
typedef union _RTL_RUN_ONCE
{
    PVOID Ptr;
} RTL_RUN_ONCE, *PRTL_RUN_ONCE;

typedef RTL_RUN_ONCE INIT_ONCE;
typedef PRTL_RUN_ONCE PINIT_ONCE;
typedef PRTL_RUN_ONCE LPINIT_ONCE;

typedef BOOL (WINAPI *PINIT_ONCE_FN) ( PINIT_ONCE InitOnce, PVOID Parameter, PVOID *Context );
#endif

typedef BOOLEAN ( NTAPI *PSECURE_MEMORY_CACHE_CALLBACK ) ( PVOID Addr, SIZE_T Range );
typedef BOOL ( CALLBACK* CALINFO_ENUMPROCEXEX )( LPWSTR, CALID, LPWSTR, LPARAM );
typedef BOOL ( CALLBACK* DATEFMT_ENUMPROCEXEX )( LPWSTR, CALID, LPARAM );
typedef BOOL ( CALLBACK* LOCALE_ENUMPROCEX )( LPWSTR, DWORD, LPARAM );
typedef DWORD ( WINAPI *APPLICATION_RECOVERY_CALLBACK )( PVOID pvParameter );

typedef struct _TP_CALLBACK_INSTANCE TP_CALLBACK_INSTANCE, *PTP_CALLBACK_INSTANCE;
typedef struct _TP_IO TP_IO, *PTP_IO;
typedef struct _TP_POOL TP_POOL, *PTP_POOL;
typedef struct _TP_CLEANUP_GROUP TP_CLEANUP_GROUP, *PTP_CLEANUP_GROUP;
typedef struct _TP_TIMER TP_TIMER, *PTP_TIMER;
typedef struct _TP_WAIT TP_WAIT, *PTP_WAIT;
typedef struct _TP_WORK TP_WORK, *PTP_WORK;

typedef VOID (WINAPI *PTP_WIN32_IO_CALLBACK)( PTP_CALLBACK_INSTANCE Instance, PVOID Context, PVOID Overlapped, ULONG IoResult, ULONG_PTR NumberOfBytesTransferred, PTP_IO Io );
typedef DWORD TP_VERSION, *PTP_VERSION;
typedef VOID ( NTAPI *PTP_CLEANUP_GROUP_CANCEL_CALLBACK)( PVOID ObjectContext, PVOID CleanupContext );
typedef VOID (NTAPI *PTP_SIMPLE_CALLBACK)( PTP_CALLBACK_INSTANCE Instance, PVOID Context );

typedef enum _TP_CALLBACK_PRIORITY
{
    TP_CALLBACK_PRIORITY_HIGH,
    TP_CALLBACK_PRIORITY_NORMAL,
    TP_CALLBACK_PRIORITY_LOW,
    TP_CALLBACK_PRIORITY_INVALID
} TP_CALLBACK_PRIORITY;


#if		(_WIN32_WINNT >= _WIN32_WINNT_WIN7 )

typedef struct _TP_CALLBACK_ENVIRON_V3
{
    TP_VERSION                         Version;
    PTP_POOL                           Pool;
    PTP_CLEANUP_GROUP                  CleanupGroup;
    PTP_CLEANUP_GROUP_CANCEL_CALLBACK  CleanupGroupCancelCallback;
    PVOID                              RaceDll;
    struct _ACTIVATION_CONTEXT        *ActivationContext;
    PTP_SIMPLE_CALLBACK                FinalizationCallback;
    union {
        DWORD                          Flags;
        struct {
            DWORD                      LongFunction :  1;
            DWORD                      Persistent   :  1;
            DWORD                      Private      : 30;
        } s;
    } u;
    TP_CALLBACK_PRIORITY               CallbackPriority;
    DWORD                              Size;
} TP_CALLBACK_ENVIRON_V3;

typedef TP_CALLBACK_ENVIRON_V3 TP_CALLBACK_ENVIRON, *PTP_CALLBACK_ENVIRON;

#else

typedef struct _TP_CALLBACK_ENVIRON_V1 {
    TP_VERSION                         Version;
    PTP_POOL                           Pool;
    PTP_CLEANUP_GROUP                  CleanupGroup;
    PTP_CLEANUP_GROUP_CANCEL_CALLBACK  CleanupGroupCancelCallback;
    PVOID                              RaceDll;
    struct _ACTIVATION_CONTEXT        *ActivationContext;
    PTP_SIMPLE_CALLBACK                FinalizationCallback;
    union {
        DWORD                          Flags;
        struct {
            DWORD                      LongFunction :  1;
            DWORD                      Persistent   :  1;
            DWORD                      Private      : 30;
        } s;
    } u;
} TP_CALLBACK_ENVIRON_V1;

typedef TP_CALLBACK_ENVIRON_V1 TP_CALLBACK_ENVIRON, *PTP_CALLBACK_ENVIRON;

#endif

typedef VOID (NTAPI *PTP_TIMER_CALLBACK)( PTP_CALLBACK_INSTANCE Instance, PVOID Context, PTP_TIMER Timer );

typedef DWORD    TP_WAIT_RESULT;
typedef VOID (NTAPI *PTP_WAIT_CALLBACK)( PTP_CALLBACK_INSTANCE Instance, PVOID Context, PTP_WAIT Wait, TP_WAIT_RESULT WaitResult );
typedef VOID (NTAPI *PTP_WORK_CALLBACK)( PTP_CALLBACK_INSTANCE Instance, PVOID Context, PTP_WORK Work );
typedef VOID (NTAPI *PFLS_CALLBACK_FUNCTION) ( PVOID lpFlsData );

typedef enum _LOGICAL_PROCESSOR_RELATIONSHIP
{
    RelationProcessorCore,
    RelationNumaNode,
    RelationCache,
    RelationProcessorPackage,
    RelationGroup,
    RelationAll = 0xffff
} LOGICAL_PROCESSOR_RELATIONSHIP;

typedef enum _PROCESSOR_CACHE_TYPE
{
    CacheUnified,
    CacheInstruction,
    CacheData,
    CacheTrace
} PROCESSOR_CACHE_TYPE;

typedef struct _CACHE_DESCRIPTOR
{
    BYTE   Level;
    BYTE   Associativity;
    WORD   LineSize;
    DWORD  Size;
    PROCESSOR_CACHE_TYPE Type;
} CACHE_DESCRIPTOR, *PCACHE_DESCRIPTOR;

typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION
{
    ULONG_PTR   ProcessorMask;
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    union {
        struct {
            BYTE  Flags;
        } ProcessorCore;
        struct {
            DWORD NodeNumber;
        } NumaNode;
        CACHE_DESCRIPTOR Cache;
        ULONGLONG  Reserved[2];
    } DUMMYUNIONNAME;
} SYSTEM_LOGICAL_PROCESSOR_INFORMATION, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION;

typedef struct _FILEMUIINFO
{
    DWORD       dwSize;                 // Size of the structure including buffer size [in]
    DWORD       dwVersion;              // Version of the structure [in]
    DWORD       dwFileType;             // Type of the file [out]
    BYTE        pChecksum[16];          // Checksum of the file [out]
    BYTE        pServiceChecksum[16];   // Checksum of the file [out]
    DWORD       dwLanguageNameOffset;   // Language name of the file [out]
    DWORD       dwTypeIDMainSize;       // Number of TypeIDs in main module [out]
    DWORD       dwTypeIDMainOffset;     // Array of TypeIDs (DWORD) in main module [out]
    DWORD       dwTypeNameMainOffset;   // Multistring array of TypeNames in main module [out]
    DWORD       dwTypeIDMUISize;        // Number of TypeIDs in MUI module [out]
    DWORD       dwTypeIDMUIOffset;      // Array of TypeIDs (DWORD) in MUI module [out]
    DWORD       dwTypeNameMUIOffset;    // Multistring array of TypeNames in MUI module [out]
    BYTE        abBuffer[8];             // Buffer for extra data [in] (Size 4 is for padding)
} FILEMUIINFO, *PFILEMUIINFO;

#if _WIN32_WINNT >= 0x0600
typedef enum _WER_REGISTER_FILE_TYPE
{
    WerRegFileTypeUserDocument = 1,
    WerRegFileTypeOther = 2,
    WerRegFileTypeMax
} WER_REGISTER_FILE_TYPE;
#endif

typedef WCHAR *PZZWSTR;
typedef CONST WCHAR *PCZZWSTR;
typedef WCHAR UNALIGNED *PUZZWSTR;
typedef CONST WCHAR UNALIGNED *PCUZZWSTR;

#define GEOID_NOT_AVAILABLE -1

typedef BOOL (CALLBACK* TIMEFMT_ENUMPROCEX)(LPWSTR, LPARAM);

#if (NTDDI_VERSION >= NTDDI_WIN2K)
__QCMP_IMPORT SIZE_T NTAPI RtlCompareMemory ( const VOID *Source1, const VOID *Source2, SIZE_T Length );
#endif

WINBASEAPI BOOL WINAPI CallbackMayRunLong( PTP_CALLBACK_INSTANCE pci );
WINBASEAPI BOOL WINAPI RequestWakeupLatency( LATENCY_TIME latency );
WINBASEAPI BOOL WINAPI SetMessageWaitingIndicator( HANDLE hMsgIndicator, ULONG ulMsgCount );
WINBASEAPI int WINAPI CompareStringEx( LPCWSTR lpLocaleName, DWORD dwCmpFlags, LPCWSTR lpString1, int cchCount1, LPCWSTR lpString2, int cchCount2, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM lParam );

WINBASEAPI DWORD WINAPI WTSGetActiveConsoleSessionId( VOID );
WINBASEAPI BOOL WINAPI CancelIoEx( HANDLE hFile, LPOVERLAPPED lpOverlapped );
WINBASEAPI BOOL WINAPI CancelSynchronousIo( HANDLE hThread );

WINBASEAPI BOOL WINAPI CopyFileTransactedA( LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction );
WINBASEAPI BOOL WINAPI CopyFileTransactedW( LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction );

#ifdef UNICODE
#	define CopyFileTransacted  CopyFileTransactedW
#else
#	define CopyFileTransacted  CopyFileTransactedA
#endif // !UNICODE

WINBASEAPI HANDLE WINAPI CreateFileTransactedA( LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, PVOID lpExtendedParameter );
WINBASEAPI HANDLE WINAPI CreateFileTransactedW( LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, PVOID  lpExtendedParameter );
#ifdef UNICODE
#define CreateFileTransacted  CreateFileTransactedW
#else
#define CreateFileTransacted  CreateFileTransactedA
#endif // !UNICODE

WINBASEAPI BOOL WINAPI CreateHardLinkTransactedA( LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction );
WINBASEAPI BOOL WINAPI CreateHardLinkTransactedW( LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction );
#ifdef UNICODE
#define CreateHardLinkTransacted  CreateHardLinkTransactedW
#else
#define CreateHardLinkTransacted  CreateHardLinkTransactedA
#endif // !UNICODE

WINBASEAPI BOOLEAN APIENTRY CreateSymbolicLinkTransactedA( LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction );
WINBASEAPI BOOLEAN APIENTRY CreateSymbolicLinkTransactedW( LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction );
#ifdef UNICODE
#define CreateSymbolicLinkTransacted  CreateSymbolicLinkTransactedW
#else
#define CreateSymbolicLinkTransacted  CreateSymbolicLinkTransactedA
#endif // !UNICODE

WINBASEAPI BOOL WINAPI DeleteFileTransactedA( LPCSTR lpFileName, HANDLE hTransaction );
WINBASEAPI BOOL WINAPI DeleteFileTransactedW( LPCWSTR lpFileName, HANDLE hTransaction );
#ifdef UNICODE
#define DeleteFileTransacted  DeleteFileTransactedW
#else
#define DeleteFileTransacted  DeleteFileTransactedA
#endif // !UNICODE

WINBASEAPI HANDLE WINAPI FindFirstFileNameTransactedW( LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWCHAR LinkName, HANDLE hTransaction );
WINBASEAPI HANDLE WINAPI FindFirstFileNameW( LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWCHAR LinkName );

WINBASEAPI HANDLE WINAPI FindFirstFileTransactedA( LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, HANDLE hTransaction );
WINBASEAPI HANDLE WINAPI FindFirstFileTransactedW( LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, HANDLE hTransaction );
#ifdef UNICODE
#define FindFirstFileTransacted  FindFirstFileTransactedW
#else
#define FindFirstFileTransacted  FindFirstFileTransactedA
#endif // !UNICODE

WINBASEAPI DWORD APIENTRY GetConsoleAliasA( LPSTR Source, LPSTR TargetBuffer, DWORD TargetBufferLength, LPSTR ExeName );
WINBASEAPI DWORD APIENTRY GetConsoleAliasW( LPWSTR Source, LPWSTR TargetBuffer, DWORD TargetBufferLength, LPWSTR ExeName );
#ifdef UNICODE
#define GetConsoleAlias  GetConsoleAliasW
#else
#define GetConsoleAlias  GetConsoleAliasA
#endif // !UNICODE

WINBASEAPI DWORD APIENTRY GetConsoleAliasesA( LPSTR AliasBuffer, DWORD AliasBufferLength, LPSTR ExeName );
WINBASEAPI DWORD APIENTRY GetConsoleAliasesW( LPWSTR AliasBuffer, DWORD AliasBufferLength, LPWSTR ExeName );
#ifdef UNICODE
#define GetConsoleAliases  GetConsoleAliasesW
#else
#define GetConsoleAliases  GetConsoleAliasesA
#endif // !UNICODE

WINBASEAPI BOOL WINAPI GetNamedPipeClientComputerNameA( HANDLE Pipe, LPSTR ClientComputerName, ULONG ClientComputerNameLength );
WINBASEAPI BOOL WINAPI GetNamedPipeClientComputerNameW( HANDLE Pipe, LPWSTR ClientComputerName, ULONG ClientComputerNameLength );
#ifdef UNICODE
#define GetNamedPipeClientComputerName  GetNamedPipeClientComputerNameW
#else
#define GetNamedPipeClientComputerName  GetNamedPipeClientComputerNameA
#endif // !UNICODE

WINBASEAPI BOOL WINAPI GetNamedPipeClientProcessId( HANDLE Pipe, PULONG ClientProcessId );
WINBASEAPI BOOL WINAPI GetNamedPipeServerProcessId( HANDLE Pipe, PULONG ServerProcessId );
WINBASEAPI BOOL WINAPI GetNamedPipeServerSessionId( HANDLE Pipe, PULONG ServerSessionId );
WINBASEAPI VOID WINAPI CancelThreadpoolIo( PTP_IO pio );
WINBASEAPI VOID WINAPI CloseThreadpool( PTP_POOL ptpp );
WINBASEAPI VOID WINAPI CloseThreadpoolCleanupGroup( PTP_CLEANUP_GROUP ptpcg );
WINBASEAPI VOID WINAPI CloseThreadpoolCleanupGroupMembers( PTP_CLEANUP_GROUP ptpcg, BOOL fCancelPendingCallbacks, PVOID pvCleanupContext );
WINBASEAPI VOID WINAPI CloseThreadpoolIo( PTP_IO pio );
WINBASEAPI VOID WINAPI CloseThreadpoolTimer( PTP_TIMER pti );
WINBASEAPI VOID WINAPI CloseThreadpoolWait( PTP_WAIT pwa );

WINBASEAPI BOOL WINAPI RemoveDirectoryTransactedA( LPCSTR lpPathName, HANDLE hTransaction );
WINBASEAPI BOOL WINAPI RemoveDirectoryTransactedW( LPCWSTR lpPathName, HANDLE hTransaction );
#ifdef UNICODE
#define RemoveDirectoryTransacted  RemoveDirectoryTransactedW
#else
#define RemoveDirectoryTransacted  RemoveDirectoryTransactedA
#endif // !UNICODE

WINBASEAPI BOOL WINAPI CreateDirectoryTransactedA( LPCSTR lpTemplateDirectory, LPCSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction );
WINBASEAPI BOOL WINAPI CreateDirectoryTransactedW( LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction );
#ifdef UNICODE
#define CreateDirectoryTransacted  CreateDirectoryTransactedW
#else
#define CreateDirectoryTransacted  CreateDirectoryTransactedA
#endif // !UNICODE

WINBASEAPI VOID WINAPI CloseThreadpoolWork( PTP_WORK pwk );
WINBASEAPI LPVOID WINAPI ConvertThreadToFiberEx( LPVOID lpParameter, DWORD dwFlags );
WINBASEAPI PTP_POOL WINAPI CreateThreadpool( PVOID reserved );
WINBASEAPI PTP_CLEANUP_GROUP WINAPI CreateThreadpoolCleanupGroup( VOID );
WINBASEAPI PTP_IO WINAPI CreateThreadpoolIo( HANDLE fl, PTP_WIN32_IO_CALLBACK pfnio, PVOID pv, PTP_CALLBACK_ENVIRON pcbe );
WINBASEAPI PTP_TIMER WINAPI CreateThreadpoolTimer( PTP_TIMER_CALLBACK pfnti, PVOID pv, PTP_CALLBACK_ENVIRON pcbe );
WINBASEAPI PTP_WAIT WINAPI CreateThreadpoolWait( PTP_WAIT_CALLBACK pfnwa, PVOID pv, PTP_CALLBACK_ENVIRON pcbe );
WINBASEAPI PTP_WORK WINAPI CreateThreadpoolWork( PTP_WORK_CALLBACK pfnwk, PVOID pv, PTP_CALLBACK_ENVIRON pcbe );

WINBASEAPI VOID WINAPI DeleteProcThreadAttributeList( LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList );
WINBASEAPI VOID WINAPI DisassociateCurrentThreadFromCallback( PTP_CALLBACK_INSTANCE pci );

WINBASEAPI BOOL WINAPI GetNamedPipeClientSessionId( HANDLE Pipe, PULONG ClientSessionId );


WINBASEAPI VOID WINAPI WakeConditionVariable( PCONDITION_VARIABLE ConditionVariable );
WINBASEAPI VOID WINAPI WakeAllConditionVariable( PCONDITION_VARIABLE ConditionVariable );
WINBASEAPI BOOL WINAPI SleepConditionVariableSRW( PCONDITION_VARIABLE ConditionVariable, PSRWLOCK SRWLock, DWORD dwMilliseconds, ULONG Flags );
WINBASEAPI BOOL WINAPI SleepConditionVariableCS( PCONDITION_VARIABLE ConditionVariable, PCRITICAL_SECTION CriticalSection, DWORD dwMilliseconds );

WINBASEAPI DWORD WINAPI Wow64SuspendThread( HANDLE hThread );
WINBASEAPI VOID WINAPI WaitForThreadpoolWorkCallbacks( PTP_WORK pwk, BOOL fCancelPendingCallbacks );
WINBASEAPI VOID WINAPI WaitForThreadpoolWaitCallbacks( PTP_WAIT pwa, BOOL fCancelPendingCallbacks );

WINBASEAPI BOOL WINAPI EnumResourceNamesExA( HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId );
WINBASEAPI BOOL WINAPI EnumResourceNamesExW( HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId );
#ifdef UNICODE
#define EnumResourceNamesEx  EnumResourceNamesExW
#else
#define EnumResourceNamesEx  EnumResourceNamesExA
#endif // !UNICODE

WINBASEAPI BOOL WINAPI EnumResourceTypesExA( HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId );
WINBASEAPI BOOL WINAPI EnumResourceTypesExW( HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId );
#ifdef UNICODE
#define EnumResourceTypesEx  EnumResourceTypesExW
#else
#define EnumResourceTypesEx  EnumResourceTypesExA
#endif // !UNICODE

WINBASEAPI BOOL WINAPI GetFileMUIPath( DWORD dwFlags, PCWSTR pcwszFilePath, PWSTR pwszLanguage, PULONG pcchLanguage, PWSTR pwszFileMUIPath, PULONG pcchFileMUIPath, PULONGLONG pululEnumerator );

WINBASEAPI VOID WINAPI AcquireSRWLockExclusive( PSRWLOCK SRWLock );
WINBASEAPI PVOID WINAPI AddVectoredContinueHandler( ULONG First, PVECTORED_EXCEPTION_HANDLER Handler );
WINBASEAPI ULONG WINAPI RemoveVectoredContinueHandler( PVOID Handle );

__QCMP_IMPORT VOID NTAPI RtlCaptureContext( PCONTEXT ContextRecord );
//WINBASEAPI UINT WINAPI EnumSystemFirmwareTables( DWORD FirmwareTableProviderSignature, PVOID pFirmwareTableEnumBuffer, DWORD BufferSize );


WINBASEAPI DWORD WINAPI GetFirmwareEnvironmentVariableA( LPCSTR lpName, LPCSTR lpGuid, PVOID pBuffer, DWORD nSize );
WINBASEAPI DWORD WINAPI GetFirmwareEnvironmentVariableW( LPCWSTR lpName, LPCWSTR lpGuid, PVOID pBuffer, DWORD nSize );
#ifdef UNICODE
#define GetFirmwareEnvironmentVariable  GetFirmwareEnvironmentVariableW
#else
#define GetFirmwareEnvironmentVariable  GetFirmwareEnvironmentVariableA
#endif // !UNICODE

WINBASEAPI BOOL WINAPI GetProductInfo( DWORD dwOSMajorVersion, DWORD dwOSMinorVersion, DWORD dwSpMajorVersion, DWORD dwSpMinorVersion, PDWORD pdwReturnedProductType );
WINBASEAPI UINT WINAPI GetSystemFirmwareTable( DWORD FirmwareTableProviderSignature, DWORD FirmwareTableID, PVOID pFirmwareTableBuffer, DWORD BufferSize );

WINBASEAPI BOOL WINAPI SetComputerNameExA( COMPUTER_NAME_FORMAT NameType, LPCSTR lpBuffer );
WINBASEAPI BOOL WINAPI SetComputerNameExW( COMPUTER_NAME_FORMAT NameType, LPCWSTR lpBuffer );
#ifdef UNICODE
#define SetComputerNameEx  SetComputerNameExW
#else
#define SetComputerNameEx  SetComputerNameExA
#endif // !UNICODE

WINBASEAPI UINT WINAPI GetErrorMode( VOID );

__QCMP_IMPORT VOID NTAPI RtlUnwind( PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue );

#if _WIN32_WINNT >= 0x0600
//WER API
HRESULT WINAPI WerGetFlags( HANDLE hProcess, PDWORD pdwFlags );
HRESULT WINAPI WerRegisterFile( PCWSTR pwzFile, WER_REGISTER_FILE_TYPE regFileType, DWORD dwFlags );
HRESULT WINAPI WerRegisterMemoryBlock( PVOID pvAddress, DWORD dwSize );
HRESULT WINAPI WerSetFlags( DWORD dwFlags );
HRESULT WINAPI WerUnregisterFile( PCWSTR pwzFilePath );
HRESULT WINAPI WerUnregisterMemoryBlock( PVOID pvAddress );


WINBASEAPI HANDLE WINAPI FindFirstStreamTransactedW( LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags, HANDLE hTransaction );
#endif // _WIN32_WINNT >= 0x600

WINBASEAPI HANDLE WINAPI FindFirstStreamW( LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags );
WINBASEAPI BOOL APIENTRY FindNextFileNameW( HANDLE hFindStream, LPDWORD StringLength, PWCHAR LinkName );

#if (_WIN32_WINNT >= 0x0501)
WINBASEAPI BOOL APIENTRY FindNextStreamW( HANDLE hFindStream, LPVOID lpFindStreamData );
#endif // (_WIN32_WINNT >= 0x0501)

#if _WIN32_WINNT >= 0x0600

WINBASEAPI DWORD WINAPI GetCompressedFileSizeTransactedA( LPCSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction );
WINBASEAPI DWORD WINAPI GetCompressedFileSizeTransactedW( LPCWSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction );
#ifdef UNICODE
#define GetCompressedFileSizeTransacted  GetCompressedFileSizeTransactedW
#else
#define GetCompressedFileSizeTransacted  GetCompressedFileSizeTransactedA
#endif // !UNICODE

#endif // _WIN32_WINNT >= 0x0600


#if _WIN32_WINNT >= 0x0600

WINBASEAPI BOOL WINAPI GetFileAttributesTransactedA( LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction );
WINBASEAPI BOOL WINAPI GetFileAttributesTransactedW( LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction );
#ifdef UNICODE
#define GetFileAttributesTransacted  GetFileAttributesTransactedW
#else
#define GetFileAttributesTransacted  GetFileAttributesTransactedA
#endif // !UNICODE

#endif // _WIN32_WINNT >= 0x0600

WINBASEAPI BOOL WINAPI GetFileBandwidthReservation( HANDLE hFile, LPDWORD lpPeriodMilliseconds, LPDWORD lpBytesPerPeriod, LPBOOL pDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests );


#if _WIN32_WINNT >= 0x0600

WINBASEAPI DWORD WINAPI GetFullPathNameTransactedA( LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR* lpFilePart, HANDLE hTransaction );
WINBASEAPI DWORD WINAPI GetFullPathNameTransactedW( LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart, HANDLE hTransaction );
#ifdef UNICODE
#define GetFullPathNameTransacted  GetFullPathNameTransactedW
#else
#define GetFullPathNameTransacted  GetFullPathNameTransactedA
#endif // !UNICODE

#endif // _WIN32_WINNT >= 0x0600


#if _WIN32_WINNT >= 0x0600

WINBASEAPI DWORD WINAPI GetLongPathNameTransactedA( LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction );
WINBASEAPI DWORD WINAPI GetLongPathNameTransactedW( LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction );
#ifdef UNICODE
#define GetLongPathNameTransacted  GetLongPathNameTransactedW
#else
#define GetLongPathNameTransacted  GetLongPathNameTransactedA
#endif // !UNICODE

#endif // _WIN32_WINNT >= 0x0600


#if (_WIN32_WINNT >= 0x0600)

WINBASEAPI BOOL WINAPI GetQueuedCompletionStatusEx( HANDLE CompletionPort, LPOVERLAPPED_ENTRY lpCompletionPortEntries, ULONG ulCount, PULONG ulNumEntriesRemoved, DWORD dwMilliseconds, BOOL fAlertable );

#endif // _WIN32_WINNT >= 0x0600

#if (_WIN32_WINNT >= 0x0600)
WINBASEAPI BOOL WINAPI MoveFileTransactedA( LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction );
WINBASEAPI BOOL WINAPI MoveFileTransactedW( LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction );
#ifdef UNICODE
#define MoveFileTransacted  MoveFileTransactedW
#else
#define MoveFileTransacted  MoveFileTransactedA
#endif // !UNICODE
#endif // (_WIN32_WINNT >= 0x0600)

#if (_WIN32_WINNT >= 0x0600)
WINBASEAPI HANDLE WINAPI OpenFileById( HANDLE hVolumeHint, LPFILE_ID_DESCRIPTOR lpFileId, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwFlagsAndAttributes );
#endif

#if _WIN32_WINNT >= 0x0600

WINBASEAPI BOOL WINAPI SetFileAttributesTransactedA( LPCSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction );
WINBASEAPI BOOL WINAPI SetFileAttributesTransactedW( LPCWSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction );
#ifdef UNICODE
#define SetFileAttributesTransacted  SetFileAttributesTransactedW
#else
#define SetFileAttributesTransacted  SetFileAttributesTransactedA
#endif // !UNICODE

#endif // _WIN32_WINNT >= 0x0600

WINBASEAPI BOOL WINAPI SetFileBandwidthReservation( HANDLE hFile, DWORD nPeriodMilliseconds, DWORD nBytesPerPeriod, BOOL bDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests );
WINBASEAPI BOOL WINAPI SetFileCompletionNotificationModes( HANDLE FileHandle, UCHAR Flags );


WINBASEAPI DWORD APIENTRY GetConsoleAliasesLengthA( LPSTR ExeName );
WINBASEAPI DWORD APIENTRY GetConsoleAliasesLengthW( LPWSTR ExeName );
#ifdef UNICODE
#define GetConsoleAliasesLength  GetConsoleAliasesLengthW
#else
#define GetConsoleAliasesLength  GetConsoleAliasesLengthA
#endif // !UNICODE

WINBASEAPI DWORD APIENTRY GetConsoleAliasExesA( LPSTR ExeNameBuffer, DWORD ExeNameBufferLength );
WINBASEAPI DWORD APIENTRY GetConsoleAliasExesW( LPWSTR ExeNameBuffer, DWORD ExeNameBufferLength );
#ifdef UNICODE
#define GetConsoleAliasExes  GetConsoleAliasExesW
#else
#define GetConsoleAliasExes  GetConsoleAliasExesA
#endif // !UNICODE

WINBASEAPI DWORD APIENTRY GetConsoleAliasExesLengthA( VOID );
WINBASEAPI DWORD APIENTRY GetConsoleAliasExesLengthW( VOID );
#ifdef UNICODE
#define GetConsoleAliasExesLength  GetConsoleAliasExesLengthW
#else
#define GetConsoleAliasExesLength  GetConsoleAliasExesLengthA
#endif // !UNICODE

WINBASEAPI COORD WINAPI GetConsoleFontSize( HANDLE hConsoleOutput, DWORD nFont );
WINBASEAPI BOOL WINAPI GetConsoleHistoryInfo( PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo );

#if(_WIN32_WINNT >= 0x0600)
WINBASEAPI DWORD WINAPI GetConsoleOriginalTitleA( LPSTR lpConsoleTitle, DWORD nSize );
WINBASEAPI DWORD WINAPI GetConsoleOriginalTitleW( LPWSTR lpConsoleTitle, DWORD nSize );
#ifdef UNICODE
#define GetConsoleOriginalTitle  GetConsoleOriginalTitleW
#else
#define GetConsoleOriginalTitle  GetConsoleOriginalTitleA
#endif // !UNICODE
#endif /* _WIN32_WINNT >= 0x0600 */

WINBASEAPI BOOL WINAPI GetConsoleScreenBufferInfoEx( HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx );
WINBASEAPI BOOL WINAPI GetConsoleSelectionInfo( PCONSOLE_SELECTION_INFO lpConsoleSelectionInfo );
WINBASEAPI BOOL WINAPI GetCurrentConsoleFont( HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFO lpConsoleCurrentFont );
WINBASEAPI BOOL WINAPI GetCurrentConsoleFontEx( HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx );
WINBASEAPI BOOL WINAPI SetConsoleHistoryInfo( PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo );
WINBASEAPI BOOL WINAPI SetConsoleScreenBufferInfoEx( HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx );
WINBASEAPI BOOL WINAPI SetCurrentConsoleFontEx( HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx );

WINBASEAPI DWORD WINAPI GetDynamicTimeZoneInformation( PDYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation );

#if (_WIN32_WINNT >= 0x0600)
WINBASEAPI ULONGLONG WINAPI GetTickCount64( VOID );
#endif

BOOL WINAPI GetTimeZoneInformationForYear( USHORT wYear, PDYNAMIC_TIME_ZONE_INFORMATION pdtzi, LPTIME_ZONE_INFORMATION ptzi );
WINBASEAPI BOOL WINAPI SetDynamicTimeZoneInformation( CONST DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation );

WINBASEAPI PVOID WINAPI DecodePointer( PVOID Ptr );
WINBASEAPI PVOID WINAPI DecodeSystemPointer( PVOID Ptr );
WINBASEAPI PVOID WINAPI EncodePointer( PVOID Ptr );
WINBASEAPI PVOID WINAPI EncodeSystemPointer( PVOID Ptr );

WINBASEAPI int WINAPI CompareStringOrdinal( LPCWSTR lpString1, int cchCount1, LPCWSTR lpString2, int cchCount2, BOOL bIgnoreCase );
WINBASEAPI BOOL WINAPI EnumCalendarInfoExEx( CALINFO_ENUMPROCEXEX pCalInfoEnumProcExEx, LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPARAM lParam );

WINBASEAPI BOOL WINAPI EnumDateFormatsA( DATEFMT_ENUMPROCA lpDateFmtEnumProc, LCID Locale, DWORD dwFlags );
WINBASEAPI BOOL WINAPI EnumDateFormatsW( DATEFMT_ENUMPROCW lpDateFmtEnumProc, LCID Locale, DWORD dwFlags );
#ifdef UNICODE
#define EnumDateFormats  EnumDateFormatsW
#else
#define EnumDateFormats  EnumDateFormatsA
#endif // !UNICODE

WINBASEAPI int WINAPI CompareStringOrdinal( LPCWSTR lpString1, int cchCount1, LPCWSTR lpString2, int cchCount2, BOOL bIgnoreCase );
WINBASEAPI BOOL WINAPI EnumCalendarInfoExEx( CALINFO_ENUMPROCEXEX pCalInfoEnumProcExEx, LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPARAM lParam );

WINBASEAPI BOOL WINAPI EnumDateFormatsA( DATEFMT_ENUMPROCA lpDateFmtEnumProc, LCID Locale, DWORD dwFlags );
WINBASEAPI BOOL WINAPI EnumDateFormatsW( DATEFMT_ENUMPROCW lpDateFmtEnumProc, LCID Locale, DWORD dwFlags );
#ifdef UNICODE
#define EnumDateFormats  EnumDateFormatsW
#else
#define EnumDateFormats  EnumDateFormatsA
#endif // !UNICODE

#if _WIN32_WINNT >= 0x0600
WINBASEAPI LPVOID WINAPI VirtualAllocExNuma( HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect, DWORD nndPreferred );
#endif // _WIN32_WINNT >= 0x0600

WINBASEAPI BOOL WINAPI SetSystemFileCacheSize( SIZE_T MinimumFileCacheSize, SIZE_T MaximumFileCacheSize, DWORD Flags );

PVOID RtlSecureZeroMemory( PVOID ptr, SIZE_T cnt );

WINBASEAPI BOOL WINAPI RemoveSecureMemoryCacheCallback( PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack );

#if _WIN32_WINNT >= 0x0600

WINBASEAPI LPVOID WINAPI MapViewOfFileExNuma( HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress, DWORD nndPreferred );

#endif // _WIN32_WINNT >= 0x0600

#define FLS_OUT_OF_INDEXES ((DWORD)0xFFFFFFFF)

WINBASEAPI DWORD WINAPI FlsAlloc( PFLS_CALLBACK_FUNCTION lpCallback );
WINBASEAPI BOOL WINAPI FlsFree( DWORD dwFlsIndex );
WINBASEAPI PVOID WINAPI FlsGetValue( DWORD dwFlsIndex );
WINBASEAPI BOOL WINAPI FlsSetValue( DWORD dwFlsIndex, PVOID lpFlsData );
WINBASEAPI VOID WINAPI FlushProcessWriteBuffers( VOID );
WINBASEAPI VOID WINAPI FreeLibraryWhenCallbackReturns( PTP_CALLBACK_INSTANCE pci, HMODULE mod );
WINBASEAPI DWORD WINAPI GetCurrentProcessorNumber( VOID );
WINBASEAPI BOOL WINAPI GetLogicalProcessorInformation( PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer, PDWORD ReturnedLength );
WINBASEAPI BOOL WINAPI GetNumaAvailableMemoryNode( UCHAR Node, PULONGLONG AvailableBytes );
WINBASEAPI BOOL WINAPI GetNumaHighestNodeNumber( PULONG HighestNodeNumber );
WINBASEAPI BOOL WINAPI GetNumaNodeProcessorMask( UCHAR Node, PULONGLONG ProcessorMask );
WINBASEAPI BOOL WINAPI GetNumaProcessorNode( UCHAR Processor, PUCHAR NodeNumber );

WINBASEAPI VOID WINAPI AcquireSRWLockShared( PSRWLOCK SRWLock );
WINBASEAPI VOID WINAPI InitializeSRWLock( PSRWLOCK SRWLock );
WINBASEAPI VOID WINAPI ReleaseSRWLockExclusive( PSRWLOCK SRWLock );
WINBASEAPI VOID WINAPI ReleaseSRWLockShared( PSRWLOCK SRWLock );

WINBASEAPI HANDLE WINAPI CreatePrivateNamespaceA( LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix );
WINBASEAPI HANDLE WINAPI CreatePrivateNamespaceW( LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCWSTR lpAliasPrefix );
#ifdef UNICODE
#define CreatePrivateNamespace  CreatePrivateNamespaceW
#else
#define CreatePrivateNamespace  CreatePrivateNamespaceA
#endif // !UNICODE

WINBASEAPI HANDLE WINAPI OpenPrivateNamespaceA( LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix );
WINBASEAPI HANDLE WINAPI OpenPrivateNamespaceW( LPVOID lpBoundaryDescriptor, LPCWSTR lpAliasPrefix );
#ifdef UNICODE
#define OpenPrivateNamespace  OpenPrivateNamespaceW
#else
#define OpenPrivateNamespace  OpenPrivateNamespaceA
#endif // !UNICODE

WINBASEAPI BOOLEAN WINAPI ClosePrivateNamespace( HANDLE Handle, ULONG Flags );

WINBASEAPI HANDLE APIENTRY CreateBoundaryDescriptorA( LPCSTR Name, ULONG Flags );
WINBASEAPI HANDLE APIENTRY CreateBoundaryDescriptorW( LPCWSTR Name, ULONG Flags );
#ifdef UNICODE
#define CreateBoundaryDescriptor  CreateBoundaryDescriptorW
#else
#define CreateBoundaryDescriptor  CreateBoundaryDescriptorA
#endif // !UNICODE

WINBASEAPI BOOL WINAPI AddSIDToBoundaryDescriptor( HANDLE* BoundaryDescriptor, PSID RequiredSid );
WINBASEAPI VOID WINAPI DeleteBoundaryDescriptor( HANDLE BoundaryDescriptor );

WINBASEAPI HANDLE WINAPI CreateEventExA( LPSECURITY_ATTRIBUTES lpEventAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess );
WINBASEAPI HANDLE WINAPI CreateEventExW( LPSECURITY_ATTRIBUTES lpEventAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess );
#ifdef UNICODE
#define CreateEventEx  CreateEventExW
#else
#define CreateEventEx  CreateEventExA
#endif // !UNICODE

WINBASEAPI HANDLE WINAPI CreateMutexExA( LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess );
WINBASEAPI HANDLE WINAPI CreateMutexExW( LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess );
#ifdef UNICODE
#define CreateMutexEx  CreateMutexExW
#else
#define CreateMutexEx  CreateMutexExA
#endif // !UNICODE

WINBASEAPI HANDLE WINAPI CreateWaitableTimerExA( LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess );
WINBASEAPI HANDLE WINAPI CreateWaitableTimerExW( LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCWSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess );
#ifdef UNICODE
#define CreateWaitableTimerEx  CreateWaitableTimerExW
#else
#define CreateWaitableTimerEx  CreateWaitableTimerExA
#endif // !UNICODE

WINBASEAPI HANDLE WINAPI OpenWaitableTimerA( DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpTimerName );
WINBASEAPI HANDLE WINAPI OpenWaitableTimerW( DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpTimerName );
#ifdef UNICODE
#define OpenWaitableTimer  OpenWaitableTimerW
#else
#define OpenWaitableTimer  OpenWaitableTimerA
#endif // !UNICODE

WINBASEAPI BOOL WINAPI InitializeCriticalSectionEx( LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, DWORD Flags );
WINBASEAPI VOID WINAPI InitializeConditionVariable( PCONDITION_VARIABLE ConditionVariable );
WINBASEAPI USHORT WINAPI QueryDepthSList( PSLIST_HEADER ListHead );

#if (_WIN32_WINNT >= 0x0600)
WINBASEAPI BOOL WINAPI InitOnceBeginInitialize( LPINIT_ONCE lpInitOnce, DWORD dwFlags, PBOOL fPending, LPVOID *lpContext );
WINBASEAPI BOOL WINAPI InitOnceComplete( LPINIT_ONCE lpInitOnce, DWORD dwFlags, LPVOID lpContext );
WINBASEAPI BOOL WINAPI InitOnceExecuteOnce( PINIT_ONCE InitOnce, PINIT_ONCE_FN InitFn, PVOID Parameter, LPVOID *Context );
WINBASEAPI VOID WINAPI InitOnceInitialize( PINIT_ONCE InitOnce );
WINBASEAPI BOOL WINAPI Wow64GetThreadContext( HANDLE hThread, PWOW64_CONTEXT lpContext );
WINBASEAPI BOOL WINAPI Wow64SetThreadContext( HANDLE hThread, CONST WOW64_CONTEXT *lpContext );



WINBASEAPI BOOL WINAPI GetNumaProximityNode( ULONG ProximityId, PUCHAR NodeNumber );

#endif

WINBASEAPI DWORD WINAPI GetProcessIdOfThread( HANDLE Thread );
WINBASEAPI BOOL WINAPI GetProcessWorkingSetSizeEx( HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize, PDWORD Flags );

#if (_WIN32_WINNT >= 0x0502)
WINBASEAPI DWORD WINAPI GetThreadId( HANDLE Thread );
#endif // _WIN32_WINNT >= 0x0502

WINBASEAPI BOOL WINAPI InitializeProcThreadAttributeList( LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwAttributeCount, DWORD dwFlags, PSIZE_T lpSize );

VOID TpInitializeCallbackEnviron( PTP_CALLBACK_ENVIRON CallbackEnviron );
VOID InitializeThreadpoolEnvironment( PTP_CALLBACK_ENVIRON pcbe );
VOID TpDestroyCallbackEnviron( PTP_CALLBACK_ENVIRON CallbackEnviron );
VOID DestroyThreadpoolEnvironment( PTP_CALLBACK_ENVIRON pcbe );

#if (_WIN32_WINNT >= 0x0600)
WINBASEAPI BOOL WINAPI IsThreadAFiber( VOID );
#endif

WINBASEAPI BOOL WINAPI IsThreadpoolTimerSet( PTP_TIMER pti );
WINBASEAPI VOID WINAPI LeaveCriticalSectionWhenCallbackReturns( PTP_CALLBACK_INSTANCE pci, PCRITICAL_SECTION pcs );

WINBASEAPI BOOL WINAPI NeedCurrentDirectoryForExePathA( LPCSTR ExeName );
WINBASEAPI BOOL WINAPI NeedCurrentDirectoryForExePathW( LPCWSTR ExeName );
#ifdef UNICODE
#define NeedCurrentDirectoryForExePath  NeedCurrentDirectoryForExePathW
#else
#define NeedCurrentDirectoryForExePath  NeedCurrentDirectoryForExePathA
#endif // !UNICODE

WINBASEAPI HANDLE WINAPI OpenJobObjectA( DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName );
WINBASEAPI HANDLE WINAPI OpenJobObjectW( DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName );
#ifdef UNICODE
#define OpenJobObject  OpenJobObjectW
#else
#define OpenJobObject  OpenJobObjectA
#endif // !UNICODE

WINBASEAPI BOOL WINAPI QueryFullProcessImageNameA( HANDLE hProcess, DWORD dwFlags, LPSTR lpExeName, PDWORD lpdwSize );
WINBASEAPI BOOL WINAPI QueryFullProcessImageNameW( HANDLE hProcess, DWORD dwFlags, LPWSTR lpExeName, PDWORD lpdwSize );
#ifdef UNICODE
#define QueryFullProcessImageName  QueryFullProcessImageNameW
#else
#define QueryFullProcessImageName  QueryFullProcessImageNameA
#endif // !UNICODE

WINBASEAPI BOOL WINAPI QueryIdleProcessorCycleTime( PULONG BufferLength, PULONG64 ProcessorIdleCycleTime );
WINBASEAPI BOOL WINAPI QueryProcessAffinityUpdateMode( HANDLE hProcess, LPDWORD lpdwFlags );
WINBASEAPI BOOL WINAPI QueryProcessCycleTime( HANDLE ProcessHandle, PULONG64 CycleTime );
WINBASEAPI BOOL WINAPI QueryThreadCycleTime( HANDLE ThreadHandle, PULONG64 CycleTime );
WINBASEAPI VOID WINAPI ReleaseMutexWhenCallbackReturns( PTP_CALLBACK_INSTANCE pci, HANDLE mut );
WINBASEAPI VOID WINAPI ReleaseSemaphoreWhenCallbackReturns( PTP_CALLBACK_INSTANCE pci, HANDLE sem, DWORD crel );

WINBASEAPI BOOL WINAPI GetSystemPreferredUILanguages( DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer );
WINBASEAPI BOOL WINAPI GetThreadPreferredUILanguages( DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer );
WINBASEAPI LANGID WINAPI GetThreadUILanguage(void);
WINBASEAPI BOOL WINAPI GetUILanguageInfo( DWORD dwFlags, PCZZWSTR pwmszLanguage, PZZWSTR pwszFallbackLanguages, PDWORD pcchFallbackLanguages, PDWORD pAttributes );
WINBASEAPI BOOL WINAPI GetUserPreferredUILanguages( DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer );
WINBASEAPI BOOL WINAPI SetThreadPreferredUILanguages( DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages );
WINBASEAPI LANGID WINAPI SetThreadUILanguage( LANGID LangId );

#if _WIN32_WINNT >= 0x0600
WINBASEAPI BOOL WINAPI SetFileInformationByHandle( HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize );
#endif
WINBASEAPI BOOL WINAPI SetFileIoOverlappedRange( HANDLE FileHandle, PUCHAR OverlappedRangeStart, ULONG Length );
WINBASEAPI BOOL WINAPI Wow64DisableWow64FsRedirection( PVOID* OldValue );
WINBASEAPI BOOLEAN WINAPI Wow64EnableWow64FsRedirection( BOOLEAN Wow64FsEnableRedirection );
WINBASEAPI BOOL WINAPI Wow64RevertWow64FsRedirection( PVOID OlValue );

WINBASEAPI BOOL WINAPI AddSecureMemoryCacheCallback( PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack );

#if _WIN32_WINNT >= 0x0600
WINBASEAPI BOOL WINAPI AllocateUserPhysicalPagesNuma( HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray, DWORD nndPreferred );
#endif // _WIN32_WINNT >= 0x0600

WINBASEAPI HANDLE WINAPI CreateFileMappingNumaA( HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName, DWORD nndPreferred );
WINBASEAPI HANDLE WINAPI CreateFileMappingNumaW( HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName, DWORD nndPreferred );
#ifdef UNICODE
#define CreateFileMappingNuma  CreateFileMappingNumaW
#else
#define CreateFileMappingNuma  CreateFileMappingNumaA
#endif // !UNICODE

WINBASEAPI SIZE_T WINAPI GetLargePageMinimum( VOID );
WINBASEAPI BOOL WINAPI GetPhysicallyInstalledSystemMemory( PULONGLONG TotalMemoryInKilobytes );

WINBASEAPI VOID WINAPI ApplicationRecoveryFinished( BOOL bSuccess );
WINBASEAPI HRESULT WINAPI ApplicationRecoveryInProgress( PBOOL pbCancelled );
WINBASEAPI HRESULT WINAPI GetApplicationRecoveryCallback( HANDLE hProcess, APPLICATION_RECOVERY_CALLBACK* pRecoveryCallback, PVOID* ppvParameter, PDWORD pdwPingInterval, PDWORD pdwFlags );
WINBASEAPI HRESULT WINAPI GetApplicationRestartSettings( HANDLE hProcess, PWSTR pwzCommandline, PDWORD pcchSize, PDWORD pdwFlags );
WINBASEAPI HRESULT WINAPI RegisterApplicationRecoveryCallback( APPLICATION_RECOVERY_CALLBACK pRecoveyCallback, PVOID pvParameter, DWORD dwPingInterval, DWORD dwFlags );
WINBASEAPI HRESULT WINAPI RegisterApplicationRestart( PCWSTR pwzCommandline, DWORD dwFlags );
WINBASEAPI HRESULT WINAPI UnregisterApplicationRecoveryCallback( void );
WINBASEAPI HRESULT WINAPI UnregisterApplicationRestart( void );

WINBASEAPI BOOL WINAPI GetSystemFileCacheSize( PSIZE_T lpMinimumFileCacheSize, PSIZE_T lpMaximumFileCacheSize, PDWORD lpFlags );

WINBASEAPI VOID WINAPI SetEventWhenCallbackReturns( PTP_CALLBACK_INSTANCE pci, HANDLE evt );
WINBASEAPI BOOL WINAPI SetProcessAffinityUpdateMode( HANDLE hProcess, DWORD dwFlags );
WINBASEAPI BOOL WINAPI SetProcessWorkingSetSizeEx( HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize, DWORD Flags );

VOID TpSetCallbackCleanupGroup( PTP_CALLBACK_ENVIRON CallbackEnviron, PTP_CLEANUP_GROUP CleanupGroup, PTP_CLEANUP_GROUP_CANCEL_CALLBACK CleanupGroupCancelCallback );
VOID SetThreadpoolCallbackCleanupGroup( PTP_CALLBACK_ENVIRON pcbe, PTP_CLEANUP_GROUP ptpcg, PTP_CLEANUP_GROUP_CANCEL_CALLBACK pfng );
VOID TpSetCallbackRaceWithDll( PTP_CALLBACK_ENVIRON CallbackEnviron, PVOID DllHandle );
VOID SetThreadpoolCallbackLibrary( PTP_CALLBACK_ENVIRON pcbe, PVOID mod );
VOID TpSetCallbackThreadpool( PTP_CALLBACK_ENVIRON CallbackEnviron, PTP_POOL Pool );
VOID SetThreadpoolCallbackPool( PTP_CALLBACK_ENVIRON pcbe, PTP_POOL ptpp );
VOID TpSetCallbackLongFunction( PTP_CALLBACK_ENVIRON CallbackEnviron );
VOID SetThreadpoolCallbackRunsLong( PTP_CALLBACK_ENVIRON pcbe );

WINBASEAPI VOID WINAPI SetThreadpoolThreadMaximum( PTP_POOL ptpp, DWORD cthrdMost );

WINBASEAPI HANDLE WINAPI CreateSemaphoreExA( LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess );
WINBASEAPI HANDLE WINAPI CreateSemaphoreExW( LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess );
#ifdef UNICODE
#define CreateSemaphoreEx  CreateSemaphoreExW
#else
#define CreateSemaphoreEx  CreateSemaphoreExA
#endif // !UNICODE

WINBASEAPI BOOL WINAPI EnumDateFormatsExEx( DATEFMT_ENUMPROCEXEX lpDateFmtEnumProcExEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam );
WINBASEAPI BOOL WINAPI EnumSystemLocalesEx( LOCALE_ENUMPROCEX lpLocaleEnumProcEx, DWORD dwFlags, LPARAM lParam, LPVOID lpReserved );
WINBASEAPI BOOL WINAPI EnumTimeFormatsEx( TIMEFMT_ENUMPROCEX lpTimeFmtEnumProcEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam );
WINBASEAPI int WINAPI FindNLSString( LCID Locale, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound );
WINBASEAPI int WINAPI FindNLSStringEx( LPCWSTR lpLocaleName, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM lParam );
WINBASEAPI int WINAPI GetCalendarInfoEx( LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPWSTR lpCalData, int cchData, LPDWORD lpValue );
WINBASEAPI int WINAPI GetCurrencyFormatEx( LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, CONST CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency );
WINBASEAPI int WINAPI GetDateFormatEx( LPCWSTR lpLocaleName, DWORD dwFlags, CONST SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate, LPCWSTR lpCalendar );
WINBASEAPI int WINAPI GetDurationFormat( LCID Locale, DWORD dwFlags, CONST SYSTEMTIME *lpDuration, ULONGLONG ullDuration, LPCWSTR lpFormat, LPWSTR lpDurationStr, int cchDuration );
WINBASEAPI int WINAPI GetDurationFormatEx( LPCWSTR lpLocaleName, DWORD dwFlags, CONST SYSTEMTIME *lpDuration, ULONGLONG ullDuration, LPCWSTR lpFormat, LPWSTR lpDurationStr, int cchDuration );
WINBASEAPI int WINAPI GetLocaleInfoEx( LPCWSTR lpLocaleName, LCTYPE LCType, LPWSTR lpLCData, int cchData );
WINBASEAPI BOOL WINAPI GetNLSVersionEx( NLS_FUNCTION function, LPCWSTR lpLocaleName, LPNLSVERSIONINFOEX lpVersionInformation );
WINBASEAPI int WINAPI GetNumberFormatEx( LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, CONST NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber );
WINBASEAPI int WINAPI GetStringScripts( DWORD dwFlags, LPCWSTR lpString, int cchString, LPWSTR lpScripts, int cchScripts );
WINBASEAPI int WINAPI GetSystemDefaultLocaleName( LPWSTR lpLocaleName, int cchLocaleName );
WINBASEAPI int WINAPI GetTimeFormatEx( LPCWSTR lpLocaleName, DWORD dwFlags, CONST SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime );
WINBASEAPI int WINAPI GetUserDefaultLocaleName( LPWSTR lpLocaleName, int cchLocaleName );

#if _WIN32_WINNT >= 0x0600
__QCMP_IMPORT BOOL WINAPI IsNormalizedString( NORM_FORM NormForm, LPCWSTR lpString, int cwLength );
#endif
WINBASEAPI BOOL WINAPI IsValidLocaleName( LPCWSTR lpLocaleName );

WINBASEAPI int WINAPI LCIDToLocaleName( LCID Locale, LPWSTR lpName, int cchName, DWORD dwFlags);
WINBASEAPI int WINAPI LCMapStringEx( LPCWSTR lpLocaleName, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM lParam );
WINBASEAPI LCID WINAPI LocaleNameToLCID( LPCWSTR lpName, DWORD dwFlags );
#if _WIN32_WINNT >= 0x0600
__QCMP_IMPORT int WINAPI NormalizeString( NORM_FORM NormForm, LPCWSTR lpSrcString, int cwSrcLength, LPWSTR lpDstString, int cwDstLength );
#endif
WINBASEAPI BOOL WINAPI VerifyScripts( DWORD dwFlags, LPCWSTR lpLocaleScripts, int cchLocaleScripts, LPCWSTR lpTestScripts, int cchTestScripts );


WINBASEAPI VOID WINAPI WaitForThreadpoolTimerCallbacks( PTP_TIMER pti, BOOL fCancelPendingCallbacks );
WINBASEAPI VOID WINAPI WaitForThreadpoolIoCallbacks( PTP_IO pio, BOOL fCancelPendingCallbacks );
WINBASEAPI BOOL WINAPI UpdateProcThreadAttribute( LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwFlags, DWORD_PTR Attribute, PVOID lpValue, SIZE_T cbSize, PVOID lpPreviousValue, PSIZE_T lpReturnSize );
WINBASEAPI BOOL WINAPI TrySubmitThreadpoolCallback( PTP_SIMPLE_CALLBACK pfns, PVOID pv, PTP_CALLBACK_ENVIRON pcbe );
WINBASEAPI VOID WINAPI SubmitThreadpoolWork( PTP_WORK pwk );
WINBASEAPI VOID WINAPI StartThreadpoolIo( PTP_IO pio );
WINBASEAPI BOOL WINAPI SetThreadStackGuarantee( PULONG StackSizeInBytes );
WINBASEAPI VOID WINAPI SetThreadpoolWait( PTP_WAIT pwa, HANDLE h, PFILETIME pftTimeout );
WINBASEAPI VOID WINAPI SetThreadpoolTimer( PTP_TIMER pti, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength );
WINBASEAPI BOOL WINAPI SetThreadpoolThreadMinimum( PTP_POOL ptpp, DWORD cthrdMic );


#define CREATE_EVENT_MANUAL_RESET 0x00000001
#define CREATE_EVENT_INITIAL_SET 0x00000002
#define CREATE_MUTEX_INITIAL_OWNER 0x00000001

#define RTL_RUN_ONCE_CHECK_ONLY     0x00000001UL
#define RTL_RUN_ONCE_ASYNC          0x00000002UL
#define RTL_RUN_ONCE_INIT_FAILED    0x00000004UL

#if _WIN32_WINNT >= 0x0600
//Define one-time initialization primitive
typedef RTL_RUN_ONCE INIT_ONCE;
typedef PRTL_RUN_ONCE PINIT_ONCE;
typedef PRTL_RUN_ONCE LPINIT_ONCE;
#define INIT_ONCE_STATIC_INIT   RTL_RUN_ONCE_INIT
//Run once flags
#define INIT_ONCE_CHECK_ONLY        RTL_RUN_ONCE_CHECK_ONLY
#define INIT_ONCE_ASYNC             RTL_RUN_ONCE_ASYNC
#define INIT_ONCE_INIT_FAILED       RTL_RUN_ONCE_INIT_FAILED

// The context stored in the run once structure must leave the following number of low order bits unused.
#define INIT_ONCE_CTX_RESERVED_BITS RTL_RUN_ONCE_CTX_RESERVED_BITS
typedef BOOL( WINAPI *PINIT_ONCE_FN ) ( PINIT_ONCE InitOnce, PVOID Parameter, PVOID* Context );
#endif

#define CREATE_WAITABLE_TIMER_MANUAL_RESET  0x00000001

// These flags define the upper byte of the critical section SpinCount field
//
#define RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO         0x01000000
#define RTL_CRITICAL_SECTION_FLAG_DYNAMIC_SPIN          0x02000000
#define RTL_CRITICAL_SECTION_FLAG_STATIC_INIT           0x04000000
#define RTL_CRITICAL_SECTION_ALL_FLAG_BITS              0xFF000000
#define RTL_CRITICAL_SECTION_FLAG_RESERVED              (RTL_CRITICAL_SECTION_ALL_FLAG_BITS & (~(RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO | RTL_CRITICAL_SECTION_FLAG_DYNAMIC_SPIN | RTL_CRITICAL_SECTION_FLAG_STATIC_INIT)))

#define CRITICAL_SECTION_NO_DEBUG_INFO  RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO

// Well known SID definitions for lookup.
typedef enum {

    WinNullSid                                  = 0,
    WinWorldSid                                 = 1,
    WinLocalSid                                 = 2,
    WinCreatorOwnerSid                          = 3,
    WinCreatorGroupSid                          = 4,
    WinCreatorOwnerServerSid                    = 5,
    WinCreatorGroupServerSid                    = 6,
    WinNtAuthoritySid                           = 7,
    WinDialupSid                                = 8,
    WinNetworkSid                               = 9,
    WinBatchSid                                 = 10,
    WinInteractiveSid                           = 11,
    WinServiceSid                               = 12,
    WinAnonymousSid                             = 13,
    WinProxySid                                 = 14,
    WinEnterpriseControllersSid                 = 15,
    WinSelfSid                                  = 16,
    WinAuthenticatedUserSid                     = 17,
    WinRestrictedCodeSid                        = 18,
    WinTerminalServerSid                        = 19,
    WinRemoteLogonIdSid                         = 20,
    WinLogonIdsSid                              = 21,
    WinLocalSystemSid                           = 22,
    WinLocalServiceSid                          = 23,
    WinNetworkServiceSid                        = 24,
    WinBuiltinDomainSid                         = 25,
    WinBuiltinAdministratorsSid                 = 26,
    WinBuiltinUsersSid                          = 27,
    WinBuiltinGuestsSid                         = 28,
    WinBuiltinPowerUsersSid                     = 29,
    WinBuiltinAccountOperatorsSid               = 30,
    WinBuiltinSystemOperatorsSid                = 31,
    WinBuiltinPrintOperatorsSid                 = 32,
    WinBuiltinBackupOperatorsSid                = 33,
    WinBuiltinReplicatorSid                     = 34,
    WinBuiltinPreWindows2000CompatibleAccessSid = 35,
    WinBuiltinRemoteDesktopUsersSid             = 36,
    WinBuiltinNetworkConfigurationOperatorsSid  = 37,
    WinAccountAdministratorSid                  = 38,
    WinAccountGuestSid                          = 39,
    WinAccountKrbtgtSid                         = 40,
    WinAccountDomainAdminsSid                   = 41,
    WinAccountDomainUsersSid                    = 42,
    WinAccountDomainGuestsSid                   = 43,
    WinAccountComputersSid                      = 44,
    WinAccountControllersSid                    = 45,
    WinAccountCertAdminsSid                     = 46,
    WinAccountSchemaAdminsSid                   = 47,
    WinAccountEnterpriseAdminsSid               = 48,
    WinAccountPolicyAdminsSid                   = 49,
    WinAccountRasAndIasServersSid               = 50,
    WinNTLMAuthenticationSid                    = 51,
    WinDigestAuthenticationSid                  = 52,
    WinSChannelAuthenticationSid                = 53,
    WinThisOrganizationSid                      = 54,
    WinOtherOrganizationSid                     = 55,
    WinBuiltinIncomingForestTrustBuildersSid    = 56,
    WinBuiltinPerfMonitoringUsersSid            = 57,
    WinBuiltinPerfLoggingUsersSid               = 58,
    WinBuiltinAuthorizationAccessSid            = 59,
    WinBuiltinTerminalServerLicenseServersSid   = 60,
    WinBuiltinDCOMUsersSid                      = 61,
    WinBuiltinIUsersSid                         = 62,
    WinIUserSid                                 = 63,
    WinBuiltinCryptoOperatorsSid                = 64,
    WinUntrustedLabelSid                        = 65,
    WinLowLabelSid                              = 66,
    WinMediumLabelSid                           = 67,
    WinHighLabelSid                             = 68,
    WinSystemLabelSid                           = 69,
    WinWriteRestrictedCodeSid                   = 70,
    WinCreatorOwnerRightsSid                    = 71,
    WinCacheablePrincipalsGroupSid              = 72,
    WinNonCacheablePrincipalsGroupSid           = 73,
    WinEnterpriseReadonlyControllersSid         = 74,
    WinAccountReadonlyControllersSid            = 75,
    WinBuiltinEventLogReadersGroup              = 76,
    WinNewEnterpriseReadonlyControllersSid      = 77,
    WinBuiltinCertSvcDComAccessGroup            = 78,
    WinMediumPlusLabelSid                       = 79,
    WinLocalLogonSid                            = 80,
    WinConsoleLogonSid							= 81,
    WinThisOrganizationCertificateSid			= 82,
} WELL_KNOWN_SID_TYPE;

typedef struct _OBJECT_TYPE_LIST
{
    WORD   Level;
    WORD   Sbz;
    GUID *ObjectType;
} OBJECT_TYPE_LIST, *POBJECT_TYPE_LIST;

typedef enum _AUDIT_EVENT_TYPE
{
    AuditEventObjectAccess,
    AuditEventDirectoryServiceAccess
} AUDIT_EVENT_TYPE, *PAUDIT_EVENT_TYPE;

#define AUDIT_ALLOW_NO_PRIVILEGE 0x1

typedef enum _PROGRESS_INVOKE_SETTING
{
    ProgressInvokeNever = 1,    // Never invoke the progress function
    ProgressInvokeEveryObject,  // Invoke for each object
    ProgressInvokeOnError,      // Invoke only for each error case
    ProgressCancelOperation,    // Stop propagation and return
    ProgressRetryOperation,     // Retry operation on subtree
#if (NTDDI_VERSION >= NTDDI_VISTA)
    ProgressInvokePrePostError, // Invoke Pre, Post, Error
#endif // (NTDDI_VERSION >= NTDDI_VISTA)
} PROG_INVOKE_SETTING, *PPROG_INVOKE_SETTING;

typedef void (*FN_PROGRESS) (
    LPWSTR                     pObjectName,    // name of object just processed
    DWORD                      Status,         // status of operation on object
    PPROG_INVOKE_SETTING		pInvokeSetting, // Never, always,
    PVOID                      Args,           // Caller specific data
    BOOL                       SecuritySet     // Whether security was set
    );

typedef struct _FN_OBJECT_MGR_FUNCTIONS
{
    ULONG   Placeholder;
} FN_OBJECT_MGR_FUNCTS, *PFN_OBJECT_MGR_FUNCTS;

typedef struct _LSA_TRANSLATED_SID2
{
    SID_NAME_USE Use;
    PSID         Sid;
    LONG         DomainIndex;
    ULONG        Flags;

} LSA_TRANSLATED_SID2, *PLSA_TRANSLATED_SID2;

typedef struct _CREDENTIAL_ATTRIBUTEA
{
    LPSTR Keyword;
    DWORD Flags;
    DWORD ValueSize;
    LPBYTE Value;
} CREDENTIAL_ATTRIBUTEA, *PCREDENTIAL_ATTRIBUTEA;

typedef struct _CREDENTIAL_ATTRIBUTEW
{
#ifdef MIDL_PASS
    [string] wchar_t * Keyword;
#else // MIDL_PASS
    LPWSTR  Keyword;
#endif // MIDL_PASS
    DWORD Flags;
#ifdef MIDL_PASS
    [range(0,CRED_MAX_VALUE_SIZE)]
#endif // MIDL_PASS
    DWORD ValueSize;
#ifdef MIDL_PASS
    [size_is(ValueSize)]
#endif // MIDL_PASS
    LPBYTE Value;
} CREDENTIAL_ATTRIBUTEW, *PCREDENTIAL_ATTRIBUTEW;

#ifdef UNICODE
typedef CREDENTIAL_ATTRIBUTEW CREDENTIAL_ATTRIBUTE;
typedef PCREDENTIAL_ATTRIBUTEW PCREDENTIAL_ATTRIBUTE;
#else
typedef CREDENTIAL_ATTRIBUTEA CREDENTIAL_ATTRIBUTE;
typedef PCREDENTIAL_ATTRIBUTEA PCREDENTIAL_ATTRIBUTE;
#endif // UNICODE


// A credential
typedef struct _CREDENTIALA
{
    DWORD Flags;
    DWORD Type;
    LPSTR TargetName;
    LPSTR Comment;
    FILETIME LastWritten;
    DWORD CredentialBlobSize;
    LPBYTE CredentialBlob;
    DWORD Persist;
    DWORD AttributeCount;
    PCREDENTIAL_ATTRIBUTEA Attributes;
    LPSTR TargetAlias;
    LPSTR UserName;
} CREDENTIALA, *PCREDENTIALA;

typedef struct _CREDENTIALW
{
    DWORD Flags;
    DWORD Type;
#ifdef MIDL_PASS
    [string,max_is(CRED_MAX_GENERIC_TARGET_NAME_LENGTH-1)] wchar_t *TargetName;
#else // MIDL_PASS
    LPWSTR TargetName;
#endif // MIDL_PASS
#ifdef MIDL_PASS
    [string,max_is(CRED_MAX_STRING_LENGTH-1)] wchar_t *Comment;
#else // MIDL_PASS
    LPWSTR Comment;
#endif // MIDL_PASS
    FILETIME LastWritten;
#ifdef MIDL_PASS
    [range(0,CRED_MAX_CREDENTIAL_BLOB_SIZE)]
#endif // MIDL_PASS
    DWORD CredentialBlobSize;
#ifdef MIDL_PASS
    [size_is(CredentialBlobSize)]
#endif // MIDL_PASS
    LPBYTE CredentialBlob;
    DWORD Persist;
#ifdef MIDL_PASS
    [range(0,CRED_MAX_ATTRIBUTES)]
#endif // MIDL_PASS
    DWORD AttributeCount;
#ifdef MIDL_PASS
    [size_is(AttributeCount)]
#endif // MIDL_PASS
    PCREDENTIAL_ATTRIBUTEW Attributes;
#ifdef MIDL_PASS
    [string,max_is(CRED_MAX_STRING_LENGTH-1)] wchar_t *TargetAlias;
#else // MIDL_PASS
    LPWSTR TargetAlias;
#endif // MIDL_PASS
#ifdef MIDL_PASS
    [string,max_is(CRED_MAX_USERNAME_LENGTH-1)] wchar_t *UserName;
#else // MIDL_PASS
    LPWSTR UserName;
#endif // MIDL_PASS
} CREDENTIALW, *PCREDENTIALW;

#ifdef UNICODE
typedef CREDENTIALW CREDENTIAL;
typedef PCREDENTIALW PCREDENTIAL;
#else
typedef CREDENTIALA CREDENTIAL;
typedef PCREDENTIALA PCREDENTIAL;
#endif // UNICODE

// A credential target
typedef struct _CREDENTIAL_TARGET_INFORMATIONA
{
    LPSTR TargetName;
    LPSTR NetbiosServerName;
    LPSTR DnsServerName;
    LPSTR NetbiosDomainName;
    LPSTR DnsDomainName;
    LPSTR DnsTreeName;
    LPSTR PackageName;
    ULONG Flags;
    DWORD CredTypeCount;
    LPDWORD CredTypes;
} CREDENTIAL_TARGET_INFORMATIONA, *PCREDENTIAL_TARGET_INFORMATIONA;

typedef struct _CREDENTIAL_TARGET_INFORMATIONW
{
#ifdef MIDL_PASS
    [string,max_is(CRED_MAX_DOMAIN_TARGET_NAME_LENGTH-1)] wchar_t *TargetName;
    [string,max_is(CRED_MAX_DOMAIN_TARGET_NAME_LENGTH-1)] wchar_t *NetbiosServerName;
    [string,max_is(CRED_MAX_DOMAIN_TARGET_NAME_LENGTH-1)] wchar_t *DnsServerName;
    [string,max_is(CRED_MAX_DOMAIN_TARGET_NAME_LENGTH-1)] wchar_t *NetbiosDomainName;
    [string,max_is(CRED_MAX_DOMAIN_TARGET_NAME_LENGTH-1)] wchar_t *DnsDomainName;
    [string,max_is(CRED_MAX_DOMAIN_TARGET_NAME_LENGTH-1)] wchar_t *DnsTreeName;
    [string,max_is(CRED_MAX_STRING_LENGTH-1)] wchar_t *PackageName;
#else // MIDL_PASS
    LPWSTR TargetName;
    LPWSTR NetbiosServerName;
    LPWSTR DnsServerName;
    LPWSTR NetbiosDomainName;
    LPWSTR DnsDomainName;
    LPWSTR DnsTreeName;
    LPWSTR PackageName;
#endif // MIDL_PASS
    ULONG Flags;
#ifdef MIDL_PASS
    [range(0,CRED_TYPE_MAXIMUM_EX)]
#endif // MIDL_PASS
    DWORD CredTypeCount;
#ifdef MIDL_PASS
    [size_is(CredTypeCount)]
#endif // MIDL_PASS
    LPDWORD CredTypes;
} CREDENTIAL_TARGET_INFORMATIONW, *PCREDENTIAL_TARGET_INFORMATIONW;

#ifdef UNICODE
typedef CREDENTIAL_TARGET_INFORMATIONW CREDENTIAL_TARGET_INFORMATION;
typedef PCREDENTIAL_TARGET_INFORMATIONW PCREDENTIAL_TARGET_INFORMATION;
#else
typedef CREDENTIAL_TARGET_INFORMATIONA CREDENTIAL_TARGET_INFORMATION;
typedef PCREDENTIAL_TARGET_INFORMATIONA PCREDENTIAL_TARGET_INFORMATION;
#endif // UNICODE

typedef enum _CRED_MARSHAL_TYPE
{
    CertCredential = 1,
    UsernameTargetCredential,
    BinaryBlobCredential,
    UsernameForPackedCredentials,  // internal only, reserved
} CRED_MARSHAL_TYPE, *PCRED_MARSHAL_TYPE;

#define CYPHER_BLOCK_LENGTH         8

typedef struct _CYPHER_BLOCK
{
    CHAR    data[CYPHER_BLOCK_LENGTH];
}CYPHER_BLOCK;

typedef struct _LM_OWF_PASSWORD
{
    CYPHER_BLOCK data[2];
}                                   LM_OWF_PASSWORD;

typedef LM_OWF_PASSWORD *           PLM_OWF_PASSWORD;
typedef LM_OWF_PASSWORD             NT_OWF_PASSWORD;
typedef NT_OWF_PASSWORD *           PNT_OWF_PASSWORD;

typedef struct _SAMPR_ENCRYPTED_USER_PASSWORD
{
    UCHAR Buffer[ (256 * 2) + 4 ];
} SAMPR_ENCRYPTED_USER_PASSWORD, *PSAMPR_ENCRYPTED_USER_PASSWORD;

typedef struct _ENCRYPTED_LM_OWF_PASSWORD
{
    CYPHER_BLOCK data[2];
} ENCRYPTED_LM_OWF_PASSWORD, *PENCRYPTED_LM_OWF_PASSWORD;

typedef ENCRYPTED_LM_OWF_PASSWORD   ENCRYPTED_NT_OWF_PASSWORD;
typedef ENCRYPTED_NT_OWF_PASSWORD * PENCRYPTED_NT_OWF_PASSWORD;

typedef struct _CERTIFICATE_BLOB
{
    DWORD   dwCertEncodingType;

#ifdef MIDL_PASS
    [range(0,32768)]
#endif // MIDL_PASS

    DWORD   cbData;

#ifdef MIDL_PASS
    [size_is(cbData)]
#endif // MIDL_PASS
    PBYTE    pbData;

} EFS_CERTIFICATE_BLOB, *PEFS_CERTIFICATE_BLOB;

typedef struct _ENCRYPTION_CERTIFICATE
{
    DWORD cbTotalLength;
    SID * pUserSid;
    PEFS_CERTIFICATE_BLOB pCertBlob;
} ENCRYPTION_CERTIFICATE, *PENCRYPTION_CERTIFICATE;

typedef struct _ENCRYPTION_CERTIFICATE_LIST
{
#ifdef MIDL_PASS
    [range(0,500)]
#endif // MIDL_PASS
    DWORD nUsers;
#ifdef MIDL_PASS
    [size_is(nUsers)]
#endif // MIDL_PASS
     PENCRYPTION_CERTIFICATE * pUsers;
} ENCRYPTION_CERTIFICATE_LIST, *PENCRYPTION_CERTIFICATE_LIST;

typedef DWORD (WINAPI *PFE_EXPORT_FUNC)(
    PBYTE pbData,
    PVOID pvCallbackContext,
    ULONG ulLength
    );

typedef struct _EFS_HASH_BLOB
{
#ifdef MIDL_PASS
    [range(0,100)]
#endif // MIDL_PASS
    DWORD   cbData;

#ifdef MIDL_PASS
    [size_is(cbData)]
#endif // MIDL_PASS
    PBYTE    pbData;

} EFS_HASH_BLOB, *PEFS_HASH_BLOB;

typedef struct _ENCRYPTION_CERTIFICATE_HASH
{
    DWORD cbTotalLength;
    SID * pUserSid;
    PEFS_HASH_BLOB  pHash;

#ifdef MIDL_PASS
    [string]
#endif // MIDL_PASS
    LPWSTR lpDisplayInformation;

} ENCRYPTION_CERTIFICATE_HASH, *PENCRYPTION_CERTIFICATE_HASH;

typedef struct _ENCRYPTION_CERTIFICATE_HASH_LIST
{
#ifdef MIDL_PASS
    [range(0,500)]
#endif // MIDL_PASS
    DWORD nCert_Hash;
#ifdef MIDL_PASS
    [size_is(nCert_Hash)]
#endif // MIDL_PASS
     PENCRYPTION_CERTIFICATE_HASH * pUsers;
} ENCRYPTION_CERTIFICATE_HASH_LIST, *PENCRYPTION_CERTIFICATE_HASH_LIST;

typedef DWORD (WINAPI *PFE_IMPORT_FUNC)(
    PBYTE pbData,
    PVOID pvCallbackContext,
    PULONG ulLength
    );


// Service notification parameters
typedef VOID ( CALLBACK * PFN_SC_NOTIFY_CALLBACK ) ( PVOID pParameter );

//  Each new notify structure is a superset of the older version
typedef struct _SERVICE_NOTIFY_1 {
    DWORD                   dwVersion;
    PFN_SC_NOTIFY_CALLBACK  pfnNotifyCallback;
    PVOID                   pContext;
    DWORD                   dwNotificationStatus;
    SERVICE_STATUS_PROCESS  ServiceStatus;
} SERVICE_NOTIFY_1, *PSERVICE_NOTIFY_1;

typedef struct _SERVICE_NOTIFY_2A {
    DWORD                   dwVersion;
    PFN_SC_NOTIFY_CALLBACK  pfnNotifyCallback;
    PVOID                   pContext;
    DWORD                   dwNotificationStatus;
    SERVICE_STATUS_PROCESS  ServiceStatus;
    DWORD                   dwNotificationTriggered;
    LPSTR                   pszServiceNames;
} SERVICE_NOTIFY_2A, *PSERVICE_NOTIFY_2A;
typedef struct _SERVICE_NOTIFY_2W {
    DWORD                   dwVersion;
    PFN_SC_NOTIFY_CALLBACK  pfnNotifyCallback;
    PVOID                   pContext;
    DWORD                   dwNotificationStatus;
    SERVICE_STATUS_PROCESS  ServiceStatus;
    DWORD                   dwNotificationTriggered;
    LPWSTR                  pszServiceNames;
} SERVICE_NOTIFY_2W, *PSERVICE_NOTIFY_2W;
#ifdef UNICODE
typedef SERVICE_NOTIFY_2W SERVICE_NOTIFY_2;
typedef PSERVICE_NOTIFY_2W PSERVICE_NOTIFY_2;
#else
typedef SERVICE_NOTIFY_2A SERVICE_NOTIFY_2;
typedef PSERVICE_NOTIFY_2A PSERVICE_NOTIFY_2;
#endif // UNICODE

typedef SERVICE_NOTIFY_2A SERVICE_NOTIFYA, *PSERVICE_NOTIFYA;
typedef SERVICE_NOTIFY_2W SERVICE_NOTIFYW, *PSERVICE_NOTIFYW;
#ifdef UNICODE
typedef SERVICE_NOTIFYW SERVICE_NOTIFY;
typedef PSERVICE_NOTIFYW PSERVICE_NOTIFY;
#else
typedef SERVICE_NOTIFYA SERVICE_NOTIFY;
typedef PSERVICE_NOTIFYA PSERVICE_NOTIFY;
#endif // UNICODE

typedef ULONG_PTR HCRYPTPROV;
typedef ULONG_PTR HCRYPTKEY;
typedef ULONG_PTR HCRYPTHASH;
typedef unsigned int ALG_ID;
typedef ULONG64 TRACEHANDLE, *PTRACEHANDLE;

//#define DECLARE_HANDLE(name) struct name##__{int unused;}; typedef struct name##__ *name

DECLARE_HANDLE(SAFER_LEVEL_HANDLE);

typedef struct _WNODE_HEADER
{
    ULONG BufferSize;        // Size of entire buffer inclusive of this ULONG
    ULONG ProviderId;    // Provider Id of driver returning this buffer
    union
    {
        ULONG64 HistoricalContext;  // Logger use
        struct
            {
            ULONG Version;           // Reserved
            ULONG Linkage;           // Linkage field reserved for WMI
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;

    union
    {
        ULONG CountLost;         // Reserved
        HANDLE KernelHandle;     // Kernel handle for data block
        LARGE_INTEGER TimeStamp; // Timestamp as returned in units of 100ns
                                 // since 1/1/1601
    } DUMMYUNIONNAME2;
    GUID Guid;                  // Guid for data block returned with results
    ULONG ClientContext;
    ULONG Flags;             // Flags, see below
} WNODE_HEADER, *PWNODE_HEADER;


typedef struct _EVENT_TRACE_PROPERTIES
{
    WNODE_HEADER Wnode;
//
// data provided by caller
    ULONG BufferSize;                   // buffer size for logging (kbytes)
    ULONG MinimumBuffers;               // minimum to preallocate
    ULONG MaximumBuffers;               // maximum buffers allowed
    ULONG MaximumFileSize;              // maximum logfile size (in MBytes)
    ULONG LogFileMode;                  // sequential, circular
    ULONG FlushTimer;                   // buffer flush timer, in seconds
    ULONG EnableFlags;                  // trace enable flags
    LONG  AgeLimit;                     // unused

// data returned to caller
    ULONG NumberOfBuffers;              // no of buffers in use
    ULONG FreeBuffers;                  // no of buffers free
    ULONG EventsLost;                   // event records lost
    ULONG BuffersWritten;               // no of buffers written to file
    ULONG LogBuffersLost;               // no of logfile write failures
    ULONG RealTimeBuffersLost;          // no of rt delivery failures
    HANDLE LoggerThreadId;              // thread id of Logger
    ULONG LogFileNameOffset;            // Offset to LogFileName
    ULONG LoggerNameOffset;             // Offset to LoggerName
} EVENT_TRACE_PROPERTIES, *PEVENT_TRACE_PROPERTIES;

typedef struct EVENT_INSTANCE_INFO
{
    HANDLE      RegHandle;
    ULONG       InstanceId;
} EVENT_INSTANCE_INFO, *PEVENT_INSTANCE_INFO;

typedef struct _TRACE_GUID_PROPERTIES
{
    GUID    Guid;
    ULONG   GuidType;
    ULONG   LoggerId;
    ULONG   EnableLevel;
    ULONG   EnableFlags;
    BOOLEAN IsEnable;
} TRACE_GUID_PROPERTIES, *PTRACE_GUID_PROPERTIES;

typedef struct _ETW_BUFFER_CONTEXT
{
    UCHAR   ProcessorNumber;
    UCHAR   Alignment;
    USHORT  LoggerId;
} ETW_BUFFER_CONTEXT, *PETW_BUFFER_CONTEXT;

// Trace header for all legacy events.
typedef struct _EVENT_TRACE_HEADER {        // overlays WNODE_HEADER
    USHORT          Size;                   // Size of entire record
    union {
        USHORT      FieldTypeFlags;         // Indicates valid fields
        struct {
            UCHAR   HeaderType;             // Header type - internal use only
            UCHAR   MarkerFlags;            // Marker - internal use only
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
    union {
        ULONG       Version;
        struct {
            UCHAR   Type;                   // event type
            UCHAR   Level;                  // trace instrumentation level
            USHORT  Version;                // version of trace record
        } Class;
    } DUMMYUNIONNAME2;
    ULONG           ThreadId;               // Thread Id
    ULONG           ProcessId;              // Process Id
    LARGE_INTEGER   TimeStamp;              // time when event happens
    union {
        GUID        Guid;                   // Guid that identifies event
        ULONGLONG   GuidPtr;                // use with WNODE_FLAG_USE_GUID_PTR
    } DUMMYUNIONNAME3;
    union {
        struct {
            ULONG   KernelTime;             // Kernel Mode CPU ticks
            ULONG   UserTime;               // User mode CPU ticks
        } DUMMYSTRUCTNAME;
        ULONG64     ProcessorTime;          // Processor Clock
        struct {
            ULONG   ClientContext;          // Reserved
            ULONG   Flags;                  // Event Flags
        } DUMMYSTRUCTNAME2;
    } DUMMYUNIONNAME4;
} EVENT_TRACE_HEADER, *PEVENT_TRACE_HEADER;

typedef struct _EVENT_TRACE
{
    EVENT_TRACE_HEADER      Header;             // Event trace header
    ULONG                   InstanceId;         // Instance Id of this event
    ULONG                   ParentInstanceId;   // Parent Instance Id.
    GUID                    ParentGuid;         // Parent Guid;
    PVOID                   MofData;            // Pointer to Variable Data
    ULONG                   MofLength;          // Variable Datablock Length
    union {
        ULONG               ClientContext;
        ETW_BUFFER_CONTEXT  BufferContext;
    } DUMMYUNIONNAME;
} EVENT_TRACE, *PEVENT_TRACE;

typedef struct _EVENT_TRACE_LOGFILEW
                EVENT_TRACE_LOGFILEW, *PEVENT_TRACE_LOGFILEW;

typedef struct _EVENT_TRACE_LOGFILEA
                EVENT_TRACE_LOGFILEA, *PEVENT_TRACE_LOGFILEA;

typedef ULONG (WINAPI * PEVENT_TRACE_BUFFER_CALLBACKW)(PEVENT_TRACE_LOGFILEW Logfile);

typedef ULONG (WINAPI * PEVENT_TRACE_BUFFER_CALLBACKA)
                (PEVENT_TRACE_LOGFILEA Logfile);

typedef VOID (WINAPI *PEVENT_CALLBACK)( PEVENT_TRACE pEvent );

typedef struct _EVENT_RECORD
                EVENT_RECORD, *PEVENT_RECORD;

typedef VOID (WINAPI *PEVENT_RECORD_CALLBACK) (PEVENT_RECORD EventRecord);

typedef struct _TRACE_LOGFILE_HEADER {
    ULONG           BufferSize;         // Logger buffer size in Kbytes
    union {
        ULONG       Version;            // Logger version
        struct {
            UCHAR   MajorVersion;
            UCHAR   MinorVersion;
            UCHAR   SubVersion;
            UCHAR   SubMinorVersion;
        } VersionDetail;
    } DUMMYUNIONNAME;
    ULONG           ProviderVersion;    // defaults to NT version
    ULONG           NumberOfProcessors; // Number of Processors
    LARGE_INTEGER   EndTime;            // Time when logger stops
    ULONG           TimerResolution;    // assumes timer is constant!!!
    ULONG           MaximumFileSize;    // Maximum in Mbytes
    ULONG           LogFileMode;        // specify logfile mode
    ULONG           BuffersWritten;     // used to file start of Circular File
    union {
        GUID LogInstanceGuid;           // For RealTime Buffer Delivery
        struct {
            ULONG   StartBuffers;       // Count of buffers written at start.
            ULONG   PointerSize;        // Size of pointer type in bits
            ULONG   EventsLost;         // Events losts during log session
            ULONG   CpuSpeedInMHz;      // Cpu Speed in MHz
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME2;
#if defined(_WMIKM_)
    PWCHAR          LoggerName;
    PWCHAR          LogFileName;
    RTL_TIME_ZONE_INFORMATION TimeZone;
#else
    LPWSTR          LoggerName;
    LPWSTR          LogFileName;
    TIME_ZONE_INFORMATION TimeZone;
#endif
    LARGE_INTEGER   BootTime;
    LARGE_INTEGER   PerfFreq;           // Reserved
    LARGE_INTEGER   StartTime;          // Reserved
    ULONG           ReservedFlags;      // ClockType
    ULONG           BuffersLost;
} TRACE_LOGFILE_HEADER, *PTRACE_LOGFILE_HEADER;

struct _EVENT_TRACE_LOGFILEW {
    LPWSTR                  LogFileName;      // Logfile Name
    LPWSTR                  LoggerName;       // LoggerName
    LONGLONG                CurrentTime;      // timestamp of last event
    ULONG                   BuffersRead;      // buffers read to date
    union {
        // Mode of the logfile
        ULONG               LogFileMode;
        // Processing flags used on Vista and above
        ULONG               ProcessTraceMode;
    } DUMMYUNIONNAME;
    EVENT_TRACE             CurrentEvent;     // Current Event from this stream.
    TRACE_LOGFILE_HEADER    LogfileHeader;    // logfile header structure
    PEVENT_TRACE_BUFFER_CALLBACKW             // callback before each buffer
                            BufferCallback;   // is read
    //
    // following variables are filled for BufferCallback.
    //
    ULONG                   BufferSize;
    ULONG                   Filled;
    ULONG                   EventsLost;
    //
    // following needs to be propaged to each buffer
    //
    union {
        // Callback with EVENT_TRACE
        PEVENT_CALLBACK         EventCallback;
        // Callback with EVENT_RECORD on Vista and above
        PEVENT_RECORD_CALLBACK  EventRecordCallback;
    } DUMMYUNIONNAME2;

    ULONG                   IsKernelTrace;    // TRUE for kernel logfile

    PVOID                   Context;          // reserved for internal use
};

struct _EVENT_TRACE_LOGFILEA
{
    LPSTR                   LogFileName;      // Logfile Name
    LPSTR                   LoggerName;       // LoggerName
    LONGLONG                CurrentTime;      // timestamp of last event
    ULONG                   BuffersRead;      // buffers read to date
    union {
        ULONG               LogFileMode;      // Mode of the logfile
        ULONG               ProcessTraceMode; // Processing flags
    } DUMMYUNIONNAME;
    EVENT_TRACE             CurrentEvent;     // Current Event from this stream
    TRACE_LOGFILE_HEADER    LogfileHeader;    // logfile header structure
    PEVENT_TRACE_BUFFER_CALLBACKA             // callback before each buffer
                            BufferCallback;   // is read

    //
    // following variables are filled for BufferCallback.
    //
    ULONG                   BufferSize;
    ULONG                   Filled;
    ULONG                   EventsLost;
    //
    // following needs to be propaged to each buffer
    //
    union {
        PEVENT_CALLBACK         EventCallback;  // callback for every event
        PEVENT_RECORD_CALLBACK  EventRecordCallback;
    } DUMMYUNIONNAME2;


    ULONG                   IsKernelTrace;  // TRUE for kernel logfile

    PVOID                   Context;        // reserved for internal use
};



#if defined(_UNICODE) || defined(UNICODE)

#define PEVENT_TRACE_BUFFER_CALLBACK    PEVENT_TRACE_BUFFER_CALLBACKW
#define EVENT_TRACE_LOGFILE             EVENT_TRACE_LOGFILEW
#define PEVENT_TRACE_LOGFILE            PEVENT_TRACE_LOGFILEW
#define KERNEL_LOGGER_NAME              KERNEL_LOGGER_NAMEW
#define GLOBAL_LOGGER_NAME              GLOBAL_LOGGER_NAMEW
#define EVENT_LOGGER_NAME               EVENT_LOGGER_NAMEW

#else

#define PEVENT_TRACE_BUFFER_CALLBACK    PEVENT_TRACE_BUFFER_CALLBACKA
#define EVENT_TRACE_LOGFILE             EVENT_TRACE_LOGFILEA
#define PEVENT_TRACE_LOGFILE            PEVENT_TRACE_LOGFILEA
#define KERNEL_LOGGER_NAME              KERNEL_LOGGER_NAMEA
#define GLOBAL_LOGGER_NAME              GLOBAL_LOGGER_NAMEA
#define EVENT_LOGGER_NAME               EVENT_LOGGER_NAMEA

#endif

// WMI request codes
typedef enum
{
#ifndef _WMIKM_
    WMI_GET_ALL_DATA = 0,
    WMI_GET_SINGLE_INSTANCE = 1,
    WMI_SET_SINGLE_INSTANCE = 2,
    WMI_SET_SINGLE_ITEM = 3,
    WMI_ENABLE_EVENTS = 4,
    WMI_DISABLE_EVENTS  = 5,
    WMI_ENABLE_COLLECTION = 6,
    WMI_DISABLE_COLLECTION = 7,
    WMI_REGINFO = 8,
    WMI_EXECUTE_METHOD = 9,
    WMI_CAPTURE_STATE = 10
#endif
} WMIDPREQUESTCODE;


typedef ULONG (
#ifndef MIDL_PASS
WINAPI
#endif
*WMIDPREQUEST)(
    WMIDPREQUESTCODE RequestCode,
    PVOID RequestContext,
    ULONG *BufferSize,
    PVOID Buffer
    );

typedef struct  _TRACE_GUID_REGISTRATION
{
    LPCGUID Guid;            // Guid of data block being registered or updated.
    HANDLE RegHandle;        // Guid Registration Handle is returned.
} TRACE_GUID_REGISTRATION, *PTRACE_GUID_REGISTRATION;


// This header is used to trace and track transaction co-relations
typedef struct _EVENT_INSTANCE_HEADER
{
    USHORT          Size;
    union {
        USHORT      FieldTypeFlags;     // Indicates valid fields
        struct {
            UCHAR   HeaderType;         // Header type - internal use only
            UCHAR   MarkerFlags;        // Marker - internal use only
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
    union {
        ULONG       Version;
        struct {
            UCHAR   Type;
            UCHAR   Level;
            USHORT  Version;
        } Class;
    } DUMMYUNIONNAME2;
    ULONG           ThreadId;
    ULONG           ProcessId;
    LARGE_INTEGER   TimeStamp;
    ULONGLONG       RegHandle;
    ULONG           InstanceId;
    ULONG           ParentInstanceId;
    union {
        struct {
            ULONG   KernelTime;             // Kernel Mode CPU ticks
            ULONG   UserTime;               // User mode CPU ticks
        } DUMMYSTRUCTNAME;
        ULONG64     ProcessorTime;          // Processor Clock
        struct {
            ULONG   EventId;                // Event ID
            ULONG   Flags;                  // Trace header Flags
        } DUMMYSTRUCTNAME2;
    } DUMMYUNIONNAME3;
    ULONGLONG       ParentRegHandle;
} EVENT_INSTANCE_HEADER, *PEVENT_INSTANCE_HEADER;

typedef struct tagSERIALIZEDPROPERTYVALUE
{
    DWORD	dwType;
    BYTE	rgb[1];
} SERIALIZEDPROPERTYVALUE;


typedef struct addrinfoW
{
    int                 ai_flags;       // AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST
    int                 ai_family;      // PF_xxx
    int                 ai_socktype;    // SOCK_xxx
    int                 ai_protocol;    // 0 or IPPROTO_xxx for IPv4 and IPv6
    size_t              ai_addrlen;     // Length of ai_addr
    PWSTR               ai_canonname;   // Canonical name for nodename
    struct sockaddr *   ai_addr;        // Binary address
    struct addrinfoW *  ai_next;        // Next structure in linked list
}
ADDRINFOW, *PADDRINFOW;

#if		( _WIN32_WINNT >= 0x0600 )
typedef struct addrinfoexA
{
    int                 ai_flags;       // AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST
    int                 ai_family;      // PF_xxx
    int                 ai_socktype;    // SOCK_xxx
    int                 ai_protocol;    // 0 or IPPROTO_xxx for IPv4 and IPv6
    size_t              ai_addrlen;     // Length of ai_addr
    char               *ai_canonname;   // Canonical name for nodename
    struct sockaddr    *ai_addr;        // Binary address
    void               *ai_blob;
    size_t              ai_bloblen;
    LPGUID              ai_provider;
    struct addrinfoexA *ai_next;        // Next structure in linked list
} ADDRINFOEXA, *PADDRINFOEXA, *LPADDRINFOEXA;

typedef struct addrinfoexW
{
    int                 ai_flags;       // AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST
    int                 ai_family;      // PF_xxx
    int                 ai_socktype;    // SOCK_xxx
    int                 ai_protocol;    // 0 or IPPROTO_xxx for IPv4 and IPv6
    size_t              ai_addrlen;     // Length of ai_addr
    PWSTR               ai_canonname;   // Canonical name for nodename
    struct sockaddr    *ai_addr;        // Binary address
    void               *ai_blob;
    size_t              ai_bloblen;
    LPGUID              ai_provider;
    struct addrinfoexW *ai_next;        // Next structure in linked list
} ADDRINFOEXW, *PADDRINFOEXW, *LPADDRINFOEXW;

#ifdef UNICODE
typedef ADDRINFOEXW     ADDRINFOEX, *PADDRINFOEX;
#else
typedef ADDRINFOEXA     ADDRINFOEX, *PADDRINFOEX;
#endif

#endif

typedef void ( CALLBACK * LPLOOKUPSERVICE_COMPLETION_ROUTINE)( DWORD dwError, DWORD dwBytes, LPWSAOVERLAPPED lpOverlapped );

typedef struct _WSAQuerySet2A
{
    DWORD           dwSize;
    LPSTR           lpszServiceInstanceName;
    LPWSAVERSION    lpVersion;
    LPSTR           lpszComment;
    DWORD           dwNameSpace;
    LPGUID          lpNSProviderId;
    LPSTR           lpszContext;
    DWORD           dwNumberOfProtocols;
    LPAFPROTOCOLS   lpafpProtocols;
    LPSTR           lpszQueryString;
    DWORD           dwNumberOfCsAddrs;
    LPCSADDR_INFO   lpcsaBuffer;
    DWORD           dwOutputFlags;
    LPBLOB          lpBlob;
} WSAQUERYSET2A, *PWSAQUERYSET2A, *LPWSAQUERYSET2A;
typedef struct _WSAQuerySet2W
{
    DWORD           dwSize;
    LPWSTR          lpszServiceInstanceName;
    LPWSAVERSION    lpVersion;
    LPWSTR          lpszComment;
    DWORD           dwNameSpace;
    LPGUID          lpNSProviderId;
    LPWSTR          lpszContext;
    DWORD           dwNumberOfProtocols;
    LPAFPROTOCOLS   lpafpProtocols;
    LPWSTR          lpszQueryString;
    DWORD           dwNumberOfCsAddrs;
    LPCSADDR_INFO   lpcsaBuffer;
    DWORD           dwOutputFlags;
    LPBLOB          lpBlob;
} WSAQUERYSET2W, *PWSAQUERYSET2W, *LPWSAQUERYSET2W;

typedef INT (WSAAPI * LPNSPV2STARTUP)(
    LPGUID lpProviderId,
    LPVOID * ppvClientSessionArg
    );

typedef INT (WSAAPI * LPNSPV2CLEANUP)(
    LPGUID lpProviderId,
    LPVOID pvClientSessionArg
    );

typedef INT (WSAAPI * LPNSPV2LOOKUPSERVICEBEGIN)(
    LPGUID lpProviderId,
    LPWSAQUERYSET2W lpqsRestrictions,
    DWORD dwControlFlags,
    LPVOID lpvClientSessionArg,
    LPHANDLE lphLookup
    );

typedef VOID (WSAAPI * LPNSPV2LOOKUPSERVICENEXTEX)(
    HANDLE hAsyncCall,
    HANDLE hLookup,
    DWORD dwControlFlags,
    LPDWORD lpdwBufferLength,
    LPWSAQUERYSET2W lpqsResults
    );

typedef
INT
(WSAAPI * LPNSPV2LOOKUPSERVICEEND)(
    HANDLE hLookup
    );

typedef VOID (WSAAPI * LPNSPV2SETSERVICEEX)(
    HANDLE hAsyncCall,
    LPGUID lpProviderId,
    LPWSAQUERYSET2W lpqsRegInfo,
    WSAESETSERVICEOP essOperation,
    DWORD dwControlFlags,
    LPVOID lpvClientSessionArg
    );

typedef VOID (WSAAPI * LPNSPV2CLIENTSESSIONRUNDOWN)(
    LPGUID lpProviderId,
    LPVOID pvClientSessionArg
    );

typedef struct _NSPV2_ROUTINE
{
    DWORD cbSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    LPNSPV2STARTUP NSPv2Startup;
    LPNSPV2CLEANUP NSPv2Cleanup;
    LPNSPV2LOOKUPSERVICEBEGIN NSPv2LookupServiceBegin;
    LPNSPV2LOOKUPSERVICENEXTEX NSPv2LookupServiceNextEx;
    LPNSPV2LOOKUPSERVICEEND NSPv2LookupServiceEnd;
    LPNSPV2SETSERVICEEX NSPv2SetServiceEx;
    LPNSPV2CLIENTSESSIONRUNDOWN NSPv2ClientSessionRundown;
} NSPV2_ROUTINE, *PNSPV2_ROUTINE, *LPNSPV2_ROUTINE;
typedef const NSPV2_ROUTINE * PCNSPV2_ROUTINE, * LPCNSPV2_ROUTINE;

typedef LPSOCKET_ADDRESS_LIST PSOCKET_ADDRESS_LIST;

typedef struct _WSANAMESPACE_INFOEXA
{
    GUID                NSProviderId;
    DWORD               dwNameSpace;
    BOOL                fActive;
    DWORD               dwVersion;
    LPSTR               lpszIdentifier;
    BLOB                ProviderSpecific;
} WSANAMESPACE_INFOEXA, *PWSANAMESPACE_INFOEXA, *LPWSANAMESPACE_INFOEXA;

typedef struct _WSANAMESPACE_INFOEXW
{
    GUID                NSProviderId;
    DWORD               dwNameSpace;
    BOOL                fActive;
    DWORD               dwVersion;
    LPWSTR              lpszIdentifier;
    BLOB                ProviderSpecific;
} WSANAMESPACE_INFOEXW, *PWSANAMESPACE_INFOEXW, *LPWSANAMESPACE_INFOEXW;

#ifdef UNICODE
typedef WSANAMESPACE_INFOEXW WSANAMESPACE_INFOEX;
typedef PWSANAMESPACE_INFOEXW PWSANAMESPACE_INFOEX;
typedef LPWSANAMESPACE_INFOEXW LPWSANAMESPACE_INFOEX;
#else
typedef WSANAMESPACE_INFOEXA WSANAMESPACE_INFOEX;
typedef PWSANAMESPACE_INFOEXA PWSANAMESPACE_INFOEX;
typedef LPWSANAMESPACE_INFOEXA LPWSANAMESPACE_INFOEX;
#endif /* UNICODE */

#if(_WIN32_WINNT >= 0x0600)
typedef enum _WSC_PROVIDER_INFO_TYPE
{
//  InfoType is:                  Info points to:
    ProviderInfoLspCategories, // DWORD (LspCategories)
    ProviderInfoAudit,         // struct WSC_PROVIDER_AUDIT_INFO
} WSC_PROVIDER_INFO_TYPE ;
#endif

#define INVALID_PROCESSTRACE_HANDLE ((TRACEHANDLE)INVALID_HANDLE_VALUE)

// Shutdown flags
#define SHUTDOWN_FORCE_OTHERS           0x00000001
#define SHUTDOWN_FORCE_SELF             0x00000002
#define SHUTDOWN_RESTART                0x00000004
#define SHUTDOWN_POWEROFF               0x00000008
#define SHUTDOWN_NOREBOOT               0x00000010
#define SHUTDOWN_GRACE_OVERRIDE         0x00000020
#define SHUTDOWN_INSTALL_UPDATES        0x00000040
#define SHUTDOWN_RESTARTAPPS            0x00000080
#define SHUTDOWN_SKIP_SVC_PRESHUTDOWN   0x00000100

typedef enum tagTYSPEC
{	TYSPEC_CLSID	= 0,
	TYSPEC_FILEEXT	= ( TYSPEC_CLSID + 1 ) ,
	TYSPEC_MIMETYPE	= ( TYSPEC_FILEEXT + 1 ) ,
	TYSPEC_FILENAME	= ( TYSPEC_MIMETYPE + 1 ) ,
	TYSPEC_PROGID	= ( TYSPEC_FILENAME + 1 ) ,
	TYSPEC_PACKAGENAME	= ( TYSPEC_PROGID + 1 ) ,
	TYSPEC_OBJECTID	= ( TYSPEC_PACKAGENAME + 1 )
}TYSPEC;

#endif//_WINQAPI_MINGW32_H_

#ifdef UNICODE
#	define RegDeleteKeyEx RegDeleteKeyExW
#else
#	define RegDeleteKeyEx RegDeleteKeyExA
#endif

