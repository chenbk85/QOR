//kFileManagement.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQAPI/Kernel32.h"
#include "../SystemQOR/MSWindows/WinQAPI/include/ReturnCheck.h"

//--------------------------------------------------------------------------------
namespace nsWinQAPI
{
	//--------------------------------------------------------------------------------
	BOOL CKernel32::AreFileApisANSI(void)
	{
		_WINQ_SFCONTEXT( "CKernel32::AreFileApisANSI" );
		return ::AreFileApisANSI();
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::CancelIo( HANDLE hFile )
	{
		_WINQ_SFCONTEXT( "CKernel32::CancelIo" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::CancelIo( hFile );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::CancelIoEx( HANDLE hFile, ::LPOVERLAPPED lpOverlapped )
	{
		_WINQ_SFCONTEXT( "CKernel32::CancelIoEx" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
		_WINQ_USESAPI( CancelIoEx );
		bResult = Call< BOOL, HANDLE, ::LPOVERLAPPED >( pFunc, hFile, lpOverlapped );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::CancelSynchronousIo( HANDLE hThread )
	{
		_WINQ_SFCONTEXT( "CKernel32::CancelSynchronousIo" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
		_WINQ_USESAPI( CancelSynchronousIo );
		bResult = Call< BOOL, HANDLE >( pFunc, hThread );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::CheckNameLegalDOS8Dot3( LPCTSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal )
	{
		_WINQ_SFCONTEXT( "CKernel32::CheckNameLegalDOS8Dot3" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#if ( _WIN32_WINNT >= 0x0501 )
		bResult = ::CheckNameLegalDOS8Dot3( lpName, lpOemName, OemNameSize, pbNameContainsSpaces, pbNameLegal );
#else
		__QCMP_UNREF4( pbNameLegal, pbNameContainsSpaces, OemNameSize, lpOemName );
		QOR_PP_UNREF( lpName );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CheckNameLegalDOS8Dot3" ), _T( "Windows XP Serivice Pack 1" ), 0 ));
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::CopyFile( LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, BOOL bFailIfExists )
	{
		_WINQ_SFCONTEXT( "CKernel32::CopyFile" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::CopyFile( lpExistingFileName, lpNewFileName, bFailIfExists );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::CopyFileEx( LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, ::LPPROGRESS_ROUTINE lpProgressRoutine, void* lpData, LPBOOL pbCancel, DWORD dwCopyFlags )
	{
		_WINQ_SFCONTEXT( "CKernel32::CopyFileEx" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0500 )
		bResult = ::CopyFileEx( lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags );
#	else
		__QCMP_UNREF4( dwCopyFlags, pbCancel, lpData, lpProgressRoutine );
		QOR_PP_UNREF( lpNewFileName );
		QOR_PP_UNREF( lpExistingFileName );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CopyFileEx" ), _T( "Windows 2000" ), 0 ));
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::CopyFileTransacted( LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, ::LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction )
	{
		_WINQ_SFCONTEXT( "CKernel32::CopyFileTransacted" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0600 )
        _WINQ_USESAPI( CopyFileTransacted );
		bResult = Call< BOOL, LPCTSTR, LPCTSTR, ::LPPROGRESS_ROUTINE, LPVOID, LPBOOL, DWORD, HANDLE >( pFunc, lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags, hTransaction );
#	else
		QOR_PP_UNREF4( hTransaction, dwCopyFlags, pbCancel, lpData );
		QOR_PP_UNREF3( lpProgressRoutine, lpNewFileName, lpExistingFileName );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CopyFileTransacted" ), _T( "Windows Vista" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	HANDLE CKernel32::CreateFileA( LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateFileA" );
		CCheckReturn< HANDLE, CHandleCheck< > >::TType h = ::CreateFileA( lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile );
		return h;
	}

	//--------------------------------------------------------------------------------
	HANDLE CKernel32::CreateFileW( LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateFileW" );
		CCheckReturn< HANDLE, CHandleCheck< > >::TType h = ::CreateFileW( lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile );
		return h;
	}

	//--------------------------------------------------------------------------------
	HANDLE CKernel32::CreateFileTransacted( LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, PVOID pExtendedParameter )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateFileTransacted" );
		CCheckReturn< HANDLE, CHandleCheck< > >::TType h;
#	if ( _WIN32_WINNT >= 0x0600 )
        _WINQ_USESAPI( CreateFileTransacted );
		h = Call< HANDLE, LPCTSTR, DWORD, DWORD, ::LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE, HANDLE, PUSHORT, PVOID >( pFunc, lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile, hTransaction, pusMiniVersion, pExtendedParameter );
#	else
		QOR_PP_UNREF( pExtendedParameter );
		QOR_PP_UNREF( pusMiniVersion );
		QOR_PP_UNREF( hTransaction );
		QOR_PP_UNREF( hTemplateFile );
		QOR_PP_UNREF( dwFlagsAndAttributes );
		QOR_PP_UNREF( dwCreationDisposition );
		QOR_PP_UNREF( lpSecurityAttributes );
		QOR_PP_UNREF( dwShareMode );
		QOR_PP_UNREF( dwDesiredAccess );
		QOR_PP_UNREF( lpFileName );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CreateFileTransacted" ), _T( "Windows Vista" ), 0 ));
#	endif
		return h;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::CreateHardLink( LPCTSTR lpFileName, LPCTSTR lpExistingFileName, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateHardLink" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0500 )
		bResult = ::CreateHardLink( lpFileName, lpExistingFileName, lpSecurityAttributes );
#	else
		QOR_PP_UNREF( lpSecurityAttributes );
		QOR_PP_UNREF( lpExistingFileName );
		QOR_PP_UNREF( lpFileName );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CreateHardLink" ), _T( "Windows 2000" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::CreateHardLinkTransacted( LPCTSTR lpFileName, LPCTSTR lpExistingFileName, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateHardLinkTransacted" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0600 )
        _WINQ_USESAPI( CreateHardLinkTransacted );
		bResult = Call< BOOL, LPCTSTR, LPCTSTR, ::LPSECURITY_ATTRIBUTES, HANDLE >( pFunc, lpFileName, lpExistingFileName, lpSecurityAttributes, hTransaction );
#	else
		QOR_PP_UNREF( hTransaction );
		QOR_PP_UNREF( lpSecurityAttributes );
		QOR_PP_UNREF( lpExistingFileName );
		QOR_PP_UNREF( lpFileName );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CreateHardLinkTransacted" ), _T( "Windows Vista" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	HANDLE CKernel32::CreateIoCompletionPort( HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateIoCompletionPort" );
		CCheckReturn< HANDLE, CHandleNullCheck< > >::TType h = ::CreateIoCompletionPort( FileHandle, ExistingCompletionPort, CompletionKey, NumberOfConcurrentThreads );
		return h;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::CreateSymbolicLink( LPCTSTR lpSymlinkFileName, LPCTSTR lpTargetFileName, DWORD dwFlags )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateSymbolicLink" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0600 )
		bResult = ::CreateSymbolicLink( lpSymlinkFileName, lpTargetFileName, dwFlags );
#	else
		QOR_PP_UNREF( dwFlags );
		QOR_PP_UNREF( lpTargetFileName );
		QOR_PP_UNREF( lpSymlinkFileName );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CreateSymbolicLink" ), _T( "Windows Vista" ), 0 ));
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::CreateSymbolicLinkTransacted( LPCTSTR lpSymlinkFileName, LPCTSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateSymbolicLinkTransacted" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0600 )
        _WINQ_USESAPI( CreateSymbolicLinkTransacted );
		bResult = Call< BOOL, LPCTSTR, LPCTSTR, DWORD, HANDLE >( pFunc, lpSymlinkFileName, lpTargetFileName, dwFlags, hTransaction );
#	else
		QOR_PP_UNREF( hTransaction );
		QOR_PP_UNREF( dwFlags );
		QOR_PP_UNREF( lpTargetFileName );
		QOR_PP_UNREF( lpSymlinkFileName );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CreateSymbolicLinkTransacted" ), _T( "Windows Vista" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::DeleteFile( LPCTSTR lpFileName )
	{
		_WINQ_SFCONTEXT( "CKernel32::DeleteFile" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
		bResult = ::DeleteFile( lpFileName );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::DeleteFileTransacted( LPCTSTR lpFileName, HANDLE hTransaction )
	{
		_WINQ_SFCONTEXT( "CKernel32::DeleteFileTransacted" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0600 )
        _WINQ_USESAPI( DeleteFileTransacted );
		bResult = Call< BOOL, LPCTSTR, HANDLE >( pFunc, lpFileName, hTransaction );
#	else
		QOR_PP_UNREF( hTransaction );
		QOR_PP_UNREF( lpFileName );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "DeleteFileTransacted" ), _T( "Windows Vista" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::FindClose( HANDLE hFindFile )
	{
		_WINQ_SFCONTEXT( "CKernel32::FindClose" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::FindClose( hFindFile );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	HANDLE CKernel32::FindFirstFile( LPCTSTR lpFileName, ::LPWIN32_FIND_DATA lpFindFileData )
	{
		_WINQ_SFCONTEXT( "CKernel32::FindFirstFile" );
		CCheckReturn< HANDLE, CHandleCheck< > >::TType h = ::FindFirstFile( lpFileName, lpFindFileData );
		return h;
	}

	//--------------------------------------------------------------------------------
	HANDLE CKernel32::FindFirstFileEx( LPCTSTR lpFileName, ::FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, ::FINDEX_SEARCH_OPS fSearchOp, void* lpSearchFilter, DWORD dwAdditionalFlags )
	{
		_WINQ_SFCONTEXT( "CKernel32::FindFirstFileEx" );
		CCheckReturn< HANDLE, CHandleCheck< > >::TType h;
#	if ( _WIN32_WINNT >= 0x0400 )
		h = ::FindFirstFileEx( lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags );
#	else
		QOR_PP_UNREF( dwAdditionalFlags );
		QOR_PP_UNREF( lpSearchFilter );
		QOR_PP_UNREF( fSearchOp );
		QOR_PP_UNREF( lpFindFileData );
		QOR_PP_UNREF( fInfoLevelId );
		QOR_PP_UNREF( lpFileName );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _TXT ( "FindFirstFileEx" ), _T( "Windows NT 4.0" ), 0 ));
#	endif
		return h;
	}

	//--------------------------------------------------------------------------------
	HANDLE CKernel32::FindFirstFileNameTransactedW( LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWCHAR LinkName, HANDLE hTransaction )
	{
		_WINQ_SFCONTEXT( "CKernel32::FindFirstFileNameTransactedW" );
		CCheckReturn< HANDLE, CHandleCheck< > >::TType h;
#	if ( _WIN32_WINNT >= 0x0600 )
        _WINQ_USESAPI( FindFirstFileNameTransactedW );
		h = Call< HANDLE, LPCWSTR, DWORD, LPDWORD, PWCHAR, HANDLE >( pFunc, lpFileName, dwFlags, StringLength, LinkName, hTransaction );
#	else
		QOR_PP_UNREF( hTransaction );
		QOR_PP_UNREF( LinkName );
		QOR_PP_UNREF( StringLength );
		QOR_PP_UNREF( dwFlags );
		QOR_PP_UNREF( lpFileName );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _CTXT ( "FindFirstFileNameTransactedW" ), _T( "Windows Vista" ), 0 ));
#	endif
		return h;
	}

	//--------------------------------------------------------------------------------
	HANDLE CKernel32::FindFirstFileNameW( LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWCHAR LinkName )
	{
		_WINQ_SFCONTEXT( "CKernel32::FindFirstFileNameW" );
		CCheckReturn< HANDLE, CHandleCheck< > >::TType h;
#	if ( _WIN32_WINNT >= 0x0600 )
        _WINQ_USESAPI( FindFirstFileNameW );
		h = Call< HANDLE, LPCWSTR, DWORD, LPDWORD, PWCHAR >( pFunc, lpFileName, dwFlags, StringLength, LinkName );
#	else
		QOR_PP_UNREF( LinkName );
		QOR_PP_UNREF( StringLength );
		QOR_PP_UNREF( dwFlags );
		QOR_PP_UNREF( lpFileName );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _CTXT ( "FindFirstFileNameW" ), _T( "Windows Vista" ), 0 ));
#	endif
		return h;
	}

	//--------------------------------------------------------------------------------
	HANDLE CKernel32::FindFirstFileTransacted( LPCTSTR lpFileName, ::FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, ::FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, HANDLE hTransaction )
	{
		_WINQ_SFCONTEXT( "CKernel32::FindFirstFileTransacted" );
		CCheckReturn< HANDLE, CHandleCheck< > >::TType h;
#	if ( _WIN32_WINNT >= 0x0600 )
        _WINQ_USESAPI( FindFirstFileTransacted );
		h = Call< HANDLE, LPCTSTR, ::FINDEX_INFO_LEVELS, LPVOID, ::FINDEX_SEARCH_OPS, LPVOID, DWORD, HANDLE >( pFunc, lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags, hTransaction );
#	else
		QOR_PP_UNREF( hTransaction );
		QOR_PP_UNREF( dwAdditionalFlags );
		QOR_PP_UNREF( lpSearchFilter );
		QOR_PP_UNREF( fSearchOp );
		QOR_PP_UNREF( lpFindFileData );
		QOR_PP_UNREF( fInfoLevelId );
		QOR_PP_UNREF( lpFileName );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _CTXT ( "FindFirstFileTransacted" ), _T( "Windows Vista" ), 0 ));
#endif
		return h;
	}

	//--------------------------------------------------------------------------------
	HANDLE CKernel32::FindFirstStreamTransactedW( LPCWSTR lpFileName, ::STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags, HANDLE hTransaction )
	{
		_WINQ_SFCONTEXT( "CKernel32::FindFirstStreamTransactedW" );
		CCheckReturn< HANDLE, CHandleCheck< > >::TType h;
#	if ( _WIN32_WINNT >= 0x0600 && NTDDI_VERSION >= NTDDI_VISTASP1 )
        _WINQ_USESAPI( FindFirstStreamTransactedW );
		h = Call< HANDLE, LPCWSTR, ::STREAM_INFO_LEVELS, LPVOID, DWORD, HANDLE >( pFunc, lpFileName, InfoLevel, lpFindStreamData, dwFlags, hTransaction );
#	else
		QOR_PP_UNREF( hTransaction );
		QOR_PP_UNREF( dwFlags );
		QOR_PP_UNREF( lpFindStreamData );
		QOR_PP_UNREF( InfoLevel );
		QOR_PP_UNREF( lpFileName );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _CTXT ( "FindFirstStreamTransactedW" ), _T( "Windows Vista Service Pack 1" ), 0 ));
#	endif
		return h;
	}

	//--------------------------------------------------------------------------------
	HANDLE CKernel32::FindFirstStreamW( LPCWSTR lpFileName, ::STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags )
	{
		_WINQ_SFCONTEXT( "CKernel32::FindFirstStreamW" );
		CCheckReturn< HANDLE, CHandleCheck< > >::TType h;
#	if ( _WIN32_WINNT >= 0x0600 )
        _WINQ_USESAPI( FindFirstStreamW );
		h = Call< HANDLE, LPCWSTR, ::STREAM_INFO_LEVELS, LPVOID, DWORD >( pFunc, lpFileName, InfoLevel, lpFindStreamData, dwFlags );
#	else
		QOR_PP_UNREF( dwFlags );
		QOR_PP_UNREF( lpFindStreamData );
		QOR_PP_UNREF( InfoLevel );
		QOR_PP_UNREF( lpFileName );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _CTXT ( "FindFirstStreamW" ), _T( "Windows Vista" ), 0 ));
#endif
		return h;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::FindNextFile( HANDLE hFindFile, ::LPWIN32_FIND_DATA lpFindFileData )
	{
		_WINQ_SFCONTEXT( "CKernel32::FindNextFile" );
		BOOL bResult = ::FindNextFile( hFindFile, lpFindFileData );
		if( bResult == FALSE )
		{
			DWORD dwError = CKernel32::GetLastError();
			if( dwError == ERROR_NO_MORE_FILES )
			{
				__WINQAPI_WARNING(( API_RETURNED_NO_DATA, _T( "FindNextFile" ), 0 ));
			}
			else
			{
				__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, _T( "FindNextFile" ), 0 ));
			}
		}
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::FindNextFileNameW( HANDLE hFindStream, LPDWORD StringLength, PWCHAR LinkName )
	{
		_WINQ_SFCONTEXT( "CKernel32::FindNextFileNameW" );
		BOOL bResult = FALSE;
		nsCodeQOR::CCodeString APIName( _T( "FindNextFileNameW" ) );
#	if ( _WIN32_WINNT >= 0x0600 )
        _WINQ_USESAPI( FindNextFileNameW );
		bResult = Call< BOOL, HANDLE, LPDWORD, PWCHAR >( pFunc, hFindStream, StringLength, LinkName );
		if( bResult == FALSE )
		{
			DWORD dwError = CKernel32::GetLastError();
			if( dwError == ERROR_HANDLE_EOF )
			{
				__WINQAPI_WARNING(( API_RETURNED_NO_DATA, APIName.c_str(), 0 ));
			}
			else
			{
				__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, APIName.c_str(), 0 ));
			}
		}
#	else
		QOR_PP_UNREF( LinkName );
		QOR_PP_UNREF( StringLength );
		QOR_PP_UNREF( hFindStream );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, APIName.c_str(), _T( "Windows Vista" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::FindNextStreamW( HANDLE hFindStream, void* lpFindStreamData )
	{
		_WINQ_SFCONTEXT( "CKernel32::FindNextStreamW" );
		BOOL bResult = FALSE;
		__QOR_CODESTRING( APIName, "FindNextStreamW" );
#	if ( _WIN32_WINNT >= 0x0501 )
        _WINQ_USESAPI( FindNextStreamW );
		bResult = Call< BOOL, HANDLE, void* >( pFunc, hFindStream, lpFindStreamData );
		if( bResult == FALSE )
		{
			DWORD dwError = CKernel32::GetLastError();
			if( dwError == ERROR_HANDLE_EOF )
			{
				__WINQAPI_WARNING(( API_RETURNED_NO_DATA, APIName, 0 ));
			}
			else
			{
				__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, APIName.c_str(), 0 ));
			}
		}
#	else
		QOR_PP_UNREF( lpFindStreamData );
		QOR_PP_UNREF( hFindStream );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, APIName.c_str(), _T( "Windows XP" ), 0 ));
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::FlushFileBuffers( HANDLE hFile )
	{
		_WINQ_SFCONTEXT( "CKernel32::FlushFileBuffers" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::FlushFileBuffers( hFile );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::GetBinaryType( LPCTSTR lpApplicationName, LPDWORD lpBinaryType )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetBinaryType" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::GetBinaryType( lpApplicationName, lpBinaryType );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::GetCompressedFileSize( LPCTSTR lpFileName, LPDWORD lpFileSizeHigh )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetCompressedFileSize" );
		DWORD dwResult = ::GetCompressedFileSize( lpFileName, lpFileSizeHigh );
		if( dwResult == INVALID_FILE_SIZE )
		{
			DWORD dwError = CKernel32::GetLastError();
			if( lpFileSizeHigh == 0 || dwError != NO_ERROR )
			{
				__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, _T( "GetCompressedFileSize" ), 0 ));
			}
		}
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::GetCompressedFileSizeTransacted( LPCTSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetCompressedFileSizeTransacted" );
		DWORD dwResult = 0;
#	if ( _WIN32_WINNT >= 0x0600 )
        _WINQ_USESAPI( GetCompressedFileSizeTransacted );
		dwResult = Call< DWORD, LPCTSTR, LPDWORD, HANDLE >( pFunc, lpFileName, lpFileSizeHigh, hTransaction );
		if( dwResult == INVALID_FILE_SIZE )
		{
			DWORD dwError = CKernel32::GetLastError();
			if( lpFileSizeHigh == 0 || dwError != NO_ERROR )
			{
				__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, _T( "GetCompressedFileSizeTransacted" ), 0 ));
			}
		}
#	else
		QOR_PP_UNREF( hTransaction );
		QOR_PP_UNREF( lpFileSizeHigh );
		QOR_PP_UNREF( lpFileName );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "GetCompressedFileSizeTransacted" ), _T( "Windows Vista" ), 0 ));
#	endif
		return dwResult;
	}
	/*Removed in Win7 at least in 64bit pro
	//--------------------------------------------------------------------------------
	static INT GetExpandedName( LPTSTR lpszSource, LPTSTR lpszBuffer )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetExpandedName" );
		INT iResult = 0;
		__QOR_PROTECT
		{
			iResult = ::GetExpandedName( lpszSource, lpszBuffer );
			if( iResult == LZERROR_BADVALUE )
			{
				__WINQAPI_CONT_ERROR(( API_FAILED, _T( "GetExpandedName" ), E_FAIL ));
			}
		}__QOR_ENDPROTECT
		return iResult;
	}
	*/
	//--------------------------------------------------------------------------------
	DWORD CKernel32::GetFileAttributes( LPCTSTR lpFileName )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetFileAttributes" );
		CCheckReturn< DWORD, CTCheckFailureValue< DWORD, INVALID_FILE_ATTRIBUTES > >::TType dwResult = ::GetFileAttributes( lpFileName );
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::GetFileAttributesEx( LPCTSTR lpFileName, ::GET_FILEEX_INFO_LEVELS fInfoLevelId, void* lpFileInformation )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetFileAttributesEx" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::GetFileAttributesEx( lpFileName, fInfoLevelId, lpFileInformation );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::GetFileAttributesTransacted( LPCTSTR lpFileName, ::GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetFileAttributesTransacted" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0600 )
        _WINQ_USESAPI( GetFileAttributesTransacted );
		bResult = Call< BOOL, LPCTSTR, ::GET_FILEEX_INFO_LEVELS, LPVOID, HANDLE >( pFunc, lpFileName, fInfoLevelId, lpFileInformation, hTransaction );
#	else
		QOR_PP_UNREF( hTransaction );
		QOR_PP_UNREF( lpFileInformation );
		QOR_PP_UNREF( fInfoLevelId );
		QOR_PP_UNREF( lpFileName );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "GetFileAttributesTransacted" ), _T( "Windows Vista" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::GetFileBandwidthReservation( HANDLE hFile, LPDWORD lpPeriodMilliseconds, LPDWORD lpBytesPerPeriod, LPBOOL pDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetFileBandwidthReservation" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
		_WINQ_USESAPI( GetFileBandwidthReservation );
		bResult = Call< BOOL, HANDLE, LPDWORD, LPDWORD, LPBOOL, LPDWORD, LPDWORD >( pFunc, hFile, lpPeriodMilliseconds, lpBytesPerPeriod, pDiscardable, lpTransferSize, lpNumOutstandingRequests );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::GetFileInformationByHandle( HANDLE hFile, ::LPBY_HANDLE_FILE_INFORMATION lpFileInformation )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetFileInformationByHandle" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::GetFileInformationByHandle( hFile, lpFileInformation );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::GetFileInformationByHandleEx( HANDLE hFile, ::FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetFileInformationByHandleEx" );
		BOOL bResult = FALSE;
#	if ( _WIN32_WINNT >= 0x0600 )
		bResult = ::GetFileInformationByHandleEx( hFile, FileInformationClass, lpFileInformation, dwBufferSize );
#	else
		QOR_PP_UNREF( dwBufferSize );
		QOR_PP_UNREF( lpFileInformation );
		QOR_PP_UNREF( FileInformationClass );
		QOR_PP_UNREF( hFile );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "GetFileInformationByHandleEx" ), _T( "Windows Vista" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::GetFileSize( HANDLE hFile, LPDWORD lpFileSizeHigh )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetFileSize" );
		CCheckReturn< DWORD, CTCheckFailureValue< DWORD, INVALID_FILE_SIZE > >::TType dwResult = ::GetFileSize( hFile, lpFileSizeHigh );
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::GetFileSizeEx( HANDLE hFile, PLARGE_INTEGER lpFileSize )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetFileSizeEx" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::GetFileSizeEx( hFile, lpFileSize );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::GetFileType( HANDLE hFile )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetFileType" );
		DWORD dwResult = 0;
		dwResult = ::GetFileType( hFile );
		if( dwResult == FILE_TYPE_UNKNOWN )
		{
			DWORD dwError = CKernel32::GetLastError();
			if( dwError != NO_ERROR )
			{
				__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, _T( "GetFileType" ), 0 ));
			}
		}
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::GetFinalPathNameByHandle( HANDLE hFile, LPTSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetFinalPathNameByHandle" );
		CCheckReturn< DWORD, CCheckNonZero< DWORD > >::TType dwResult;
#	if ( _WIN32_WINNT >= 0x0600 )
		dwResult = ::GetFinalPathNameByHandle( hFile, lpszFilePath, cchFilePath, dwFlags );
#	else
		QOR_PP_UNREF( dwFlags );
		QOR_PP_UNREF( cchFilePath );
		QOR_PP_UNREF( lpszFilePath );
		QOR_PP_UNREF( hFile );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "GetFinalPathNameByHandle" ), _T( "Windows Vista" ), 0 ));
#	endif
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::GetFullPathName( LPCTSTR lpFileName, DWORD nBufferLength, LPTSTR lpBuffer, LPTSTR* lpFilePart )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetFullPathName" );
		CCheckReturn< DWORD, CCheckNonZero< DWORD > >::TType dwResult = ::GetFullPathName( lpFileName, nBufferLength, lpBuffer, lpFilePart );
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::GetFullPathNameTransacted( LPCTSTR lpFileName, DWORD nBufferLength, LPTSTR lpBuffer, LPTSTR *lpFilePart, HANDLE hTransaction )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetFullPathNameTransacted" );
		CCheckReturn< DWORD, CCheckNonZero< DWORD > >::TType dwResult;
#	if ( _WIN32_WINNT >= 0x0600 )
        _WINQ_USESAPI( GetFullPathNameTransacted );
		dwResult = Call< DWORD, LPCTSTR, DWORD, LPTSTR, LPTSTR*, HANDLE >( pFunc, lpFileName, nBufferLength, lpBuffer, lpFilePart, hTransaction );
#	else
		QOR_PP_UNREF( hTransaction );
		QOR_PP_UNREF( lpFilePart );
		QOR_PP_UNREF( lpBuffer );
		QOR_PP_UNREF( nBufferLength );
		QOR_PP_UNREF( lpFileName );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "GetFullPathNameTransacted" ), _T( "Windows Vista" ), 0 ));
#	endif
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::GetLongPathName( LPCTSTR lpszShortPath, LPTSTR lpszLongPath, DWORD cchBuffer )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetLongPathName" );
		CCheckReturn< DWORD, CCheckNonZero< DWORD > >::TType dwResult = ::GetLongPathName( lpszShortPath, lpszLongPath, cchBuffer );
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::GetLongPathNameTransacted( LPCTSTR lpszShortPath, LPTSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetLongPathNameTransacted" );
		CCheckReturn< DWORD, CCheckNonZero< DWORD > >::TType dwResult;
#	if ( _WIN32_WINNT >= 0x0600 )
        _WINQ_USESAPI( GetLongPathNameTransacted );
		dwResult = Call< DWORD, LPCTSTR, LPTSTR, DWORD, HANDLE >( pFunc, lpszShortPath, lpszLongPath, cchBuffer, hTransaction );
#	else
		QOR_PP_UNREF( hTransaction );
		QOR_PP_UNREF( cchBuffer );
		QOR_PP_UNREF( lpszLongPath );
		QOR_PP_UNREF( lpszShortPath );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "GetLongPathName" ), _T( "Windows Vista" ), 0 ));
#	endif
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::GetQueuedCompletionStatus( HANDLE CompletionPort, LPDWORD lpNumberOfBytes, PULONG_PTR lpCompletionKey, ::LPOVERLAPPED* lpOverlapped, DWORD dwMilliseconds )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetQueuedCompletionStatus" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::GetQueuedCompletionStatus( CompletionPort, lpNumberOfBytes, lpCompletionKey, lpOverlapped, dwMilliseconds );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::GetQueuedCompletionStatusEx( HANDLE CompletionPort, ::LPOVERLAPPED_ENTRY lpCompletionPortEntries, ULONG ulCount, PULONG ulNumEntriesRemoved, DWORD dwMilliseconds, BOOL fAlertable )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetQueuedCompletionStatusEx" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0600 )
        _WINQ_USESAPI( GetQueuedCompletionStatusEx );
		bResult = Call< BOOL, HANDLE, ::LPOVERLAPPED_ENTRY, ULONG, PULONG, DWORD, BOOL >( pFunc, CompletionPort, lpCompletionPortEntries, ulCount, ulNumEntriesRemoved, dwMilliseconds, fAlertable );
#	else
		QOR_PP_UNREF( fAlertable );
		QOR_PP_UNREF( dwMilliseconds );
		QOR_PP_UNREF( ulNumEntriesRemoved );
		QOR_PP_UNREF( ulCount );
		QOR_PP_UNREF( lpCompletionPortEntries );
		QOR_PP_UNREF( CompletionPort );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "GetQueuedCompletionStatusEx" ), _T( "Windows Vista" ), 0 ));
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::GetShortPathName( LPCTSTR lpszLongPath, LPTSTR lpszShortPath, DWORD cchBuffer )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetShortPathName" );
		CCheckReturn< DWORD, CCheckNonZero< DWORD > >::TType dwResult = ::GetShortPathName( lpszLongPath, lpszShortPath, cchBuffer );
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	UINT CKernel32::GetTempFileName( LPCTSTR lpPathName, LPCTSTR lpPrefixString, UINT uUnique, LPTSTR lpTempFileName )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetTempFileName" );
		CCheckReturn< DWORD, CCheckNonZero< DWORD > >::TType dwResult = ::GetTempFileName( lpPathName, lpPrefixString, uUnique, lpTempFileName );
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::GetTempPath( DWORD nBufferLength, LPTSTR lpBuffer )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetTempPath" );
		CCheckReturn< DWORD, CCheckNonZero< DWORD > >::TType dwResult = ::GetTempPath( nBufferLength, lpBuffer );
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::LockFile( HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh )
	{
		_WINQ_SFCONTEXT( "CKernel32::LockFile" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::LockFile( hFile, dwFileOffsetLow, dwFileOffsetHigh, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::LockFileEx( HANDLE hFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, ::LPOVERLAPPED lpOverlapped )
	{
		_WINQ_SFCONTEXT( "CKernel32::LockFileEx" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::LockFileEx( hFile, dwFlags, dwReserved, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh, lpOverlapped );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::MoveFile( LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName )
	{
		_WINQ_SFCONTEXT( "CKernel32::MoveFile" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::MoveFile( lpExistingFileName, lpNewFileName );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::MoveFileEx( LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, DWORD dwFlags )
	{
		_WINQ_SFCONTEXT( "CKernel32::MoveFileEx" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::MoveFileEx( lpExistingFileName, lpNewFileName, dwFlags );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::MoveFileTransacted( LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, ::LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction )
	{
		_WINQ_SFCONTEXT( "CKernel32::MoveFileTransacted" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0600 )
        _WINQ_USESAPI( MoveFileTransacted );
		bResult = Call< BOOL, LPCTSTR, LPCTSTR, ::LPPROGRESS_ROUTINE, LPVOID, DWORD, HANDLE >( pFunc, lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags, hTransaction );
#else
		QOR_PP_UNREF( hTransaction );
		QOR_PP_UNREF( dwFlags );
		QOR_PP_UNREF( lpData );
		QOR_PP_UNREF( lpProgressRoutine );
		QOR_PP_UNREF( lpNewFileName );
		QOR_PP_UNREF( lpExistingFileName );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "MoveFileTransacted" ), _T( "Windows Vista" ), 0 ));
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::MoveFileWithProgress( LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, ::LPPROGRESS_ROUTINE lpProgressRoutine, void* lpData, DWORD dwFlags )
	{
		_WINQ_SFCONTEXT( "CKernel32::MoveFileWithProgress" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if( _WIN32_WINNT >= 0x0500 )
		bResult = ::MoveFileWithProgress( lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags );
#	else
		QOR_PP_UNREF( dwFlags );
		QOR_PP_UNREF( lpData );
		QOR_PP_UNREF( lpProgressRoutine );
		QOR_PP_UNREF( lpNewFileName );
		QOR_PP_UNREF( lpExistingFileName );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "MoveFileWithProgress" ), _T( "Windows 2000" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	HFILE CKernel32::OpenFile( LPCSTR lpFileName, ::LPOFSTRUCT lpReOpenBuff, UINT uStyle )
	{
		_WINQ_SFCONTEXT( "CKernel32::OpenFile" );
		CCheckReturn< HFILE, CTCheckFailureValue< HFILE, HFILE_ERROR > >::TType hFile = ::OpenFile( lpFileName, lpReOpenBuff, uStyle );
		return hFile;
	}

	//--------------------------------------------------------------------------------
	//Requires Windows SDK on Windows Server 2003 and Windows XP.
	HANDLE CKernel32::OpenFileById( HANDLE hFile, ::LPFILE_ID_DESCRIPTOR lpFileID, DWORD dwDesiredAccess, DWORD dwShareMode, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwFlags )
	{
		_WINQ_SFCONTEXT( "CKernel32::OpenFileById" );
		CCheckReturn< HANDLE, CHandleCheck< > >::TType h;
#	if ( _WIN32_WINNT >= 0x0600 )
        _WINQ_USESAPI( OpenFileById );
		h = Call< HANDLE, HANDLE, ::LPFILE_ID_DESCRIPTOR, DWORD, DWORD, ::LPSECURITY_ATTRIBUTES, DWORD >( pFunc, hFile, lpFileID, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwFlags );
#	else
		QOR_PP_UNREF( dwFlags );
		QOR_PP_UNREF( lpSecurityAttributes );
		QOR_PP_UNREF( dwShareMode );
		QOR_PP_UNREF( dwDesiredAccess );
		QOR_PP_UNREF( lpFileID );
		QOR_PP_UNREF( hFile );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "OpenFileById" ), _T( "Windows Vista" ), 0 ));
#	endif
		return h;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::PostQueuedCompletionStatus( HANDLE CompletionPort, DWORD dwNumberOfBytesTransferred, ULONG_PTR dwCompletionKey, ::LPOVERLAPPED lpOverlapped )
	{
		_WINQ_SFCONTEXT( "CKernel32::PostQueuedCompletionStatus" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::PostQueuedCompletionStatus( CompletionPort, dwNumberOfBytesTransferred, dwCompletionKey, lpOverlapped );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::ReadFile( HANDLE hFile, void* lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, ::LPOVERLAPPED lpOverlapped )
	{
		_WINQ_SFCONTEXT( "CKernel32::ReadFile" );
		BOOL bResult = ::ReadFile( hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped );

		if( !bResult )
		{
			unsigned long ulError = GetLastError();

			if( ulError == ERROR_MORE_DATA )
			{
				//More data is good! May indicate a message mode Pipe being read in byte mode.
			}
			else
			{
			}
		}
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::ReadFileEx( HANDLE hFile, void* lpBuffer, DWORD nNumberOfBytesToRead, ::LPOVERLAPPED lpOverlapped, ::LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine )
	{
		_WINQ_SFCONTEXT( "CKernel32::ReadFileEx" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::ReadFileEx( hFile, lpBuffer, nNumberOfBytesToRead, lpOverlapped, lpCompletionRoutine );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::ReadFileScatter( HANDLE hFile, ::FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToRead, LPDWORD lpReserved, ::LPOVERLAPPED lpOverlapped )
	{
		_WINQ_SFCONTEXT( "CKernel32::ReadFileScatter" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::ReadFileScatter( hFile, aSegmentArray, nNumberOfBytesToRead, lpReserved, lpOverlapped );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	HANDLE CKernel32::ReOpenFile( HANDLE hOriginalFile, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwFlags )
	{
		_WINQ_SFCONTEXT( "CKernel32::ReOpenFile" );
		CCheckReturn< HANDLE, CHandleCheck< > >::TType h;
#	if ( _WIN32_WINNT >= 0x0502 )
		h = ::ReOpenFile( hOriginalFile, dwDesiredAccess, dwShareMode, dwFlags );
#	else
		QOR_PP_UNREF( dwFlags );
		QOR_PP_UNREF( dwShareMode );
		QOR_PP_UNREF( dwDesiredAccess );
		QOR_PP_UNREF( hOriginalFile );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "ReOpenFile" ), _T( "Windows Server 2003" ), 0 ));
#	endif
		return h;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::ReplaceFile( LPCTSTR lpReplacedFileName, LPCTSTR lpReplacementFileName, LPCTSTR lpBackupFileName, DWORD dwReplaceFlags, void* lpExclude, LPVOID lpReserved )
	{
		_WINQ_SFCONTEXT( "CKernel32::ReplaceFile" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0500 )
		bResult = ::ReplaceFile( lpReplacedFileName, lpReplacementFileName, lpBackupFileName, dwReplaceFlags, lpExclude, lpReserved );
#	else
		QOR_PP_UNREF( lpReserved );
		QOR_PP_UNREF( lpExclude );
		QOR_PP_UNREF( dwReplaceFlags );
		QOR_PP_UNREF( lpBackupFileName );
		QOR_PP_UNREF( lpReplacementFileName );
		QOR_PP_UNREF( lpReplacedFileName );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "ReplaceFile" ), _T( "Windows 2000" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::SearchPath( LPCTSTR lpPath, LPCTSTR lpFileName, LPCTSTR lpExtension, DWORD nBufferLength, LPTSTR lpBuffer, LPTSTR* lpFilePart )
	{
		_WINQ_SFCONTEXT( "CKernel32::SearchPath" );
		CCheckReturn< DWORD, CCheckNonZero< DWORD > >::TType dwResult = ::SearchPath( lpPath, lpFileName, lpExtension, nBufferLength, lpBuffer, lpFilePart );
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::SetEndOfFile( HANDLE hFile )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetEndOfFile" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::SetEndOfFile( hFile );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	void CKernel32::SetFileApisToANSI(void)
	{
		_WINQ_SFCONTEXT( "CKernel32::SetFileApisToANSI" );
		::SetFileApisToANSI();
	}

	//--------------------------------------------------------------------------------
	void CKernel32::SetFileApisToOEM(void)
	{
		_WINQ_SFCONTEXT( "CKernel32::SetFileApisToOEM" );
		::SetFileApisToOEM();
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::SetFileAttributes( LPCTSTR lpFileName, DWORD dwFileAttributes )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetFileAttributes" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::SetFileAttributes( lpFileName, dwFileAttributes );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::SetFileAttributesTransacted( LPCTSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetFileAttributesTransacted" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0600 )
        _WINQ_USESAPI( SetFileAttributesTransacted );
		bResult = Call< BOOL, LPCTSTR, DWORD, HANDLE >( pFunc, lpFileName, dwFileAttributes, hTransaction );
#	else
		QOR_PP_UNREF( hTransaction );
		QOR_PP_UNREF( dwFileAttributes );
		QOR_PP_UNREF( lpFileName );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SetFileAttributesTransacted" ), _T( "Windows Vista" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::SetFileBandwidthReservation( HANDLE hFile, DWORD nPeriodMilliseconds, DWORD nBytesPerPeriod, BOOL bDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetFileBandwidthReservation" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0600 )
        _WINQ_USESAPI( SetFileBandwidthReservation );
		bResult = Call< BOOL, HANDLE, DWORD, DWORD, BOOL, LPDWORD, LPDWORD >( pFunc, hFile, nPeriodMilliseconds, nBytesPerPeriod, bDiscardable, lpTransferSize, lpNumOutstandingRequests );
#	else
		QOR_PP_UNREF( lpNumOutstandingRequests );
		QOR_PP_UNREF( lpTransferSize );
		QOR_PP_UNREF( bDiscardable );
		QOR_PP_UNREF( nBytesPerPeriod );
		QOR_PP_UNREF( nPeriodMilliseconds );
		QOR_PP_UNREF( hFile );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SetFileBandwidthReservation" ), _T( "Windows Vista" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::SetFileCompletionNotificationModes( HANDLE FileHandle, UCHAR Flags )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetFileCompletionNotificationModes" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0600 )
        _WINQ_USESAPI( SetFileCompletionNotificationModes );
		bResult = Call< BOOL, HANDLE, UCHAR >( pFunc, FileHandle, Flags );
#	else
		QOR_PP_UNREF( Flags );
		QOR_PP_UNREF( FileHandle );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SetFileCompletionNotificationModes" ), _T( "Windows Vista" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	//Requires Windows SDK on Windows Server 2003 and Windows XP.
	//Use FileExtd.lib in Windows Server 2003 and Windows XP
	BOOL CKernel32::SetFileInformationByHandle( HANDLE hFile, ::FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetFileInformationByHandle" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0600 )
        _WINQ_USESAPI( SetFileInformationByHandle );
		bResult = Call< BOOL, HANDLE, ::FILE_INFO_BY_HANDLE_CLASS, LPVOID, DWORD >( pFunc, hFile, FileInformationClass, lpFileInformation, dwBufferSize );
#	else
		QOR_PP_UNREF( dwBufferSize );
		QOR_PP_UNREF( lpFileInformation );
		QOR_PP_UNREF( FileInformationClass );
		QOR_PP_UNREF( hFile );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SetFileInformationByHandle" ), _T( "Windows Vista" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::SetFileIoOverlappedRange( HANDLE FileHandle, PUCHAR OverlappedRangeStart, ULONG Length )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetFileIoOverlappedRange" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0600 )
        _WINQ_USESAPI( SetFileIoOverlappedRange );
		bResult = Call< BOOL, HANDLE, PUCHAR, ULONG >( pFunc, FileHandle, OverlappedRangeStart, Length );
#	else
		QOR_PP_UNREF( Length );
		QOR_PP_UNREF( OverlappedRangeStart );
		QOR_PP_UNREF( FileHandle );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SetFileIoOverlappedRange" ), _T( "Windows Vista" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::SetFilePointer( HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetFilePointer" );
		DWORD dwResult = ::SetFilePointer( hFile, lDistanceToMove, lpDistanceToMoveHigh, dwMoveMethod );
		if( dwResult == INVALID_SET_FILE_POINTER )
		{
			DWORD dwError = CKernel32::GetLastError();
			if( lpDistanceToMoveHigh == 0 || dwError != NO_ERROR )
			{
				__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, _T( "SetFilePointer" ), 0 ));
			}
		}
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::SetFilePointerEx( HANDLE hFile, ::LARGE_INTEGER liDistanceToMove, ::PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetFilePointerEx" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::SetFilePointerEx( hFile, liDistanceToMove, lpNewFilePointer, dwMoveMethod );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::SetFileShortName( HANDLE hFile, LPCTSTR lpShortName )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetFileShortName" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::SetFileShortName( hFile, lpShortName );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::SetFileValidData( HANDLE hFile, LONGLONG ValidDataLength )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetFileValidData" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0501 )
		bResult = ::SetFileValidData( hFile, ValidDataLength );
#	else
		QOR_PP_UNREF( ValidDataLength );
		QOR_PP_UNREF( hFile );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SetFileValidData" ), _T( "Windows XP" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::UnlockFile( HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh )
	{
		_WINQ_SFCONTEXT( "CKernel32::UnlockFile" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::UnlockFile( hFile, dwFileOffsetLow, dwFileOffsetHigh, nNumberOfBytesToUnlockLow, nNumberOfBytesToUnlockHigh );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::UnlockFileEx( HANDLE hFile, DWORD dwReserved, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh, ::LPOVERLAPPED lpOverlapped )
	{
		_WINQ_SFCONTEXT( "CKernel32::UnlockFileEx" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::UnlockFileEx( hFile, dwReserved, nNumberOfBytesToUnlockLow, nNumberOfBytesToUnlockHigh, lpOverlapped );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	//Client Requires Windows XP Professional x64 Edition.
	//Server Requires Windows Server 2003 SP1.
	BOOL CKernel32::Wow64DisableWow64FsRedirection( PVOID* OldValue )
	{
		_WINQ_SFCONTEXT( "CKernel32::Wow64DisableWow64FsRedirection" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0501 )
        _WINQ_USESAPI( Wow64DisableWow64FsRedirection );
		bResult = Call< BOOL, PVOID* >( pFunc, OldValue );
#	else
		QOR_PP_UNREF( OldValue );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "Wow64DisableWow64FsRedirection" ), _T( "Windows XP Professional x64 Edition" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOLEAN CKernel32::Wow64EnableWow64FsRedirection( BOOLEAN Wow64FsEnableRedirection )
	{
		_WINQ_SFCONTEXT( "CKernel32::Wow64EnableWow64FsRedirection" );
		CCheckReturn< BOOLEAN, CCheckNonZero< BOOLEAN > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0501 )
        _WINQ_USESAPI( Wow64EnableWow64FsRedirection );
		bResult = Call< BOOLEAN, BOOLEAN >( pFunc, Wow64FsEnableRedirection );
#	else
		QOR_PP_UNREF( Wow64FsEnableRedirection );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "Wow64EnableWow64FsRedirection" ), _T( "Windows XP Professional x64 Edition" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	//Client Requires Windows XP Professional x64 Edition.
	//Server Requires Windows Server 2003 SP1.
	BOOL CKernel32::Wow64RevertWow64FsRedirection( PVOID OldValue )
	{
		_WINQ_SFCONTEXT( "CKernel32::Wow64RevertWow64FsRedirection" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if	( _WIN32_WINNT >= 0x0501 )
        _WINQ_USESAPI( Wow64RevertWow64FsRedirection );
		bResult = Call< BOOL, PVOID >( pFunc, OldValue );
#	else
		QOR_PP_UNREF( OldValue );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "Wow64EnableWow64FsRedirection" ), _T( "Windows XP Professional x64 Edition" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::WriteFile( HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, ::LPOVERLAPPED lpOverlapped )
	{
		_WINQ_SFCONTEXT( "CKernel32::WriteFile" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::WriteFile( hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::WriteFileEx( HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, ::LPOVERLAPPED lpOverlapped, ::LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine )
	{
		_WINQ_SFCONTEXT( "CKernel32::WriteFileEx" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::WriteFileEx( hFile, lpBuffer, nNumberOfBytesToWrite, lpOverlapped, lpCompletionRoutine );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::WriteFileGather( HANDLE hFile, ::FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToWrite, LPDWORD lpReserved, ::LPOVERLAPPED lpOverlapped )
	{
		_WINQ_SFCONTEXT( "CKernel32::WriteFileGather" );
		BOOL bResult = ::WriteFileGather( hFile, aSegmentArray, nNumberOfBytesToWrite, lpReserved, lpOverlapped );
		if( bResult == FALSE )
		{
			DWORD dwError = CKernel32::GetLastError();
			if( dwError != ERROR_IO_PENDING )
			{
				__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, _T( "WriteFileGather" ), 0 ));
			}
		}
		return bResult;
	}

	//--------------------------------------------------------------------------------
	//This function has no effect on 32 bit Windows and therefore essentially cannot fail
	//We only call it at all here to validate any hooking or other Kernel mode side effects
	UINT CKernel32::SetHandleCount( UINT uNumber )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetHandleCount" );
		return ::SetHandleCount( uNumber );
	}

}//nsWinQAPI
