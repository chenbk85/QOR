//kProcessThread.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQAPI/Kernel32.h"
#include "../SystemQOR/MSWindows/WinQAPI/include/ReturnCheck.h"

//------------------------------------------------------------------------------
namespace nsWinQAPI
{
	//--------------------------------------------------------------------------------
	BOOL CKernel32::AssignProcessToJobObject( HANDLE hJob, HANDLE hProcess )
	{
		_WINQ_SFCONTEXT( "CKernel32::AssignProcessToJobObject" );
		CCheckReturn< BOOL, CBoolCheck<> >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0500 )
		bResult = ::AssignProcessToJobObject( hJob, hProcess );
#	else
		QOR_PP_UNREF2( hProcess, hJob );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "AssignProcessToJobObject" ), _T( "Windows 2000" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::BindIoCompletionCallback( HANDLE FileHandle, ::LPOVERLAPPED_COMPLETION_ROUTINE Function, ULONG Flags )
	{
		_WINQ_SFCONTEXT( "CKernel32::BindIoCompletionCallback" );
		CCheckReturn< BOOL, CBoolCheck<> >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "BindIoCompletionCallback" ), 0 ));
#else

#	if ( _WIN32_WINNT >= 0x0500 )
		bResult = ::BindIoCompletionCallback( FileHandle, Function, Flags );
#	else
		QOR_PP_UNREF3( Flags, Function, FileHandle );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "BindIoCompletionCallback" ), _T( "Windows 2000" ), 0 ));
#	endif
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::CallbackMayRunLong( ::PTP_CALLBACK_INSTANCE pci )
	{
		_WINQ_SFCONTEXT( "CKernel32::CallbackMayRunLong" );
		CCheckReturn< BOOL, CBoolCheck<> >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "CallbackMayRunLong" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		bResult = ::CallbackMayRunLong( pci );
#	else
		QOR_PP_UNREF( pci );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "BindIoCompletionCallback" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::CancelThreadpoolIo( ::PTP_IO pio )
	{
		_WINQ_SFCONTEXT( "CKernel32::CancelThreadpoolIo" );
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "CancelThreadpoolIo" ), 0 ));
#else

#	if ( _WIN32_WINNT >= 0x0600 )
		::CancelThreadpoolIo( pio );
#	else
		QOR_PP_UNREF( pio );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CancelThreadpoolIo" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::CloseThreadpool( ::PTP_POOL ptpp )
	{
		_WINQ_SFCONTEXT( "CKernel32::CloseThreadpool" );
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "CloseThreadpool" ), 0 ));
#else

#	if ( _WIN32_WINNT >= 0x0600 )
		::CloseThreadpool( ptpp );
#	else
		QOR_PP_UNREF( ptpp );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CloseThreadpool" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::CloseThreadpoolCleanupGroup( ::PTP_CLEANUP_GROUP ptpcg )
	{
		_WINQ_SFCONTEXT( "CKernel32::CloseThreadpoolCleanupGroup" );
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "CloseThreadpoolCleanupGroup" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		::CloseThreadpoolCleanupGroup( ptpcg );
#	else
		QOR_PP_UNREF( ptpcg );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CloseThreadpoolCleanupGroup" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::CloseThreadpoolCleanupGroupMembers( ::PTP_CLEANUP_GROUP ptpcg, BOOL fCancelPendingCallbacks, PVOID pvCleanupContext )
	{
		_WINQ_SFCONTEXT( "CKernel32::CloseThreadpoolCleanupGroupMembers" );
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "CloseThreadpoolCleanupGroupMembers" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		::CloseThreadpoolCleanupGroupMembers( ptpcg, fCancelPendingCallbacks, pvCleanupContext );
#	else
		QOR_PP_UNREF( pvCleanupContext, fCancelPendingCallbacks, ptpcg );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CloseThreadpoolCleanupGroupMembers" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::CloseThreadpoolIo( ::PTP_IO pio )
	{
		_WINQ_SFCONTEXT( "CKernel32::CloseThreadpoolIo" );
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "CloseThreadpoolIo" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		::CloseThreadpoolIo( pio );
#	else
		QOR_PP_UNREF( pio );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CloseThreadpoolIo" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::CloseThreadpoolTimer( ::PTP_TIMER pti )
	{
		_WINQ_SFCONTEXT( "CKernel32::CloseThreadpoolTimer" );
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "CloseThreadpoolTimer" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		::CloseThreadpoolTimer( pti );
#	else
		QOR_PP_UNREF( pti );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CloseThreadpoolTimer" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::CloseThreadpoolWait( ::PTP_WAIT pwa )
	{
		_WINQ_SFCONTEXT( "CKernel32::CloseThreadpoolWait" );
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "CloseThreadpoolWait" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		::CloseThreadpoolWait( pwa );
#	else
		QOR_PP_UNREF( pwa );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CloseThreadpoolWait" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::CloseThreadpoolWork( ::PTP_WORK pwk )
	{
		_WINQ_SFCONTEXT( "CKernel32::CloseThreadpoolWork" );
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "CloseThreadpoolWork" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		::CloseThreadpoolWork( pwk );
#	else
		QOR_PP_UNREF( pwk );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CloseThreadpoolWork" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::ConvertFiberToThread(void)
	{
		_WINQ_SFCONTEXT( "CKernel32::ConvertFiberToThread" );
		CCheckReturn< BOOL, CBoolCheck<> >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0501 )
		bResult = ::ConvertFiberToThread();
#	else
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "ConvertFiberToThread" ), _T( "Windows XP" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	void* CKernel32::ConvertThreadToFiber( void* lpParameter )
	{
		_WINQ_SFCONTEXT( "CKernel32::ConvertThreadToFiber" );
		CCheckReturn< void*, CCheckNonZero< void* > >::TType pResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "ConvertThreadToFiber" ), 0 ));
#else
#	if ( _WIN32_WINNT > 0x0400 )
		pResult = ::ConvertThreadToFiber( lpParameter );
#	else
		QOR_PP_UNREF( lpParameter );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "ConvertThreadToFiber" ), _T( "Windows NT 4.0" ), 0 ));
#	endif
#endif
		return pResult;
	}

	//--------------------------------------------------------------------------------
	LPVOID CKernel32::ConvertThreadToFiberEx( void* lpParameter, DWORD dwFlags )
	{
		_WINQ_SFCONTEXT( "CKernel32::ConvertThreadToFiberEx" );
		CCheckReturn< LPVOID, CCheckNonZero< LPVOID > >::TType pResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "ConvertThreadToFiberEx" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0502 )
		pResult = ::ConvertThreadToFiberEx( lpParameter, dwFlags );
#	else
		QOR_PP_UNREF2( dwFlags, lpParameter );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "ConvertThreadToFiberEx" ), _T( "Windows NT 4.0" ), 0 ));
#	endif
#endif
		return pResult;
	}

	//--------------------------------------------------------------------------------
	void* CKernel32::CreateFiber( SIZE_T dwStackSize, ::LPFIBER_START_ROUTINE lpStartAddress, void* lpParameter )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateFiber" );
		CCheckReturn< LPVOID, CCheckNonZero< LPVOID > >::TType pResult;
#	if ( _WIN32_WINNT >= 0x0400 )
		pResult = ::CreateFiber( dwStackSize, lpStartAddress, lpParameter );
#	else
		QOR_PP_UNREF3( lpParameter, lpStartAddress, dwStackSize );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CreateFiber" ), _T( "Windows NT 4.0" ), 0 ));
#	endif
		return pResult;
	}

	//--------------------------------------------------------------------------------
	void* CKernel32::CreateFiberEx( SIZE_T dwStackCommitSize, SIZE_T dwStackReserveSize, DWORD dwFlags, ::LPFIBER_START_ROUTINE lpStartAddress, void* lpParameter )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateFiberEx" );
		CCheckReturn< void*, CCheckNonZero< void* > >::TType pResult;
#	if ( _WIN32_WINNT >= 0x0500 )
		pResult = ::CreateFiberEx( dwStackCommitSize, dwStackReserveSize, dwFlags, lpStartAddress, lpParameter );
#	else
		QOR_PP_UNREF5( lpParameter, lpStartAddress, dwFlags, dwStackReserveSize, dwStackCommitSize );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CreateFiberEx" ), _T( "Windows NT 4.0" ), 0 ));
#	endif
		return pResult;
	}

	//--------------------------------------------------------------------------------
	HANDLE CKernel32::CreateJobObject( ::LPSECURITY_ATTRIBUTES lpJobAttributes, LPCTSTR lpName )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateJobObject" );
		CCheckReturn< HANDLE, CHandleNullCheck< > >::TType h;
#	if ( _WIN32_WINNT >= 0x0500 )
		h = ::CreateJobObject( lpJobAttributes, lpName );
#	else
		QOR_PP_UNREF2( lpName, lpJobAttributes );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CreateJobObject" ), _T( "Windows 2000" ), 0 ));
#	endif
		return h;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::CreateProcess( LPCTSTR lpApplicationName, LPTSTR lpCommandLine, ::LPSECURITY_ATTRIBUTES lpProcessAttributes, ::LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, void* lpEnvironment, LPCTSTR lpCurrentDirectory, ::LPSTARTUPINFO lpStartupInfo, ::LPPROCESS_INFORMATION lpProcessInformation )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateProcess" );
		CCheckReturn< BOOL, CBoolCheck<> >::TType bResult;
		bResult = ::CreateProcess( lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation );
		return bResult;
	}

	//------------------------------------------------------------------------------
	HANDLE CKernel32::CreateRemoteThread( HANDLE hProcess, ::LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, void* lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateRemoteThread" );
		CCheckReturn< HANDLE, CHandleNullCheck<> >::TType h;
		h = ::CreateRemoteThread( hProcess, lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId );
		return h;
	}

	//------------------------------------------------------------------------------
	HANDLE CKernel32::CreateThread( ::LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, ::LPTHREAD_START_ROUTINE lpStartAddress, void* lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateThread" );
		CCheckReturn< HANDLE, CHandleNullCheck<> >::TType h;
		h = ::CreateThread( lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId );
		return h;
	}

	//--------------------------------------------------------------------------------
	::PTP_POOL CKernel32::CreateThreadpool( PVOID reserved )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateThreadpool" );
		CCheckReturn< ::PTP_POOL, CCheckNonZero< ::PTP_POOL > >::TType pResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "CreateThreadpool" ), 0 ));
#else

#	if ( _WIN32_WINNT >= 0x0600 )
		pResult = ::CreateThreadpool( reserved );
#	else
			QOR_PP_UNREF( reserved );
			__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CreateThreadpool" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
		return pResult;
	}

	//--------------------------------------------------------------------------------
	::PTP_CLEANUP_GROUP CKernel32::CreateThreadpoolCleanupGroup(void)
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateThreadpoolCleanupGroup" );
		CCheckReturn< ::PTP_CLEANUP_GROUP, CCheckNonZero< ::PTP_CLEANUP_GROUP > >::TType pResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "CreateThreadpoolCleanupGroup" ), 0 ));
#else

#	if ( _WIN32_WINNT >= 0x0600 )
		pResult = ::CreateThreadpoolCleanupGroup();
#	else
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CreateThreadpoolCleanupGroup" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
		return pResult;
	}

	//--------------------------------------------------------------------------------
	::PTP_IO CKernel32::CreateThreadpoolIo( HANDLE fl, ::PTP_WIN32_IO_CALLBACK pfnio, PVOID pv, ::PTP_CALLBACK_ENVIRON pcbe )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateThreadpoolIo" );
		CCheckReturn< ::PTP_IO, CCheckNonZero< ::PTP_IO > >::TType pResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "CreateThreadpoolIo" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		pResult = ::CreateThreadpoolIo( fl, pfnio, pv, pcbe );
#	else
		QOR_PP_UNREF4( pcbe, pv, pfnio, fl );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CreateThreadpoolIo" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
		return pResult;
	}

	//--------------------------------------------------------------------------------
	::PTP_TIMER CKernel32::CreateThreadpoolTimer( ::PTP_TIMER_CALLBACK pfnti, PVOID pv, ::PTP_CALLBACK_ENVIRON pcbe )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateThreadpoolTimer" );
		CCheckReturn< ::PTP_TIMER, CCheckNonZero< ::PTP_TIMER > >::TType pResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "CreateThreadpoolTimer" ), 0 ));
#else

#	if ( _WIN32_WINNT >= 0x0600 )
		pResult = ::CreateThreadpoolTimer( pfnti, pv, pcbe );
#	else
		QOR_PP_UNREF3( pcbe, pv, pfnti );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CreateThreadpoolTimer" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
		return pResult;
	}

	//--------------------------------------------------------------------------------
	::PTP_WAIT CKernel32::CreateThreadpoolWait( ::PTP_WAIT_CALLBACK pfnwa, PVOID pv, ::PTP_CALLBACK_ENVIRON pcbe )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateThreadpoolWait" );
		CCheckReturn< ::PTP_WAIT, CCheckNonZero< ::PTP_WAIT > >::TType pResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "CreateThreadpoolWait" ), 0 ));
#else

#	if ( _WIN32_WINNT >= 0x0600 )
		pResult = ::CreateThreadpoolWait( pfnwa, pv, pcbe );
#	else
		QOR_PP_UNREF3( pcbe, pv, pfnwa );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CreateThreadpoolWait" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
		return pResult;
	}

	//--------------------------------------------------------------------------------
	::PTP_WORK CKernel32::CreateThreadpoolWork( ::PTP_WORK_CALLBACK pfnwk, PVOID pv, ::PTP_CALLBACK_ENVIRON pcbe )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateThreadpoolWork" );
		CCheckReturn< ::PTP_WORK, CCheckNonZero< ::PTP_WORK > >::TType pResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "CreateThreadpoolWork" ), 0 ));
#else

#	if ( _WIN32_WINNT >= 0x0600 )
		pResult = ::CreateThreadpoolWork( pfnwk, pv, pcbe );
#	else
		QOR_PP_UNREF3( pcbe, pv, pfnwk );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CreateThreadpoolWork" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
		return pResult;
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::DeleteFiber( void* lpFiber )
	{
		_WINQ_SFCONTEXT( "CKernel32::DeleteFiber" );
#	if ( _WIN32_WINNT >= 0x0400 )
		::DeleteFiber( lpFiber );
#	else
		QOR_PP_UNREF( lpFiber );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "DeleteFiber" ), _T( "Windows NT 4.0" ), 0 ));
#	endif
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::DeleteProcThreadAttributeList( ::LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList )
	{
		_WINQ_SFCONTEXT( "CKernel32::DeleteProcThreadAttributeList" );
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "DeleteProcThreadAttributeList" ), 0 ));
#else

#	if ( _WIN32_WINNT >= 0x0600 )
		::DeleteProcThreadAttributeList( lpAttributeList );
#	else
		QOR_PP_UNREF( lpAttributeList );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "DeleteProcThreadAttributeList" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::DisassociateCurrentThreadFromCallback( ::PTP_CALLBACK_INSTANCE pci )
	{
		_WINQ_SFCONTEXT( "CKernel32::DisassociateCurrentThreadFromCallback" );
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "DisassociateCurrentThreadFromCallback" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		::DisassociateCurrentThreadFromCallback( pci );
#	else
		QOR_PP_UNREF( pci );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "DisassociateCurrentThreadFromCallback" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
	}

	//------------------------------------------------------------------------------
	VOID CKernel32::ExitProcess( UINT uExitCode )
	{
		_WINQ_SFCONTEXT( "CKernel32::ExitProcess" );
		::ExitProcess( uExitCode );
	}

	//------------------------------------------------------------------------------
	VOID CKernel32::ExitThread( DWORD dwExitCode )
	{
		_WINQ_SFCONTEXT( "CKernel32::ExitThread" );
		::ExitThread( dwExitCode );
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::FlsAlloc( ::PFLS_CALLBACK_FUNCTION lpCallback )
	{
		_WINQ_SFCONTEXT( "CKernel32::FlsAlloc" );
		CCheckReturn< DWORD, CTCheckFailureValue< DWORD, FLS_OUT_OF_INDEXES > >::TType dwResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "FlsAlloc" ), 0 ));
#else
		
#	if ( _WIN32_WINNT >= 0x0502 )
		dwResult = ::FlsAlloc( lpCallback );
#	else
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "FlsAlloc" ), _T( "Windows Server 2003" ), 0 ));
#	endif

#endif
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::FlsFree( DWORD dwFlsIndex )
	{
		_WINQ_SFCONTEXT( "CKernel32::FlsFree" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "FlsFree" ), 0 ));
#else
		
#	if ( _WIN32_WINNT >= 0x0502 )
		bResult = ::FlsFree( dwFlsIndex );
#	else
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "FlsFree" ), _T( "Windows Server 2003" ), 0 ));
#	endif

#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	PVOID CKernel32::FlsGetValue( DWORD dwFlsIndex )
	{
		_WINQ_SFCONTEXT( "CKernel32::FlsGetValue" );
		CCheckReturn< PVOID, CCheckNonZero< PVOID > >::TType pResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "FlsGetValue" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0502 )
		pResult = ::FlsGetValue( dwFlsIndex );
#	else
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "FlsGetValue" ), _T( "Windows Server 2003" ), 0 ));
#	endif
		
#endif
		return pResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::FlsSetValue( DWORD dwFlsIndex, PVOID lpFlsData )
	{
		_WINQ_SFCONTEXT( "CKernel32::FlsSetValue" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "FlsSetValue" ), 0 ));
#else

#	if ( _WIN32_WINNT >= 0x0502 )
		bResult = ::FlsSetValue( dwFlsIndex, lpFlsData );
#	else
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "FlsSetValue" ), _T( "Windows Server 2003" ), 0 ));
#	endif

#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::FlushProcessWriteBuffers(void)
	{
		_WINQ_SFCONTEXT( "CKernel32::FlushProcessWriteBuffers" );
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "FlushProcessWriteBuffers" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		::FlushProcessWriteBuffers();
#	else
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "FlushProcessWriteBuffers" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::FreeEnvironmentStrings( LPTSTR lpszEnvironmentBlock )
	{
		_WINQ_SFCONTEXT( "CKernel32::FreeEnvironmentStrings" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
		bResult = ::FreeEnvironmentStrings( lpszEnvironmentBlock );
		return bResult;
	}

	#ifdef UNICODE
	//------------------------------------------------------------------------------
	BOOL CKernel32::FreeEnvironmentStringsA( LPSTR lpszEnvironmentBlock )
	{
		_WINQ_SFCONTEXT( "CKernel32::FreeEnvironmentStringsA" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
		bResult = ::FreeEnvironmentStringsA( lpszEnvironmentBlock );
		return bResult;
	}
	#else
	//------------------------------------------------------------------------------
	BOOL CKernel32::FreeEnvironmentStringsW( LPWSTR lpszEnvironmentBlock )
	{
		_WINQ_SFCONTEXT( "CKernel32::FreeEnvironmentStringsW" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
		bResult = ::FreeEnvironmentStringsW( lpszEnvironmentBlock );
		return bResult;
	}
	#endif

	//--------------------------------------------------------------------------------
	VOID CKernel32::FreeLibraryWhenCallbackReturns( ::PTP_CALLBACK_INSTANCE pci, HMODULE mod )
	{
		_WINQ_SFCONTEXT( "CKernel32::FreeLibraryWhenCallbackReturns" );
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "FreeLibraryWhenCallbackReturns" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		::FreeLibraryWhenCallbackReturns( pci, mod );
#	else
		QOR_PP_UNREF2( mod, pci );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "FreeLibraryWhenCallbackReturns" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
	}

	//------------------------------------------------------------------------------
	LPTSTR CKernel32::GetCommandLine(void)
	{
		_WINQ_SFCONTEXT( "CKernel32::GetCommandLine" );
		LPTSTR pResult = 0;
		pResult = ::GetCommandLine();
		return pResult;
	}

	//------------------------------------------------------------------------------
	HANDLE CKernel32::GetCurrentProcess(void)
	{
		_WINQ_SFCONTEXT( "CKernel32::GetCurrentProcess" );
		return ::GetCurrentProcess();
	}

	//------------------------------------------------------------------------------
	DWORD CKernel32::GetCurrentProcessId(void)
	{
		_WINQ_SFCONTEXT( "CKernel32::GetCurrentProcessId" );
		DWORD dwResult = ::GetCurrentProcessId();
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::GetCurrentProcessorNumber(void)
	{
		_WINQ_SFCONTEXT( "CKernel32::GetCurrentProcessorNumber" );
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "GetCurrentProcessorNumber" ), 0 ));
#else
#	if( _MSC_VER >= 1700 )
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "GetCurrentProcessorNumber" ), _T( "Windows 7" ), 0 ));
#	else
#		if ( _WIN32_WINNT >= 0x0502 )
			return ::GetCurrentProcessorNumber();
#		else
			__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "GetCurrentProcessorNumber" ), _T( "Windows Server 2003" ), 0 ));
#		endif
#	endif
#endif
		return 0;
	}

	//------------------------------------------------------------------------------
	HANDLE CKernel32::GetCurrentThread(void)
	{
		_WINQ_SFCONTEXT( "CKernel32::GetCurrentThread" );
		CCheckReturn< HANDLE, CHandleCheck<> >::TType h = ::GetCurrentThread();
		return h;
	}

	//------------------------------------------------------------------------------
	DWORD CKernel32::GetCurrentThreadId(void)
	{
		_WINQ_SFCONTEXT( "CKernel32::GetCurrentThreadId" );
		return ::GetCurrentThreadId();
	}

	//------------------------------------------------------------------------------
	LPVOID CKernel32::GetEnvironmentStringsA(void)
	{
		_WINQ_SFCONTEXT( "CKernel32::GetEnvironmentStringsA" );
		CCheckReturn< LPVOID, CCheckNonZero< LPVOID > >::TType pResult;
		pResult = ::GetEnvironmentStrings();
		return pResult;
	}

	//------------------------------------------------------------------------------
	LPVOID CKernel32::GetEnvironmentStringsW(void)
	{
		_WINQ_SFCONTEXT( "CKernel32::GetEnvironmentStringsW" );
		CCheckReturn< LPVOID, CCheckNonZero< LPVOID > >::TType pResult;
		pResult = ::GetEnvironmentStringsW();
		return pResult;
	}

	//------------------------------------------------------------------------------
	DWORD CKernel32::GetEnvironmentVariable( LPCTSTR lpName, LPTSTR lpBuffer, DWORD nSize )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetEnvironmentVariable" );
		CCheckReturn< DWORD, CCheckNonZero< DWORD > >::TType dwResult;
		dwResult = ::GetEnvironmentVariable( lpName, lpBuffer, nSize );
		return dwResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::GetExitCodeProcess( HANDLE hProcess, LPDWORD lpExitCode )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetExitCodeProcess" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
		bResult = ::GetExitCodeProcess( hProcess, lpExitCode );
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::GetExitCodeThread( HANDLE hThread, LPDWORD lpExitCode )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetExitCodeThread" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
		bResult = ::GetExitCodeThread( hThread, lpExitCode );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::GetLogicalProcessorInformation( ::PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer, PDWORD ReturnLength )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetLogicalProcessorInformation" );
		BOOL bResult = FALSE;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "GetLogicalProcessorInformation" ), 0 ));
#else
		bResult = ::GetLogicalProcessorInformation( Buffer, ReturnLength );
		if( bResult == FALSE && Buffer != 0 )//If you just want to query the needed size pass a NULL Buffer
		{
			__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, _T( "GetLogicalProcessorInformation" ), 0 ));
		}
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::GetNumaAvailableMemoryNode( UCHAR Node, PULONGLONG AvailableBytes )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetNumaAvailableMemoryNode" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "GetNumaAvailableMemoryNode" ), 0 ));
#else
		bResult = ::GetNumaAvailableMemoryNode( Node, AvailableBytes );
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::GetNumaHighestNodeNumber( PULONG HighestNodeNumber )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetNumaHighestNodeNumber" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "GetNumaHighestNodeNumber" ), 0 ));
#else
		bResult = ::GetNumaHighestNodeNumber( HighestNodeNumber );
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::GetNumaNodeProcessorMask( UCHAR Node, PULONGLONG ProcessorMask )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetNumaNodeProcessorMask" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "GetNumaNodeProcessorMask" ), 0 ));
#else
		bResult = ::GetNumaNodeProcessorMask( Node, ProcessorMask );
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::GetNumaProcessorNode( UCHAR Processor, PUCHAR NodeNumber )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetNumaProcessorNode" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "GetNumaProcessorNode" ), 0 ));
#else
		bResult = ::GetNumaProcessorNode( Processor, NodeNumber );
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::GetNumaProximityNode( ULONG ProximityId, PUCHAR NodeNumber )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetNumaProximityNode" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "GetNumaProximityNode" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		bResult = ::GetNumaProximityNode( ProximityId, NodeNumber );
#	else
		QOR_PP_UNREF2( NodeNumber, ProximityId );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "GetNumaProximityNode" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	DWORD CKernel32::GetPriorityClass( HANDLE hProcess )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetPriorityClass" );
		CCheckReturn< DWORD, CCheckNonZero< DWORD > >::TType dwResult;
		dwResult = ::GetPriorityClass( hProcess );
		return dwResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::GetProcessAffinityMask( HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetProcessAffinityMask" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
		bResult = ::GetProcessAffinityMask( hProcess, lpProcessAffinityMask, lpSystemAffinityMask );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::GetProcessHandleCount( HANDLE hProcess, PDWORD pdwHandleCount )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetProcessHandleCount" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0501 )
		bResult = ::GetProcessHandleCount( hProcess, pdwHandleCount );
#	else
		QOR_PP_UNREF2( pdwHandleCount, hProcess );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "GetProcessHandleCount" ), _T( "Windows XP Service Pack 1" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::GetProcessId( HANDLE Process )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetProcessId" );
		CCheckReturn< DWORD, CCheckNonZero< DWORD > >::TType dwResult;
		dwResult = ::GetProcessId( Process );
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::GetProcessIdOfThread( HANDLE Thread )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetProcessIdOfThread" );
		CCheckReturn< DWORD, CCheckNonZero< DWORD > >::TType dwResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "GetProcessIdOfThread" ), 0 ));
#else
#	if( _MSC_VER >= 1700 )
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "GetProcessIdOfThread" ), _T( "Windows 7" ), 0 ));
#	else
#		if ( _WIN32_WINNT >= 0x0502 )
			dwResult = ::GetProcessIdOfThread( Thread );
#		else
			QOR_PP_UNREF( Thread );
			__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "GetProcessIdOfThread" ), _T( "Windows Server 2003" ), 0 ));
#		endif
#	endif
#endif
		return dwResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::GetProcessIoCounters( HANDLE hProcess, ::PIO_COUNTERS lpIoCounters )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetProcessIoCounters" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0500 )//Win2K
		bResult = ::GetProcessIoCounters( hProcess, lpIoCounters );
#	else
		QOR_PP_UNREF( lpIoCounters, hProcess );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "GetProcessIoCounters" ), _T( "Windows 2000" ), 0 ));
#	endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::GetProcessPriorityBoost( HANDLE hProcess, PBOOL pDisablePriorityBoost )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetProcessPriorityBoost" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0400 )
		bResult = ::GetProcessPriorityBoost( hProcess, pDisablePriorityBoost );
#	else
		QOR_PP_UNREF2( pDisablePriorityBoost, hProcess );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "GetProcessPriorityBoost" ), _T( "Windows NT 4.0" ), 0 ));
#	endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::GetProcessShutdownParameters( LPDWORD lpdwLevel, LPDWORD lpdwFlags )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetProcessShutdownParameters" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT > 0x0500 )
		bResult = ::GetProcessShutdownParameters( lpdwLevel, lpdwFlags );
#	else
		QOR_PP_UNREF2( lpdwFlags, lpdwLevel );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "GetProcessShutdownParameters" ), _T( "Windows 2000" ), 0 ));
#	endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::GetProcessTimes( HANDLE hProcess, ::LPFILETIME lpCreationTime, ::LPFILETIME lpExitTime, ::LPFILETIME lpKernelTime, ::LPFILETIME lpUserTime )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetProcessTimes" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT > 0x0400 )//NT4
		bResult = ::GetProcessTimes( hProcess, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime );
#	else
		QOR_PP_UNREF5( lpUserTime, lpKernelTime, lpExitTime, lpCreationTime, hProcess );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "GetProcessTimes" ), _T( "Windows NT 4.0" ), 0 ));
#	endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	DWORD CKernel32::GetProcessVersion( DWORD ProcessId )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetProcessVersion" );
		CCheckReturn< DWORD, CCheckNonZero< DWORD > >::TType dwResult;
		dwResult = ::GetProcessVersion( ProcessId );
		return dwResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::GetProcessWorkingSetSize( HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetProcessWorkingSetSize" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT > 0x0400 )
		bResult = ::GetProcessWorkingSetSize( hProcess, lpMinimumWorkingSetSize, lpMaximumWorkingSetSize );
#	else
		QOR_PP_UNREF3( lpMaximumWorkingSetSize, lpMinimumWorkingSetSize, hProcess );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "GetProcessWorkingSetSize" ), _T( "Windows NT 4.0" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::GetProcessWorkingSetSizeEx( HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize, PDWORD Flags )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetProcessWorkingSetSizeEx" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "GetProcessWorkingSetSizeEx" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0502 )
		bResult = ::GetProcessWorkingSetSizeEx( hProcess, lpMinimumWorkingSetSize, lpMaximumWorkingSetSize, Flags );
#	else
		QOR_PP_UNREF4( hProcess, lpMinimumWorkingSetSize, lpMaximumWorkingSetSize, Flags );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "GetProcessWorkingSetSizeEx" ), _T( "Windows Server 2003" ), 0 ));
#	endif
#endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	VOID CKernel32::GetStartupInfo( CCheckParam< ::LPSTARTUPINFO, CTRWPointerCheck< sizeof( ::STARTUPINFO ) > >::TType pStartupInfo )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetStartupInfo" );
		::GetStartupInfo( pStartupInfo );
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::GetThreadId( HANDLE Thread )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetThreadId" );
		CCheckReturn< DWORD, CCheckNonZero< DWORD > >::TType dwResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "GetProcessWorkingSetSizeEx" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0502 )
		dwResult = ::GetThreadId( Thread );
#	else
		QOR_PP_UNREF( Thread );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "GetThreadId" ), _T( "Windows Server 2003" ), 0 ));
#	endif
#endif
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::GetThreadIOPendingFlag( HANDLE hThread, PBOOL lpIOIsPending )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetThreadIOPendingFlag" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if( _WIN32_WINNT >= 0x0501 )
		bResult = ::GetThreadIOPendingFlag( hThread, lpIOIsPending );
#	else
		QOR_PP_UNREF2( lpIOIsPending, hThread );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "GetThreadIOPendingFlag" ), _T( "Windows XP" ), 0 ));
#	endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	int CKernel32::GetThreadPriority( HANDLE hThread )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetThreadPriority" );
		CCheckReturn< int, CTCheckFailureValue< int, THREAD_PRIORITY_ERROR_RETURN > >::TType iResult;
		iResult = ::GetThreadPriority( hThread );
		return iResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::GetThreadPriorityBoost( HANDLE hThread, PBOOL pDisablePriorityBoost )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetThreadPriorityBoost" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
		bResult = ::GetThreadPriorityBoost( hThread, pDisablePriorityBoost );
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::GetThreadTimes( HANDLE hThread, ::LPFILETIME lpCreationTime, ::LPFILETIME lpExitTime, ::LPFILETIME lpKernelTime, ::LPFILETIME lpUserTime )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetThreadTimes" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
		bResult = ::GetThreadTimes( hThread, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::InitializeProcThreadAttributeList( ::LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwAttributeCount, DWORD dwFlags, PSIZE_T lpSize )
	{
		_WINQ_SFCONTEXT( "CKernel32::InitializeProcThreadAttributeList" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "InitializeProcThreadAttributeList" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		bResult = ::InitializeProcThreadAttributeList( lpAttributeList, dwAttributeCount, dwFlags, lpSize );
#	else
		QOR_PP_UNREF4( lpSize, dwFlags, dwAttributeCount, lpAttributeList );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "InitializeProcThreadAttributeList" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::InitializeThreadpoolEnvironment( ::PTP_CALLBACK_ENVIRON pcbe )
	{
		_WINQ_SFCONTEXT( "CKernel32::InitializeThreadpoolEnvironment" );
#	if ( _WIN32_WINNT >= 0x0600 )
		::InitializeThreadpoolEnvironment( pcbe );
#	else
		QOR_PP_UNREF( pcbe );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "InitializeThreadpoolEnvironment" ), _T( "Windows Vista" ), 0 ));
#	endif
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::DestroyThreadpoolEnvironment( ::PTP_CALLBACK_ENVIRON pcbe )
	{
		_WINQ_SFCONTEXT( "CKernel32::DestroyThreadpoolEnvironment" );
#	if ( _WIN32_WINNT >= 0x0600 )
		::DestroyThreadpoolEnvironment( pcbe );
#	else
		QOR_PP_UNREF( pcbe );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "InitializeThreadpoolEnvironment" ), _T( "Windows Vista" ), 0 ));
#	endif
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::IsProcessInJob( HANDLE ProcessHandle, HANDLE JobHandle, PBOOL Result )
	{
		_WINQ_SFCONTEXT( "CKernel32::IsProcessInJob" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "IsProcessInJob" ), 0 ));
#else
#	if( _WIN32_WINNT >= 0x0501 )
		bResult = ::IsProcessInJob( ProcessHandle, JobHandle, Result );
#	else
		QOR_PP_UNREF3( Result, JobHandle, ProcessHandle );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "IsProcessInJob" ), _T( "Windows XP" ), 0 ));
#endif
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::IsThreadAFiber(void)
	{
		_WINQ_SFCONTEXT( "CKernel32::IsThreadAFiber" );
		BOOL bResult = FALSE;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "IsThreadAFiber" ), 0 ));
#else
#	if( _WIN32_WINNT >= 0x0600 )
		bResult = ::IsThreadAFiber();
#	else
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "IsThreadAFiber" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::IsThreadpoolTimerSet( ::PTP_TIMER pti )
	{
		_WINQ_SFCONTEXT( "CKernel32::IsThreadpoolTimerSet" );
		BOOL bResult = FALSE;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "IsThreadpoolTimerSet" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		bResult = ::IsThreadpoolTimerSet( pti );
#	else
		QOR_PP_UNREF( pti );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "IsThreadpoolTimerSet" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::IsWow64Process( HANDLE hProcess, PBOOL Wow64Process )
	{
		_WINQ_SFCONTEXT( "CKernel32::IsWow64Process" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if( _WIN32_WINNT >= 0x0501 )
		bResult = ::IsWow64Process( hProcess, Wow64Process );
#	else
		QOR_PP_UNREF2( Wow64Process, hProcess );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "IsWow64Process" ), _T( "Windows XP" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::LeaveCriticalSectionWhenCallbackReturns( ::PTP_CALLBACK_INSTANCE pci, ::PCRITICAL_SECTION pcs )
	{
		_WINQ_SFCONTEXT( "CKernel32::LeaveCriticalSectionWhenCallbackReturns" );
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "LeaveCriticalSectionWhenCallbackReturns" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		::LeaveCriticalSectionWhenCallbackReturns( pci, pcs );
#	else
		QOR_PP_UNREF2( pcs, pci );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "LeaveCriticalSectionWhenCallbackReturns" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::NeedCurrentDirectoryForExePath( LPCTSTR ExeName )
	{
		_WINQ_SFCONTEXT( "CKernel32::NeedCurrentDirectoryForExePath" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "NeedCurrentDirectoryForExePath" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0502 )
		bResult = ::NeedCurrentDirectoryForExePath( ExeName );
#	else
		QOR_PP_UNREF( ExeName );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "NeedCurrentDirectoryForExePath" ), _T( "Windows Server 2003" ), 0 ));
#	endif
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	HANDLE CKernel32::OpenJobObject( DWORD dwDesiredAccess, BOOL bInheritHandles, LPCTSTR lpName )
	{
		_WINQ_SFCONTEXT( "CKernel32::OpenJobObject" );
		CCheckReturn< HANDLE, CHandleNullCheck< > >::TType h;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "OpenJobObject" ), 0 ));
#else
#	if( _WIN32_WINNT >= 0x0500 )
		h = ::OpenJobObject( dwDesiredAccess, bInheritHandles, lpName );
#	else
		QOR_PP_UNREF3( lpName, bInheritHandles, dwDesiredAccess );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "OpenJobObject" ), _T( "Windows 2000" ), 0 ));
#	endif
#endif
		return h;
	}

	//------------------------------------------------------------------------------
	HANDLE CKernel32::OpenProcess( DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId )
	{
		_WINQ_SFCONTEXT( "CKernel32::OpenProcess" );
		CCheckReturn< HANDLE, CHandleNullCheck< > >::TType h;
		h = ::OpenProcess( dwDesiredAccess, bInheritHandle, dwProcessId );
		return h;
	}

	//------------------------------------------------------------------------------
	HANDLE CKernel32::OpenThread( DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwThreadId )
	{
		_WINQ_SFCONTEXT( "CKernel32::OpenThread" );
		CCheckReturn< HANDLE, CHandleNullCheck< > >::TType h;
		h = ::OpenThread( dwDesiredAccess, bInheritHandle, dwThreadId );
		return h;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::QueryFullProcessImageName( HANDLE hProcess, DWORD dwFlags, LPTSTR lpExeName, PDWORD lpdwSize )
	{
		_WINQ_SFCONTEXT( "CKernel32::QueryFullProcessImageName" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "QueryFullProcessImageName" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		bResult = ::QueryFullProcessImageName( hProcess, dwFlags, lpExeName, lpdwSize );
#	else
		QOR_PP_UNREF4( lpdwSize, lpExeName, dwFlags, hProcess );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "QueryFullProcessImageName" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::QueryIdleProcessorCycleTime( PULONG BufferLength, PULONG64 ProcessorIdleCycleTime )
	{
		_WINQ_SFCONTEXT( "CKernel32::QueryIdleProcessorCycleTime" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "QueryIdleProcessorCycleTime" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		bResult = ::QueryIdleProcessorCycleTime( BufferLength, ProcessorIdleCycleTime );
#	else
		QOR_PP_UNREF( ProcessorIdleCycleTime, BufferLength );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "QueryIdleProcessorCycleTime" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::QueryInformationJobObject( HANDLE hJob, ::JOBOBJECTINFOCLASS JobObjectInfoClass, void* lpJobObjectInfo, DWORD cbJobObjectInfoLength, LPDWORD lpReturnLength )
	{
		_WINQ_SFCONTEXT( "CKernel32::QueryInformationJobObject" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if( _WIN32_WINNT >= 0x0500 )
		bResult = ::QueryInformationJobObject( hJob, JobObjectInfoClass, lpJobObjectInfo, cbJobObjectInfoLength, lpReturnLength );
#	else
		QOR_PP_UNREF5( lpReturnLength, cbJobObjectInfoLength, lpJobObjectInfo, JobObjectInfoClass, hJob );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "QueryInformationJobObject" ), _T( "Windows 2000" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	//Requires Windows Vista SP1. Server Requires Windows Server 2008.
	BOOL CKernel32::QueryProcessAffinityUpdateMode( HANDLE ProcessHandle, LPDWORD lpdwFlags )
	{
		_WINQ_SFCONTEXT( "CKernel32::QueryProcessAffinityUpdateMode" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "QueryProcessAffinityUpdateMode" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 && NTDDI_VERSION >= NTDDI_VISTASP1 )
		bResult = ::QueryProcessAffinityUpdateMode( ProcessHandle, lpdwFlags );
#	else
		QOR_PP_UNREF2( lpdwFlags, ProcessHandle );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "QueryProcessAffinityUpdateMode" ), _T( "Windows Vista Service Pack 1" ), 0 ));
#	endif
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::QueryProcessCycleTime( HANDLE ProcessHandle, PULONG64 CycleTime )
	{
		_WINQ_SFCONTEXT( "CKernel32::QueryProcessCycleTime" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "QueryProcessCycleTime" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		bResult = ::QueryProcessCycleTime( ProcessHandle, CycleTime );
#	else
		QOR_PP_UNREF2( CycleTime, ProcessHandle );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "QueryProcessCycleTime" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::QueryThreadCycleTime( HANDLE ThreadHandle, PULONG64 CycleTime )
	{
		_WINQ_SFCONTEXT( "CKernel32::QueryThreadCycleTime" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "QueryThreadCycleTime" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		bResult = ::QueryThreadCycleTime( ThreadHandle, CycleTime );
#	else
		QOR_PP_UNREF2( CycleTime, ThreadHandle );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "QueryThreadCycleTime" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::QueueUserWorkItem( LPTHREAD_START_ROUTINE Function, PVOID Context, ULONG Flags )
	{
		_WINQ_SFCONTEXT( "CKernel32::QueueUserWorkItem" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if( _WIN32_WINNT >= 0x0500 )
		bResult = ::QueueUserWorkItem( Function, Context, Flags );
#	else
		QOR_PP_UNREF3( Flags, Context, Function );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "QueueUserWorkItem" ), _T( "Windows 2000" ), 0 ));
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::ReleaseMutexWhenCallbackReturns( ::PTP_CALLBACK_INSTANCE pci, HANDLE mut )
	{
		_WINQ_SFCONTEXT( "CKernel32::ReleaseMutexWhenCallbackReturns" );
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "ReleaseMutexWhenCallbackReturns" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		::ReleaseMutexWhenCallbackReturns( pci, mut );
#	else
		QOR_PP_UNREF2( mut, pci );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "ReleaseMutexWhenCallbackReturns" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::ReleaseSemaphoreWhenCallbackReturns( ::PTP_CALLBACK_INSTANCE pci, HANDLE sem, DWORD crel )
	{
		_WINQ_SFCONTEXT( "CKernel32::ReleaseSemaphoreWhenCallbackReturns" );
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "ReleaseSemaphoreWhenCallbackReturns" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		::ReleaseSemaphoreWhenCallbackReturns( pci, sem, crel );
#	else
		QOR_PP_UNREF3( crel, sem, pci );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "ReleaseSemaphoreWhenCallbackReturns" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
	}

	//------------------------------------------------------------------------------
	DWORD CKernel32::ResumeThread( HANDLE hThread )
	{
		_WINQ_SFCONTEXT( "CKernel32::ResumeThread" );
		CCheckReturn< DWORD, CTCheckFailureValue< DWORD, 0xFFFFFFFF > >::TType dwResult;
		dwResult = ::ResumeThread( hThread );
		return dwResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::SetEnvironmentVariable( LPCTSTR lpName, LPCTSTR lpValue )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetEnvironmentVariable" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
		bResult = ::SetEnvironmentVariable( lpName, lpValue );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::SetEventWhenCallbackReturns( ::PTP_CALLBACK_INSTANCE pci, HANDLE evt )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetEventWhenCallbackReturns" );
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "SetEventWhenCallbackReturns" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		::SetEventWhenCallbackReturns( pci, evt );
#	else
		QOR_PP_UNREF2( evt, pci );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SetEventWhenCallbackReturns" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::SetInformationJobObject( HANDLE hJob, ::JOBOBJECTINFOCLASS JobObjectInfoClass, void* lpJobObjectInfo, DWORD cbJobObjectInfoLength )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetInformationJobObject" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if( _WIN32_WINNT >= 0x0500 )
		bResult = ::SetInformationJobObject( hJob, JobObjectInfoClass, lpJobObjectInfo, cbJobObjectInfoLength );
#	else
		QOR_PP_UNREF4( cbJobObjectInfoLength, lpJobObjectInfo, JobObjectInfoClass, hJob );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SetInformationJobObject" ), _T( "Windows 2000" ), 0 ));
#	endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::SetPriorityClass( HANDLE hProcess, DWORD dwPriorityClass )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetPriorityClass" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
		bResult = ::SetPriorityClass( hProcess, dwPriorityClass );
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::SetProcessAffinityMask( HANDLE hProcess, DWORD_PTR dwProcessAffinityMask )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetProcessAffinityMask" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT > 0x0400 )//NT4
		bResult= ::SetProcessAffinityMask( hProcess, dwProcessAffinityMask );
#	else
		QOR_PP_UNREF2( dwProcessAffinityMask, hProcess );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SetProcessAffinityMask" ), _T( "Windows NT 4.0" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::SetProcessAffinityUpdateMode( HANDLE ProcessHandle, DWORD dwFlags )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetProcessAffinityUpdateMode" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "SetProcessAffinityUpdateMode" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 && NTDDI_VERSION >= NTDDI_VISTASP1 )
		bResult = ::SetProcessAffinityUpdateMode( ProcessHandle, dwFlags );
#	else
		QOR_PP_UNREF2( dwFlags, ProcessHandle );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SetProcessAffinityUpdateMode" ), _T( "Windows Vista Service Pack 1" ), 0 ));
#	endif
#endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::SetProcessPriorityBoost( HANDLE hProcess, BOOL DisablePriorityBoost )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetProcessPriorityBoost" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT > 0x0400 )
		bResult = ::SetProcessPriorityBoost( hProcess, DisablePriorityBoost );
#	else
		QOR_PP_UNREF2( DisablePriorityBoost, hProcess );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SetProcessPriorityBoost" ), _T( "Windows NT 4.0" ), 0 ));
#	endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::SetProcessShutdownParameters( DWORD dwLevel, DWORD dwFlags )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetProcessShutdownParameters" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT > 0x0000 )
		bResult = ::SetProcessShutdownParameters( dwLevel, dwFlags );
#	else
		QOR_PP_UNREF2( dwFlags, dwLevel );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SetProcessShutdownParameters" ), _T( "Windows NT" ), 0 ));
#	endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::SetProcessWorkingSetSize( HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetProcessWorkingSetSize" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT > 0x0400 )
		bResult = ::SetProcessWorkingSetSize( hProcess, dwMinimumWorkingSetSize, dwMaximumWorkingSetSize );
#	else
		QOR_PP_UNREF3( dwMaximumWorkingSetSize, dwMinimumWorkingSetSize, hProcess );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SetProcessWorkingSetSize" ), _T( "Windows NT" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::SetProcessWorkingSetSizeEx( HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize, DWORD Flags )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetProcessWorkingSetSizeEx" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "SetProcessWorkingSetSizeEx" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0502 )
		bResult = ::SetProcessWorkingSetSizeEx( hProcess, dwMinimumWorkingSetSize, dwMaximumWorkingSetSize, Flags );
#	else
		QOR_PP_UNREF4( Flags, dwMaximumWorkingSetSize, dwMinimumWorkingSetSize, hProcess );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SetProcessWorkingSetSizeEx" ), _T( "Windows 2003" ), 0 ));
#	endif
#endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	DWORD_PTR CKernel32::SetThreadAffinityMask( HANDLE hThread, DWORD_PTR dwThreadAffinityMask )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetThreadAffinityMask" );
		CCheckReturn< DWORD_PTR, CCheckNonZero< DWORD_PTR > >::TType dwResult;
		dwResult = ::SetThreadAffinityMask( hThread, dwThreadAffinityMask );
		return dwResult;
	}

	//------------------------------------------------------------------------------
	DWORD CKernel32::SetThreadIdealProcessor( HANDLE hThread, DWORD dwIdealProcessor )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetThreadIdealProcessor" );
		CCheckReturn< DWORD, CTCheckFailureValue< DWORD, 0xFFFFFFFF > >::TType dwResult;
#	if ( _WIN32_WINNT >= 0x0400 )
		dwResult = ::SetThreadIdealProcessor( hThread, dwIdealProcessor );
#	else
		QOR_PP_UNREF2( dwIdealProcessor, hThread );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SetThreadIdealProcessor" ), _T( "Windows NT 4.0" ), 0 ));
#	endif
		return dwResult;
	}

	//------------------------------------------------------------------------------
	VOID CKernel32::SetThreadpoolCallbackCleanupGroup( ::PTP_CALLBACK_ENVIRON pcbe, ::PTP_CLEANUP_GROUP ptpcg, ::PTP_CLEANUP_GROUP_CANCEL_CALLBACK pfng )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetThreadpoolCallbackCleanupGroup" );
#	if ( _WIN32_WINNT >= 0x0600 )
		::SetThreadpoolCallbackCleanupGroup( pcbe, ptpcg, pfng );
#	else
		QOR_PP_UNREF3( pfng, ptpcg, pcbe );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SetThreadpoolCallbackCleanupGroup" ), _T( "Windows Vista" ), 0 ));
#	endif
	}

	//------------------------------------------------------------------------------
	VOID CKernel32::SetThreadpoolCallbackLibrary( ::PTP_CALLBACK_ENVIRON pcbe, PVOID mod )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetThreadpoolCallbackLibrary" );
#	if ( _WIN32_WINNT >= 0x0600 )
		::SetThreadpoolCallbackLibrary( pcbe, mod );
#	else
		QOR_PP_UNREF( mod, pcbe );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SetThreadpoolCallbackLibrary" ), _T( "Windows Vista" ), 0 ));
#	endif
	}

	//------------------------------------------------------------------------------
	VOID CKernel32::SetThreadpoolCallbackPool( ::PTP_CALLBACK_ENVIRON pcbe, ::PTP_POOL ptpp )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetThreadpoolCallbackPool" );
#	if ( _WIN32_WINNT >= 0x0600 )
		::SetThreadpoolCallbackPool( pcbe, ptpp );
#	else
		QOR_PP_UNREF( ptpp, pcbe );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SetThreadpoolCallbackPool" ), _T( "Windows Vista" ), 0 ));
#	endif
	}

	//------------------------------------------------------------------------------
	VOID CKernel32::SetThreadpoolCallbackRunsLong( ::PTP_CALLBACK_ENVIRON pcbe )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetThreadpoolCallbackRunsLong" );
	#	if ( _WIN32_WINNT >= 0x0600 )
			::SetThreadpoolCallbackRunsLong( pcbe );
	#	else
			QOR_PP_UNREF( pcbe );
			__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SetThreadpoolCallbackRunsLong" ), _T( "Windows Vista" ), 0 ));
	#	endif
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::SetThreadpoolThreadMaximum( ::PTP_POOL ptpp, DWORD cthrdMost )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetThreadpoolThreadMaximum" );
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "SetThreadpoolThreadMaximum" ), 0 ));
#else
	#	if ( _WIN32_WINNT >= 0x0600 )
			::SetThreadpoolThreadMaximum( ptpp, cthrdMost );
	#	else
			QOR_PP_UNREF( cthrdMost, ptpp );
			__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SetThreadpoolThreadMaximum" ), _T( "Windows Vista" ), 0 ));
	#	endif
#endif
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::SetThreadpoolThreadMinimum( ::PTP_POOL ptpp, DWORD cthrdMic )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetThreadpoolThreadMinimum" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "SetThreadpoolThreadMinimum" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		bResult = ::SetThreadpoolThreadMinimum( ptpp, cthrdMic );
#	else
		QOR_PP_UNREF( cthrdMic, ptpp );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SetThreadpoolThreadMinimum" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::SetThreadpoolTimer( ::PTP_TIMER pti, ::PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetThreadpoolTimer" );
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "SetThreadpoolTimer" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		::SetThreadpoolTimer( pti, pftDueTime, msPeriod, msWindowLength );
#	else
		QOR_PP_UNREF4( msWindowLength, msPeriod, pftDueTime, pti );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SetThreadpoolTimer" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::SetThreadpoolWait( ::PTP_WAIT pwa, HANDLE h, ::PFILETIME pftTimeout )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetThreadpoolWait" );
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "SetThreadpoolWait" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		::SetThreadpoolWait( pwa, h, pftTimeout );
#	else
		QOR_PP_UNREF3( pftTimeout, h, pwa );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SetThreadpoolWait" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::SetThreadPriority( HANDLE hThread, int nPriority )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetThreadPriority" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
		bResult = ::SetThreadPriority( hThread, nPriority );
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::SetThreadPriorityBoost( HANDLE hThread, BOOL bDisablePriorityBoost )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetThreadPriorityBoost" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
		bResult = ::SetThreadPriorityBoost( hThread, bDisablePriorityBoost );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	//Client Requires Windows XP Professional x64 Edition.
	//Server Requires Windows Server 2003 SP1.
	BOOL CKernel32::SetThreadStackGuarantee( PULONG StackSizeInBytes )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetThreadStackGuarantee" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "SetThreadStackGuarantee" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0502 )
		bResult = ::SetThreadStackGuarantee( StackSizeInBytes );
#	else
		QOR_PP_UNREF( StackSizeInBytes );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SetThreadStackGuarantee" ), _T( "Windows Server 2003" ), 0 ));
#	endif
#endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	VOID CKernel32::Sleep( DWORD dwMilliseconds )
	{
		_WINQ_SFCONTEXT( "CKernel32::Sleep" );
		::Sleep( dwMilliseconds );
	}

	//------------------------------------------------------------------------------
	DWORD CKernel32::SleepEx( DWORD dwMilliseconds, BOOL bAlertable )
	{
		_WINQ_SFCONTEXT( "CKernel32::SleepEx" );
		DWORD dwResult = 0;
		dwResult = ::SleepEx( dwMilliseconds, bAlertable );
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::StartThreadpoolIo( ::PTP_IO pio )
	{
		_WINQ_SFCONTEXT( "CKernel32::StartThreadpoolIo" );
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "StartThreadpoolIo" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		::StartThreadpoolIo( pio );
#	else
		QOR_PP_UNREF( pio );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "StartThreadpoolIo" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::SubmitThreadpoolWork( ::PTP_WORK pwk )
	{
		_WINQ_SFCONTEXT( "CKernel32::SubmitThreadpoolWork" );
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "StartThreadpoolIo" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		::SubmitThreadpoolWork( pwk );
#	else
		QOR_PP_UNREF( pwk );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SubmitThreadpoolWork" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
	}

	//------------------------------------------------------------------------------
	DWORD CKernel32::SuspendThread( HANDLE hThread )
	{
		_WINQ_SFCONTEXT( "CKernel32::SuspendThread" );
		CCheckReturn< DWORD, CTCheckFailureValue< DWORD, 0xFFFFFFFF > >::TType dwResult;
		dwResult = ::SuspendThread( hThread );
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::SwitchToFiber( void* lpFiber )
	{
		_WINQ_SFCONTEXT( "CKernel32::SwitchToFiber" );
#	if( _WIN32_WINNT >= 0x0400 )
		::SwitchToFiber( lpFiber );
#	else
		QOR_PP_UNREF( lpFiber );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SwitchToFiber" ), _T( "Windows NT 4.0" ), 0 ));
#	endif
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::SwitchToThread(void)
	{
		_WINQ_SFCONTEXT( "CKernel32::SwitchToThread" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0400 )
		bResult = ::SwitchToThread();
#	else
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SwitchToThread" ), _T( "Windows NT 4.0" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::TerminateJobObject( HANDLE hJob, UINT uExitCode )
	{
		_WINQ_SFCONTEXT( "CKernel32::TerminateJobObject" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if( _WIN32_WINNT >= 0x0500 )
		bResult = ::TerminateJobObject( hJob, uExitCode );
#	else
		QOR_PP_UNREF2( uExitCode, hJob );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "TerminateJobObject" ), _T( "Windows 2000" ), 0 ));
#	endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::TerminateProcess( HANDLE hProcess, UINT uExitCode )
	{
		_WINQ_SFCONTEXT( "CKernel32::TerminateProcess" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
		bResult = ::TerminateProcess( hProcess, uExitCode );
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::TerminateThread( HANDLE hThread,  DWORD dwExitCode )
	{
		_WINQ_SFCONTEXT( "CKernel32::TerminateThread" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
		bResult = ::TerminateThread( hThread, dwExitCode );
		return bResult;
	}

	//------------------------------------------------------------------------------
	DWORD CKernel32::TlsAlloc(void)
	{
		_WINQ_SFCONTEXT( "CKernel32::TlsAlloc" );
		CCheckReturn< DWORD, CTCheckFailureValue< DWORD, TLS_OUT_OF_INDEXES > >::TType dwResult;
		dwResult = ::TlsAlloc();
		return dwResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::TlsFree( DWORD dwTlsIndex )
	{
		_WINQ_SFCONTEXT( "CKernel32::TlsFree" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
		bResult = ::TlsFree( dwTlsIndex );
		return bResult;
	}

	//------------------------------------------------------------------------------
	void* CKernel32::TlsGetValue( DWORD dwTlsIndex )
	{
		_WINQ_SFCONTEXT( "CKernel32::TlsGetValue" );
		void* pResult = 0;
		pResult = ::TlsGetValue( dwTlsIndex );
		if( pResult == 0 )
		{
			DWORD dwError = CKernel32::GetLastError();
			if( dwError != ERROR_SUCCESS )
			{
				__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, _T( "TlsGetValue" ), 0 ));
			}
		}
		return pResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::TlsSetValue( DWORD dwTlsIndex, void* lpTlsValue )
	{
		_WINQ_SFCONTEXT( "CKernel32::TlsSetValue" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
		bResult = ::TlsSetValue( dwTlsIndex, lpTlsValue );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::TrySubmitThreadpoolCallback( ::PTP_SIMPLE_CALLBACK pfns, PVOID pv, ::PTP_CALLBACK_ENVIRON pcbe )
	{
		_WINQ_SFCONTEXT( "CKernel32::TrySubmitThreadpoolCallback" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "TrySubmitThreadpoolCallback" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		bResult = ::TrySubmitThreadpoolCallback( pfns, pv, pcbe );
#	else
		QOR_PP_UNREF3( pcbe, pv, pfns );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "TrySubmitThreadpoolCallback" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::UpdateProcThreadAttribute( ::LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwFlags, DWORD_PTR Attribute, PVOID lpValue, SIZE_T cbSize, PVOID lpPreviousValue, PSIZE_T lpReturnSize )
	{
		_WINQ_SFCONTEXT( "CKernel32::UpdateProcThreadAttribute" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "UpdateProcThreadAttribute" ), 0 ));
#else
#   if ( _WIN32_WINNT >= 0x0600 )
		bResult = ::UpdateProcThreadAttribute( lpAttributeList, dwFlags, Attribute, lpValue, cbSize, lpPreviousValue, lpReturnSize );
#   else
		QOR_PP_UNREF7( lpAttributeList, dwFlags, Attribute, lpValue, cbSize, lpPreviousValue, lpReturnSize );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "UpdateProcThreadAttribute" ), _T( "Windows Vista" ), 0 ));
#   endif
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::WaitForThreadpoolIoCallbacks( ::PTP_IO pio, BOOL fCancelPendingCallbacks )
	{
		_WINQ_SFCONTEXT( "CKernel32::WaitForThreadpoolIoCallbacks" );
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "WaitForThreadpoolIoCallbacks" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		::WaitForThreadpoolIoCallbacks( pio, fCancelPendingCallbacks );
#	else
		QOR_PP_UNREF2( fCancelPendingCallbacks, pio );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "WaitForThreadpoolIoCallbacks" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::WaitForThreadpoolTimerCallbacks( ::PTP_TIMER pti, BOOL fCancelPendingCallbacks )
	{
		_WINQ_SFCONTEXT( "CKernel32::WaitForThreadpoolTimerCallbacks" );
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "WaitForThreadpoolTimerCallbacks" ), 0 ));
#else
#if ( _WIN32_WINNT >= 0x0600 )
		::WaitForThreadpoolTimerCallbacks( pti, fCancelPendingCallbacks );
#	else
		QOR_PP_UNREF2( fCancelPendingCallbacks, pti );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "WaitForThreadpoolTimerCallbacks" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::WaitForThreadpoolWaitCallbacks( ::PTP_WAIT pwa, BOOL fCancelPendingCallbacks )
	{
		_WINQ_SFCONTEXT( "CKernel32::WaitForThreadpoolWaitCallbacks" );
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "WaitForThreadpoolWaitCallbacks" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		::WaitForThreadpoolWaitCallbacks( pwa, fCancelPendingCallbacks );
#	else
		QOR_PP_UNREF2( fCancelPendingCallbacks, pwa );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "WaitForThreadpoolWaitCallbacks" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::WaitForThreadpoolWorkCallbacks( ::PTP_WORK pwk, BOOL fCancelPendingCallbacks )
	{
		_WINQ_SFCONTEXT( "CKernel32::WaitForThreadpoolWorkCallbacks" );
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "WaitForThreadpoolWorkCallbacks" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		::WaitForThreadpoolWorkCallbacks( pwk, fCancelPendingCallbacks );
#	else
		QOR_PP_UNREF2( fCancelPendingCallbacks, pwk );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "WaitForThreadpoolWorkCallbacks" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
	}

	//--------------------------------------------------------------------------------
	UINT CKernel32::WinExec( LPCSTR lpCmdLine, UINT uCmdShow )
	{
		_WINQ_SFCONTEXT( "CKernel32::WinExec" );
		UINT uiResult = ::WinExec( lpCmdLine, uCmdShow );
		switch ( uiResult )
		{
		case 0:
			__WINQAPI_CONT_ERROR(( WINEXEC_API_ERROR, _T( "WinExec" ), _T( "The system is out of memory or resources." ), 0 ));
			break;
		case ERROR_BAD_FORMAT:
			__WINQAPI_CONT_ERROR(( WINEXEC_API_ERROR, _T( "WinExec" ), _T( "The .exe file is invalid." ), 0 ));
			break;
		case ERROR_FILE_NOT_FOUND:
			__WINQAPI_CONT_ERROR(( WINEXEC_API_ERROR, _T( "WinExec" ), _T( "The specified file was not found." ), 0 ));
			break;
		case ERROR_PATH_NOT_FOUND:
			__WINQAPI_CONT_ERROR(( WINEXEC_API_ERROR, _T( "WinExec" ), _T( "The specified path was not found." ), 0 ));
			break;
		default:
			break;
		}
		return uiResult;
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::Wow64SuspendThread( HANDLE hThread )
	{
		_WINQ_SFCONTEXT( "CKernel32::Wow64SuspendThread" );
		CCheckReturn< DWORD, CTCheckFailureValue< DWORD, 0xFFFFFFFF > >::TType dwResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "Wow64SuspendThread" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		dwResult = ::Wow64SuspendThread( hThread );
#	else
		QOR_PP_UNREF( hThread );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "Wow64SuspendThread" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::LoadModule( LPCSTR lpModuleName, void* lpParameterBlock )
	{
		_WINQ_SFCONTEXT( "CKernel32::LoadModule" );
		DWORD dwResult = ::LoadModule( lpModuleName, lpParameterBlock );
		if( dwResult <= 31 )
		{
			switch ( dwResult )
			{
			case 0:
				__WINQAPI_CONT_ERROR(( WINEXEC_API_ERROR, _T( "LoadModule" ), _T( "The system is out of memory or resources." ), 0 ));
				break;
			case ERROR_BAD_FORMAT:
				__WINQAPI_CONT_ERROR(( WINEXEC_API_ERROR, _T( "LoadModule" ), _T( "The .exe file is invalid." ), 0 ));
				break;
			case ERROR_FILE_NOT_FOUND:
				__WINQAPI_CONT_ERROR(( WINEXEC_API_ERROR, _T( "LoadModule" ), _T( "The specified file was not found." ), 0 ));
				break;
			case ERROR_PATH_NOT_FOUND:
				__WINQAPI_CONT_ERROR(( WINEXEC_API_ERROR, _T( "LoadModule" ), _T( "The specified path was not found." ), 0 ));
				break;
			default:
				__WINQAPI_CONT_ERROR(( WINEXEC_API_ERROR, _T( "LoadModule" ), _T( "Unknown error." ), 0 ));
				break;
			}
		}
		return dwResult;
	}

}//nsWinQAPI

