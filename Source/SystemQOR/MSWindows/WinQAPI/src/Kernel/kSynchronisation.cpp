//kSynchronisation

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQAPI/Kernel32.h"
#include "../Source/SystemQOR/MSWindows/WinQAPI/include/ReturnCheck.h"

//------------------------------------------------------------------------------
namespace nsWinQAPI
{
	//--------------------------------------------------------------------------------
	VOID CKernel32::AcquireSRWLockExclusive( CCheckParam< PSRWLOCK, CTRWPointerCheck< sizeof( SRWLOCK ) > >::TType pSRWLock )
	{
		_WINQ_SFCONTEXT( "CKernel32::AcquireSRWLockExclusive" );
#	if ( _WIN32_WINNT >= 0x0600 )
		::AcquireSRWLockExclusive( pSRWLock );
#	else
		__QCMP_UNREF( pSRWLock );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "AcquireSRWLockExclusive" ), _T( "Windows Vista" ), 0 ));
#	endif
		return;
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::AcquireSRWLockShared( CCheckParam< PSRWLOCK, CTRWPointerCheck< sizeof( SRWLOCK ) > >::TType pSRWLock )
	{
		_WINQ_SFCONTEXT( "CKernel32::AcquireSRWLockShared" );
#	if ( _WIN32_WINNT >= 0x0600 )
		::AcquireSRWLockShared( pSRWLock );
#	else
		__QCMP_UNREF( pSRWLock );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "AcquireSRWLockShared" ), _T( "Windows Vista" ), 0 ));
#	endif
		return;
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::InitializeSRWLock( CCheckParam< PSRWLOCK, CTRWPointerCheck< sizeof( SRWLOCK ) > >::TType pSRWLock )
	{
		_WINQ_SFCONTEXT( "CKernel32::InitializeSRWLock" );
#	if ( _WIN32_WINNT >= 0x0600 )
		::InitializeSRWLock( pSRWLock );
#	else
		__QCMP_UNREF( pSRWLock );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "InitializeSRWLock" ), _T( "Windows Vista" ), 0 ));
#	endif
		return;
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::ReleaseSRWLockExclusive( CCheckParam< PSRWLOCK, CTRWPointerCheck< sizeof( SRWLOCK ) > >::TType pSRWLock )
	{
		_WINQ_SFCONTEXT( "CKernel32::ReleaseSRWLockExclusive" );
#	if ( _WIN32_WINNT >= 0x0600 )
		::ReleaseSRWLockExclusive( pSRWLock );
#	else
		__QCMP_UNREF( pSRWLock );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "ReleaseSRWLockExclusive" ), _T( "Windows Vista" ), 0 ));
#	endif
		return;
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::ReleaseSRWLockShared( CCheckParam< PSRWLOCK, CTRWPointerCheck< sizeof( SRWLOCK ) > >::TType pSRWLock )
	{
		_WINQ_SFCONTEXT( "CKernel32::ReleaseSRWLockShared" );
#	if ( _WIN32_WINNT >= 0x0600 )
		::ReleaseSRWLockShared( pSRWLock );
#	else
		__QCMP_UNREF( pSRWLock );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "ReleaseSRWLockShared" ), _T( "Windows Vista" ), 0 ));
#	endif
		return;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::SleepConditionVariableSRW( 
			CCheckParam< PCONDITION_VARIABLE, CTRWPointerCheck< sizeof( CONDITION_VARIABLE ) > >::TType pConditionVariable, 
			CCheckParam< PSRWLOCK, CTRWPointerCheck< sizeof( SRWLOCK ) > >::TType pSRWLock, 
			CCheckParam< DWORD, CNoCheck >::TType dwMilliseconds, 
			CCheckParam< ULONG, CNoCheck >::TType Flags )
	{
		_WINQ_SFCONTEXT( "CKernel32::SleepConditionVariableSRW" );
		CCheckReturn< BOOL, CBoolCheck<> >::TType bResult;
#if		( _WIN32_WINNT >= 0x0600 )
		bResult = ::SleepConditionVariableSRW( pConditionVariable, pSRWLock, dwMilliseconds, Flags );
#else//!( _WIN32_WINNT >= 0x0600 )
		__QCMP_UNREF( Flags );
		__QCMP_UNREF( dwMilliseconds );
		__QCMP_UNREF( pSRWLock );
		__QCMP_UNREF( pConditionVariable );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SleepConditionVariableSRW" ), _T( "Windows Vista" ), 0 ));
#endif//!( _WIN32_WINNT >= 0x0600 )
		return bResult;
	}


	//--------------------------------------------------------------------------------
	/*Object Namespaces
	An object namespace protects named objects from unauthorized access. Creating a 
	private namespace enables applications and services to build a more secure environment.

	A process can create a private namespace using the CreatePrivateNamespace function. 
	This function requires that you specify a boundary that defines how the objects in 
	the namespace are to be isolated. The caller must be within the specified boundary 
	for the create operation to succeed. To specify a boundary, use the 
	CreateBoundaryDescriptor and AddSIDToBoundaryDescriptor functions.

	The lpAliasPrefix parameter of CreatePrivateNamespace serves as the name of the 
	namespace. Each namespace is uniquely identified by its name and boundaries. The 
	system supports multiple private namespaces with the same name, as long as they 
	specify different boundaries.

	Suppose that a process requests the creation of a namespace, NS1, that defines a 
	boundary containing two elements: the administrator SID and the current session 
	number. The namespace is created if the process is running under the Administrator 
	account in the specified session. Another process can access this namespace using 
	the OpenPrivateNamespace function. Both the specified name and boundary must match 
	if this process is to open the namespace created by the first process. Note that a 
	process can open an existing namespace even if it is not within the boundary unless 
	the creator restricted access to the namespace using the 
	lpPrivateNamespaceAttributes parameter.

	The objects that are created in this namespace have names that are of the form 
	prefix\objectname. The prefix is the namespace name specified by the lpAliasPrefix 
	parameter of CreatePrivateNamespace. For example, to create an event object named 
	MyEvent in the NS1 namespace, call the CreateEvent function with the lpName parameter 
	set to NS1\MyEvent.

	The process that created the namespace can use the ClosePrivateNamespace function to 
	close the handle to the namespace. The handle is also closed when the process that 
	created the namespace terminates. After the namespace handle is closed, subsequent 
	calls to OpenPrivateNamespace fail, but all operations on objects in the namespace 
	succeed.*/
	//--------------------------------------------------------------------------------
	HANDLE CKernel32::CreatePrivateNamespace( 
		CCheckParam< ::SECURITY_ATTRIBUTES*, CTReadablePointerCheck< sizeof( ::SECURITY_ATTRIBUTES ) > >::TType lpPrivateNamespaceAttributes,
		CCheckParam< LPVOID, CNullPointerCheck >::TType lpBoundaryDescriptor, 
		CCheckParam< LPCTSTR, CTStringKernelObjestNamespacePrefixCheck< LPCTSTR > >::TType lpAliasPrefix )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreatePrivateNamespace" );
		CCheckReturn< HANDLE, CHandleNullCheck<> >::TType h;
#	if ( _WIN32_WINNT >= 0x0600 )
		h = ::CreatePrivateNamespace( lpPrivateNamespaceAttributes, lpBoundaryDescriptor, lpAliasPrefix );
#	else
		__QCMP_UNREF( lpAliasPrefix );
		__QCMP_UNREF( lpBoundaryDescriptor );
		__QCMP_UNREF( lpPrivateNamespaceAttributes );	
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CreatePrivateNamespace" ), _T( "Windows Vista" ), 0 ));
#	endif
		return h;
	}

	//--------------------------------------------------------------------------------
	HANDLE CKernel32::OpenPrivateNamespace( 
		CCheckParam< LPVOID, CNullPointerCheck >::TType lpBoundaryDescriptor,
		CCheckParam< LPCTSTR, CTStringKernelObjestNamespacePrefixCheck< LPCTSTR > >::TType lpAliasPrefix )
	{
		_WINQ_SFCONTEXT( "CKernel32::OpenPrivateNamespace" );
		CCheckReturn< HANDLE, CHandleNullCheck<> >::TType h;
#	if ( _WIN32_WINNT >= 0x0600 )
		h = ::OpenPrivateNamespace( lpBoundaryDescriptor, lpAliasPrefix );
#	else
		__QCMP_UNREF( lpAliasPrefix );
		__QCMP_UNREF( lpBoundaryDescriptor );	
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "OpenPrivateNamespace" ), _T( "Windows Vista" ), 0 ));
#	endif
		return h;
	}

	//--------------------------------------------------------------------------------
	BOOLEAN CKernel32::ClosePrivateNamespace( HANDLE Handle, CCheckParam< ULONG, CNoCheck >::TType Flags )
	{
		_WINQ_SFCONTEXT( "CKernel32::ClosePrivateNamespace" );
		CCheckReturn< BOOLEAN, CTCheckFailureValue< BOOLEAN, FALSE > >::TType bResult = FALSE;
#	if ( _WIN32_WINNT >= 0x0600 )
		bResult = ::ClosePrivateNamespace( Handle, Flags );
#	else
		__QCMP_UNREF( Flags );
		__QCMP_UNREF( Handle );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "ClosePrivateNamespace" ), _T( "Windows Vista" ), 0 ));
#endif
		return bResult;
	}


	//--------------------------------------------------------------------------------
	//Boundary Descriptor
	//--------------------------------------------------------------------------------
	HANDLE CKernel32::CreateBoundaryDescriptor( 
		CCheckParam< LPCTSTR, CNullPointerCheck >::TType Name, 
		CCheckParam< ULONG, CNoCheck >::TType Flags )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateBoundaryDescriptor" );
		CCheckReturn< HANDLE, CHandleNullCheck<> >::TType h;
#	if ( _WIN32_WINNT >= 0x0600 )
		h = ::CreateBoundaryDescriptor( Name, Flags );
#	else
		__QCMP_UNREF( Flags );
		__QCMP_UNREF( Name );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CreateBoundaryDescriptor" ), _T( "Windows Vista" ), 0 ));
#	endif
		return h;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::AddSIDToBoundaryDescriptor( PHANDLE BoundaryDescriptor, CCheckParam< PSID, CNullPointerCheck >::TType pRequiredSid )
	{
		_WINQ_SFCONTEXT( "CKernel32::AddSIDToBoundaryDescriptor" );
		CCheckReturn< BOOL, CBoolCheck<> >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0600 )
		bResult = ::AddSIDToBoundaryDescriptor( BoundaryDescriptor, pRequiredSid );
#	else
		__QCMP_UNREF( pRequiredSid );
		__QCMP_UNREF( BoundaryDescriptor );	
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "AddSIDToBoundaryDescriptor" ), _T( "Windows Vista" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	void CKernel32::DeleteBoundaryDescriptor( CCheckParam< HANDLE, CHandleParamCheck >::TType BoundaryDescriptor )
	{
		_WINQ_SFCONTEXT( "CKernel32::DeleteBoundaryDescriptor" );
#	if ( _WIN32_WINNT >= 0x0600 )
		::DeleteBoundaryDescriptor( BoundaryDescriptor );
#	else
		__QCMP_UNREF( BoundaryDescriptor );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "DeleteBoundaryDescriptor" ), _T( "Windows Vista" ), 0 ));
#	endif
	}



	//--------------------------------------------------------------------------------
	//Event
	//--------------------------------------------------------------------------------
	HANDLE CKernel32::CreateEvent( 
		CCheckParam< ::SECURITY_ATTRIBUTES*, CTNullOrReadablePointerCheck< sizeof( ::SECURITY_ATTRIBUTES ) > >::TType lpEventAttributes,
		CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType bManualReset,
		CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType bInitialState,
		CCheckParam< LPCTSTR, CTStringKernelObjNameOrNullCheck< LPCTSTR > >::TType lpName,
		bool& bAlreadyExists )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateEvent" );
		HANDLE h = INVALID_HANDLE_VALUE;
		bAlreadyExists = false;
		h = ::CreateEvent( lpEventAttributes, bManualReset, bInitialState, lpName );
		if( h == 0 )
		{
			__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, _T( "CreateEvent" ), 0 ));
		}
		else
		{
			DWORD dwErr = CKernel32::GetLastError();
			if( dwErr == ERROR_ALREADY_EXISTS )
			{
				bAlreadyExists = true;
			}
		}
		return h;
	}

	//--------------------------------------------------------------------------------
	HANDLE CKernel32::CreateEventEx( 
		CCheckParam< ::SECURITY_ATTRIBUTES*, CTNullOrReadablePointerCheck< sizeof( ::SECURITY_ATTRIBUTES ) > >::TType lpEventAttributes,
		CCheckParam< LPCTSTR, CTStringKernelObjNameOrNullCheck< LPCTSTR > >::TType lpName, 
		CCheckParam< DWORD, CEventFlagsCheck >::TType dwFlags, 
		CCheckParam< DWORD, CEventSyncAccessFlagsCheck >::TType dwDesiredAccess,
		bool& bAlreadyExists )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateEventEx" );
		HANDLE h = INVALID_HANDLE_VALUE;
		bAlreadyExists = false;
#	if ( _WIN32_WINNT >= 0x0600 )
		h = ::CreateEventEx( lpEventAttributes, lpName, dwFlags, dwDesiredAccess );
		if( h == NULL )
		{
			__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, _T( "CreateEventEx" ), 0 ));
		}
		else
		{
			DWORD dwErr = ::GetLastError();
			if( dwErr == ERROR_ALREADY_EXISTS )
			{
				bAlreadyExists = true;
			}
		}
#	else
		__QCMP_UNREF( bAlreadyExists );
		__QCMP_UNREF( dwDesiredAccess );
		__QCMP_UNREF( dwFlags );
		__QCMP_UNREF( lpName );
		__QCMP_UNREF( lpEventAttributes );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CreateEventEx" ), _T( "Windows Vista" ), 0 ));
#endif
		return h;
	}

	//--------------------------------------------------------------------------------
	HANDLE CKernel32::OpenEvent( 
		CCheckParam< DWORD, CEventFlagsCheck >::TType dwDesiredAccess,
		CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType bInheritHandle, 
		CCheckParam< LPCTSTR, CTStringKernelObjNameCheck< LPCTSTR > >::TType lpName )
	{
		_WINQ_SFCONTEXT( "CKernel32::OpenEvent" );
		CCheckReturn< HANDLE, CHandleNullCheck<> >::TType h;
		h = ::OpenEvent( dwDesiredAccess, bInheritHandle, lpName );
		return h;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::PulseEvent( HANDLE hEvent )
	{
		_WINQ_SFCONTEXT( "CKernel32::PulseEvent" );
		CCheckReturn< BOOL, CBoolCheck<> >::TType bResult;
		__WINQAPI_WARNING(( UNRELIABLE_API, _T( "PulseEvent" ), 0 ));
		bResult = ::PulseEvent( hEvent );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::ResetEvent( HANDLE hEvent )
	{
		_WINQ_SFCONTEXT( "CKernel32::ResetEvent" );
		//CCheckReturn< BOOL, CBoolCheck<> >::TType bResult;
		BOOL bResult = ::ResetEvent( hEvent );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::SetEvent( HANDLE hEvent )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetEvent" );
		CCheckReturn< BOOL, CBoolCheck<> >::TType bResult;
		bResult = ::SetEvent( hEvent );
		return bResult;
	}


	//--------------------------------------------------------------------------------
	//Mutex
	//--------------------------------------------------------------------------------
	HANDLE CKernel32::CreateMutex( 
		CCheckParam< ::SECURITY_ATTRIBUTES*, CTNullOrReadablePointerCheck< sizeof( ::SECURITY_ATTRIBUTES ) > >::TType lpMutexAttributes,
		CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType bInitialOwner,
		CCheckParam< LPCTSTR, CTStringKernelObjNameOrNullCheck< LPCTSTR > >::TType lpName,
		bool& bAlreadyExists )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateMutex" );
		HANDLE h = INVALID_HANDLE_VALUE;
		bAlreadyExists = false;
		h = ::CreateMutex( lpMutexAttributes, bInitialOwner, lpName );
		if( h == 0 )
		{
			__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, _T( "CreateMutex" ), 0 ));
		}
		else if( CKernel32::GetLastError() == ERROR_ALREADY_EXISTS )
		{
			bAlreadyExists = true;
		}
		return h;
	}

	//--------------------------------------------------------------------------------
	HANDLE CKernel32::CreateMutexEx( 
		CCheckParam< ::SECURITY_ATTRIBUTES*, CTNullOrReadablePointerCheck< sizeof( ::SECURITY_ATTRIBUTES ) > >::TType lpMutexAttributes,
		CCheckParam< LPCTSTR, CTStringKernelObjNameOrNullCheck< LPCTSTR > >::TType lpName, 
		CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType dwFlags,
		CCheckParam< DWORD, CMutexAccessFlagsCheck >::TType dwDesiredAccess,
		bool& bAlreadyExists )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateMutexEx" );
		CCheckReturn< HANDLE, CHandleCheck< > >::TType h;
		bAlreadyExists = false;
#	if ( _WIN32_WINNT >= 0x0600 )
		h = ::CreateMutexEx( lpMutexAttributes, lpName, dwFlags, dwDesiredAccess );
		if( h == NULL )
		{
			__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, _T( "CreateMutexEx" ), 0 ));
		}
		else if( CKernel32::GetLastError() == ERROR_ALREADY_EXISTS )
		{
			bAlreadyExists = true;
		}
#	else
		__QCMP_UNREF( dwDesiredAccess );
		__QCMP_UNREF( dwFlags );
		__QCMP_UNREF( lpName );
		__QCMP_UNREF( lpMutexAttributes );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CreateMutexEx" ), _T( "Windows Vista" ), 0 ));
#endif
		return h;
	}

	//--------------------------------------------------------------------------------
	HANDLE CKernel32::OpenMutex( 
		CCheckParam< DWORD, CMutexAccessFlagsCheck > dwDesiredAccess,
		CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType bInheritHandle,
		CCheckParam< LPCTSTR, CTStringKernelObjNameCheck< LPCTSTR > >::TType lpName )
	{
		_WINQ_SFCONTEXT( "CKernel32::OpenMutex" );
		HANDLE h = INVALID_HANDLE_VALUE;
		h = ::OpenMutex( dwDesiredAccess, bInheritHandle, lpName );
		if( h == 0 )
		{
			if( CKernel32::GetLastError() == ERROR_FILE_NOT_FOUND )
			{
				__WINQAPI_CONT_ERROR(( NAMED_KERNELOBJ_NOT_FOUND, _T( "OpenMutex" ), static_cast< const TCHAR* >( lpName ), 0 ));
			}
			else
			{
				__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, _T( "OpenMutex" ), 0 ));
			}
		}
		return h;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::ReleaseMutex( HANDLE hMutex )
	{
		_WINQ_SFCONTEXT( "CKernel32::ReleaseMutex" );
		CCheckReturn< BOOL, CBoolCheck<> >::TType bResult;
		bResult = ::ReleaseMutex( hMutex );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	//Semaphore
	//--------------------------------------------------------------------------------
	HANDLE CKernel32::CreateSemaphore( 
		CCheckParam< ::SECURITY_ATTRIBUTES*, CTNullOrReadablePointerCheck< sizeof( ::SECURITY_ATTRIBUTES ) > >::TType lpSemaphoreAttributes, 
		CCheckParam< LONG, nsCodeQOR::CTInterLargerEqualCheck< LONG, 2 > >::TType lInitialCount,//CCheckParam< LONG, nsParamChecking::CTLargerCheck< LONG, 0 > >::TType
		CCheckParam< LONG, nsParamChecking::CTLargerCheck< LONG, 0 > >::TType lMaximumCount,
		CCheckParam< LPCTSTR, CTStringKernelObjNameOrNullCheck< LPCTSTR > >::TType lpName,
		bool& bAlreadyExists )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateSemaphore" );
		HANDLE h = INVALID_HANDLE_VALUE;
		bAlreadyExists = false;
		h = ::CreateSemaphore( lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName );
		if( h == 0 )
		{
			__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, _T( "CreateSemaphore" ), 0 ));
		}
		else if( CKernel32::GetLastError() == ERROR_ALREADY_EXISTS )
		{
			bAlreadyExists = true;
		}
		return h;
	}

	//--------------------------------------------------------------------------------
	HANDLE CKernel32::CreateSemaphoreEx( 
		CCheckParam< ::SECURITY_ATTRIBUTES*, CTNullOrReadablePointerCheck< sizeof( ::SECURITY_ATTRIBUTES ) > >::TType lpSemaphoreAttributes, 
		CCheckParam< LONG, nsCodeQOR::CTInterSmallerEqualCheck< LONG, 4 > >::TType lInitialCount,//CCheckParam< LONG, nsParamChecking::CTLargerCheck< LONG, 0 > >::TType
		CCheckParam< LONG, nsParamChecking::CTLargerCheck< LONG, 0 > >::TType lMaximumCount,
		CCheckParam< LPCTSTR, CTStringKernelObjNameOrNullCheck< LPCTSTR > >::TType lpName, 
		CCheckParam< DWORD, nsParamChecking::CTEqualCheck< DWORD, 0 > >::TType dwFlags,
		CCheckParam< DWORD, CSemaphoreAccessFlagsCheck >::TType dwDesiredAccess, 
		bool& bAlreadyExists )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateSemaphoreEx" );
		HANDLE h = INVALID_HANDLE_VALUE;
		bAlreadyExists = false;
#	if ( _WIN32_WINNT >= 0x0600 )
		h = ::CreateSemaphoreEx( lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName, dwFlags, dwDesiredAccess );
		if( h == NULL )
		{
			__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, _T( "CreateSemaphoreEx" ), 0 ));
		}
		else if( CKernel32::GetLastError() == ERROR_ALREADY_EXISTS )
		{
			bAlreadyExists = true;
		}
#	else
		__QCMP_UNREF( dwDesiredAccess );
		__QCMP_UNREF( dwFlags );
		__QCMP_UNREF( lpName );
		__QCMP_UNREF( lMaximumCount );
		__QCMP_UNREF( lInitialCount );
		__QCMP_UNREF( lpSemaphoreAttributes );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CreateSemaphoreEx" ), _T( "Windows Vista" ), 0 ));
#endif
		return h;
	}

	//--------------------------------------------------------------------------------
	HANDLE CKernel32::OpenSemaphore( 
		CCheckParam< DWORD, CSemaphoreAccessFlagsCheck >::TType dwDesiredAccess, 
		CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType bInheritHandle,
		CCheckParam< LPCTSTR, CTStringKernelObjNameOrNullCheck< LPCTSTR > >::TType lpName )
	{
		_WINQ_SFCONTEXT( "CKernel32::OpenSemaphore" );
		CCheckReturn< HANDLE, CHandleNullCheck<> >::TType h;
		h = ::OpenSemaphore( dwDesiredAccess, bInheritHandle, lpName );
		return h;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::ReleaseSemaphore( 
		HANDLE hSemaphore, 
		CCheckParam< LONG, nsParamChecking::CTLargerCheck< LONG, 0 > >::TType lReleaseCount, 
		CCheckParam< LONG*, CTNullOrWriteablePointerCheck< sizeof( LONG ) > >::TType lpPreviousCount )
	{
		_WINQ_SFCONTEXT( "CKernel32::ReleaseSemaphore" );
		//CCheckReturn< BOOL, CBoolCheck<> >::TType
		BOOL bResult = ::ReleaseSemaphore( hSemaphore, lReleaseCount, lpPreviousCount );
		return bResult;
	}


	//------------------------------------------------------------------------------
	//Timer Queue
	//Timer-queue timers are lightweight objects that enable you to specify a 
	//callback function to be called at a specified time.
	//------------------------------------------------------------------------------
	HANDLE CKernel32::CreateTimerQueue(void)
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateTimerQueue" );
		CCheckReturn< HANDLE, CHandleNullCheck<> >::TType h;
#	if ( _WIN32_WINNT >= 0x0500 )
		h = ::CreateTimerQueue();
#	else
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CreateTimerQueue" ), _T( "Windows 2000" ), 0 ));
#	endif
		return h;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::DeleteTimerQueue( HANDLE TimerQueue )
	{
		_WINQ_SFCONTEXT( "CKernel32::DeleteTimerQueue" );
		CCheckReturn< BOOL, CBoolCheck<> >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0500 )
		bResult = ::DeleteTimerQueue( TimerQueue );
#	else
		__QCMP_UNREF( TimerQueue );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "DeleteTimerQueue" ), _T( "Windows 2000" ), 0 ));
#	endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::DeleteTimerQueueEx( HANDLE TimerQueue, HANDLE CompletionEvent )
	{
		_WINQ_SFCONTEXT( "CKernel32::DeleteTimerQueueEx" );
		CCheckReturn< BOOL, CBoolCheck<> >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0500 )
		bResult = ::DeleteTimerQueueEx( TimerQueue, CompletionEvent );
#	else
		__QCMP_UNREF( CompletionEvent );
		__QCMP_UNREF( TimerQueue );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "DeleteTimerQueueEx" ), _T( "Windows 2000" ), 0 ));
#	endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::ChangeTimerQueueTimer( HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period )
	{
		_WINQ_SFCONTEXT( "CKernel32::ChangeTimerQueueTimer" );
		CCheckReturn< BOOL, CBoolCheck<> >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0500 )
		bResult = ::ChangeTimerQueueTimer( TimerQueue, Timer, DueTime, Period );
#	else
			__QCMP_UNREF( Period );
			__QCMP_UNREF( DueTime );
			__QCMP_UNREF( Timer );
			__QCMP_UNREF( TimerQueue );
			__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "ChangeTimerQueueTimer" ), _T( "Windows 2000" ), 0 ));
#	endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	//TimerQueueTimer
	//------------------------------------------------------------------------------
	BOOL CKernel32::CreateTimerQueueTimer( 
		CCheckParam< HANDLE*, CTWritablePointerCheck< sizeof( HANDLE ) > >::TType phNewTimer, 
		CCheckParam< HANDLE, CNoCheck >::TType TimerQueue, 
		CCheckParam< WAITORTIMERCALLBACK, CTCodePointerCheck< WAITORTIMERCALLBACK > >::TType Callback, 
		CCheckParam< PVOID, CNoCheck >::TType Parameter, 
		CCheckParam< DWORD, CNoCheck >::TType DueTime, 
		CCheckParam< DWORD, CNoCheck >::TType Period, 
		CCheckParam< ULONG, CTQTCreateFlagsCheck >::TType Flags )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateTimerQueueTimer" );
		CCheckReturn< BOOL, CBoolCheck<> >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0500 )
		bResult = ::CreateTimerQueueTimer( phNewTimer, TimerQueue, Callback, Parameter, DueTime, Period, Flags );
#	else
		__QCMP_UNREF( phNewTimer );
		__QCMP_UNREF( TimerQueue );
		__QCMP_UNREF( Callback );
		__QCMP_UNREF( Parameter );
		__QCMP_UNREF( DueTime );
		__QCMP_UNREF( Period );
		__QCMP_UNREF( Flags );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CreateTimerQueueTimer" ), _T( "Windows 2000" ), 0 ));
#	endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	//NOTE:This function cannot be called while the thread is using impersonation. The resulting behavior is undefined.
	BOOL CKernel32::DeleteTimerQueueTimer( HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent, bool& bRetry )
	{
		_WINQ_SFCONTEXT( "CKernel32::DeleteTimerQueueTimer" );
		BOOL bResult = FALSE;
		bRetry = false;
#	if ( _WIN32_WINNT >= 0x0500 )
		bResult = ::DeleteTimerQueueTimer( TimerQueue, Timer, CompletionEvent );
		if( bResult == FALSE )
		{
			if( ::GetLastError() != ERROR_IO_PENDING )
			{
				bRetry = true;
				__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, _T( "DeleteTimerQueueTimer" ), 0 ));
			}
		}
#	else
		__QCMP_UNREF( CompletionEvent );
		__QCMP_UNREF( Timer );
		__QCMP_UNREF( TimerQueue );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "DeleteTimerQueueTimer" ), _T( "Windows 2000" ), 0 ));
#endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	//Waitable Timer
	//------------------------------------------------------------------------------
	HANDLE CKernel32::CreateWaitableTimer( 
		CCheckParam< ::SECURITY_ATTRIBUTES*, CTNullOrReadablePointerCheck< sizeof( ::SECURITY_ATTRIBUTES ) > >::TType lpTimerAttributes,
		CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType bManualReset,
		CCheckParam< LPCTSTR, CTStringKernelObjNameOrNullCheck< LPCTSTR > >::TType lpTimerName, 
		bool& bAlreadyExists )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateWaitableTimer" );
		HANDLE h = INVALID_HANDLE_VALUE;
		bAlreadyExists = false;
#	if ( _WIN32_WINNT >= 0x0400 )
		h = ::CreateWaitableTimer( lpTimerAttributes, bManualReset, lpTimerName );
		if( h == NULL )
		{
			__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, _T( "CreateWaitableTimer" ), 0 ));
		}
		else if( ::GetLastError() == ERROR_ALREADY_EXISTS )
		{
			bAlreadyExists = true;
		}
#	else
		__QCMP_UNREF( lpTimerName );
		__QCMP_UNREF( bManualReset );
		__QCMP_UNREF( lpTimerAttributes );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CreateWaitableTimer" ), _T( "Windows NT 4.0" ), 0 ));
#	endif
		return h;
	}

	//--------------------------------------------------------------------------------
	HANDLE CKernel32::CreateWaitableTimerEx( 
		CCheckParam< ::SECURITY_ATTRIBUTES*, CTNullOrReadablePointerCheck< sizeof( ::SECURITY_ATTRIBUTES ) > >::TType lpTimerAttributes,
		CCheckParam< LPCTSTR, CTStringKernelObjNameOrNullCheck< LPCTSTR > >::TType lpTimerName,
		CCheckParam< DWORD, CWaitTmrCreateFlagsCheck >::TType dwFlags,
		CCheckParam< DWORD, CSybcObjAccessFlagsCheck >::TType dwDesiredAccess, bool& bAlreadyExists )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateWaitableTimerEx" );
		HANDLE h = INVALID_HANDLE_VALUE;
		bAlreadyExists = false;
#	if ( _WIN32_WINNT >= 0x0600 )
		h = ::CreateWaitableTimerEx( lpTimerAttributes, lpTimerName, dwFlags, dwDesiredAccess );
		if( h == NULL )
		{
			__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, _T( "CreateWaitableTimerEx" ), 0 ));
		}
		else if( ::GetLastError() == ERROR_ALREADY_EXISTS )
		{
			bAlreadyExists = true;
		}
#	else
		__QCMP_UNREF( dwDesiredAccess );
		__QCMP_UNREF( dwFlags );
		__QCMP_UNREF( lpTimerName );
		__QCMP_UNREF( lpTimerAttributes );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CreateWaitableTimerEx" ), _T( "Windows Vista" ), 0 ));
#endif
		return h;
	}

	//------------------------------------------------------------------------------
	HANDLE CKernel32::OpenWaitableTimer( 
		CCheckParam< DWORD, CSybcObjAccessFlagsCheck >::TType dwDesiredAccess,
		CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType bInheritHandle, 
		CCheckParam< LPCTSTR, CTStringKernelObjNameOrNullCheck< LPCTSTR > >::TType lpTimerName )
	{
		_WINQ_SFCONTEXT( "CKernel32::OpenWaitableTimer" );
		CCheckReturn< HANDLE, CHandleNullCheck<> >::TType h;
#	if ( _WIN32_WINNT >= 0x0400 )
		h = ::OpenWaitableTimer( dwDesiredAccess, bInheritHandle, lpTimerName );
#	else
		__QCMP_UNREF( lpTimerName );
		__QCMP_UNREF( bInheritHandle );
		__QCMP_UNREF( dwDesiredAccess );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "OpenWaitableTimer" ), _T( "Windows NT 4.0" ), 0 ));
#	endif
		return h;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::SetWaitableTimer( 
		HANDLE hTimer, 
		CConstCheckParam< ::LARGE_INTEGER*, CTReadablePointerCheck< sizeof( ::LARGE_INTEGER ) > >::TType pDueTime,							 
		CCheckParam< LONG, CNoCheck >::TType lPeriod, 
		CCheckParam< PTIMERAPCROUTINE, CTNullOrCodePointer< PTIMERAPCROUTINE > >::TType pfnCompletionRoutine, 
		CCheckParam< PVOID, CNoCheck >::TType lpArgToCompletionRoutine, 
		CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType fResume )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetWaitableTimer" );
		CCheckReturn< BOOL, CBoolCheck<> >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0401 )
		bResult = ::SetWaitableTimer( hTimer, pDueTime, lPeriod, pfnCompletionRoutine, lpArgToCompletionRoutine, fResume );
#	else
		__QCMP_UNREF( fResume );
		__QCMP_UNREF( lpArgToCompletionRoutine );
		__QCMP_UNREF( pfnCompletionRoutine );
		__QCMP_UNREF( lPeriod );
		__QCMP_UNREF( pDueTime );
		__QCMP_UNREF( hTimer );	
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SetWaitableTimer" ), _T( "Windows NT 4 Service Pack 1" ), 0 ));
#endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::CancelWaitableTimer( HANDLE hTimer )
	{
		_WINQ_SFCONTEXT( "CKernel32::CancelWaitableTimer" );
		CCheckReturn< BOOL, CBoolCheck<> >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0400 )
		bResult = ::CancelWaitableTimer( hTimer );
#	else
		__QCMP_UNREF( hTimer );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CancelWaitableTimer" ), _T( "Windows NT 4.0" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	//CriticalSection
	//--------------------------------------------------------------------------------
	void CKernel32::InitializeCriticalSection( CCheckParam< ::LPCRITICAL_SECTION, CTRWPointerCheck< sizeof( ::CRITICAL_SECTION ) > >::TType pCriticalSection )
	{
		_WINQ_SFCONTEXT( "CKernel32::InitializeCriticalSection" );
		::InitializeCriticalSection( pCriticalSection );
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::InitializeCriticalSectionAndSpinCount( 
		CCheckParam< ::LPCRITICAL_SECTION, CNullPointerCheck >::TType pCriticalSection, 
		CCheckParam< DWORD, CNoCheck >::TType dwSpinCount )
	{
		_WINQ_SFCONTEXT( "CKernel32::InitializeCriticalSectionAndSpinCount" );
		CCheckReturn< BOOL, CBoolCheck<> >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0403 )
		bResult = ::InitializeCriticalSectionAndSpinCount( pCriticalSection, dwSpinCount );
#	else
		__QCMP_UNREF( dwSpinCount );
		__QCMP_UNREF( pCriticalSection );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "InitializeCriticalSectionAndSpinCount" ), _T( "Windows NT 4 Service Pack 3" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::InitializeCriticalSectionEx( 
		CCheckParam< ::LPCRITICAL_SECTION, CNullPointerCheck >::TType pCriticalSection,
		CCheckParam< DWORD, CNoCheck >::TType dwSpinCount,
		CCheckParam< DWORD, CCritSecCreateFlagsCheck >::TType Flags )
	{
		_WINQ_SFCONTEXT( "CKernel32::InitializeCriticalSectionEx" );
		CCheckReturn< BOOL, CBoolCheck<> >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0600 )
		bResult = ::InitializeCriticalSectionEx( pCriticalSection, dwSpinCount, Flags );
#	else
		__QCMP_UNREF( Flags );
		__QCMP_UNREF( dwSpinCount );
		__QCMP_UNREF( pCriticalSection );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "InitializeCriticalSectionEx" ), _T( "Windows Vista" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	void CKernel32::DeleteCriticalSection( CCheckParam< ::LPCRITICAL_SECTION, CNullPointerCheck >::TType pCriticalSection )
	{
		_WINQ_SFCONTEXT( "CKernel32::DeleteCriticalSection" );
		::DeleteCriticalSection( pCriticalSection );
	}

	//--------------------------------------------------------------------------------
	void CKernel32::EnterCriticalSection( CCheckParam< ::LPCRITICAL_SECTION, CNullPointerCheck >::TType lpCriticalSection )
	{
		_WINQ_SFCONTEXT( "CKernel32::EnterCriticalSection" );
		::EnterCriticalSection( lpCriticalSection );
	}

	//--------------------------------------------------------------------------------
	void CKernel32::LeaveCriticalSection( CCheckParam< ::LPCRITICAL_SECTION, CNullPointerCheck >::TType lpCriticalSection )
	{
		_WINQ_SFCONTEXT( "CKernel32::LeaveCriticalSection" );
		::LeaveCriticalSection( lpCriticalSection );
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::SetCriticalSectionSpinCount( 
		CCheckParam< ::LPCRITICAL_SECTION, CNullPointerCheck >::TType pCriticalSection, 
		CCheckParam< DWORD, CNoCheck >::TType dwSpinCount )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetCriticalSectionSpinCount" );
		DWORD dwResult = 0;
#	if ( _WIN32_WINNT >= 0x0403 )
		dwResult = ::SetCriticalSectionSpinCount( pCriticalSection, dwSpinCount );
#	else	
		__QCMP_UNREF( dwSpinCount );
		__QCMP_UNREF( pCriticalSection );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SetCriticalSectionSpinCount" ), _T( "Windows NT 4 Service Pack 3" ), 0 ));
#	endif
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::TryEnterCriticalSection( CCheckParam< LPCRITICAL_SECTION, CNullPointerCheck >::TType pCriticalSection )
	{
		_WINQ_SFCONTEXT( "CKernel32::TryEnterCriticalSection" );
		BOOL bResult = FALSE;
#	if ( _WIN32_WINNT >= 0x0400 )
		bResult = ::TryEnterCriticalSection( pCriticalSection );
#	else
		__QCMP_UNREF( pCriticalSection );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "TryEnterCriticalSection" ), _T( "Windows NT 4.0" ), 0 ));
#	endif
		return bResult;
	}


	//--------------------------------------------------------------------------------
	//Overlapped
	//--------------------------------------------------------------------------------
	BOOL CKernel32::GetOverlappedResult( HANDLE hFile, 
		CCheckParam< ::OVERLAPPED*, CTWritablePointerCheck< sizeof( ::OVERLAPPED ) > >::TType lpOverlapped, 
		CCheckParam< DWORD*, CTWritablePointerCheck< sizeof( DWORD ) > >::TType lpNumberOfBytesTransferred, 
		CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType bWait )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetOverlappedResult" );
		BOOL bResult = FALSE;
		bResult = ::GetOverlappedResult( hFile, lpOverlapped, lpNumberOfBytesTransferred, bWait );
		return bResult;
	}


	//--------------------------------------------------------------------------------
	//ConditionVariable
	//--------------------------------------------------------------------------------
	void CKernel32::InitializeConditionVariable( CCheckParam< CONDITION_VARIABLE*, CTWritablePointerCheck< sizeof( CONDITION_VARIABLE ) > >::TType pConditionVariable )
	{
		_WINQ_SFCONTEXT( "CKernel32::InitializeConditionVariable" );
#	if ( _WIN32_WINNT >= 0x0600 )
		::InitializeConditionVariable( pConditionVariable );
#	else
		__QCMP_UNREF( pConditionVariable );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "InitializeConditionVariable" ), _T( "Windows Vista" ), 0 ));
#	endif
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::SleepConditionVariableCS( 
		CCheckParam< ::CONDITION_VARIABLE*, CTWritablePointerCheck< sizeof( ::CONDITION_VARIABLE ) > >::TType ConditionVariable, 
		CCheckParam< ::CRITICAL_SECTION*, CTWritablePointerCheck< sizeof( ::CRITICAL_SECTION ) > >::TType CriticalSection, 
		CCheckParam< DWORD, CNoCheck >::TType dwMilliseconds )
	{
		_WINQ_SFCONTEXT( "CKernel32::SleepConditionVariableCS" );
		CCheckReturn< BOOL, CBoolCheck< nsCodeQOR::CError::ERR_LVL_CONTINUE, API_TIMEOUT_OR_FAILURE > >::TType bResult;
#	if	( _WIN32_WINNT >= 0x0600 )
		bResult = ::SleepConditionVariableCS( ConditionVariable, CriticalSection, dwMilliseconds );
#	else
		__QCMP_UNREF( dwMilliseconds );
		__QCMP_UNREF( CriticalSection );
		__QCMP_UNREF( ConditionVariable );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SleepConditionVariableCS" ), _T( "Windows Vista" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::WakeAllConditionVariable( CCheckParam< ::CONDITION_VARIABLE*, CTWritablePointerCheck< sizeof( ::CONDITION_VARIABLE ) > >::TType ConditionVariable )
	{
		_WINQ_SFCONTEXT( "CKernel32::WakeAllConditionVariable" );
#	if ( _WIN32_WINNT >= 0x0600 )
		::WakeAllConditionVariable( ConditionVariable );
#	else
		__QCMP_UNREF( ConditionVariable );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "WakeAllConditionVariable" ), _T( "Windows Vista" ), 0 ));
#	endif
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::WakeConditionVariable( 
		CCheckParam< CONDITION_VARIABLE*, CTWritablePointerCheck< sizeof( CONDITION_VARIABLE ) > >::TType ConditionVariable )
	{
		_WINQ_SFCONTEXT( "CKernel32::WakeConditionVariable" );
#	if ( _WIN32_WINNT >= 0x0600 )
		::WakeConditionVariable( ConditionVariable );
#	else
		__QCMP_UNREF( ConditionVariable );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "WakeConditionVariable" ), _T( "Windows Vista" ), 0 ));
#	endif
	}


	//--------------------------------------------------------------------------------
	//SList
	//--------------------------------------------------------------------------------
	void CKernel32::InitializeSListHead( CCheckParam< SLIST_HEADER*, CTWritablePointerCheck< sizeof( SLIST_HEADER ) > >::TType ListHead )
	{
		_WINQ_SFCONTEXT( "CKernel32::InitializeSListHead" );
		::InitializeSListHead( ListHead );
	}

	//------------------------------------------------------------------------------
	::PSINGLE_LIST_ENTRY CKernel32::InterlockedFlushSList( CCheckParam< SLIST_HEADER*, CTWritablePointerCheck< sizeof( SLIST_HEADER ) > >::TType ListHead )
	{
		_WINQ_SFCONTEXT( "CKernel32::InterlockedFlushSList" );
		::PSLIST_ENTRY pEntry = 0;
		pEntry = ::InterlockedFlushSList( ListHead );
		return pEntry;
	}

	//------------------------------------------------------------------------------
	::PSINGLE_LIST_ENTRY CKernel32::InterlockedPopEntrySList( CCheckParam< SLIST_HEADER*, CTWritablePointerCheck< sizeof( SLIST_HEADER ) > >::TType ListHead )
	{
		_WINQ_SFCONTEXT( "CKernel32::InterlockedPopEntrySList" );
		::PSLIST_ENTRY pEntry = 0;
		pEntry = ::InterlockedPopEntrySList( ListHead );
		return pEntry;
	}

	//------------------------------------------------------------------------------
	::PSLIST_ENTRY CKernel32::InterlockedPushEntrySList( 
		CCheckParam< SLIST_HEADER*, CTWritablePointerCheck< sizeof( SLIST_HEADER ) > >::TType ListHead, 
		CCheckParam< SLIST_ENTRY*, CTWritablePointerCheck< sizeof( SLIST_ENTRY ) > >::TType ListEntry )
	{
		_WINQ_SFCONTEXT( "CKernel32::InterlockedPushEntrySList" );
		::PSLIST_ENTRY pEntry = 0;
		pEntry = ::InterlockedPushEntrySList( ListHead, ListEntry );
		return pEntry;
	}

	//------------------------------------------------------------------------------
	USHORT CKernel32::QueryDepthSList( CCheckParam< SLIST_HEADER*, CTWritablePointerCheck< sizeof( SLIST_HEADER ) > >::TType ListHead )
	{
		_WINQ_SFCONTEXT( "CKernel32::QueryDepthSList" );
		return ::QueryDepthSList( ListHead );
	}


	//--------------------------------------------------------------------------------
	//InitOnce
	//--------------------------------------------------------------------------------
	BOOL CKernel32::InitOnceBeginInitialize( 
		CCheckParam< INIT_ONCE*, CTWritablePointerCheck< sizeof( INIT_ONCE ) > >::TType lpInitOnce, 
		CCheckParam< DWORD, CInitOnceBeginFlagsCheck >::TType dwFlags, 
		CCheckParam< BOOL*, CTWritablePointerCheck< sizeof( BOOL ) > >::TType fPending, 
		CCheckParam< PVOID*, CNoCheck >::TType lpContext )
	{
		_WINQ_SFCONTEXT( "CKernel32::InitOnceBeginInitialize" );
		CCheckReturn< BOOL, CBoolCheck<> >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0600 )
		bResult = ::InitOnceBeginInitialize( lpInitOnce, dwFlags, fPending, lpContext );
#	else
		__QCMP_UNREF( lpContext );
		__QCMP_UNREF( fPending );
		__QCMP_UNREF( dwFlags );
		__QCMP_UNREF( lpInitOnce );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "InitOnceBeginInitialize" ), _T( "Windows Vista" ), 0 ));
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::InitOnceComplete( 
		CCheckParam< INIT_ONCE*, CTWritablePointerCheck< sizeof( INIT_ONCE ) > >::TType lpInitOnce,
		CCheckParam< DWORD, CInitOnceCompleteFlagsCheck >::TType dwFlags, 
		CCheckParam< PVOID, CNoCheck >::TType lpContext )
	{
		_WINQ_SFCONTEXT( "CKernel32::InitOnceComplete" );
		CCheckReturn< BOOL, CBoolCheck<> >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0600 )
		bResult = ::InitOnceComplete( lpInitOnce, dwFlags, lpContext );
#	else
		__QCMP_UNREF( lpContext );
		__QCMP_UNREF( dwFlags );
		__QCMP_UNREF( lpInitOnce );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "InitOnceComplete" ), _T( "Windows Vista" ), 0 ));
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::InitOnceExecuteOnce( 
		CCheckParam< INIT_ONCE*, CTWritablePointerCheck< sizeof( INIT_ONCE ) > >::TType InitOnce, 
		CCheckParam< PINIT_ONCE_FN, CTCodePointerCheck< PINIT_ONCE_FN > >::TType InitFn, 
		CCheckParam< PVOID, CNoCheck >::TType Parameter, 
		CCheckParam< PVOID*, CNoCheck >::TType Context )
	{
		_WINQ_SFCONTEXT( "CKernel32::InitOnceExecuteOnce" );
		CCheckReturn< BOOL, CBoolCheck<> >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0600 )
		bResult = ::InitOnceExecuteOnce( InitOnce, InitFn, Parameter, Context );
#	else
		__QCMP_UNREF( Context );
		__QCMP_UNREF( Parameter );
		__QCMP_UNREF( InitFn );
		__QCMP_UNREF( InitOnce );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "InitOnceExecuteOnce" ), _T( "Windows Vista" ), 0 ));
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::InitOnceInitialize( CCheckParam< INIT_ONCE*, CTWritablePointerCheck< sizeof( INIT_ONCE ) > >::TType pInitOnce )
	{
		_WINQ_SFCONTEXT( "CKernel32::InitOnceInitialize" );
#	if ( _WIN32_WINNT >= 0x0600 )
		::InitOnceInitialize( pInitOnce );
#	else
		__QCMP_UNREF( pInitOnce );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "InitOnceInitialize" ), _T( "Windows Vista" ), 0 ));
#	endif
	}

	//--------------------------------------------------------------------------------
	//Interlocked primitvies
	//--------------------------------------------------------------------------------
	LONG CKernel32::InterlockedIncrement( LONG volatile* Addend )
	{
		_WINQ_SFCONTEXT( "CKernel32::InterlockedIncrement" );
		return ::InterlockedIncrement( Addend );
	}

	//--------------------------------------------------------------------------------
#ifndef __MINGW32__
	LONGLONG CKernel32::InterlockedCompareExchange64( LONGLONG volatile* Destination, LONGLONG Exchange, LONGLONG Comperand )
	{
		_WINQ_SFCONTEXT( "CKernel32::InterlockedCompareExchange64" );
		#if ( _WIN32_WINNT >= 0x0502 )
			return ::InterlockedCompareExchange64( Destination, Exchange, Comperand );
		#else
			__QCMP_UNREF( Comperand );
			__QCMP_UNREF( Exchange );
			__QCMP_UNREF( Destination );
			__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "InterlockedCompareExchange64" ), _T( "Windows XP" ), 0 ));
			return 0;
		#endif
	}

	//--------------------------------------------------------------------------------
	LONG CKernel32::mxInterlockedCompareExchangeAcquire( LONG volatile* Destination, LONG Exchange, LONG Comperand )
	{
		_WINQ_SFCONTEXT( "CKernel32::mxInterlockedCompareExchangeAcquire" );
		return ::InterlockedCompareExchangeAcquire( Destination, Exchange, Comperand );
	}

	//--------------------------------------------------------------------------------
	LONGLONG CKernel32::mxInterlockedCompareExchangeAcquire64( LONGLONG volatile* Destination, LONGLONG Exchange, LONGLONG Comperand )
	{
		_WINQ_SFCONTEXT( "CKernel32::mxInterlockedCompareExchangeAcquire64" );
		#if ( _WIN32_WINNT >= 0x0502 )
			return ::InterlockedCompareExchangeAcquire64( Destination, Exchange, Comperand );
		#else
			__QCMP_UNREF( Comperand );
			__QCMP_UNREF( Exchange );
			__QCMP_UNREF( Destination );
			__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "InterlockedCompareExchangeAcquire64" ), _T( "Windows XP" ), 0 ));
			return 0;
		#endif
	}

	//--------------------------------------------------------------------------------
	LONG CKernel32::mxInterlockedCompareExchangeRelease( LONG volatile* Destination, LONG Exchange, LONG Comperand )
	{
		_WINQ_SFCONTEXT( "CKernel32::mxInterlockedCompareExchangeRelease" );
		return ::InterlockedCompareExchangeRelease( Destination, Exchange, Comperand );
	}

	//--------------------------------------------------------------------------------
	LONGLONG CKernel32::mxInterlockedCompareExchangeRelease64( LONGLONG volatile* Destination, LONGLONG Exchange, LONGLONG Comperand )
	{
		_WINQ_SFCONTEXT( "CKernel32::mxInterlockedCompareExchangeRelease64" );
		#if ( _WIN32_WINNT >= 0x0502 )
			return ::InterlockedCompareExchangeRelease64( Destination, Exchange, Comperand );
		#else
			__QCMP_UNREF( Comperand );
			__QCMP_UNREF( Exchange );
			__QCMP_UNREF( Destination );
			__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "InterlockedCompareExchangeRelease64" ), _T( "Windows XP" ), 0 ));
			return 0;
		#endif
	}

	//--------------------------------------------------------------------------------
	LONGLONG CKernel32::InterlockedDecrement64( LONGLONG volatile* Addend )
	{
		_WINQ_SFCONTEXT( "CKernel32::InterlockedDecrement64" );
		#if ( _WIN32_WINNT >= 0x0502 )
			return ::InterlockedDecrement64( Addend );
		#else
			__QCMP_UNREF( Addend );
			__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "InterlockedDecrement64" ), _T( "Windows XP" ), 0 ));
			return 0;
		#endif
	}

	//--------------------------------------------------------------------------------
	LONG CKernel32::mxInterlockedDecrementAcquire( LONG volatile* Addend )
	{
		_WINQ_SFCONTEXT( "CKernel32::mxInterlockedDecrementAcquire" );
		return ::InterlockedDecrementAcquire( Addend );
	}

	//--------------------------------------------------------------------------------
	LONG CKernel32::mxInterlockedDecrementRelease( LONG volatile* Addend )
	{
		_WINQ_SFCONTEXT( "CKernel32::mxInterlockedDecrementRelease" );
		return ::InterlockedDecrementRelease( Addend );
	}

	//--------------------------------------------------------------------------------
	LONGLONG CKernel32::InterlockedExchange64( LONGLONG volatile* Target, LONGLONG Value )
	{
		_WINQ_SFCONTEXT( "CKernel32::InterlockedExchange64" );
		#if ( _WIN32_WINNT >= 0x0502 )
			return ::InterlockedExchange64( Target, Value );
		#else
			__QCMP_UNREF( Value );
			__QCMP_UNREF( Target );
			__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "InterlockedExchange64" ), _T( "Windows XP" ), 0 ));
			return 0;
		#endif
	}

	//--------------------------------------------------------------------------------
	LONGLONG CKernel32::InterlockedExchangeAcquire64( LONGLONG volatile Target, LONGLONG Value )
	{
		_WINQ_SFCONTEXT( "CKernel32::InterlockedExchangeAcquire64" );
		#if ( _WIN32_WINNT >= 0x0502 )
			QOR_PP_UNREF2( Value, Target );
			//IPF 64 only
			return 0;//::_InterlockedExchange64_acq( Target, Value );
		#else
			__QCMP_UNREF( Value );
			__QCMP_UNREF( Target );
			__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "InterlockedExchangeAcquire64" ), _T( "Windows XP" ), 0 ));
			return 0;
		#endif
	}

	//--------------------------------------------------------------------------------
	LONGLONG CKernel32::InterlockedExchangeAdd64( LONGLONG volatile* Addend, LONGLONG Value )
	{
		_WINQ_SFCONTEXT( "CKernel32::InterlockedExchangeAdd64" );
		#if ( _WIN32_WINNT >= 0x0502 )
			return ::InterlockedExchangeAdd64( Addend, Value );
		#else
			__QCMP_UNREF( Value );
			__QCMP_UNREF( Addend );
			__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "InterlockedExchangeAdd64" ), _T( "Windows XP" ), 0 ));
			return 0;
		#endif
	}

	//--------------------------------------------------------------------------------
	LONGLONG CKernel32::InterlockedIncrement64( LONGLONG volatile* Addend )
	{
		_WINQ_SFCONTEXT( "CKernel32::InterlockedIncrement64" );
		#if ( _WIN32_WINNT >= 0x0502 )
			return ::InterlockedIncrement64( Addend );
		#else
			__QCMP_UNREF( Addend );
			__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "InterlockedIncrement64" ), _T( "Windows XP" ), 0 ));
			return 0;
		#endif
	}

	//--------------------------------------------------------------------------------
	LONG CKernel32::mxInterlockedIncrementAcquire( LONG volatile* Addend )
	{
		_WINQ_SFCONTEXT( "CKernel32::mxInterlockedIncrementAcquire" );
		return ::InterlockedIncrementAcquire( Addend );
	}

	//--------------------------------------------------------------------------------
	LONG CKernel32::mxInterlockedIncrementRelease( LONG volatile* Addend )
	{
		_WINQ_SFCONTEXT( "CKernel32::mxInterlockedIncrementRelease" );
		return ::InterlockedIncrementRelease( Addend );
	}
#endif//__MINGW32__
	//--------------------------------------------------------------------------------
	LONG CKernel32::InterlockedCompareExchange( LONG volatile* Destination, LONG Exchange, LONG Comperand )
	{
		_WINQ_SFCONTEXT( "CKernel32::InterlockedCompareExchange" );
		return ::InterlockedCompareExchange( Destination, Exchange, Comperand );
	}

	//--------------------------------------------------------------------------------
#ifndef __MINGW32__
	PVOID CKernel32::mxInterlockedCompareExchangePointer( PVOID volatile* Destination, PVOID Exchange, PVOID Comperand )
	{
		_WINQ_SFCONTEXT( "CKernel32::mxInterlockedCompareExchangePointer" );
		return ::InterlockedCompareExchangePointer( Destination, Exchange, Comperand );
	}
#endif//__MINGW32__

	//--------------------------------------------------------------------------------
	LONG CKernel32::InterlockedExchangeAdd( LONG volatile* Addend, LONG Value )
	{
		_WINQ_SFCONTEXT( "CKernel32::InterlockedExchangeAdd" );
		return ::InterlockedExchangeAdd( Addend, Value );
	}

	//--------------------------------------------------------------------------------
	LONG CKernel32::InterlockedDecrement( LONG volatile* Addend )
	{
		_WINQ_SFCONTEXT( "CKernel32::InterlockedDecrement" );
		return ::InterlockedDecrement( Addend );
	}

	//--------------------------------------------------------------------------------
	LONG CKernel32::InterlockedExchange( LONG volatile* Target, LONG Value )
	{
		_WINQ_SFCONTEXT( "CKernel32::InterlockedExchange" );
		return ::InterlockedExchange( Target, Value );
	}

	//--------------------------------------------------------------------------------
	//APC
	//--------------------------------------------------------------------------------
	DWORD CKernel32::QueueUserAPC( 
		CCheckParam< PAPCFUNC, CTCodePointerCheck< PAPCFUNC > >::TType pfnAPC, 
		CCheckParam< HANDLE, CNoCheck >::TType hThread, 
		CCheckParam< ULONG_PTR, CNoCheck >::TType dwData )
	{
		_WINQ_SFCONTEXT( "CKernel32::QueueUserAPC" );
		CCheckReturn< DWORD, CCheckNonZero< DWORD, nsCodeQOR::CError::ERR_LVL_CONTINUE, API_FAILED > >::TType dwResult;
#	if( _WIN32_WINNT >= 0x0400 )
		dwResult = ::QueueUserAPC( pfnAPC, hThread, dwData );
#	else
		__QCMP_UNREF( dwData );
		__QCMP_UNREF( hThread );
		__QCMP_UNREF( pfnAPC );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "QueueUserAPC" ), _T( "Windows NT 4.0" ), 0 ));
#	endif
		return dwResult;
	}


	//------------------------------------------------------------------------------
	//Wait
	//------------------------------------------------------------------------------
	BOOL CKernel32::RegisterWaitForSingleObject( 
		CCheckParam< HANDLE*, CTWritablePointerCheck< sizeof( HANDLE ) > >::TType phNewWaitObject, 
		CCheckParam< HANDLE, CNoCheck >::TType hObject, 
		CCheckParam< WAITORTIMERCALLBACK, CTCodePointerCheck< WAITORTIMERCALLBACK > >::TType Callback, 
		CCheckParam< PVOID, CNoCheck >::TType Context, 
		CCheckParam< ULONG, CNoCheck >::TType dwMilliseconds,
		CCheckParam< ULONG, CRgstrWaitFlagsCheck >::TType dwFlags )
	{
		_WINQ_SFCONTEXT( "CKernel32::RegisterWaitForSingleObject" );
		CCheckReturn< BOOL, CBoolCheck<> >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0500 )
		bResult = ::RegisterWaitForSingleObject( phNewWaitObject, hObject, Callback, Context, dwMilliseconds, dwFlags );
#else
		__QCMP_UNREF( dwFlags );
		__QCMP_UNREF( dwMilliseconds );
		__QCMP_UNREF( Context );
		__QCMP_UNREF( Callback );
		__QCMP_UNREF( hObject );
		__QCMP_UNREF( phNewWaitObject );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "RegisterWaitForSingleObject" ), _T( "Windows 2000" ), 0 ));
#endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	DWORD CKernel32::SignalObjectAndWait( 
		CCheckParam< HANDLE, CNoCheck >::TType hObjectToSignal, 
		CCheckParam< HANDLE, CNoCheck >::TType hObjectToWaitOn, 
		CCheckParam< DWORD, CNoCheck >::TType dwMilliseconds, 
		CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType bAlertable )
	{
		_WINQ_SFCONTEXT( "CKernel32::SignalObjectAndWait" );
		CCheckReturn< DWORD, CTCheckFailureValue< DWORD, WAIT_FAILED, nsCodeQOR::CError::ERR_LVL_CONTINUE, API_WAIT_FAILED > >::TType dwResult;
#	if ( _WIN32_WINNT >= 0x0400 )
		dwResult = ::SignalObjectAndWait( hObjectToSignal, hObjectToWaitOn, dwMilliseconds, bAlertable );
#else
		__QCMP_UNREF( bAlertable );
		__QCMP_UNREF( dwMilliseconds );
		__QCMP_UNREF( hObjectToWaitOn );
		__QCMP_UNREF( hObjectToSignal );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SignalObjectAndWait" ), _T( "Windows NT 4.0" ), 0 ));
#endif
		return dwResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::UnregisterWait( 
		CCheckParam< HANDLE, CNoCheck >::TType WaitHandle )
	{
		_WINQ_SFCONTEXT( "CKernel32::UnregisterWait" );
		CCheckReturn< BOOL, CBoolCheck<> >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0500 )
		bResult = ::UnregisterWait( WaitHandle );
#	else
		__QCMP_UNREF( WaitHandle );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "UnregisterWait" ), _T( "Windows 2000" ), 0 ));
#	endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::UnregisterWaitEx( 
		CCheckParam< HANDLE, CNoCheck >::TType WaitHandle,
		CCheckParam< HANDLE, CNoCheck >::TType CompletionEvent )
	{
		_WINQ_SFCONTEXT( "CKernel32::UnregisterWaitEx" );
		CCheckReturn< BOOL, CBoolCheck<> >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0500 )
		bResult = ::UnregisterWaitEx( WaitHandle, CompletionEvent );
#	else
		__QCMP_UNREF( CompletionEvent );
		__QCMP_UNREF( WaitHandle );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "UnregisterWaitEx" ), _T( "Windows 2000" ), 0 ));
#	endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	//nCount must be valid array size of lpHandles && <= MAXIMUM_WAIT_OBJECTS
	//lpHandles must be handles to one of
	/*
	Change notification 
	Console input 
	Event 
	Memory resource notification 
	Mutex 
	Process 
	Semaphore 
	Thread 
	Waitable timer 
	*/
	//each must have SYNCHRONIZE access
	DWORD CKernel32::WaitForMultipleObjects( 
		CCheckParam< DWORD, nsParamChecking::CTIntegerRangeCheck< DWORD, 1, MAXIMUM_WAIT_OBJECTS > >::TType nCount,									
		HANDLE* lpHandles /*CConstCheckParam< PHANDLE, CTArrayNCheck< PHANDLE, 0 > >::TType lpHandles*/,
		CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType bWaitAll, 
		CCheckParam< DWORD, CNoCheck >::TType dwMilliseconds )
	{
		_WINQ_SFCONTEXT( "CKernel32::WaitForMultipleObjects" );
		CCheckReturn< DWORD, CTCheckFailureValue< DWORD, WAIT_FAILED, nsCodeQOR::CError::ERR_LVL_CONTINUE, API_WAIT_FAILED > >::TType dwResult(
		::WaitForMultipleObjects( nCount, lpHandles, bWaitAll, dwMilliseconds ) );
		return dwResult;
	}

	//------------------------------------------------------------------------------
	//TODO:
	//lpHandles must be handles to one of
	/*
	Change notification 
	Console input 
	Event 
	Memory resource notification 
	Mutex 
	Process 
	Semaphore 
	Thread 
	Waitable timer 
	*/
	//each must have SYNCHRONIZE access
	//nCount must be valid array size
	DWORD CKernel32::WaitForMultipleObjectsEx( 
		CCheckParam< DWORD, nsParamChecking::CTIntegerRangeCheck< DWORD, 1, MAXIMUM_WAIT_OBJECTS > >::TType nCount,
		CConstCheckParam< PHANDLE, nsCodeQOR::CTArrayNCheck< PHANDLE, 0 > >::TType lpHandles, 
		CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType bWaitAll, 
		CCheckParam< DWORD, CNoCheck >::TType dwMilliseconds, 
		CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType bAlertable )
	{
		_WINQ_SFCONTEXT( "CKernel32::WaitForMultipleObjectsEx" );
		CCheckReturn< DWORD, CTCheckFailureValue< DWORD, WAIT_FAILED, nsCodeQOR::CError::ERR_LVL_CONTINUE, API_WAIT_FAILED > >::TType dwResult;
		dwResult = ::WaitForMultipleObjectsEx( nCount, lpHandles, bWaitAll, dwMilliseconds, bAlertable );
		return dwResult;
	}

	//------------------------------------------------------------------------------
	//TODO:
	//hHandle must be one of 
	/*
	Change notification 
	Console input 
	Event 
	Memory resource notification 
	Mutex 
	Process 
	Semaphore 
	Thread 
	Waitable timer 
	*/
	//and must have SYNCHRONIZE access
	//If a synchronization manager is used this should register with it before calling
	DWORD CKernel32::WaitForSingleObject( 
		CCheckParam< HANDLE, CNoCheck >::TType hHandle, 
		CCheckParam< DWORD, CNoCheck >::TType dwMilliseconds )
	{
		_WINQ_SFCONTEXT( "CKernel32::WaitForSingleObject" );
		CCheckReturn< DWORD, CTCheckFailureValue< DWORD, WAIT_FAILED, nsCodeQOR::CError::ERR_LVL_CONTINUE, API_WAIT_FAILED > >::TType dwResult( ::WaitForSingleObject( hHandle, dwMilliseconds ) );
		return dwResult;
	}

	//------------------------------------------------------------------------------
	//TODO:
	//hHandle must be one of 
	/*
	Change notification 
	Console input 
	Event 
	Memory resource notification 
	Mutex 
	Process 
	Semaphore 
	Thread 
	Waitable timer 
	*/
	//and must have SYNCHRONIZE access
	//If a synchronization manager is used this should register with it before calling
	DWORD CKernel32::WaitForSingleObjectEx( 
		CCheckParam< HANDLE, CNoCheck >::TType hHandle, 
		CCheckParam< DWORD, CNoCheck >::TType dwMilliseconds,
		CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType bAlertable )
	{
		_WINQ_SFCONTEXT( "CKernel32::WaitForSingleObjectEx" );
		CCheckReturn< DWORD, CTCheckFailureValue< DWORD, WAIT_FAILED, nsCodeQOR::CError::ERR_LVL_CONTINUE, API_WAIT_FAILED > >::TType dwResult;
		dwResult = ::WaitForSingleObjectEx( hHandle, dwMilliseconds, bAlertable );
		return dwResult;
	}

}//nsWinQAPI
