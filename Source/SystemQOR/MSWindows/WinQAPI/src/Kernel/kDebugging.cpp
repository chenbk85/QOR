//kDebugging.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQAPI/Kernel32.h"
#include "../SystemQOR/MSWindows/WinQAPI/include/ReturnCheck.h"

//--------------------------------------------------------------------------------
namespace nsWinQAPI
{
	// {461A8D35-5C0B-4990-A9BF-C4B18965D85B}
	__QOR_IMPLEMENT_OCLASS_GUID( CKernel32, 0x461a8d35, 0x5c0b, 0x4990, 0xa9, 0xbf, 0xc4, 0xb1, 0x89, 0x65, 0xd8, 0x5b );

	//--------------------------------------------------------------------------------
	BOOL CKernel32::CheckRemoteDebuggerPresent( HANDLE hProcess, PBOOL pbDebuggerPresent )
	{
		_WINQ_SFCONTEXT( "CKernel32::CheckRemoteDebuggerPresent" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
		__QOR_CODESTRING( APIName, "CheckRemoteDebuggerPresent" );
#	if ( _WIN32_WINNT >= 0x0501 )
		bResult = ::CheckRemoteDebuggerPresent( hProcess, pbDebuggerPresent );
#	else
		QOR_PP_UNREF2( pbDebuggerPresent, hProcess );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, APIName.c_str(), _T( "Windows XP" ), 0 ));
#	endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::ContinueDebugEvent( DWORD dwProcessId, DWORD dwThreadId, DWORD dwContinueStatus )
	{
		_WINQ_SFCONTEXT( "CKernel32::ContinueDebugEvent" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::ContinueDebugEvent( dwProcessId, dwThreadId, dwContinueStatus );
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::DebugActiveProcess( DWORD dwProcessId )
	{
		_WINQ_SFCONTEXT( "CKernel32::DebugActiveProcess" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::DebugActiveProcess( dwProcessId );
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::DebugActiveProcessStop( DWORD dwProcessId )
	{
		_WINQ_SFCONTEXT( "CKernel32::DebugActiveProcessStop" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::DebugActiveProcessStop( dwProcessId );
		return bResult;
	}

	//------------------------------------------------------------------------------
	void CKernel32::DebugBreak(void)
	{
		_WINQ_SFCONTEXT( "CKernel32::DebugBreak" );
		::DebugBreak();
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::DebugBreakProcess( HANDLE Process )
	{
		_WINQ_SFCONTEXT( "CKernel32::DebugBreakProcess" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::DebugBreakProcess( Process );
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::DebugSetProcessKillOnExit( BOOL KillOnExit )
	{
		_WINQ_SFCONTEXT( "CKernel32::DebugSetProcessKillOnExit" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::DebugSetProcessKillOnExit( KillOnExit );
		return bResult;
	}

	//------------------------------------------------------------------------------
	void CKernel32::FatalExit( int ExitCode )
	{
		_WINQ_SFCONTEXT( "CKernel32::FatalExit" );
		::FatalExit( ExitCode );
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::FlushInstructionCache( HANDLE hProcess, LPCVOID lpBaseAddress, SIZE_T dwSize )
	{
		_WINQ_SFCONTEXT( "CKernel32::FlushInstructionCache" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::FlushInstructionCache( hProcess, lpBaseAddress, dwSize );
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::GetThreadContext( HANDLE hThread, LPCONTEXT lpContext )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetThreadContext" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::GetThreadContext( hThread, lpContext );
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::GetThreadSelectorEntry( HANDLE hThread, DWORD dwSelector, ::LPLDT_ENTRY lpSelectorEntry )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetThreadSelectorEntry" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::GetThreadSelectorEntry( hThread, dwSelector, lpSelectorEntry );
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::IsDebuggerPresent(void)
	{
		_WINQ_SFCONTEXT( "CKernel32::IsDebuggerPresent" );
		BOOL bResult = FALSE;
#	if ( _WIN32_WINNT >= 0x0400 )
		bResult = ::IsDebuggerPresent();
#	else
#	endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	void CKernel32::OutputDebugStringA( LPCSTR lpOutputString )
	{
		::OutputDebugStringA( lpOutputString );
	}

	//------------------------------------------------------------------------------
	void CKernel32::OutputDebugStringW( LPCWSTR lpOutputString )
	{
		::OutputDebugStringW( lpOutputString );
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::ReadProcessMemory( HANDLE hProcess, LPCVOID lpBaseAddress, void* lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesRead )
	{
		_WINQ_SFCONTEXT( "CKernel32::ReadProcessMemory" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::ReadProcessMemory( hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesRead );
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::SetThreadContext( HANDLE hThread, const ::CONTEXT* lpContext )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetThreadContext" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::SetThreadContext( hThread, lpContext );
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::WaitForDebugEvent( ::LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds )
	{
		_WINQ_SFCONTEXT( "CKernel32::WaitForDebugEvent" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::WaitForDebugEvent( lpDebugEvent, dwMilliseconds );
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::Wow64GetThreadContext( HANDLE hThread, ::PWOW64_CONTEXT lpContext )
	{
		_WINQ_SFCONTEXT( "CKernel32::Wow64GetThreadContext" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "Wow64GetThreadContext" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		bResult = ::Wow64GetThreadContext( hThread, lpContext );
#	else
		QOR_PP_UNREF2( lpContext, hThread );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "Wow64GetThreadContext" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::Wow64SetThreadContext( HANDLE hThread, const ::WOW64_CONTEXT* lpContext )
	{
		_WINQ_SFCONTEXT( "CKernel32::Wow64SetThreadContext" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "Wow64GetThreadContext" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		bResult = ::Wow64SetThreadContext( hThread, lpContext );
#	else
		QOR_PP_UNREF( lpContext, hThread );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "Wow64SetThreadContext" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::WriteProcessMemory( HANDLE hProcess, void* lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesWritten )
	{
		_WINQ_SFCONTEXT( "CKernel32::WriteProcessMemory" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::WriteProcessMemory( hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten );
		return bResult;
	}

#if( _MSC_VER < 1700 && !defined( __MINGW32__ ) )

	//--------------------------------------------------------------------------------
	BOOL CKernel32::Thread32First( HANDLE hSnapshot, ::LPTHREADENTRY32 lpte )
	{
		_WINQ_SFCONTEXT( "CKernel32::Thread32First" );
		BOOL bResult = ::Thread32First( hSnapshot, lpte );
		if( bResult == FALSE )
		{
			__QOR_CODESTRING( APIName, "Thread32First" );
			DWORD dwError = CKernel32::GetLastError();
			if( dwError == ERROR_NO_MORE_FILES )
			{
				__WINQAPI_CONT_ERROR(( SNAPSHOT_API_ERROR, APIName.c_str(), _T( "No threads exist or the snapshot does not contain thread information." ), 0 ));
			}
			else
			{
				__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, APIName.c_str(), 0 ));
			}
		}
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::Thread32Next( HANDLE hSnapshot, ::LPTHREADENTRY32 lpte )
	{
		_WINQ_SFCONTEXT( "CKernel32::Thread32Next" );
		BOOL bResult = ::Thread32Next( hSnapshot, lpte );
		if( bResult == FALSE )
		{
			__QOR_CODESTRING( APIName, "Thread32Next" );
			DWORD dwError = CKernel32::GetLastError();
			if( dwError == ERROR_NO_MORE_FILES )
			{
				__WINQAPI_CONT_ERROR(( SNAPSHOT_API_ERROR, APIName.c_str(), _T( "No threads exist or the snapshot does not contain thread information." ), 0 ));
			}
			else
			{
				__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, APIName.c_str(), 0 ));
			}
		}
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::Toolhelp32ReadProcessMemory( DWORD th32ProcessID, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T cbRead, SIZE_T* lpNumberOfBytesRead )
	{
		_WINQ_SFCONTEXT( "CKernel32::Toolhelp32ReadProcessMemory" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::Toolhelp32ReadProcessMemory( th32ProcessID, lpBaseAddress, lpBuffer, cbRead, lpNumberOfBytesRead );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::Process32First( HANDLE hSnapshot, ::LPPROCESSENTRY32 lppe )
	{
		_WINQ_SFCONTEXT( "CKernel32::Process32First" );
		BOOL bResult = ::Process32First( hSnapshot, lppe );
		if( bResult == FALSE )
		{
			__QOR_CODESTRING( APIName, "Process32First" );
			DWORD dwError = CKernel32::GetLastError();
			if( dwError == ERROR_NO_MORE_FILES )
			{
				__WINQAPI_CONT_ERROR(( SNAPSHOT_API_ERROR, APIName.c_str(), _T( "No processes exist or the snapshot does not contain process information." ), 0 ));
			}
			else
			{
				__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, APIName.c_str(), 0 ));
			}
		}
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::Process32Next( HANDLE hSnapshot, ::LPPROCESSENTRY32 lppe )
	{
		_WINQ_SFCONTEXT( "CKernel32::Process32Next" );
		BOOL bResult = ::Process32Next( hSnapshot, lppe );
		if( bResult == FALSE )
		{
			__QOR_CODESTRING( APIName, "Process32Next" );
			DWORD dwError = CKernel32::GetLastError();
			if( dwError == ERROR_NO_MORE_FILES )
			{
				__WINQAPI_CONT_ERROR(( SNAPSHOT_API_ERROR, APIName.c_str(), _T( "No processes exist or the snapshot does not contain process information." ), 0 ));
			}
			else
			{
				__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, APIName.c_str(), 0 ));
			}
		}
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::Module32First( HANDLE hSnapshot, ::LPMODULEENTRY32 lpme )
	{
		_WINQ_SFCONTEXT( "CKernel32::Module32First" );
		BOOL bResult = ::Module32First( hSnapshot, lpme );
		if( bResult == FALSE )
		{
			__QOR_CODESTRING( APIName, "Module32First" );
			DWORD dwError = CKernel32::GetLastError();
			if( dwError == ERROR_NO_MORE_FILES )
			{
				__WINQAPI_CONT_ERROR(( SNAPSHOT_API_ERROR, APIName.c_str(), _T( "No modules exist or the snapshot does not contain module information." ), 0 ));
			}
			else
			{
				__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, APIName.c_str(), 0 ));
			}
		}
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::Module32Next( HANDLE hSnapshot, ::LPMODULEENTRY32 lpme )
	{
		_WINQ_SFCONTEXT( "CKernel32::Module32Next" );
		BOOL bResult = ::Module32Next( hSnapshot, lpme );
		if( bResult == FALSE )
		{
			__QOR_CODESTRING( APIName, "Module32Next" );
			DWORD dwError = CKernel32::GetLastError();
			if( dwError == ERROR_NO_MORE_FILES )
			{
				__WINQAPI_CONT_ERROR(( SNAPSHOT_API_ERROR, APIName.c_str(), _T( "No modules exist or the snapshot does not contain module information." ), 0 ));
			}
			else
			{
				__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, APIName.c_str(), 0 ));
			}
		}
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::Heap32First( ::LPHEAPENTRY32 lphe, DWORD th32ProcessID, ULONG_PTR th32HeapID )
	{
		_WINQ_SFCONTEXT( "CKernel32::Heap32First" );
		BOOL bResult = ::Heap32First( lphe, th32ProcessID, th32HeapID );
		if( bResult == FALSE )
		{
			__QOR_CODESTRING( APIName, "Heap32First" );
			DWORD dwError = CKernel32::GetLastError();
			if( dwError == ERROR_NO_MORE_FILES )
			{
				__WINQAPI_CONT_ERROR(( SNAPSHOT_API_ERROR, APIName.c_str(), _T( "The heap is invalid or empty." ), 0 ));
			}
			else
			{
				__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, APIName.c_str(), 0 ));
			}
		}
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::Heap32ListFirst( HANDLE hSnapshot, ::LPHEAPLIST32 lphl )
	{
		_WINQ_SFCONTEXT( "CKernel32::Heap32ListFirst" );
		BOOL bResult = ::Heap32ListFirst( hSnapshot, lphl );
		if( bResult == FALSE )
		{
			__QOR_CODESTRING( APIName, "Heap32ListFirst" );
			DWORD dwError = CKernel32::GetLastError();
			if( dwError == ERROR_NO_MORE_FILES )
			{
				__WINQAPI_CONT_ERROR(( SNAPSHOT_API_ERROR, APIName.c_str(), _T( "No heap list exists or the snapshot does not contain heap list information." ), 0 ));
			}
			else
			{
				__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, APIName.c_str(), 0 ));
			}
		}
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::Heap32ListNext( HANDLE hSnapshot, ::LPHEAPLIST32 lphl )
	{
		_WINQ_SFCONTEXT( "CKernel32::Heap32ListNext" );
		BOOL bResult = ::Heap32ListNext( hSnapshot, lphl );
		if( bResult == FALSE )
		{
			__QOR_CODESTRING( APIName, "Heap32ListNext" );
			DWORD dwError = CKernel32::GetLastError();
			if( dwError == ERROR_NO_MORE_FILES )
			{
				__WINQAPI_CONT_ERROR(( SNAPSHOT_API_ERROR, APIName.c_str(), _T( "No more entries in the heap list exist." ), 0 ));
			}
			else
			{
				__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, APIName.c_str(), 0 ));
			}
		}
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::Heap32Next( ::LPHEAPENTRY32 lphe )
	{
		_WINQ_SFCONTEXT( "CKernel32::Heap32Next" );
		BOOL bResult = ::Heap32Next( lphe );
		if( bResult == FALSE )
		{
			__QOR_CODESTRING( APIName, "Heap32Next" );
			DWORD dwError = CKernel32::GetLastError();
			if( dwError == ERROR_NO_MORE_FILES )
			{
				__WINQAPI_CONT_ERROR(( SNAPSHOT_API_ERROR, APIName.c_str(), _T( "No more objects in the heap exist." ), 0 ));
			}
			else if( dwError == ERROR_INVALID_DATA )
			{
				__WINQAPI_CONT_ERROR(( SNAPSHOT_API_ERROR, APIName.c_str(), _T( "The heap appears to be corrupt or has been modified in such a way that the heap walk cannot continue." ), 0 ));
			}
			else
			{
				__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, APIName.c_str(), 0 ));
			}
		}
		return bResult;
	}

	//--------------------------------------------------------------------------------
	HANDLE CKernel32::CreateToolhelp32Snapshot( DWORD dwFlags, DWORD th32ProcessID )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateToolhelp32Snapshot" );
		CCheckReturn< HANDLE, CHandleCheck< > >::TType h = ::CreateToolhelp32Snapshot( dwFlags, th32ProcessID );
		return h;
	}
#endif
	//--------------------------------------------------------------------------------
	BOOL CKernel32::IsBadHugeReadPtr( CONST VOID* lp, UINT_PTR ucb )
	{
		_WINQ_SFCONTEXT( "CKernel32::IsBadHugeReadPtr" );
		return ::IsBadHugeReadPtr( lp, ucb );
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::IsBadHugeWritePtr( void* lp, UINT_PTR ucb )
	{
		_WINQ_SFCONTEXT( "CKernel32::IsBadHugeWritePtr" );
		return ::IsBadHugeWritePtr( lp, ucb );
	}

}//nsWinQAPI

