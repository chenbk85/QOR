//kBackup.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQAPI/Kernel32.h"
#include "ReturnCheck.h"

//--------------------------------------------------------------------------------
namespace nsWinQAPI
{
	//--------------------------------------------------------------------------------
	BOOL CKernel32::BackupRead( HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, BOOL bAbort, BOOL bProcessSecurity, void** lpContext )
	{
		_WINQ_SFCONTEXT( "CKernel32::BackupRead" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::BackupRead( hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, bAbort, bProcessSecurity, lpContext );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::BackupSeek( HANDLE hFile, DWORD dwLowBytesToSeek, DWORD dwHighBytesToSeek, LPDWORD lpdwLowByteSeeked, LPDWORD lpdwHighByteSeeked, void* *lpContext )
	{
		_WINQ_SFCONTEXT( "CKernel32::BackupSeek" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::BackupSeek( hFile, dwLowBytesToSeek, dwHighBytesToSeek, lpdwLowByteSeeked, lpdwHighByteSeeked, lpContext );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::BackupWrite( HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, BOOL bAbort, BOOL bProcessSecurity, void** lpContext )
	{
		_WINQ_SFCONTEXT( "CKernel32::BackupWrite" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::BackupWrite( hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, bAbort, bProcessSecurity, lpContext );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	void CKernel32::TapeAPIResult( nsCodeQOR::CTLRef< mxTCHAR > StrAPI, DWORD dwResult )
	{
		_WINQ_SFCONTEXT( "CKernel32::TapeAPIResult" );
		if( dwResult != NO_ERROR )
		{
			switch ( dwResult )
			{
			case ERROR_BEGINNING_OF_MEDIA:
				__WINQAPI_CONT_ERROR(( TAPE_API_ERROR, StrAPI.operator mxTCHAR*(), _T( "An attempt to access data before the beginning-of-medium marker failed." ), 0 ));
				break;
			case ERROR_BUS_RESET:
				__WINQAPI_CONT_ERROR(( TAPE_API_ERROR, StrAPI.operator mxTCHAR*(), _T( "A reset condition was detected on the bus." ), 0 ));
				break;
			case ERROR_END_OF_MEDIA:
				__WINQAPI_CONT_ERROR(( TAPE_API_ERROR, StrAPI.operator mxTCHAR*(), _T( "The end-of-tape marker was reached during an operation." ), 0 ));
				break;
			case ERROR_FILEMARK_DETECTED:
				__WINQAPI_CONT_ERROR(( TAPE_API_ERROR, StrAPI.operator mxTCHAR*(), _T( "A filemark was reached during an operation." ), 0 ));
				break;
			case ERROR_SETMARK_DETECTED:
				__WINQAPI_CONT_ERROR(( TAPE_API_ERROR, StrAPI.operator mxTCHAR*(), _T( "A setmark was reached during an operation." ), 0 ));
				break;
			case ERROR_NO_DATA_DETECTED:
				__WINQAPI_CONT_ERROR(( TAPE_API_ERROR, StrAPI.operator mxTCHAR*(), _T( "The end-of-data marker was reached during an operation." ), 0 ));
				break;
			case ERROR_PARTITION_FAILURE:
				__WINQAPI_CONT_ERROR(( TAPE_API_ERROR, StrAPI.operator mxTCHAR*(), _T( "The tape could not be partitioned." ), 0 ));
				break;
			case ERROR_INVALID_BLOCK_LENGTH:
				__WINQAPI_CONT_ERROR(( TAPE_API_ERROR, StrAPI.operator mxTCHAR*(), _T( "The block size is incorrect on a new tape in a multivolume partition." ), 0 ));
				break;
			case ERROR_DEVICE_NOT_PARTITIONED:
				__WINQAPI_CONT_ERROR(( TAPE_API_ERROR, StrAPI.operator mxTCHAR*(), _T( "The partition information could not be found when a tape was being loaded." ), 0 ));
				break;
			case ERROR_MEDIA_CHANGED:
				__WINQAPI_CONT_ERROR(( TAPE_API_ERROR, StrAPI.operator mxTCHAR*(), _T( "The tape that was in the drive has been replaced or removed." ), 0 ));
				break;
			case ERROR_NO_MEDIA_IN_DRIVE:
				__WINQAPI_CONT_ERROR(( TAPE_API_ERROR, StrAPI.operator mxTCHAR*(), _T( "There is no media in the drive." ), 0 ));
				break;
			case ERROR_NOT_SUPPORTED:
				__WINQAPI_CONT_ERROR(( TAPE_API_ERROR, StrAPI.operator mxTCHAR*(), _T( "The tape driver does not support a requested function." ), 0 ));
				break;
			case ERROR_UNABLE_TO_LOCK_MEDIA:
				__WINQAPI_CONT_ERROR(( TAPE_API_ERROR, StrAPI.operator mxTCHAR*(), _T( "An attempt to lock the ejection mechanism failed." ), 0 ));
				break;				
			case ERROR_UNABLE_TO_UNLOAD_MEDIA:
				__WINQAPI_CONT_ERROR(( TAPE_API_ERROR, StrAPI.operator mxTCHAR*(), _T( "An attempt to unload the tape failed." ), 0 ));
				break;				
			case ERROR_WRITE_PROTECT:
				__WINQAPI_CONT_ERROR(( TAPE_API_ERROR, StrAPI.operator mxTCHAR*(), _T( "The media is write protected." ), 0 ));
				break;				
			default:
				__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, StrAPI.operator mxTCHAR*(), 0 ));
				break;
			}
		}
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::CreateTapePartition( HANDLE hDevice, DWORD dwPartitionMethod, DWORD dwCount, DWORD dwSize )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateTapePartition" );
		DWORD dwResult = ::CreateTapePartition( hDevice, dwPartitionMethod, dwCount, dwSize );
		TapeAPIResult( _T( "CreateTapePartition" ), dwResult );
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::EraseTape( HANDLE hDevice, DWORD dwEraseType, BOOL bImmediate )
	{
		_WINQ_SFCONTEXT( "CKernel32::EraseTape" );
		DWORD dwResult = ::EraseTape( hDevice, dwEraseType, bImmediate );
		TapeAPIResult( _T( "EraseTape" ), dwResult );
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::GetTapeParameters( HANDLE hDevice, DWORD dwOperation, LPDWORD lpdwSize, void* lpTapeInformation )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetTapeParameters" );
		DWORD dwResult = ::GetTapeParameters( hDevice, dwOperation, lpdwSize, lpTapeInformation );
		TapeAPIResult( _T( "GetTapeParameters" ), dwResult );
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::GetTapePosition( HANDLE hDevice, DWORD dwPositionType, LPDWORD lpdwPartition, LPDWORD lpdwOffsetLow, LPDWORD lpdwOffsetHigh )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetTapePosition" );
		DWORD dwResult = ::GetTapePosition( hDevice, dwPositionType, lpdwPartition, lpdwOffsetLow, lpdwOffsetHigh );
		TapeAPIResult( _T( "GetTapePosition" ), dwResult );
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::GetTapeStatus( HANDLE hDevice )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetTapeStatus" );
		DWORD dwResult = ::GetTapeStatus( hDevice );
		TapeAPIResult( _T( "GetTapeStatus" ), dwResult );
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::PrepareTape( HANDLE hDevice, DWORD dwOperation, BOOL bImmediate )
	{
		_WINQ_SFCONTEXT( "CKernel32::PrepareTape" );
		DWORD dwResult = ::PrepareTape( hDevice, dwOperation, bImmediate );
		TapeAPIResult( _T( "PrepareTape" ), dwResult );
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::SetTapeParameters( HANDLE hDevice, DWORD dwOperation, void* lpTapeInformation )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetTapeParameters" );
		DWORD dwResult = ::SetTapeParameters( hDevice, dwOperation, lpTapeInformation );
		TapeAPIResult( _T( "SetTapeParameters" ), dwResult );
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::SetTapePosition( HANDLE hDevice, DWORD dwPositionMethod, DWORD dwPartition, DWORD dwOffsetLow, DWORD dwOffsetHigh, BOOL bImmediate )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetTapePosition" );
		DWORD dwResult = ::SetTapePosition( hDevice, dwPositionMethod, dwPartition, dwOffsetLow, dwOffsetHigh, bImmediate );
		TapeAPIResult( _T( "SetTapePosition" ), dwResult );
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	DWORD CKernel32::WriteTapemark( HANDLE hDevice, DWORD dwTapemarkType, DWORD dwTapemarkCount, BOOL bImmediate )
	{
		_WINQ_SFCONTEXT( "CKernel32::WriteTapemark" );
		DWORD dwResult = ::WriteTapemark( hDevice, dwTapemarkType, dwTapemarkCount, bImmediate );
		TapeAPIResult( _T( "WriteTapemark" ), dwResult );
		return dwResult;
	}

}//nsWinQAPI

