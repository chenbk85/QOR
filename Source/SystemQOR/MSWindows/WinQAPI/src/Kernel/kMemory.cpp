//kMemory.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQAPI/Kernel32.h"
#include "../SystemQOR/MSWindows/WinQAPI/include/ReturnCheck.h"

#define QOR_HEAP_TRACK 0

//--------------------------------------------------------------------------------
namespace
{
	Cmp_unsigned_long_long g_ullWin32MemoryCount = 0;
	TCHAR szMemoryMessage[ 512 ];
}

//--------------------------------------------------------------------------------
namespace nsWinQAPI
{
	//--------------------------------------------------------------------------------
	SIZE_T CKernel32::RtlCompareMemory( CONST VOID* Source1, CONST VOID* Source2, SIZE_T Length )
	{
		_WINQ_SFCONTEXT( "CKernel32::RtlCompareMemory" );
		SIZE_T Result = 0;
#	if ( WINVER >= 0x0501 )
		Result = 0;//::RtlCompareMemory( Source1, Source2, Length );
#	else
		QOR_PP_UNREF3( Length, Source2, Source1 );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "RtlCompareMemory" ), _T( "Windows XP" ), 0 ));
#	endif
		return Result;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::AddSecureMemoryCacheCallback( PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack )
	{
		_WINQ_SFCONTEXT( "CKernel32::AddSecureMemoryCacheCallback" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "AddSecureMemoryCacheCallback" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 && NTDDI_VERSION >= NTDDI_VISTASP1 )
		bResult = ::AddSecureMemoryCacheCallback( pfnCallBack );
#	else
		QOR_PP_UNREF( pfnCallBack );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "AddSecureMemoryCacheCallback" ), _T( "Windows Vista Service Pack 1" ), 0 ));
#	endif
#endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::AllocateUserPhysicalPages( HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray )
	{
		_WINQ_SFCONTEXT( "CKernel32::AllocateUserPhysicalPages" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0500 )
		bResult = ::AllocateUserPhysicalPages( hProcess, NumberOfPages, UserPfnArray );
#	else
		QOR_PP_UNREF3( UserPfnArray, NumberOfPages, hProcess );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "AllocateUserPhysicalPages" ), _T( "Windows 2000" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::AllocateUserPhysicalPagesNuma( HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray, DWORD nndPreferred )
	{
		_WINQ_SFCONTEXT( "CKernel32::AllocateUserPhysicalPagesNuma" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "AllocateUserPhysicalPagesNuma" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		bResult = ::AllocateUserPhysicalPagesNuma( hProcess, NumberOfPages, PageArray, nndPreferred );
#	else
		QOR_PP_UNREF4( nndPreferred, PageArray, NumberOfPages, hProcess );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "AllocateUserPhysicalPagesNuma" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	VOID CKernel32::mxRtlCopyMemory( VOID* Destination, CONST VOID* Source, SIZE_T Length )
	{
		_WINQ_SFCONTEXT( "CKernel32::mxRtlCopyMemory" );
		::RtlCopyMemory( Destination, Source, Length );
	}

	//--------------------------------------------------------------------------------
	HANDLE CKernel32::CreateFileMapping( HANDLE hFile, ::LPSECURITY_ATTRIBUTES lpAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCTSTR lpName )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateFileMapping" );
		CCheckReturn< HANDLE, CHandleNullCheck< > >::TType h;
		h = ::CreateFileMapping( hFile, lpAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName );
		return h;
	}

	//--------------------------------------------------------------------------------
	HANDLE CKernel32::CreateFileMappingNuma( HANDLE hFile, ::LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCTSTR lpName, DWORD nndPreferred )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateFileMappingNuma" );
		CCheckReturn< HANDLE, CHandleNullCheck< > >::TType h;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "CreateFileMappingNuma" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		h = ::CreateFileMappingNuma( hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName, nndPreferred );
#	else
		QOR_PP_UNREF7( nndPreferred, lpName, dwMaximumSizeLow, dwMaximumSizeHigh, flProtect, lpFileMappingAttributes, hFile );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CreateFileMappingNuma" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
		return h;
	}

	//--------------------------------------------------------------------------------
	HANDLE CKernel32::CreateMemoryResourceNotification( ::MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType )
	{
		_WINQ_SFCONTEXT( "CKernel32::CreateMemoryResourceNotification" );
		CCheckReturn< HANDLE, CHandleNullCheck< > >::TType h;
#	if ( _WIN32_WINNT >= 0x0501 )
		h = ::CreateMemoryResourceNotification( NotificationType );
#	else
		QOR_PP_UNREF( NotificationType );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "CreateMemoryResourceNotification" ), _T( "Windows XP" ), 0 ));
#	endif
		return h;
	}

	//--------------------------------------------------------------------------------
	void CKernel32::mxFillMemory( PVOID Destination, SIZE_T Length, BYTE Fill )
	{
		_WINQ_SFCONTEXT( "CKernel32::mxFillMemory" );
		::RtlFillMemory( Destination, Length, Fill );
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::FlushViewOfFile( LPCVOID lpBaseAddress, SIZE_T dwNumberOfBytesToFlush )
	{
		_WINQ_SFCONTEXT( "CKernel32::FlushViewOfFile" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
		bResult = ::FlushViewOfFile( lpBaseAddress, dwNumberOfBytesToFlush );
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::FreeUserPhysicalPages( HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray )
	{
		_WINQ_SFCONTEXT( "CKernel32::FreeUserPhysicalPages" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0500 )
		bResult = ::FreeUserPhysicalPages( hProcess, NumberOfPages, UserPfnArray );
#	else
		QOR_PP_UNREF3( UserPfnArray, NumberOfPages, hProcess );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "FreeUserPhysicalPages" ), _T( "Windows 2000" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	SIZE_T CKernel32::GetLargePageMinimum(void)
	{
		_WINQ_SFCONTEXT( "CKernel32::GetLargePageMinimum" );
		SIZE_T Result = 0;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "GetLargePageMinimum" ), 0 ));		
#else
#	if ( _WIN32_WINNT >= 0x0502 )
		Result = ::GetLargePageMinimum();
		if( Result == 0 )
		{
			__WINQAPI_WARNING(( RESULT_INDICATES_UNSUPPORTED_FEATURE, _T( "GetLargePageMinimum" ), 0 ));
		}
#	else
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "GetLargePageMinimum" ), _T( "Windows Server 2003" ), 0 ));
#	endif
#endif
		return Result;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::GetPhysicallyInstalledSystemMemory( PULONGLONG TotalMemoryInKilobytes )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetPhysicallyInstalledSystemMemory" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "GetPhysicallyInstalledSystemMemory" ), 0 ));
#else

#	if ( _WIN32_WINNT >= 0x0600 && NTDDI_VERSION >= NTDDI_VISTASP1 )
		bResult = ::GetPhysicallyInstalledSystemMemory( TotalMemoryInKilobytes );
#	else
		QOR_PP_UNREF( TotalMemoryInKilobytes );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "GetPhysicallyInstalledSystemMemory" ), _T( "Windows Vista Service Pack 1" ), 0 ));
#	endif
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::GetProcessDEPPolicy( HANDLE hProcess, LPDWORD lpFlags, PBOOL lpPermanent )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetProcessDEPPolicy" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0600 && NTDDI_VERSION >= NTDDI_VISTASP1 )
		bResult = ::GetProcessDEPPolicy( hProcess, lpFlags, lpPermanent );
#	else
		QOR_PP_UNREF3( lpPermanent, lpFlags, hProcess );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "GetProcessDEPPolicy" ), _T( "Windows Vista Service Pack 1" ), 0 ));
#	endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	HANDLE CKernel32::GetProcessHeap(void)
	{
		_WINQ_SFCONTEXT( "CKernel32::GetProcessHeap" );
		CCheckReturn< HANDLE, CHandleNullCheck< > >::TType h;
		h = ::GetProcessHeap();
		return h;
	}

	//------------------------------------------------------------------------------
	DWORD CKernel32::GetProcessHeaps( DWORD NumberOfHeaps, PHANDLE ProcessHeaps )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetProcessHeaps" );
		CCheckReturn< DWORD, CCheckNonZero< DWORD > >::TType dwResult;
#	if ( _WIN32_WINNT > 0x0400 )//NT4
		dwResult = ::GetProcessHeaps( NumberOfHeaps, ProcessHeaps );
#	else
		QOR_PP_UNREF2( ProcessHeaps, NumberOfHeaps );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "GetProcessHeaps" ), _T( "Windows NT 4.0" ), 0 ));
#	endif
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	DEP_SYSTEM_POLICY_TYPE CKernel32::GetSystemDEPPolicy(void)
	{
		_WINQ_SFCONTEXT( "CKernel32::GetSystemDEPPolicy" );
		/*Really screwed up under MinGW
#   ifdef __MINGW32__
		DEP_SYSTEM_POLICY_TYPE Result = AlwaysOff;
#   else
		DEP_SYSTEM_POLICY_TYPE Result = DEPPolicyAlwaysOff;
#   endif
#	if ( _WIN32_WINNT >= 0x0600 && NTDDI_VERSION >= NTDDI_VISTASP1 )
		Result = ::GetSystemDEPPolicy();
#	else
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "GetProcessHeaps" ), _T( "Windows Vista Service Pack 1" ), 0 ));
#	endif
		return Result;
		*/
		DEP_SYSTEM_POLICY_TYPE Result = (DEP_SYSTEM_POLICY_TYPE)1;
		return Result;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::GetSystemFileCacheSize( PSIZE_T lpMinimumFileCacheSize, PSIZE_T lpMaximumFileCacheSize, PDWORD lpFlags )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetSystemFileCacheSize" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "GetSystemFileCacheSize" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0502 )
		bResult = ::GetSystemFileCacheSize( lpMinimumFileCacheSize, lpMaximumFileCacheSize, lpFlags );
#	else
		QOR_PP_UNREF3( lpFlags, lpMaximumFileCacheSize, lpMinimumFileCacheSize );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "GetSystemFileCacheSize" ), _T( "Windows Server 2003" ), 0 ));
#	endif
#endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	UINT CKernel32::GetWriteWatch( DWORD dwFlags, PVOID lpBaseAddress, SIZE_T dwRegionSize, PVOID* lpAddresses, PULONG_PTR lpdwCount, PULONG lpdwGranularity )
	{
		_WINQ_SFCONTEXT( "CKernel32::GetWriteWatch" );
		CCheckReturn< UINT, CTSuccessCheck< UINT > >::TType uiResult;
		uiResult = ::GetWriteWatch( dwFlags, lpBaseAddress, dwRegionSize, lpAddresses, lpdwCount, lpdwGranularity );
		return uiResult;
	}

	//------------------------------------------------------------------------------
	HGLOBAL CKernel32::GlobalAlloc( UINT uFlags, SIZE_T dwBytes )
	{
		_WINQ_SFCONTEXT( "CKernel32::GlobalAlloc" );
		CCheckReturn< HGLOBAL, CCheckNonZero< HGLOBAL > >::TType h;
		h = ::GlobalAlloc( uFlags, dwBytes );
		return h;
	}

	//------------------------------------------------------------------------------
	UINT CKernel32::GlobalFlags( HGLOBAL hMem )
	{
		_WINQ_SFCONTEXT( "CKernel32::GlobalFlags" );
		CCheckReturn< UINT, CTCheckFailureValue< UINT, GMEM_INVALID_HANDLE > >::TType uiResult;
		uiResult = ::GlobalFlags( hMem );
		return uiResult;
	}

	//------------------------------------------------------------------------------
	HGLOBAL CKernel32::GlobalFree( HGLOBAL hMem )
	{
		_WINQ_SFCONTEXT( "CKernel32::GlobalFree" );
		HGLOBAL h = ::GlobalFree( hMem );
		if( h == hMem )
		{
			__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, _T( "GlobalFree" ), 0 ));
		}
		return h;
	}

	//------------------------------------------------------------------------------
	HGLOBAL CKernel32::GlobalHandle( LPCVOID pMem )
	{
		_WINQ_SFCONTEXT( "CKernel32::GlobalHandle" );
		CCheckReturn< HGLOBAL, CCheckNonZero< HGLOBAL > >::TType h = ::GlobalHandle( pMem );
		return h;
	}

	//------------------------------------------------------------------------------
	void* CKernel32::GlobalLock( HGLOBAL hMem )
	{
		_WINQ_SFCONTEXT( "CKernel32::GlobalLock" );
		CCheckReturn< void*, CCheckNonZero< void* > >::TType pResult = ::GlobalLock( hMem );
		return pResult;
	}

	//------------------------------------------------------------------------------
	//[GlobalMemoryStatus can return incorrect information. Use the GlobalMemoryStatusEx function instead. ]
	void CKernel32::GlobalMemoryStatus( LPMEMORYSTATUS lpBuffer )
	{
		_WINQ_SFCONTEXT( "CKernel32::GlobalMemoryStatus" );
		__WINQAPI_WARNING(( UNRELIABLE_API, _T( "GlobalMemoryStatus" ), 0 ));
		::GlobalMemoryStatus( lpBuffer );
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::GlobalMemoryStatusEx( ::LPMEMORYSTATUSEX lpBuffer )
	{
		_WINQ_SFCONTEXT( "CKernel32::GlobalMemoryStatusEx" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::GlobalMemoryStatusEx( lpBuffer );
		return bResult;
	}

	//------------------------------------------------------------------------------
	HGLOBAL CKernel32::GlobalReAlloc( HGLOBAL hMem, SIZE_T dwBytes, UINT uFlags )
	{
		_WINQ_SFCONTEXT( "CKernel32::GlobalReAlloc" );
		CCheckReturn< HGLOBAL, CCheckNonZero< HGLOBAL > >::TType h = ::GlobalReAlloc( hMem, dwBytes, uFlags );
		return h;
	}

	//------------------------------------------------------------------------------
	SIZE_T CKernel32::GlobalSize( HGLOBAL hMem )
	{
		_WINQ_SFCONTEXT( "CKernel32::GlobalSize" );
		CCheckReturn< SIZE_T, CCheckNonZero< SIZE_T > >::TType Result = ::GlobalSize( hMem );
		return Result;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::GlobalUnlock( HGLOBAL hMem )
	{
		_WINQ_SFCONTEXT( "CKernel32::GlobalUnlock" );
		BOOL bResult = ::GlobalUnlock( hMem );
		if( bResult == FALSE )
		{
			DWORD dwError = CKernel32::GetLastError();
			if( dwError != NO_ERROR )
			{
				__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, _T( "GlobalUnlock" ), 0 ));
			}
		}
		return bResult;
	}

	//------------------------------------------------------------------------------
	void* CKernel32::HeapAlloc( HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes )
	{
		_WINQ_SFCONTEXT( "CKernel32::HeapAlloc" );
		CCheckReturn< void*, CCheckNonZero< void* > >::TType pResult = ::HeapAlloc( hHeap, dwFlags, dwBytes );
#if QOR_HEAP_TRACK
		g_ullWin32MemoryCount += dwBytes;
		::FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY , "Allocate 0x%1!X! - ", 0, 0, szMemoryMessage, 512, (va_list*)(&pResult) );		
		::OutputDebugString( szMemoryMessage );		
		::FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY , "Heap size now %1!u!\n", 0, 0, szMemoryMessage, 512, (va_list*)(&g_ullWin32MemoryCount) );		
		::OutputDebugString( szMemoryMessage );
#endif
		return pResult;
	}

	//------------------------------------------------------------------------------
	SIZE_T CKernel32::HeapCompact( HANDLE hHeap, DWORD dwFlags )
	{
		_WINQ_SFCONTEXT( "CKernel32::HeapCompact" );
		SIZE_T Result = 0;
#	if ( _WIN32_WINNT >= 0x0400 )
		Result = ::HeapCompact( hHeap, dwFlags );
		if( Result == 0 )
		{
			DWORD dwError = CKernel32::GetLastError();
			if( dwError != NO_ERROR )
			{
				__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, _T( "HeapCompact" ), 0 ));
			}
		}
#	else
		QOR_PP_UNREF2( dwFlags, hHeap );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "HeapCompact" ), _T( "Windows NT 4.0" ), 0 ));
#	endif
		return Result;
	}

	//------------------------------------------------------------------------------
	HANDLE CKernel32::HeapCreate( DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize )
	{
		_WINQ_SFCONTEXT( "CKernel32::HeapCreate" );
		CCheckReturn< HANDLE, CHandleNullCheck< > >::TType h = ::HeapCreate( flOptions, dwInitialSize, dwMaximumSize );
		return h;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::HeapDestroy( HANDLE hHeap )
	{
		_WINQ_SFCONTEXT( "CKernel32::HeapDestroy" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::HeapDestroy( hHeap );
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::HeapFree( HANDLE hHeap, DWORD dwFlags, void* lpMem )
	{
		_WINQ_SFCONTEXT( "CKernel32::HeapFree" );
#if QOR_HEAP_TRACK
		SIZE_T dwBytes = HeapSize( hHeap, dwFlags, lpMem );
#endif
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::HeapFree( hHeap, dwFlags, lpMem );
#if QOR_HEAP_TRACK
		g_ullWin32MemoryCount -= dwBytes;
		::FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY , "Free 0x%1!X! - ", 0, 0, szMemoryMessage, 512, (va_list*)(&lpMem) );		
		::OutputDebugString( szMemoryMessage );
		::FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY , "Heap size now %1!u!\n", 0, 0, szMemoryMessage, 512, (va_list*)(&g_ullWin32MemoryCount) );		
		::OutputDebugString( szMemoryMessage );
#endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::HeapLock( HANDLE hHeap )
	{
		_WINQ_SFCONTEXT( "CKernel32::HeapLock" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0400 )
		bResult = ::HeapLock( hHeap );
#	else
		QOR_PP_UNREF( hHeap );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "HeapLock" ), _T( "Windows NT 4.0" ), 0 ));
#	endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::HeapQueryInformation ( PVOID HeapHandle, ::HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength, PSIZE_T ReturnLength )
	{
		_WINQ_SFCONTEXT( "CKernel32::HeapQueryInformation" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0501 )
		bResult = ::HeapQueryInformation( HeapHandle, HeapInformationClass, HeapInformation, HeapInformationLength, ReturnLength );
#	else
		QOR_PP_UNREF5( ReturnLength, HeapInformationLength, HeapInformation, HeapInformationClass, HeapHandle );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "HeapQueryInformation" ), _T( "Windows XP" ), 0 ));
#	endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	LPVOID CKernel32::HeapReAlloc( HANDLE hHeap, DWORD dwFlags, void* lpMem, SIZE_T dwBytes )
	{
		_WINQ_SFCONTEXT( "CKernel32::HeapReAlloc" );
		CCheckReturn< LPVOID, CCheckNonZero< LPVOID > >::TType pResult = ::HeapReAlloc( hHeap, dwFlags, lpMem, dwBytes );
		return pResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::HeapSetInformation( PVOID HeapHandle, ::HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength )
	{
		_WINQ_SFCONTEXT( "CKernel32::HeapSetInformation" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0501 )
		bResult = ::HeapSetInformation( HeapHandle, HeapInformationClass, HeapInformation, HeapInformationLength );
#	else
		QOR_PP_UNREF4( HeapInformationLength, HeapInformation, HeapInformationClass, HeapHandle );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "HeapSetInformation" ), _T( "Windows XP" ), 0 ));
#	endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	SIZE_T CKernel32::HeapSize( HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem )
	{
		_WINQ_SFCONTEXT( "CKernel32::HeapSize" );
		CCheckReturn< SIZE_T, CTCheckFailureValue< SIZE_T, (SIZE_T)(-1) > >::TType Result = ::HeapSize( hHeap, dwFlags, lpMem );
		return Result;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::HeapUnlock( HANDLE hHeap )
	{
		_WINQ_SFCONTEXT( "CKernel32::HeapUnlock" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0400 )
		bResult = ::HeapUnlock( hHeap );
#	else
		QOR_PP_UNREF( hHeap );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "HeapUnlock" ), _T( "Windows NT 4.0" ), 0 ));
#	endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::HeapValidate( HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem )
	{
		_WINQ_SFCONTEXT( "CKernel32::HeapValidate" );
		BOOL bResult;
#	if ( _WIN32_WINNT >= 0x0400 )
		bResult = ::HeapValidate( hHeap, dwFlags, lpMem );
#	else
		QOR_PP_UNREF( lpMem, dwFlags, hHeap );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "HeapValidate" ), _T( "Windows NT 4.0" ), 0 ));
#	endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::HeapWalk( HANDLE hHeap, ::LPPROCESS_HEAP_ENTRY lpEntry )
	{
		_WINQ_SFCONTEXT( "CKernel32::HeapWalk" );
		BOOL bResult = FALSE;
#	if ( _WIN32_WINNT >= 0x0400 )
		bResult = ::HeapWalk( hHeap, lpEntry );
		if( bResult == FALSE )
		{
			DWORD dwError = CKernel32::GetLastError();
			if( dwError != ERROR_NO_MORE_ITEMS )
			{
				__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, _T( "HeapWalk" ), 0 ));
			}
		}
#	else
		QOR_PP_UNREF( hHeap, lpEntry );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "HeapWalk" ), _T( "Windows NT 4.0" ), 0 ));
#	endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::IsBadCodePtr( FARPROC lpfn )
	{
		_WINQ_SFCONTEXT( "CKernel32::IsBadCodePtr" );
		return ::IsBadCodePtr( lpfn );
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::IsBadReadPtr( const VOID* lp, UINT_PTR ucb )
	{
		_WINQ_SFCONTEXT( "CKernel32::IsBadReadPtr" );
		return ::IsBadReadPtr( lp, ucb );
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::IsBadStringPtr( LPCTSTR lpsz, UINT_PTR ucchMax )
	{
		_WINQ_SFCONTEXT( "CKernel32::IsBadStringPtr" );
		return ::IsBadStringPtr( lpsz, ucchMax );
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::IsBadWritePtr( void* lp, UINT_PTR ucb )
	{
		_WINQ_SFCONTEXT( "CKernel32::IsBadWritePtr" );
		return ::IsBadWritePtr( lp, ucb );
	}

	//------------------------------------------------------------------------------
	HLOCAL CKernel32::LocalAlloc( UINT uFlags, SIZE_T uBytes )
	{
		_WINQ_SFCONTEXT( "CKernel32::LocalAlloc" );
		CCheckReturn< HLOCAL, CCheckNonZero< HLOCAL > >::TType h = ::LocalAlloc( uFlags, uBytes );
		return h;
	}

	//------------------------------------------------------------------------------
	UINT CKernel32::LocalFlags( HLOCAL hMem )
	{
		_WINQ_SFCONTEXT( "CKernel32::LocalFlags" );
		CCheckReturn< UINT, CTCheckFailureValue< UINT, LMEM_INVALID_HANDLE > >::TType uiResult = ::LocalFlags( hMem );
		return uiResult;
	}

	//------------------------------------------------------------------------------
	HLOCAL CKernel32::LocalFree( HLOCAL hMem )
	{
		_WINQ_SFCONTEXT( "CKernel32::LocalFree" );
		HLOCAL h = ::LocalFree( hMem );
		if( h == hMem )
		{
			__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, _T( "LocalFree" ), 0 ));
		}
		return h;
	}

	//------------------------------------------------------------------------------
	HLOCAL CKernel32::LocalHandle( LPCVOID pMem )
	{
		_WINQ_SFCONTEXT( "CKernel32::LocalHandle" );
		CCheckReturn< HLOCAL, CCheckNonZero< HLOCAL > >::TType h = ::LocalHandle( pMem );
		return h;
	}

	//------------------------------------------------------------------------------
	void* CKernel32::LocalLock( HLOCAL hMem )
	{
		_WINQ_SFCONTEXT( "CKernel32::LocalLock" );
		CCheckReturn< void*, CCheckNonZero< void* > >::TType pResult = ::LocalLock( hMem );
		return pResult;
	}

	//------------------------------------------------------------------------------
	HLOCAL CKernel32::LocalReAlloc( HLOCAL hMem, SIZE_T uBytes, UINT uFlags)
	{
		_WINQ_SFCONTEXT( "CKernel32::LocalReAlloc" );
		CCheckReturn< HLOCAL, CCheckNonZero< HLOCAL > >::TType h = ::LocalReAlloc( hMem, uBytes, uFlags );
		return h;
	}

	//------------------------------------------------------------------------------
	SIZE_T CKernel32::LocalSize( HLOCAL hMem )
	{
		_WINQ_SFCONTEXT( "CKernel32::LocalSize" );
		CCheckReturn< SIZE_T, CCheckNonZero< SIZE_T > >::TType Result = ::LocalSize( hMem );
		return Result;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::LocalUnlock( HLOCAL hMem )
	{
		_WINQ_SFCONTEXT( "CKernel32::LocalUnlock" );
		BOOL bResult = FALSE;
		bResult = ::LocalUnlock( hMem );
		if( bResult == FALSE )
		{
			DWORD dwError = CKernel32::GetLastError();
			if( dwError != NO_ERROR )
			{
				__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, _T( "LocalUnlock" ), 0 ));
			}
		}
		return bResult;
	}

	//--------------------------------------------------------------------------------
	void* CKernel32::MapViewOfFile( HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap )
	{
		_WINQ_SFCONTEXT( "CKernel32::MapViewOfFile" );
		CCheckReturn< void*, CCheckNonZero< void* > >::TType pResult = ::MapViewOfFile( hFileMappingObject, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap );
		return pResult;
	}

	//--------------------------------------------------------------------------------
	void* CKernel32::MapViewOfFileEx( HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, void* lpBaseAddress )
	{
		_WINQ_SFCONTEXT( "CKernel32::MapViewOfFileEx" );
		CCheckReturn< void*, CCheckNonZero< void* > >::TType pResult = ::MapViewOfFileEx( hFileMappingObject, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap, lpBaseAddress );
		return pResult;
	}

	//--------------------------------------------------------------------------------
	LPVOID CKernel32::MapViewOfFileExNuma( HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress, DWORD nndPreferred )
	{
		_WINQ_SFCONTEXT( "CKernel32::MapViewOfFileExNuma" );
		CCheckReturn< LPVOID, CCheckNonZero< LPVOID > >::TType pResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "MapViewOfFileExNuma" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		pResult = ::MapViewOfFileExNuma( hFileMappingObject, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap, lpBaseAddress, nndPreferred );
#	else
		QOR_PP_UNREF7( nndPreferred, lpBaseAddress, dwNumberOfBytesToMap, dwFileOffsetLow, dwFileOffsetHigh, dwDesiredAccess, hFileMappingObject );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "MapViewOfFileExNuma" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
		return pResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::MapUserPhysicalPages( PVOID lpAddress, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray )
	{
		_WINQ_SFCONTEXT( "CKernel32::MapUserPhysicalPages" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0500 )//Win2K
		bResult = ::MapUserPhysicalPages( lpAddress, NumberOfPages, UserPfnArray );
#	else
		QOR_PP_UNREF3( UserPfnArray, NumberOfPages, lpAddress );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "MapUserPhysicalPages" ), _T( "Windows 2000" ), 0 ));
#	endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::MapUserPhysicalPagesScatter( PVOID* VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR PageArray )
	{
		_WINQ_SFCONTEXT( "CKernel32::MapUserPhysicalPagesScatter" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0500 )
		bResult = ::MapUserPhysicalPagesScatter( VirtualAddresses, NumberOfPages, PageArray );
#else
		QOR_PP_UNREF3( PageArray, NumberOfPages, VirtualAddresses );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "MapUserPhysicalPagesScatter" ), _T( "Windows 2000" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	void CKernel32::mxMoveMemory( PVOID Destination, const VOID* Source, SIZE_T Length )
	{
		_WINQ_SFCONTEXT( "CKernel32::mxMoveMemory" );
		::RtlMoveMemory( Destination, Source, Length );
	}

	//--------------------------------------------------------------------------------
	HANDLE CKernel32::OpenFileMapping( DWORD dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName )
	{
		_WINQ_SFCONTEXT( "CKernel32::OpenFileMapping" );
		CCheckReturn< HANDLE, CHandleNullCheck< > >::TType h = ::OpenFileMapping( dwDesiredAccess, bInheritHandle, lpName );
		return h;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::QueryMemoryResourceNotification( HANDLE ResourceNotificationHandle, PBOOL ResourceState )
	{
		_WINQ_SFCONTEXT( "CKernel32::QueryMemoryResourceNotification" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if( _WIN32_WINNT >= 0x0501 )
		bResult = ::QueryMemoryResourceNotification( ResourceNotificationHandle, ResourceState );
#	else
		QOR_PP_UNREF2( ResourceState, ResourceNotificationHandle );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "QueryMemoryResourceNotification" ), _T( "Windows XP" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::RemoveSecureMemoryCacheCallback( PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack )
	{
		_WINQ_SFCONTEXT( "CKernel32::RemoveSecureMemoryCacheCallback" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "RemoveSecureMemoryCacheCallback" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 && NTDDI_VERSION >= NTDDI_VISTASP1 )
		bResult = ::RemoveSecureMemoryCacheCallback( pfnCallBack );
#	else
		QOR_PP_UNREF( pfnCallBack );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "RemoveSecureMemoryCacheCallback" ), _T( "Windows Vista Service Pack 1" ), 0 ));
#	endif
#endif
		return bResult;
	}

	//------------------------------------------------------------------------------
	UINT CKernel32::ResetWriteWatch( void* lpBaseAddress, SIZE_T dwRegionSize )
	{
		_WINQ_SFCONTEXT( "CKernel32::ResetWriteWatch" );
		CCheckReturn< UINT, CTSuccessCheck< UINT > >::TType uiResult = ::ResetWriteWatch( lpBaseAddress, dwRegionSize );
		return uiResult;
	}

	//------------------------------------------------------------------------------
	PVOID CKernel32::mxSecureZeroMemory( PVOID ptr, SIZE_T cnt )
	{
		_WINQ_SFCONTEXT( "CKernel32::mxSecureZeroMemory" );
		PVOID pResult = ::RtlSecureZeroMemory( ptr, cnt );
		if( pResult != ptr )
		{
			__WINQAPI_CONT_ERROR(( GENERAL_API_ERROR, _T( "RtlSecureZeroMemory" ), 0 ));
		}
		return pResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::SetProcessDEPPolicy( DWORD dwFlags )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetProcessDEPPolicy" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#	if ( _WIN32_WINNT >= 0x0600 && NTDDI_VERSION >= NTDDI_VISTASP1 )
		bResult = ::SetProcessDEPPolicy( dwFlags );
#	else
		QOR_PP_UNREF( dwFlags );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SetProcessDEPPolicy" ), _T( "Windows Vista Service Pack 1" ), 0 ));
#	endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::SetSystemFileCacheSize( SIZE_T MinimumFileCacheSize, SIZE_T MaximumFileCacheSize, DWORD Flags )
	{
		_WINQ_SFCONTEXT( "CKernel32::SetSystemFileCacheSize" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "SetSystemFileCacheSize" ), 0 ));
#else
		//Client Requires Windows XP Professional x64 Edition.
		//Server Requires Windows Server 2003 SP1.
#	if ( _WIN32_WINNT >= 0x0502 )
		bResult = ::SetSystemFileCacheSize( MinimumFileCacheSize, MaximumFileCacheSize, Flags );
#	else
		QOR_PP_UNREF3( Flags, MaximumFileCacheSize, MinimumFileCacheSize );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "SetSystemFileCacheSize" ), _T( "Windows Server 2003" ), 0 ));
#	endif
#endif
		return bResult;
	}

	//--------------------------------------------------------------------------------
	BOOL CKernel32::UnmapViewOfFile( LPCVOID lpBaseAddress )
	{
		_WINQ_SFCONTEXT( "CKernel32::UnmapViewOfFile" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::UnmapViewOfFile( lpBaseAddress );
		return bResult;
	}

	//------------------------------------------------------------------------------
	void* CKernel32::VirtualAlloc( void* lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect )
	{
		_WINQ_SFCONTEXT( "CKernel32::VirtualAlloc" );
		CCheckReturn< void*, CCheckNonZero< void* > >::TType pResult = ::VirtualAlloc( lpAddress, dwSize, flAllocationType, flProtect );
		return pResult;
	}

	//------------------------------------------------------------------------------
	void* CKernel32::VirtualAllocEx( HANDLE hProcess, void* lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect )
	{
		_WINQ_SFCONTEXT( "CKernel32::VirtualAllocEx" );
		CCheckReturn< void*, CCheckNonZero< void* > >::TType pResult = ::VirtualAllocEx( hProcess, lpAddress, dwSize, flAllocationType, flProtect );
		return pResult;
	}

	//--------------------------------------------------------------------------------
	LPVOID CKernel32::VirtualAllocExNuma( HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect, DWORD nndPreferred )
	{
		_WINQ_SFCONTEXT( "CKernel32::VirtualAllocExNuma" );
		CCheckReturn< LPVOID, CCheckNonZero< LPVOID > >::TType pResult;
#ifdef	__MINGW32__
		__WINQAPI_CONT_ERROR(( API_NOT_IN_MINGW32, _T( "VirtualAllocExNuma" ), 0 ));
#else
#	if ( _WIN32_WINNT >= 0x0600 )
		pResult = ::VirtualAllocExNuma( hProcess, lpAddress, dwSize, flAllocationType, flProtect, nndPreferred );
#	else
		QOR_PP_UNREF6( nndPreferred, flProtect, flAllocationType, dwSize, lpAddress, hProcess );
		__WINQAPI_CONT_ERROR(( API_REQUIRES_VERSION, _T( "VirtualAllocExNuma" ), _T( "Windows Vista" ), 0 ));
#	endif
#endif
		return pResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::VirtualFree( void* lpAddress, SIZE_T dwSize, DWORD dwFreeType )
	{
		_WINQ_SFCONTEXT( "CKernel32::VirtualFree" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::VirtualFree( lpAddress, dwSize, dwFreeType );
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::VirtualFreeEx( HANDLE hProcess, void* lpAddress, SIZE_T dwSize, DWORD dwFreeType )
	{
		_WINQ_SFCONTEXT( "CKernel32::VirtualFreeEx" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::VirtualFreeEx( hProcess, lpAddress, dwSize, dwFreeType );
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::VirtualLock( void* lpAddress, SIZE_T dwSize )
	{
		_WINQ_SFCONTEXT( "CKernel32::VirtualLock" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::VirtualLock( lpAddress, dwSize );
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::VirtualProtect( void* lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect )
	{
		_WINQ_SFCONTEXT( "CKernel32::VirtualProtect" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::VirtualProtect( lpAddress, dwSize, flNewProtect, lpflOldProtect );
		return bResult;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::VirtualProtectEx( HANDLE hProcess, void* lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect )
	{
		_WINQ_SFCONTEXT( "CKernel32::VirtualProtectEx" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::VirtualProtectEx( hProcess, lpAddress, dwSize, flNewProtect, lpflOldProtect );
		return bResult;
	}

	//------------------------------------------------------------------------------
	SIZE_T CKernel32::VirtualQuery( LPCVOID lpAddress, ::PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength )
	{
		_WINQ_SFCONTEXT( "CKernel32::VirtualQuery" );
		CCheckReturn< SIZE_T, CCheckNonZero< SIZE_T > >::TType Result = ::VirtualQuery( lpAddress, lpBuffer, dwLength );
		return Result;
	}

	//------------------------------------------------------------------------------
	SIZE_T CKernel32::VirtualQueryEx( HANDLE hProcess, LPCVOID lpAddress, ::PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength )
	{
		_WINQ_SFCONTEXT( "CKernel32::VirtualQueryEx" );
		CCheckReturn< SIZE_T, CCheckNonZero< SIZE_T > >::TType Result = ::VirtualQueryEx( hProcess, lpAddress, lpBuffer, dwLength );
		return Result;
	}

	//------------------------------------------------------------------------------
	BOOL CKernel32::VirtualUnlock( void* lpAddress, SIZE_T dwSize )
	{
		_WINQ_SFCONTEXT( "CKernel32::VirtualUnlock" );
		CCheckReturn< BOOL, CBoolCheck< > >::TType bResult = ::VirtualUnlock( lpAddress, dwSize );
		return bResult;
	}

	//--------------------------------------------------------------------------------
	void CKernel32::mxZeroMemory( PVOID Destination, SIZE_T Length )
	{
		_WINQ_SFCONTEXT( "CKernel32::mxZeroMemory" );
		::RtlZeroMemory( Destination, Length );
	}

	//--------------------------------------------------------------------------------
	//This essentially cannot fail because it has no effect in 32 bit Windows
	SIZE_T CKernel32::LocalCompact( UINT uMinFree )
	{
		_WINQ_SFCONTEXT( "CKernel32::LocalCompact" );
		return ::LocalCompact( uMinFree );
	}

	//--------------------------------------------------------------------------------
	//This essentially cannot fail because it has no effect in 32 bit Windows
	SIZE_T CKernel32::LocalShrink( HLOCAL hMem, UINT cbNewSize )
	{
		_WINQ_SFCONTEXT( "CKernel32::LocalShrink" );
		return ::LocalShrink( hMem, cbNewSize );
	}

}//nsWinQAPI
