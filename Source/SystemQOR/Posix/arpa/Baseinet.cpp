//Baseinet.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "SystemQOR/Posix/arpa/Baseinet.h"
#include <errno.h>
#include <sys/socket.h>
#include "CodeQOR/Tracing/FunctionContextBase.h"

//--------------------------------------------------------------------------------
namespace nsBaseCRT
{
	__QOR_IMPLEMENT_OCLASS_LUID(Cinet);

	//--------------------------------------------------------------------------------
	Cinet::Cinet()
	{
		__QCS_FCONTEXT("Cinet::Cinet");
	}

	//--------------------------------------------------------------------------------
	Cinet::~Cinet()
	{
		__QCS_FCONTEXT("Cinet::~Cinet");
	}

	//--------------------------------------------------------------------------------
    uint32_t Cinet::htonl( uint32_t n )
	{
		__QCS_FCONTEXT("Cinet::htonl");
		union { int i; char c; } u = { 1 };
		return u.c ? __bswap_32(n) : n;
	}

	//--------------------------------------------------------------------------------
    uint16_t Cinet::htons( uint16_t n )
	{
		__QCS_FCONTEXT("Cinet::htons");
		union { int i; char c; } u = { 1 };
		return u.c ? __bswap_16(n) : n;
	}

	//--------------------------------------------------------------------------------
    uint32_t Cinet::ntohl( uint32_t n)
	{
		__QCS_FCONTEXT("Cinet::ntohl");
		union { int i; char c; } u = { 1 };
		return u.c ? __bswap_32(n) : n;
	}

	//--------------------------------------------------------------------------------
    uint16_t Cinet::ntohs( uint16_t n)
	{
		__QCS_FCONTEXT("Cinet::ntohs");
		union { int i; char c; } u = { 1 };
		return u.c ? __bswap_16(n) : n;
	}

	//--------------------------------------------------------------------------------
    char* Cinet::inet_ntoa( in_addr in )
	{
		__QCS_FCONTEXT("Cinet::inet_ntoa");
		static char buf[16];
		unsigned char* a = reinterpret_cast< unsigned char* >( &in );
		snprintf(buf, sizeof buf, "%d.%d.%d.%d", a[0], a[1], a[2], a[3]);
		return buf;
	}

	//--------------------------------------------------------------------------------
    const char* Cinet::inet_ntop( int af, const void* __QCMP_RESTRICT a0, char* __QCMP_RESTRICT s, socklen_t l )
	{
		__QCS_FCONTEXT("Cinet::inet_ntop");
		const unsigned char *a = reinterpret_cast< const unsigned char* >(a0);
		int i, j, max, best;
		char buf[100];

		switch (af)
		{
		case AF_INET:
			if (snprintf(s, l, "%d.%d.%d.%d", a[0], a[1], a[2], a[3]) < l)
				return s;
			break;
		case AF_INET6:
			if (memcmp(a, "\0\0\0\0\0\0\0\0\0\0\377\377", 12))
				snprintf(buf, sizeof buf,
				"%x:%x:%x:%x:%x:%x:%x:%x",
				256 * a[0] + a[1], 256 * a[2] + a[3],
				256 * a[4] + a[5], 256 * a[6] + a[7],
				256 * a[8] + a[9], 256 * a[10] + a[11],
				256 * a[12] + a[13], 256 * a[14] + a[15]);
			else
				snprintf(buf, sizeof buf,
				"%x:%x:%x:%x:%x:%x:%d.%d.%d.%d",
				256 * a[0] + a[1], 256 * a[2] + a[3],
				256 * a[4] + a[5], 256 * a[6] + a[7],
				256 * a[8] + a[9], 256 * a[10] + a[11],
				a[12], a[13], a[14], a[15]);
			/* Replace longest /(^0|:)[:0]{2,}/ with "::" */
			for (i = best = 0, max = 2; buf[i]; i++) {
				if (i && buf[i] != ':') continue;
				j = strspn(buf + i, ":0");
				if (j>max) best = i, max = j;
			}
			if (max>2) {
				buf[best] = buf[best + 1] = ':';
				memmove(buf + best + 2, buf + best + max, i - best - max + 1);
			}
			if (strlen(buf) < l) {
				strcpy(s, buf);
				return s;
			}
			break;
		default:
			errno = EAFNOSUPPORT;
			return 0;
		}
		errno = ENOSPC;
		return 0;
	}

	//--------------------------------------------------------------------------------
    int Cinet::inet_pton( int af, const char* __QCMP_RESTRICT s, void* __QCMP_RESTRICT a0)
	{
		__QCS_FCONTEXT("Cinet::inet_pton");
		uint16_t ip[8];
		unsigned char* a = reinterpret_cast< unsigned char* >(a0);
		int i, j, v, d, brk = -1, need_v4 = 0;

		if (af == AF_INET)
		{
			for (i = 0; i<4; i++)
			{
				for (v = j = 0; j < 3 && isdigit(s[j]); j++)
				{
					v = 10 * v + s[j] - '0';
				}
				if (j == 0 || (j>1 && s[0] == '0') || v > 255)
				{
					return 0;
				}
				a[i] = v;
				if (s[j] == 0 && i == 3)
				{
					return 1;
				}
				if (s[j] != '.')
				{
					return 0;
				}
				s += j + 1;
			}
			return 0;
		}
		else if (af != AF_INET6)
		{
			errno = EAFNOSUPPORT;
			return -1;
		}

		if (*s == ':' && *++s != ':')
		{
			return 0;
		}

		for (i = 0;; i++)
		{
			if( s[0] == ':' && brk<0)
			{
				brk = i;
				ip[i] = 0;
				if (!*++s) break;
				continue;
			}
			for (v = j = 0; j < 4 && (d = hexval(s[j])) >= 0; j++)
			{
				v = 16 * v + d;
			}
			if (j == 0)
			{
				return 0;
			}
			ip[i] = v;
			if (!s[j] && (brk >= 0 || i == 7))
			{
				break;
			}
			if (i == 7)
			{
				return 0;
			}
			if (s[j] != ':')
			{
				if (s[j] != '.' || (i < 6 && brk < 0))
				{
					return 0;
				}
				need_v4 = 1;
				i++;
				break;
			}
			s += j + 1;
		}
		if (brk >= 0)
		{
			memmove(ip + brk + 7 - i, ip + brk, 2 * (i + 1 - brk));
			for (j = 0; j < 7 - i; j++)
			{
				ip[brk + j] = 0;
			}
		}
		for (j = 0; j<8; j++)
		{
			*a++ = ip[j] >> 8;
			*a++ = ip[j];
		}
		if (need_v4 && inet_pton(AF_INET, s, a - 4) <= 0)
		{
			return 0;
		}
		return 1;
	}

	//--------------------------------------------------------------------------------
	int Cinet::hexval( unsigned c )
	{
		if (c - '0'<10) return c - '0';
		c |= 32;
		if (c - 'a'<6) return c - 'a' + 10;
		return -1;
	}

	//--------------------------------------------------------------------------------
	int Cinet::__aton(const char* s0, in_addr* dest)
	{
		const char* s = s0;
		unsigned char* d = reinterpret_cast< unsigned char* >( dest );
		unsigned long a[4] = { 0 };
		char *z;
		int i;

		for (i = 0; i<4; i++)
		{
			a[ i ] = strtoul( s, &z, 0 );
			if (z == s || (*z && *z != '.') || !isdigit(*s))
			{
				return 0;
			}
			if (!*z)
			{
				break;
			}
			s = z + 1;
		}
		if (i == 4)
		{
			return 0;
		}
		switch (i)
		{
		case 0:
			a[1] = a[0] & 0xffffff;
			a[0] >>= 24;
		case 1:
			a[2] = a[1] & 0xffff;
			a[1] >>= 16;
		case 2:
			a[3] = a[2] & 0xff;
			a[2] >>= 8;
		}

		for (i = 0; i<4; i++)
		{
			if (a[i] > 255)
			{
				return 0;
			}
			d[i] = a[i];
		}
		return 1;
	}

}//nsBaseCRT
