//Baseaio.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "SystemQOR/Posix/Baseaio.h"
#include <errno.h>
#include "CodeQOR/Tracing/FunctionContextBase.h"

//--------------------------------------------------------------------------------
namespace nsBaseCRT
{
	__QOR_IMPLEMENT_OCLASS_LUID(Caio);

	//--------------------------------------------------------------------------------
	Caio::Caio()
	{
		__QCS_MEMBER_FCONTEXT("Caio::Caio");
	}

	//--------------------------------------------------------------------------------
	Caio::~Caio()
	{
		__QCS_MEMBER_FCONTEXT("Caio::~Caio");
	}
	
	//--------------------------------------------------------------------------------
	//The aio_cancel() function shall attempt to cancel one or more asynchronous I/O requests currently outstanding against file descriptor fildes. The aiocbp argument points to the asynchronous I/O control block for a particular request to be canceled. If aiocbp is NULL, then all outstanding cancelable asynchronous I/O requests against fildes shall be canceled.
	//Normal asynchronous notification shall occur for asynchronous I/O operations that are successfully canceled. If there are requests that cannot be canceled, then the normal asynchronous completion process shall take place for those requests when they are completed.
	//For requested operations that are successfully canceled, the associated error status shall be set to [ECANCELED] and the return status shall be -1. For requested operations that are not successfully canceled, the aiocbp shall not be modified by aio_cancel().
	//If aiocbp is not NULL, then if fildes does not have the same value as the file descriptor with which the asynchronous operation was initiated, unspecified results occur.
	//Which operations are cancelable is implementation-defined.
	//
	//The aio_cancel() function shall return the value AIO_CANCELED if the requested operation(s) were canceled. The value AIO_NOTCANCELED shall be returned if at least one of the requested operation(s) cannot be canceled because it is in progress. In this case, the state of the other operations, if any, referenced in the call to aio_cancel() is not indicated by the return value of aio_cancel(). The application may determine the state of affairs for these operations by using aio_error(). The value AIO_ALLDONE is returned if all of the operations have already completed. Otherwise, the function shall return -1 and set errno to indicate the error.
	//
	//The aio_cancel() function shall fail if:
	//[EBADF] 
	//The fildes argument is not a valid file descriptor. 
    int Caio::cancel( int, aiocb* )
	{
		__QCS_MEMBER_FCONTEXT( "Caio::cancel" );
		errno = ENOSYS;
		return 0;
	}

	//--------------------------------------------------------------------------------
	//The aio_error() function shall return the error status associated with the aiocb structure referenced by the aiocbp argument. The error status for an asynchronous I/O operation is the errno value that would be set by the corresponding read(), write(), [SIO]  fdatasync(),  or fsync() operation. If the operation has not yet completed, then the error status shall be equal to [EINPROGRESS].
	//If the aiocb structure pointed to by aiocbp is not associated with an operation that has been scheduled, the results are undefined.
	//
	//If the asynchronous I/O operation has completed successfully, then 0 shall be returned. If the asynchronous operation has completed unsuccessfully, then the error status, as described for read(), write(), [SIO]  fdatasync(),  and fsync(), shall be returned. If the asynchronous I/O operation has not yet completed, then [EINPROGRESS] shall be returned.
	//If the aio_error() function fails, it shall return -1 and set errno to indicate the error.
	//
	//The aio_error() function may fail if:
	//[EINVAL] 
	//The aiocbp argument does not refer to an asynchronous operation whose return status has not yet been retrieved.
    int Caio::error( const aiocb* )
	{
		__QCS_MEMBER_FCONTEXT( "Caio::error" );
		errno = ENOSYS;
		return 0;
	}

	//--------------------------------------------------------------------------------
	//The aio_fsync() function shall asynchronously force all I/O operations associated with the file indicated by the file descriptor aio_fildes member of the aiocb structure referenced by the aiocbp argument and queued at the time of the call to aio_fsync() to the synchronized I/O completion state. The function call shall return when the synchronization request has been initiated or queued to the file or device (even when the data cannot be synchronized immediately).
	//If op is O_DSYNC, all currently queued I/O operations shall be completed as if by a call to fdatasync(); that is, as defined for synchronized I/O data integrity completion. If op is O_SYNC, all currently queued I/O operations shall be completed as if by a call to fsync(); that is, as defined for synchronized I/O file integrity completion. If the aio_fsync() function fails, or if the operation queued by aio_fsync() fails, then, as for fsync() and fdatasync(), outstanding I/O operations are not guaranteed to have been completed.
	//If aio_fsync() succeeds, then it is only the I/O that was queued at the time of the call to aio_fsync() that is guaranteed to be forced to the relevant completion state. The completion of subsequent I/O on the file descriptor is not guaranteed to be completed in a synchronized fashion.
	//The aiocbp argument refers to an asynchronous I/O control block. The aiocbp value may be used as an argument to aio_error() and aio_return() in order to determine the error status and return status, respectively, of the asynchronous operation while it is proceeding. When the request is queued, the error status for the operation is [EINPROGRESS]. When all data has been successfully transferred, the error status shall be reset to reflect the success or failure of the operation. If the operation does not complete successfully, the error status for the operation shall be set to indicate the error. The aio_sigevent member determines the asynchronous notification to occur as specified in Signal Generation and Delivery when all operations have achieved synchronized I/O completion. All other members of the structure referenced by aiocbp are ignored. If the control block referenced by aiocbp becomes an illegal address prior to asynchronous I/O completion, then the behavior is undefined.
	//If the aio_fsync() function fails or aiocbp indicates an error condition, data is not guaranteed to have been successfully transferred.
	//
	//The aio_fsync() function shall return the value 0 if the I/O operation is successfully queued; otherwise, the function shall return the value -1 and set errno to indicate the error.
	//
	//The aio_fsync() function shall fail if:
	//[EAGAIN] 
	//The requested asynchronous operation was not queued due to temporary resource limitations. 
	//[EBADF] 
	//The aio_fildes member of the aiocb structure referenced by the aiocbp argument is not a valid file descriptor open for writing. 
	//[EINVAL] 
	//This implementation does not support synchronized I/O for this file. 
	//[EINVAL] 
	//A value of op other than O_DSYNC or O_SYNC was specified. 
	//In the event that any of the queued I/O operations fail, aio_fsync() shall return the error condition defined for read() and write(). The error is returned in the error status for the asynchronous fsync() operation, which can be retrieved using aio_error().
    int Caio::fsync( int, aiocb* )
	{
		__QCS_MEMBER_FCONTEXT( "Caio::fsync" );
		errno = ENOSYS;
		return 0;
	}

	//--------------------------------------------------------------------------------
	//The aio_read() function shall read aiocbp->aio_nbytes from the file associated with aiocbp->aio_fildes into the buffer pointed to by aiocbp->aio_buf. The function call shall return when the read request has been initiated or queued to the file or device (even when the data cannot be delivered immediately).
	//[PIO]  If prioritized I/O is supported for this file, then the asynchronous operation shall be submitted at a priority equal to a base scheduling priority minus aiocbp->aio_reqprio. If Thread Execution Scheduling is not supported, then the base scheduling priority is that of the calling process;
	//[PIO TPS]  otherwise, the base scheduling priority is that of the calling thread. 
	//The aiocbp value may be used as an argument to aio_error() and aio_return() in order to determine the error status and return status, respectively, of the asynchronous operation while it is proceeding. If an error condition is encountered during queuing, the function call shall return without having initiated or queued the request. The requested operation takes place at the absolute position in the file as given by aio_offset, as if lseek() were called immediately prior to the operation with an offset equal to aio_offset and a whence equal to SEEK_SET. After a successful call to enqueue an asynchronous I/O operation, the value of the file offset for the file is unspecified.
	//The aio_sigevent member specifies the notification which occurs when the request is completed.
	//The aiocbp->aio_lio_opcode field shall be ignored by aio_read().
	//The aiocbp argument points to an aiocb structure. If the buffer pointed to by aiocbp->aio_buf or the control block pointed to by aiocbp becomes an illegal address prior to asynchronous I/O completion, then the behavior is undefined.
	//Simultaneous asynchronous operations using the same aiocbp produce undefined results.
	//[SIO]  If synchronized I/O is enabled on the file associated with aiocbp->aio_fildes, the behavior of this function shall be according to the definitions of synchronized I/O data integrity completion and synchronized I/O file integrity completion. 
	//For any system action that changes the process memory space while an asynchronous I/O is outstanding to the address range being changed, the result of that action is undefined.
	//For regular files, no data transfer shall occur past the offset maximum established in the open file description associated with aiocbp->aio_fildes.
	//
	//The aio_read() function shall return the value zero if the I/O operation is successfully queued; otherwise, the function shall return the value -1 and set errno to indicate the error.
	//
	//The aio_read() function shall fail if:
	//[EAGAIN] 
	//The requested asynchronous I/O operation was not queued due to system resource limitations. 
	//Each of the following conditions may be detected synchronously at the time of the call to aio_read(), or asynchronously. If any of the conditions below are detected synchronously, the aio_read() function shall return -1 and set errno to the corresponding value. If any of the conditions below are detected asynchronously, the return status of the asynchronous operation is set to -1, and the error status of the asynchronous operation is set to the corresponding value.
	//[EBADF] 
	//The aiocbp->aio_fildes argument is not a valid file descriptor open for reading. 
	//[EINVAL] 
	//The file offset value implied by aiocbp->aio_offset would be invalid,
	//[PIO]  aiocbp->aio_reqprio is not a valid value,   or aiocbp->aio_nbytes is an invalid value. 
	//In the case that the aio_read() successfully queues the I/O operation but the operation is subsequently canceled or encounters an error, the return status of the asynchronous operation is one of the values normally returned by the read() function call. In addition, the error status of the asynchronous operation is set to one of the error statuses normally set by the read() function call, or one of the following values:
	//[EBADF] 
	//The aiocbp->aio_fildes argument is not a valid file descriptor open for reading. 
	//[ECANCELED] 
	//The requested I/O was canceled before the I/O completed due to an explicit aio_cancel() request. 
	//[EINVAL] 
	//The file offset value implied by aiocbp->aio_offset would be invalid. 
	//The following condition may be detected synchronously or asynchronously:
	//[EOVERFLOW] 
	//The file is a regular file, aiobcp->aio_nbytes is greater than 0, and the starting offset in aiobcp->aio_offset is before the end-of-file and is at or beyond the offset maximum in the open file description associated with aiocbp->aio_fildes. 
	//
    int Caio::read( aiocb* )
	{
		__QCS_MEMBER_FCONTEXT( "Caio::read" );
		errno = ENOSYS;
		return 0;
	}

	//--------------------------------------------------------------------------------
	//The aio_return() function shall return the return status associated with the aiocb structure referenced by the aiocbp argument. The return status for an asynchronous I/O operation is the value that would be returned by the corresponding read(), write(), or fsync() function call. If the error status for the operation is equal to [EINPROGRESS], then the return status for the operation is undefined. The aio_return() function may be called exactly once to retrieve the return status of a given asynchronous operation; thereafter, if the same aiocb structure is used in a call to aio_return() or aio_error(), an error may be returned. When the aiocb structure referred to by aiocbp is used to submit another asynchronous operation, then aio_return() may be successfully used to retrieve the return status of that operation.
	//
	//If the asynchronous I/O operation has completed, then the return status, as described for read(), write(), and fsync(), shall be returned. If the asynchronous I/O operation has not yet completed, the results of aio_return() are undefined.
	//If the aio_return() function fails, it shall return -1 and set errno to indicate the error.
	//The aio_return() function may fail if:
	//[EINVAL] 
	//The aiocbp argument does not refer to an asynchronous operation whose return status has not yet been retrieved.
    ssize_t Caio::_return( aiocb* )
	{
		__QCS_MEMBER_FCONTEXT( "Caio::_return" );
		errno = ENOSYS;
		return 0;
	}

	//--------------------------------------------------------------------------------
	//The aio_suspend() function shall suspend the calling thread until at least one of the asynchronous I/O operations referenced by the list argument has completed, until a signal interrupts the function, or, if timeout is not NULL, until the time interval specified by timeout has passed. If any of the aiocb structures in the list correspond to completed asynchronous I/O operations (that is, the error status for the operation is not equal to [EINPROGRESS]) at the time of the call, the function shall return without suspending the calling thread. The list argument is an array of pointers to asynchronous I/O control blocks. The nent argument indicates the number of elements in the array. Each aiocb structure pointed to has been used in initiating an asynchronous I/O request via aio_read(), aio_write(), or lio_listio(). This array may contain null pointers, which are ignored. If this array contains pointers that refer to aiocb structures that have not been used in submitting asynchronous I/O, the effect is undefined.
	//If the time interval indicated in the timespec structure pointed to by timeout passes before any of the I/O operations referenced by list are completed, then aio_suspend() shall return with an error. [MON]   If the Monotonic Clock option is supported, the clock that shall be used to measure this time interval shall be the CLOCK_MONOTONIC clock. 
	//
	//If the aio_suspend() function returns after one or more asynchronous I/O operations have completed, the function shall return zero. Otherwise, the function shall return a value of -1 and set errno to indicate the error.
	//The application may determine which asynchronous I/O completed by scanning the associated error and return status using aio_error() and aio_return(), respectively.
	//
	//The aio_suspend() function shall fail if:
	//[EAGAIN] 
	//No asynchronous I/O indicated in the list referenced by list completed in the time interval indicated by timeout. 
	//[EINTR] 
	//A signal interrupted the aio_suspend() function. Note that, since each asynchronous I/O operation may possibly provoke a signal when it completes, this error return may be caused by the completion of one (or more) of the very I/O operations being awaited. 
    int Caio::suspend( const aiocb* const[], int, const timespec* )
	{
		__QCS_MEMBER_FCONTEXT( "Caio::suspend" );
		errno = ENOSYS;
		return 0;
	}

	//--------------------------------------------------------------------------------
	//The aio_write() function shall write aiocbp->aio_nbytes to the file associated with aiocbp->aio_fildes from the buffer pointed to by aiocbp->aio_buf. The function shall return when the write request has been initiated or, at a minimum, queued to the file or device.
	//[PIO]  If prioritized I/O is supported for this file, then the asynchronous operation shall be submitted at a priority equal to a base scheduling priority minus aiocbp->aio_reqprio. If Thread Execution Scheduling is not supported, then the base scheduling priority is that of the calling process;
	//[PIO TPS]  otherwise, the base scheduling priority is that of the calling thread. 
	//The aiocbp argument may be used as an argument to aio_error() and aio_return() in order to determine the error status and return status, respectively, of the asynchronous operation while it is proceeding.
	//The aiocbp argument points to an aiocb structure. If the buffer pointed to by aiocbp->aio_buf or the control block pointed to by aiocbp becomes an illegal address prior to asynchronous I/O completion, then the behavior is undefined.
	//If O_APPEND is not set for the file descriptor aio_fildes, then the requested operation shall take place at the absolute position in the file as given by aio_offset, as if lseek() were called immediately prior to the operation with an offset equal to aio_offset and a whence equal to SEEK_SET. If O_APPEND is set for the file descriptor, write operations append to the file in the same order as the calls were made. After a successful call to enqueue an asynchronous I/O operation, the value of the file offset for the file is unspecified.
	//The aio_sigevent member specifies the notification which occurs when the request is completed.
	//The aiocbp->aio_lio_opcode field shall be ignored by aio_write().
	//Simultaneous asynchronous operations using the same aiocbp produce undefined results.
	//[SIO]  If synchronized I/O is enabled on the file associated with aiocbp->aio_fildes, the behavior of this function shall be according to the definitions of synchronized I/O data integrity completion, and synchronized I/O file integrity completion. 
	//For any system action that changes the process memory space while an asynchronous I/O is outstanding to the address range being changed, the result of that action is undefined.
	//For regular files, no data transfer shall occur past the offset maximum established in the open file description associated with aiocbp->aio_fildes.
	//
	//The aio_write() function shall return the value zero if the I/O operation is successfully queued; otherwise, the function shall return the value -1 and set errno to indicate the error.
	//
	//The aio_write() function shall fail if:
	//[EAGAIN] 
	//The requested asynchronous I/O operation was not queued due to system resource limitations. 
	//Each of the following conditions may be detected synchronously at the time of the call to aio_write(), or asynchronously. If any of the conditions below are detected synchronously, the aio_write() function shall return -1 and set errno to the corresponding value. If any of the conditions below are detected asynchronously, the return status of the asynchronous operation shall be set to -1, and the error status of the asynchronous operation is set to the corresponding value.
	//[EBADF] 
	//The aiocbp->aio_fildes argument is not a valid file descriptor open for writing. 
	//[EINVAL] 
	//The file offset value implied by aiocbp->aio_offset would be invalid,
	//[PIO]  aiocbp->aio_reqprio is not a valid value,   or aiocbp->aio_nbytes is an invalid value. 
	//In the case that the aio_write() successfully queues the I/O operation, the return status of the asynchronous operation shall be one of the values normally returned by the write() function call. If the operation is successfully queued but is subsequently canceled or encounters an error, the error status for the asynchronous operation contains one of the values normally set by the write() function call, or one of the following:
	//[EBADF] 
	//The aiocbp->aio_fildes argument is not a valid file descriptor open for writing. 
	//[EINVAL] 
	//The file offset value implied by aiocbp->aio_offset would be invalid. 
	//[ECANCELED] 
	//The requested I/O was canceled before the I/O completed due to an explicit aio_cancel() request. 
	//The following condition may be detected synchronously or asynchronously:
	//[EFBIG] 
	//The file is a regular file, aiobcp->aio_nbytes is greater than 0, and the starting offset in aiobcp->aio_offset is at or beyond the offset maximum in the open file description associated with aiocbp->aio_fildes. 
    int Caio::write( aiocb* )
	{
		__QCS_MEMBER_FCONTEXT( "Caio::write" );
		errno = ENOSYS;
		return 0;
	}

	//--------------------------------------------------------------------------------
	//The lio_listio() function shall initiate a list of I/O requests with a single function call.
	//The mode argument takes one of the values LIO_WAIT or LIO_NOWAIT declared in <aio.h> and determines whether the function returns when the I/O operations have been completed, or as soon as the operations have been queued. If the mode argument is LIO_WAIT, the function shall wait until all I/O is complete and the sig argument shall be ignored.
	//If the mode argument is LIO_NOWAIT, the function shall return immediately, and asynchronous notification shall occur, according to the sig argument, when all the I/O operations complete. If sig is NULL, then no asynchronous notification shall occur. If sig is not NULL, asynchronous notification occurs as specified in Signal Generation and Delivery when all the requests in list have completed.
	//The I/O requests enumerated by list are submitted in an unspecified order.
	//The list argument is an array of pointers to aiocb structures. The array contains nent elements. The array may contain NULL elements, which shall be ignored.
	//If the buffer pointed to by list or the aiocb structures pointed to by the elements of the array list become illegal addresses before all asynchronous I/O completed and, if necessary, the notification is sent, then the behavior is undefined. If the buffers pointed to by the aio_buf member of the aiocb structure pointed to by the elements of the array list become illegal addresses prior to the asynchronous I/O associated with that aiocb structure being completed, the behavior is undefined.
	//The aio_lio_opcode field of each aiocb structure specifies the operation to be performed. The supported operations are LIO_READ, LIO_WRITE, and LIO_NOP; these symbols are defined in <aio.h>. The LIO_NOP operation causes the list entry to be ignored. If the aio_lio_opcode element is equal to LIO_READ, then an I/O operation is submitted as if by a call to aio_read() with the aiocbp equal to the address of the aiocb structure. If the aio_lio_opcode element is equal to LIO_WRITE, then an I/O operation is submitted as if by a call to aio_write() with the aiocbp equal to the address of the aiocb structure.
	//The aio_fildes member specifies the file descriptor on which the operation is to be performed.
	//The aio_buf member specifies the address of the buffer to or from which the data is transferred.
	//The aio_nbytes member specifies the number of bytes of data to be transferred.
	//The members of the aiocb structure further describe the I/O operation to be performed, in a manner identical to that of the corresponding aiocb structure when used by the aio_read() and aio_write() functions.
	//The nent argument specifies how many elements are members of the list; that is, the length of the array.
	//The behavior of this function is altered according to the definitions of synchronized I/O data integrity completion and synchronized I/O file integrity completion if synchronized I/O is enabled on the file associated with aio_fildes.
	//For regular files, no data transfer shall occur past the offset maximum established in the open file description associated with aiocbp->aio_fildes.
	//If sig->sigev_notify is SIGEV_THREAD and sig->sigev_notify_attributes is a non-null pointer and the block pointed to by this pointer becomes an illegal address prior to all asynchronous I/O being completed, then the behavior is undefined.
	//
	//If the mode argument has the value LIO_NOWAIT, the lio_listio() function shall return the value zero if the I/O operations are successfully queued; otherwise, the function shall return the value -1 and set errno to indicate the error.
	//If the mode argument has the value LIO_WAIT, the lio_listio() function shall return the value zero when all the indicated I/O has completed successfully. Otherwise, lio_listio() shall return a value of -1 and set errno to indicate the error.
	//In either case, the return value only indicates the success or failure of the lio_listio() call itself, not the status of the individual I/O requests. In some cases one or more of the I/O requests contained in the list may fail. Failure of an individual request does not prevent completion of any other individual request. To determine the outcome of each I/O request, the application shall examine the error status associated with each aiocb control block. The error statuses so returned are identical to those returned as the result of an aio_read() or aio_write() function.
	//
	//The lio_listio() function shall fail if:
	//[EAGAIN] 
	//The resources necessary to queue all the I/O requests were not available. The application may check the error status for each aiocb to determine the individual request(s) that failed. 
	//[EAGAIN] 
	//The number of entries indicated by nent would cause the system-wide limit {AIO_MAX} to be exceeded. 
	//[EINVAL] 
	//The mode argument is not a proper value, or the value of nent was greater than {AIO_LISTIO_MAX}. 
	//[EINTR] 
	//A signal was delivered while waiting for all I/O requests to complete during an LIO_WAIT operation. Note that, since each I/O operation invoked by lio_listio() may possibly provoke a signal when it completes, this error return may be caused by the completion of one (or more) of the very I/O operations being awaited. Outstanding I/O requests are not canceled, and the application shall examine each list element to determine whether the request was initiated, canceled, or completed. 
	//[EIO] 
	//One or more of the individual I/O operations failed. The application may check the error status for each aiocb structure to determine the individual request(s) that failed. 
	//In addition to the errors returned by the lio_listio() function, if the lio_listio() function succeeds or fails with errors of [EAGAIN], [EINTR], or [EIO], then some of the I/O specified by the list may have been initiated. If the lio_listio() function fails with an error code other than [EAGAIN], [EINTR], or [EIO], no operations from the list shall have been initiated. The I/O operation indicated by each list element can encounter errors specific to the individual read or write function being performed. In this event, the error status for each aiocb control block contains the associated error code. The error codes that can be set are the same as would be set by a read() or write() function, with the following additional error codes possible:
	//[EAGAIN] 
	//The requested I/O operation was not queued due to resource limitations. 
	//[ECANCELED] 
	//The requested I/O was canceled before the I/O completed due to an explicit aio_cancel() request. 
	//[EFBIG] 
	//The aiocbp->aio_lio_opcode is LIO_WRITE, the file is a regular file, aiocbp->aio_nbytes is greater than 0, and the aiocbp->aio_offset is greater than or equal to the offset maximum in the open file description associated with aiocbp->aio_fildes. 
	//[EINPROGRESS] 
	//The requested I/O is in progress. 
	//[EOVERFLOW] 
	//The aiocbp->aio_lio_opcode is LIO_READ, the file is a regular file, aiocbp->aio_nbytes is greater than 0, and the aiocbp->aio_offset is before the end-of-file and is greater than or equal to the offset maximum in the open file description associated with aiocbp->aio_fildes. 
    int Caio::lio_listio( int, aiocb* __QCMP_RESTRICT const[/*__QCMP_RESTRICT*/], int, sigevent* __QCMP_RESTRICT )
	{
		__QCS_MEMBER_FCONTEXT( "Caio::lio_listio" );
		errno = ENOSYS;
		return 0;
	}

}//nsBaseCRT
