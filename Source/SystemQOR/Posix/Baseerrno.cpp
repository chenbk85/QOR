//Baseerrno.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "SystemQOR/Posix/Baseerrno.h"
#include "CodeQOR/Tracing/FunctionContextBase.h"
#include "CodeQOR/Instancing/TInstancePtr.h"
#include <stdarg.h>

__QOR_INTERFACE( __CQOR ) int& f_errno()
{
	return *(nsBaseCRT::CCRTErrorDomain::m_errno.operator int *());
}

//--------------------------------------------------------------------------------
namespace nsBaseCRT
{
	CCRTErrorDomain CRTErrorDomain;
    using nsPlatform::va_list;

	//------------------------------------------------------------------------------
	__QOR_IMPLEMENT_OCLASS_LUID( Cerrno );

	//--------------------------------------------------------------------------------
	Cerrno::Cerrno() : m_uiErr( 0 )
	{
		__QCS_MEMBER_FCONTEXT( "Cerrno::Cerrno" );
	}

	//--------------------------------------------------------------------------------
	Cerrno::~Cerrno()
	{
		__QCS_MEMBER_FCONTEXT( "Cerrno::~Cerrno" );
	}

    //--------------------------------------------------------------------------------
    Cerrno& Cerrno::operator = ( unsigned int uiErr )
    {
        __QCS_MEMBER_FCONTEXT( "Cerrno::operator =" );
        m_uiErr = uiErr;
#if( __QOR_ERROR_SYSTEM )
		if( _FContext_.GetParent() )
		{
			nsCodeQOR::CObjectContextBase& refObjContext = ( *_FContext_.ObjectContextPointer() );
			nsCodeQOR::CError::Raise( __FILE__ ,__LINE__ , _FContext_.GetParent()->Name(), refObjContext, uiErr, &CRTErrorDomain, nsCodeQOR::CError::ERR_LVL_CONTINUE );
		}
#endif
        return *this;
    }

	//--------------------------------------------------------------------------------
    Cerrno::operator unsigned int()
    {
		__QCS_MEMBER_FCONTEXT( "Cerrno::operator unsigned int" );
        return m_uiErr;
    }

	//--------------------------------------------------------------------------------
    Cerrno::operator int*()
    {
		__QCS_MEMBER_FCONTEXT( "Cerrno::operator int*" );
        return reinterpret_cast< int* >( &m_uiErr );
    }


    Cerrno __QOR_INTERFACE( __QSYS ) CCRTErrorDomain::m_errno;

	__QOR_IMPLEMENT_OCLASS_LUID( CCRTErrorDomain );

    //--------------------------------------------------------------------------------
    CCRTErrorDomain::CCRTErrorDomain() : CBaseErrorDomain( _TXT( "CQOR runtime errors" ) )
    {
		__QCS_MEMBER_FCONTEXT( "CCRTErrorDomain::CCRTErrorDomain" );
    }

    //--------------------------------------------------------------------------------
    CCRTErrorDomain::~CCRTErrorDomain()
    {
		__QCS_MEMBER_FCONTEXT( "CCRTErrorDomain::~CCRTErrorDomain" );
    }

	//--------------------------------------------------------------------------------
	int* CCRTErrorDomain::ErrNo()
	{
		__QCS_FCONTEXT( "CCRTErrorDomain::ErrNo" );
		return (m_errno);
	}

    //--------------------------------------------------------------------------------
    nsCodeQOR::CBaseErrorDomain::s_BaseError CCRTErrorDomain::m_CRTNotes[ CCRTErrorDomain::MAXCRT_NOTES - nsCodeQOR::CBaseErrorDomain::MAX_NOTES ] =
    {
        { _TXT("%s\n"), { &nsCodeQOR::CBaseErrorDomain::GetParam< 0 >, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }
    };

    //--------------------------------------------------------------------------------
    nsCodeQOR::CBaseErrorDomain::s_BaseError CCRTErrorDomain::m_CRTWarnings[ CCRTErrorDomain::MAXCRT_WARNS - nsCodeQOR::CBaseErrorDomain::MAX_WARNS ] =
    {
        { _TXT("Unknown Warning.\n"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }
    };

    //--------------------------------------------------------------------------------
    nsCodeQOR::CBaseErrorDomain::s_BaseError CCRTErrorDomain::m_CRTErrors[ CCRTErrorDomain::MAXCRT_ERRORS - nsCodeQOR::CBaseErrorDomain::MAX_ERRORS ] =
    {
        { _TXT("Unknown Error.\n"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
        { _TXT("Arg list too long"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_E2BIG
        { _TXT("Permission denied"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EACCESS
        { _TXT("Address in use"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EADDRINUSE
        { _TXT("Address not available"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EADDRNOTAVAIL
        { _TXT("Address family not supported"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EAFNOSUPPORT
        { _TXT("Resource unavailable, try again"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EAGAIN
        { _TXT("Connection already in progress"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EALREADY
        { _TXT("Bad file descriptor"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EBADF
        { _TXT("Bad message"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EBADMSG
        { _TXT("Device or resource busy"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EBUSY
        { _TXT("Operation canceled"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ECANCELED
        { _TXT("No child processes"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ECHILD
        { _TXT("Connection aborted"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ECONNABORTED
        { _TXT("Connection refused"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ECONNREFUSED
        { _TXT("Connection reset"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ECONNRESET
        { _TXT("Resource deadlock would occur"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EDEADLK
        { _TXT("Destination address required"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EDESTADDRREQ
        { _TXT("Mathematics argument out of domain of function"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EDOM
        { _TXT("Reserved"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EDQUOT
        { _TXT("File exists"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EEXIST
        { _TXT("Bad address"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EFAULT
        { _TXT("File too large"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EFBIG
        { _TXT("Host is unreachable"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EHOSTUNREACH
        { _TXT("Identifier removed"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EIDRM
        { _TXT("Illegal byte sequence"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EILSEQ
		{ _TXT("Operation in progress"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EINPROGRESS

		{ _TXT("Interrupted function"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EINTR
		{ _TXT("Invalid argument"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EINVAL
		{ _TXT("I/O error"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EIO
		{ _TXT("Socket is connected"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EISCONN
		{ _TXT("Is a directory"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EISDIR
		{ _TXT("Too many levels of symbolic links"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ELOOP
		{ _TXT("Too many open files"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EMFILE
		{ _TXT("Too many links"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EMLINK
		{ _TXT("Message too large"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EMSGSIZE
		{ _TXT("Reserved"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EMULTIHOP
		{ _TXT("Filename too long"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ENAMETOOLONG
		{ _TXT("Network is down"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ENETDOWN
		{ _TXT("Connection aborted by network"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ENETRESET
		{ _TXT("Network unreachable"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ENETUNREACH
		{ _TXT("Too many files open in system"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ENFILE
		{ _TXT("No buffer space available"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ENOBUFS
		{ _TXT("No message is available on the STREAM head read queue"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ENODATA
		{ _TXT("No such device"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ENODEV
		{ _TXT("No such file or directory"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ENOENT
		{ _TXT("Executable file format error"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ENOEXEC
		{ _TXT("No locks available"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ENOLCK
		{ _TXT("Reserved"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ENOLINK
		{ _TXT("Not enough space"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ENOMEM
		{ _TXT("No message of the desired type"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ENOMSG
		{ _TXT("Protocol not available"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ENOPROTOOPT
		{ _TXT("No space left on device"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ENOSPC
		{ _TXT("No STREAM resources"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ENOSR
		{ _TXT("Not a STREAM"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ENOSTR
		{ _TXT("Function not supported"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ENOSYS
		{ _TXT("The socket is not connected"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ENOTCONN
		{ _TXT("Not a directory"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ENOTDIR
		{ _TXT("Directory not empty"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ENOTEMPTY
		{ _TXT("Not a socket"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ENOTSOCK
		{ _TXT("Not supported"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ENOTSUP
		{ _TXT("Inappropriate I/O control operation"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ENOTTY
		{ _TXT("No such device or address"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ENXIO
		{ _TXT("Operation not supported on socket"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EOPNOTSUPP
		{ _TXT("Value too large to be stored in data type"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EOVERFLOW
		{ _TXT("Operation not permitted"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EPERM
		{ _TXT("Broken pipe"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EPIPE
		{ _TXT("Protocol error"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EPROTO
		{ _TXT("Protocol not supported"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EPROTONOSUPPORT
		{ _TXT("Protocol wrong type for socket"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EPROTOTYPE
		{ _TXT("Result too large"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ERANGE
		{ _TXT("Read-only file system"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EROFS
		{ _TXT("Invalid seek"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ESPIPE
		{ _TXT("No such process"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ESRCH
		{ _TXT("Reserved"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ESTALE
		{ _TXT("Stream ioctl() timeout"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ETIME
		{ _TXT("Connection timed out"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ETIMEDOUT
		{ _TXT("Text file busy"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ETXTBSY
		{ _TXT("Operation would block"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EWOULDBLOCK
		{ _TXT("Cross-device link"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EXDEV
		{ _TXT("State not recoverable"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_ENOTRECOVERABLE
		{ _TXT("Previous owner died"), { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//CRT_EOWNERDEAD
    };

	//--------------------------------------------------------------------------------
	const nsCodeQOR::CBaseErrorDomain::s_BaseError* CCRTErrorDomain::NoteTemplate( unsigned int uiCode )
	{
		__QCS_MEMBER_FCONTEXT( "CCRTErrorDomain::NoteTemplate" );
		if( uiCode < MAXCRT_NOTES )
		{
			return (CBaseErrorDomain::s_BaseError*)&m_CRTNotes[ uiCode - CBaseErrorDomain::MAX_NOTES ];
		}
		else
		{
			return 0;
		}
	}

	//--------------------------------------------------------------------------------
	const nsCodeQOR::CBaseErrorDomain::s_BaseError* CCRTErrorDomain::WarningTemplate( unsigned int uiCode )
	{
		__QCS_MEMBER_FCONTEXT( "CCRTErrorDomain::WarningTemplate" );
		if( uiCode < MAXCRT_WARNS )
		{
			return (CBaseErrorDomain::s_BaseError*)&m_CRTWarnings[ uiCode - CBaseErrorDomain::MAX_WARNS ];
		}
		else
		{
			return 0;
		}
	}

	//--------------------------------------------------------------------------------
	const nsCodeQOR::CBaseErrorDomain::s_BaseError* CCRTErrorDomain::ErrorTemplate( unsigned int uiCode )
	{
		__QCS_MEMBER_FCONTEXT( "CCRTErrorDomain::ErrorTemplate" );
		if( uiCode < MAXCRT_ERRORS )
		{
			return (CBaseErrorDomain::s_BaseError*)&m_CRTErrors[ uiCode - CBaseErrorDomain::MAX_ERRORS ];
		}
		else
		{
			return 0;
		}
	}

}//nsBaseCRT
