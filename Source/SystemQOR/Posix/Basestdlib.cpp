//Basestdlib.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "SystemQOR/Posix/Basestdlib.h"
#include "SystemQOR/Posix/Baselimits.h"
#include <math.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include <float.h>
#include <limits.h>
#include <assert.h>
#include <errno.h>
#include "CodeQOR/Tracing/FunctionContextBase.h"
#include "CQOR.h"

//--------------------------------------------------------------------------------
namespace nsBaseCRT
{
	__QOR_IMPLEMENT_OCLASS_LUID( Cstdlib );

	//--------------------------------------------------------------------------------
	Cstdlib::Cstdlib() 
	{
		//__QCS_MEMBER_FCONTEXT( "Cstdlib::Cstdlib" );
		m_uiSeed = ( ( 6364136223846793005LL + 1 ) >> 32 ) & RAND_MAX;
	}

	//--------------------------------------------------------------------------------
	Cstdlib::~Cstdlib()
	{
		//__QCS_MEMBER_FCONTEXT( "Cstdlib::~Cstdlib" );
	}

    //--------------------------------------------------------------------------------
    void Cstdlib::_Exit( int status )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::_Exit" );
        exit( status );
    }

	//--------------------------------------------------------------------------------
    long Cstdlib::a64l( const char* pInput )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::a64l" );

        unsigned long result = 0;
        __QCS_PROTECT
        {
            const char* ptr;
            char ch;
            int i, digit;

            if( pInput != NULL )
            {
                ptr = pInput;

                // it easiest to go from most significant digit to least to find end of input or up to 6 characters worth
                for( i = 0; i < 6; ++i )
                {
                    if( *ptr )
                    {
                        ++ptr;
                    }
                }

                while( ptr > pInput )
                {
                    ch = *( --ptr );

                    if( ch >= 'a' )
                    {
                        digit = ( ch - 'a' ) + 38;
                    }
                    else if( ch >= 'A' )
                    {
                        digit = ( ch - 'A' ) + 12;
                    }
                    else if( ch >= '0' )
                    {
                        digit = ( ch - '0' ) + 2;
                    }
                    else if( ch == '/' )
                    {
                        digit = 1;
                    }
                    else
                    {
                        digit = 0;
                    }

                    result = ( result << 6 ) + digit;

                }

				if( sizeof( long ) > 4 )
				{
					// for implementations where long is > 32 bits, the result must be sign-extended */
					if( result & 0x80000000 )
					{
						result = ( ( (long) - 1 >> 32 ) << 32 ) + result;
					}
				}
            }

        }__QCS_ENDPROTECT

        return result;
    }

	//--------------------------------------------------------------------------------
    __QCMP_NORETURN void Cstdlib::abort( void )
	{
		__QCS_MEMBER_FCONTEXT( "Cstdlib::abort" );
		errno = ENOSYS;
	}

    //--------------------------------------------------------------------------------
    int Cstdlib::abs( int j )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::abs" );
        return ( j < 0 ) ? ( -j ) : j;
    }

	//--------------------------------------------------------------------------------
	int Cstdlib::atexit( void (*func)(void) )
	{
		__QCS_MEMBER_FCONTEXT( "Cstdlib::atexit" );
		errno = ENOSYS;
		return 0;
	}

	//--------------------------------------------------------------------------------
	errno_t Cstdlib::_get_doserrno( int* pValue )
	{
		__QCS_MEMBER_FCONTEXT( "CStdlib::_get_doserrno" );
		errno_t Result = 0;
		__QCS_PROTECT
		{
			errno = ENOSYS;
		}__QCS_ENDPROTECT
		return Result;
	}

	//--------------------------------------------------------------------------------
	errno_t Cstdlib::_set_doserrno( int value )
	{
        __QCS_MEMBER_FCONTEXT( "Cstdlib::_set_doserrno" );
        errno_t Result = 0;
        __QCS_PROTECT
        {
            errno = ENOSYS;
        }__QCS_ENDPROTECT
        return Result;
	}

    //--------------------------------------------------------------------------------
    double Cstdlib::atof( const char* nptr )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::atof" );
        double dResult = 0;
        __QCS_PROTECT
        {
            dResult = strtod( nptr, 0 );
        }__QCS_ENDPROTECT
        return dResult;
    }

    //--------------------------------------------------------------------------------
    int Cstdlib::atoi( const char* nptr )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::atoi" );
        int iResult = 0;
        __QCS_PROTECT
        {
            iResult = static_cast< int >( strtol ( nptr, 0, 10 ) );
        }__QCS_ENDPROTECT
        return iResult;
    }

    //--------------------------------------------------------------------------------
    long int Cstdlib::atol( const char* nptr )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::atol" );
        long lResult = 0;
        __QCS_PROTECT
        {
            lResult = strtol( nptr, 0, 10 );
        }__QCS_ENDPROTECT
        return lResult;
    }

    //--------------------------------------------------------------------------------
    long long int Cstdlib::atoll( const char* nptr )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::atoll" );
        long long int lliResult = 0;
        __QCS_PROTECT
        {
            lliResult = strtoll( nptr, (char**)0, 10 );
        }__QCS_ENDPROTECT
        return lliResult;
    }

	//--------------------------------------------------------------------------------
    void* Cstdlib::bsearch( const void* key, const void* base, size_t num, size_t width, int (*compare)(const void *, const void *) )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::bsearch" );

        __QCS_PROTECT
        {
            char* lo = (char *)base;
            char* hi = (char *)base + (num - 1) * width;
            char* mid;
            size_t half;
            int result;

            if( base == NULL || num == 0 || width <= 0 || compare == NULL )
            {
                errno = EINVAL;
                return 0;
            }

            while( lo <= hi )
            {
                if( ( half = num / 2 ) != 0 )
                {
                    mid = lo + ( num & 1 ? half : ( half - 1 ) ) * width;
                    if( !( result = (*compare)( key, mid ) ) )
                    {
                        return( mid );
                    }
                    else if( result < 0 )
                    {
                        hi = mid - width;
                        num = num & 1 ? half : half-1;
                    }
                    else
                    {
                        lo = mid + width;
                        num = half;
                    }
                }
                else if( num )
                {
                    return ( (*compare)( key, lo ) ? NULL : lo );
                }
                else
                {
                    break;
                }
            }
        }__QCS_ENDPROTECT
        return 0;
    }

    //--------------------------------------------------------------------------------
    void* Cstdlib::bsearch_s( const void* key, const void* base, size_t num, size_t width, int ( *compare )( void*, const void*, const void* ), void* pvContext )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::bsearch_s" );

        __QCS_PROTECT
        {
            char* lo = (char *)base;
            char* hi = (char *)base + (num - 1) * width;
            char* mid;
            size_t half;
            int result;

            if( base == NULL || num == 0 || width <= 0 || compare == NULL )
            {
                errno = EINVAL;
                return 0;
            }

            while( lo <= hi )
            {
                if( ( half = num / 2 ) != 0 )
                {
                    mid = lo + ( num & 1 ? half : ( half - 1 ) ) * width;
                    if( !( result = (*compare)( pvContext, key, mid ) ) )
                    {
                        return( mid );
                    }
                    else if( result < 0 )
                    {
                        hi = mid - width;
                        num = num & 1 ? half : half-1;
                    }
                    else
                    {
                        lo = mid + width;
                        num = half;
                    }
                }
                else if( num )
                {
                    return ( (*compare)( pvContext, key, lo ) ? NULL : lo );
                }
                else
                {
                    break;
                }
            }
        }__QCS_ENDPROTECT
        return 0;
    }

    //--------------------------------------------------------------------------------
    div_t Cstdlib::div( int numer, int denom )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::div" );
        div_t Result = {0};
        __QCS_PROTECT
        {
            Result.quot = numer / denom;
            Result.rem = numer % denom;

            if( numer >= 0 && Result.rem < 0 )
            {
                ++Result.quot;
                Result.rem -= denom;
            }
        }__QCS_ENDPROTECT

        return Result;
    }

    //--------------------------------------------------------------------------------
    double Cstdlib::drand48( void )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::drand48" );
        double dResult = 0;
        __QCS_PROTECT
        {
            clib_execution_context* pEC = get_execution_context();
            dResult = erand48( pEC->_r48._seed );
        }__QCS_ENDPROTECT
        return dResult;
    }


    //--------------------------------------------------------------------------------
    char* Cstdlib::ecvt( double dValue, int iDigit, int* pDecpt, int* pSign )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::ecvt" );
        char* pResult = 0;
        __QCS_PROTECT
        {
            pResult = ecvtbuf( dValue, iDigit, pDecpt, pSign, 0 );
        }__QCS_ENDPROTECT
        return pResult;
    }

	//--------------------------------------------------------------------------------
    double Cstdlib::erand48( unsigned short xsubi[ 3 ] )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::erand48" );
        double dResult = 0;
        __QCS_PROTECT
        {
            clib_execution_context* pEC = get_execution_context();
            __dorand48( pEC, xsubi );
            dResult = ldexp( (double)xsubi[ 0 ], -48 ) + ldexp( (double)xsubi[ 1 ], -32 ) + ldexp( (double)xsubi[ 2 ], -16 );
        }__QCS_ENDPROTECT
        return dResult;
    }

	//--------------------------------------------------------------------------------
	void Cstdlib::exit( int status )
	{
		__QCS_MEMBER_FCONTEXT( "Cstdlib::exit" );
		errno = ENOSYS;
	}

    //--------------------------------------------------------------------------------
    char* Cstdlib::fcvt( double dValue, int iDigit, int* pDecpt, int* pSign )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::fcvt" );
        char* pResult = 0;
        __QCS_PROTECT
        {
            pResult = fcvtbuf( dValue, iDigit, pDecpt, pSign, 0 );
        }__QCS_ENDPROTECT
        return pResult;
    }

	//--------------------------------------------------------------------------------
	void Cstdlib::free( void* ptr )
	{
		__QCS_MEMBER_FCONTEXT( "Cstdlib::free" );
		errno = ENOSYS;
	}

    //--------------------------------------------------------------------------------
    char* Cstdlib::gcvt( double dValue, int iDigit, char* pBuf )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::gcvt" );
        char* pResult = 0;
        __QCS_PROTECT
        {
            char* tbuf = pBuf;
            if( dValue < 0 )
            {
                *pBuf = '-';
                pBuf++;
                iDigit--;
            }
            pResult = ( _gcvt( dValue, iDigit, pBuf, 'g', 0 ) ? tbuf : 0 );
        }__QCS_ENDPROTECT
        return pResult;
    }

	//--------------------------------------------------------------------------------
    char* Cstdlib::getenv( const char* name )
	{
		__QCS_MEMBER_FCONTEXT( "Cstdlib::getenv" );
		errno = ENOSYS;
		return 0;
	}

	//--------------------------------------------------------------------------------
    errno_t Cstdlib::getenv_s( size_t* pReturnSize, char* pDstBuf, size_t DstSize, const char* pszVarName )
	{
		__QCS_MEMBER_FCONTEXT( "Cstdlib::getenv_s" );
		errno = ENOSYS;
		return ENOSYS;
	}

	//--------------------------------------------------------------------------------
    int Cstdlib::getsubopt( char** optionp, char* const* tokens, char** valuep )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::getsubopt" );
        int iResult = -1;
        __QCS_PROTECT
        {
            int cnt;
            char* p;

            suboptarg = *valuep = NULL;

            if( !( !optionp || !*optionp ) )
            {
                // skip leading white-space, commas
                for( p = *optionp; *p && ( *p == ',' || *p == ' ' || *p == '\t'); ++p );

                if( !*p )
                {
                    *optionp = p;
                }
                else
                {
                    // save the start of the token, and skip the rest of the token.
                    for( suboptarg = p; *++p && *p != ',' && *p != '=' && *p != ' ' && *p != '\t'; );

                    if( *p )
                    {
                        //If there's an equals sign, set the value pointer, and skip over the value
                        //part of the token.  Terminate the token.
                        if( *p == '=' )
                        {
                            *p = '\0';
                            for( *valuep = ++p; *p && *p != ',' && *p != ' ' && *p != '\t'; ++p );

                            if( *p )
                            {
                                *p++ = '\0';
                            }
                        }
                        else
                        {
                            *p++ = '\0';
                        }

                        // Skip any whitespace or commas after this token.
                        for( ; *p && (*p == ',' || *p == ' ' || *p == '\t'); ++p );
                    }

                    // set optionp for next round.
                    *optionp = p;

                    for( cnt = 0; *tokens; ++tokens, ++cnt )
                    {
                        if( !strcmp( suboptarg, *tokens ) )
                        {
                            iResult = cnt;
                            break;
                        }
                    }
                }
            }
        }__QCS_ENDPROTECT
        return( iResult );
    }

	//--------------------------------------------------------------------------------
    int Cstdlib::grantpt( int iFileDes )
	{
		__QCS_MEMBER_FCONTEXT( "Cstdlib::grantpt" );
		errno = ENOSYS;
		return 0;
	}

	//--------------------------------------------------------------------------------
    char* Cstdlib::initstate( unsigned int uiSeed, char* pState, size_t Size )
	{
		__QCS_MEMBER_FCONTEXT( "Cstdlib::initstate" );
		errno = ENOSYS;
		return 0;
	}

    //--------------------------------------------------------------------------------
    long Cstdlib::jrand48( unsigned short xsubi[ 3 ] )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::jrand48" );
        long lResult = 0;
        __QCS_PROTECT
        {
            clib_execution_context* pEC = get_execution_context();
             __dorand48( pEC, xsubi );
            lResult = ( static_cast< long >( xsubi[ 2 ] << 16 ) ) + static_cast< long >( xsubi[ 1 ] );
        }__QCS_ENDPROTECT
        return lResult;
    }

    //--------------------------------------------------------------------------------
    char* Cstdlib::l64a( long lValue )
    {
		__QCS_MEMBER_FCONTEXT( "Cstdlib::l64a" );

        static const char R64_ARRAY[] = "./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

        char* ptr;
        char* result;
        int i, index;
        unsigned long tmp = (unsigned long)lValue & 0xffffffff;

        clib_execution_context* pEC = get_execution_context();
        result = pEC->_l64a_buf;
        ptr = result;

        for( i = 0; i < 6; ++i )
        {
            if( tmp == 0 )
            {
                *ptr = '\0';
                break;
            }

            index = tmp & ( 64 - 1 );
            *ptr++ = R64_ARRAY[ index ];
            tmp >>= 6;
        }

        return result;
    }

    //--------------------------------------------------------------------------------
    long int Cstdlib::labs( long int j )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::labs" );
        return ( j < 0 ) ? ( -j ) : j;
    }

    //--------------------------------------------------------------------------------
    void Cstdlib::lcong48( unsigned short param[ 7 ] )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::lcong48" );

        clib_execution_context* pEC = get_execution_context();
        pEC->_r48._seed[ 0 ] = param[ 0 ];
        pEC->_r48._seed[ 1 ] = param[ 1 ];
        pEC->_r48._seed[ 2 ] = param[ 2 ];
        pEC->_r48._mult[ 0 ] = param[ 3 ];
        pEC->_r48._mult[ 1 ] = param[ 4 ];
        pEC->_r48._mult[ 2 ] = param[ 5 ];
        pEC->_r48._add = param[ 6 ];
    }

    //--------------------------------------------------------------------------------
    ldiv_t Cstdlib::ldiv( long int numer, long int denom )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::ldiv" );

        ldiv_t Result = {0};
        __QCS_PROTECT
        {
            Result.quot = numer / denom;
            Result.rem = numer % denom;

            if( numer >= 0 && Result.rem < 0 )
            {
                ++Result.quot;
                Result.rem -= denom;
            }
        }__QCS_ENDPROTECT
        return Result;
    }

    //--------------------------------------------------------------------------------
    Cmp_long_long Cstdlib::llabs(long long int j)
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::llabs" );
        return ( j < 0 ) ? ( -j ) : j;
    }

    //--------------------------------------------------------------------------------
    lldiv_t Cstdlib::lldiv(long long int numer, long long int denom)
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::lldiv" );
        lldiv_t Result = {0};

        __QCS_PROTECT
        {
            Result.quot = numer / denom;
            Result.rem = numer % denom;

            if( numer >= 0 && Result.rem < 0 )
            {
                ++Result.quot;
                Result.rem -= denom;
            }
        }__QCS_ENDPROTECT

        return Result;
    }

    //--------------------------------------------------------------------------------
    long Cstdlib::lrand48( void )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::lrand48" );
        long lResult = 0;
        __QCS_PROTECT
        {
            clib_execution_context* pEC = get_execution_context();
            __dorand48( pEC, pEC->_r48._seed );
            lResult = static_cast< long >( static_cast< unsigned long >( pEC->_r48._seed[ 2 ] << 15 ) ) + ( static_cast< unsigned long >( pEC->_r48._seed[ 1 ] >> 1 ) );
        }__QCS_ENDPROTECT
        return lResult;
    }

	//--------------------------------------------------------------------------------
	void* Cstdlib::malloc( size_t size )
	{
		__QCS_MEMBER_FCONTEXT( "Cstdlib::malloc" );
		errno = ENOSYS;
		return 0;
	}

    //--------------------------------------------------------------------------------
    int Cstdlib::mblen( const char* s, size_t n )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::mblen" );
		errno = ENOSYS;
        int retval = 0;
#pragma TODO( "mblen" )
        /*
        mbstate_t *state;

        _REENT_CHECK_MISC(_REENT);
        state = &(_REENT_MBLEN_STATE(_REENT));
        retval = _mbtowc_r( _REENT, NULL, s, n, state );
        if( retval < 0 )
        {
            state->__count = 0;
            return -1;
        }
        else
        {
        */
        return retval;
    }

	//--------------------------------------------------------------------------------
	size_t Cstdlib::mbstowcs( wchar_t* pwcs, const char* s, size_t n )
	{
		__QCS_MEMBER_FCONTEXT( "Cstdlib::mbstowcs" );
		errno = ENOSYS;
		return 0;
	}

	//--------------------------------------------------------------------------------
    errno_t Cstdlib::mbstowcs_s( size_t* pNumOfCharConverted, wchar_t* pDstBuf, size_t SizeInWords, const char* s, size_t MaxCount )
	{
		__QCS_MEMBER_FCONTEXT( "Cstdlib::mbstowcs_s" );
		errno = ENOSYS;
		return ENOSYS;
	}

	//--------------------------------------------------------------------------------
    int Cstdlib::mbtowc( wchar_t* pwc, const char* s, size_t n ) 
	{
		__QCS_MEMBER_FCONTEXT( "Cstdlib::mbtowc" );
		errno = ENOSYS;
		return 0;
	}

    //--------------------------------------------------------------------------------
    char* Cstdlib::mktemp( char* pTemplate )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::mktemp" );
        char* pResult = 0;
        __QCS_PROTECT
        {
            pResult = ( _gettemp( pTemplate, 0 ) ? pTemplate : 0 );
        }__QCS_ENDPROTECT
        return pResult;
    }

    //--------------------------------------------------------------------------------
    int Cstdlib::mkstemp( char* pTemplate )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::mkstemp" );
        int iResult = 0;
        int fd = 0;
        __QCS_PROTECT
        {
            iResult = ( _gettemp( pTemplate, fd ) ? fd : -1 );
        }__QCS_ENDPROTECT
        return iResult;
    }

	//--------------------------------------------------------------------------------
    long Cstdlib::mrand48( void )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::mrand48" );
        long lResult = 0;
        __QCS_PROTECT
        {
            clib_execution_context* pEC = get_execution_context();
            __dorand48( pEC, pEC->_r48._seed );
            lResult = ( static_cast< long >( pEC->_r48._seed[ 2 ] << 16 ) ) + static_cast< long >( pEC->_r48._seed[ 1 ] );
        }__QCS_ENDPROTECT
        return lResult;
    }

    //--------------------------------------------------------------------------------
    long Cstdlib::nrand48( unsigned short xsubi[ 3 ] )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::nrand48" );
        long lResult = 0;
        __QCS_PROTECT
        {
            clib_execution_context* pEC = get_execution_context();
            __dorand48( pEC, xsubi );
            lResult = static_cast< long >( ( static_cast< unsigned long > ( xsubi[ 2 ] << 15 ) ) + ( static_cast< unsigned long >( xsubi[ 1 ] >> 1 ) ) );
        }__QCS_ENDPROTECT
        return lResult;
    }

    //--------------------------------------------------------------------------------
    int Cstdlib::posix_memalign( void** memptr, size_t alignment, size_t size )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::posix_memalign" );

        int iResult = ENOMEM;
        __QCS_PROTECT
        {
            void* mem = 0;

            //// Test whether the ALIGNMENT argument is valid.  It must be a power of two multiple of sizeof (void *).
            if( alignment % sizeof( void* ) != 0 || ( alignment & ( alignment - 1 ) ) != 0 )
            {
                iResult = EINVAL;
            }
            else
            {
#	pragma TODO( "__libc_memalign" )
                //mem = __libc_memalign( alignment, size );

                if( mem != 0 )
                {
                    *memptr = mem;
                    iResult = 0;
                }
            }
        }__QCS_ENDPROTECT
        return iResult;
    }

	//--------------------------------------------------------------------------------
	int Cstdlib::posix_openpt( int oflag )
	{
		__QCS_MEMBER_FCONTEXT( "Cstdlib::posix_openpt" );
		errno = ENOSYS;
		return 0;
	}

	//--------------------------------------------------------------------------------
	char* Cstdlib::ptsname( int iFileDes )
	{
		__QCS_MEMBER_FCONTEXT( "Cstdlib::ptsname" );
		errno = ENOSYS;
		return 0;
	}

    //--------------------------------------------------------------------------------
    int Cstdlib::putenv( const char* str )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::putenv" );

        char* p, *equal;
        int rval = 0;
        __QCS_PROTECT
        {
            p = strdup( str );

            if( !p )
            {
                rval = 1;
            }
            else
            {
                if( !( equal = strchr( p, '=' ) ) )
                {
                    (void) free( p );
                    rval = 1;
                }
                else
                {
                    *equal = '\0';
                    rval = setenv( p, equal + 1, 1 );
                    free( p );
                }
            }
        }__QCS_ENDPROTECT
        return rval;
    }

	//--------------------------------------------------------------------------------
    int Cstdlib::_putenv( const char* envstring )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::_putenv" );
        int iResult = 0;
        __QCS_PROTECT
        {
            iResult = putenv( envstring );
        }__QCS_ENDPROTECT
        return iResult;
    }
		
	//--------------------------------------------------------------------------------
    void Cstdlib::qsort( void* base, size_t num, size_t width, int (*comp)(const void *, const void *) )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::qsort" );
        // Note: the number of stack entries required is no more than
        //1 + log2(num), so 30 is sufficient for any array

        char *lo, *hi;              // ends of sub-array currently sorting
        char *mid;                  // points to middle of subarray
        char *loguy, *higuy;        // traveling pointers for partition step
        size_t size;                // size of the sub-array
        char* lostk[ STKSIZ ];
        char* histk[ STKSIZ ];
        int stkptr;                 //stack for saving sub-array to be processed

        if( base == NULL || num == 0 || width <= 0 || comp == NULL )
        {
            errno = EINVAL;
            return;
        }

        if( num < 2 )
        {
            return;                 // nothing to do
        }

        stkptr = 0;                 // initialize stack

        lo = (char*)base;
        hi = (char*)base + width * ( num - 1 );        // initialize limits

        /* this entry point is for pseudo-recursion calling: setting
        lo and hi and jumping to here is like recursion, but stkptr is
        preserved, locals aren't, so we preserve stuff on the stack */
        recurse:

        size = ( hi - lo ) / width + 1;        // number of el's to sort

        // below a certain size, it is faster to use a O(n^2) sorting method
        if (size <= CUTOFF)
        {
            shortsort( lo, hi, width, comp );
        }
        else
        {
            /* First we pick a partitioning element.  The efficiency of the
            algorithm demands that we find one that is approximately the median
            of the values, but also that we select one fast.  We choose the
            median of the first, middle, and last elements, to avoid bad
            performance in the face of already sorted data, or data that is made
            up of multiple sorted runs appended together.  Testing shows that a
            median-of-three algorithm provides better performance than simply
            picking the middle element for the latter case. */

            mid = lo + ( size / 2 ) * width;      // find middle element

            // Sort the first, middle, last elements into order
            if( comp( lo, mid ) > 0 )
            {
                swap( lo, mid, width );
            }

            if( comp( lo, hi ) > 0 )
            {
                swap( lo, hi, width );
            }

            if( comp( mid, hi ) > 0 )
            {
                swap( mid, hi, width );
            }

            /* We now wish to partition the array into three pieces, one consisting
            of elements <= partition element, one of elements equal to the
            partition element, and one of elements > than it.  This is done
            below; comments indicate conditions established at every step. */

            loguy = lo;
            higuy = hi;

            /* Note that higuy decreases and loguy increases on every iteration,
            so loop must terminate. */
            for (;;)
            {
                /* lo <= loguy < hi, lo < higuy <= hi,
                A[i] <= A[mid] for lo <= i <= loguy,
                A[i] > A[mid] for higuy <= i < hi,
                A[hi] >= A[mid] */

                /* The doubled loop is to avoid calling comp(mid,mid), since some
                existing comparison funcs don't work when passed the same
                value for both pointers. */

                if( mid > loguy )
                {
                    do
                    {
                        loguy += width;
                    } while( loguy < mid && comp( loguy, mid ) <= 0 );
                }

                if( mid <= loguy )
                {
                    do
                    {
                        loguy += width;
                    } while( loguy <= hi && comp( loguy, mid ) <= 0 );
                }

                /* lo < loguy <= hi+1, A[i] <= A[mid] for lo <= i < loguy,
                either loguy > hi or A[loguy] > A[mid] */

                do
                {
                    higuy -= width;
                } while( higuy > mid && comp( higuy, mid ) > 0 );

                /* lo <= higuy < hi, A[i] > A[mid] for higuy < i < hi,
                either higuy == lo or A[higuy] <= A[mid] */

                if( higuy < loguy )
                {
                    break;
                }

                /* if loguy > hi or higuy == lo, then we would have exited, so
                A[loguy] > A[mid], A[higuy] <= A[mid],
                loguy <= hi, higuy > lo */

                swap( loguy, higuy, width );

                /* If the partition element was moved, follow it.  Only need
                to check for mid == higuy, since before the swap,
                A[loguy] > A[mid] implies loguy != mid. */

                if( mid == higuy )
                {
                    mid = loguy;
                }

                /* A[loguy] <= A[mid], A[higuy] > A[mid]; so condition at top
                of loop is re-established */
            }

            /*     A[i] <= A[mid] for lo <= i < loguy,
            A[i] > A[mid] for higuy < i < hi,
            A[hi] >= A[mid]
            higuy < loguy
            implying:
            higuy == loguy-1
            or higuy == hi - 1, loguy == hi + 1, A[hi] == A[mid] */

            /* Find adjacent elements equal to the partition element.  The
            doubled loop is to avoid calling comp(mid,mid), since some
            existing comparison funcs don't work when passed the same value
            for both pointers. */

            higuy += width;
            if (mid < higuy)
            {
                do
                {
                    higuy -= width;
                } while( higuy > mid && comp( higuy, mid ) == 0 );
            }

            if( mid >= higuy )
            {
                do
                {
                    higuy -= width;
                } while( higuy > lo && comp( higuy, mid ) == 0 );
            }

            /* OK, now we have the following:
            higuy < loguy
            lo <= higuy <= hi
            A[i]  <= A[mid] for lo <= i <= higuy
            A[i]  == A[mid] for higuy < i < loguy
            A[i]  >  A[mid] for loguy <= i < hi
            A[hi] >= A[mid] */

            /* We've finished the partition, now we want to sort the subarrays
            [lo, higuy] and [loguy, hi].
            We do the smaller one first to minimize stack usage.
            We only sort arrays of length 2 or more.*/

            if ( higuy - lo >= hi - loguy )
            {
                if( lo < higuy )
                {
                    lostk[ stkptr ] = lo;
                    histk[ stkptr ] = higuy;
                    ++stkptr;
                }                           // save big recursion for later

                if( loguy < hi )
                {
                    lo = loguy;
                    goto recurse;           // do small recursion
                }
            }
            else
            {
                if( loguy < hi )
                {
                    lostk[ stkptr ] = loguy;
                    histk[ stkptr ] = hi;
                    ++stkptr;               // save big recursion for later
                }

                if( lo < higuy )
                {
                    hi = higuy;
                    goto recurse;           // do small recursion
                }
            }
        }

        /* We have sorted the array, except for any pending sorts on the stack.
        Check if there are any, and do them. */

        --stkptr;
        if( stkptr >= 0 )
        {
            lo = lostk[ stkptr ];
            hi = histk[ stkptr ];
            goto recurse;           // pop subarray from stack
        }
        else
        {
            return;                 // all subarrays done
        }
    }

	//--------------------------------------------------------------------------------
	void Cstdlib::qsort_s( void* base, size_t nmemb, size_t SizeOfElements, int ( *pFuncCompare )( void*, const void*, const void* ), void* pvContext )
	{
		__QCS_MEMBER_FCONTEXT( "Cstdlib::qsort_s" );
		errno = ENOSYS;
	}

    //--------------------------------------------------------------------------------
    int Cstdlib::rand(void)
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::rand" );
        int iResult = 0;
        __QCS_PROTECT
        {
            rand_s( reinterpret_cast< unsigned int* >( &iResult ) );
        }__QCS_ENDPROTECT
        return iResult;
    }

	//--------------------------------------------------------------------------------
    errno_t Cstdlib::rand_s( unsigned int* puiRandomValue )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::rand_s" );
        /* This multiplier was obtained from Knuth, D.E., "The Art of
        Computer Programming," Vol 2, Seminumerical Algorithms, Third
        Edition, Addison-Wesley, 1998, p. 106 (line 26) & p. 108 */
        
        errno_t errResult = 0;
        if( puiRandomValue != 0 )
        {
            //unsigned int uiSeed = ( ( 6364136223846793005LL + 1 ) >> 32 ) & RAND_MAX;
            unsigned int* pSeed = &m_uiSeed;
            *puiRandomValue = rand_r( pSeed );
        }
        else
        {
            errno = EINVAL;
            errResult = EINVAL;
        }
        return errResult;        
    }

    //--------------------------------------------------------------------------------
    int Cstdlib::rand_r( unsigned int* pSeed )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::rand_r" );
        int iResult = 0;
        long k;
        long s = static_cast< long >( *pSeed );
        if( s == 0 )
        {
            s = 0x12345987;
        }
        k = s / 127773;
        s = 16807 * ( s - k * 127773 ) - 2836 * k;
        if( s < 0 )
        {
            s += 2147483647;
        }
        ( *pSeed ) = static_cast< unsigned int >( s );
		iResult = (s & nsPlatform::RandMax );
        return iResult;
    }

	//--------------------------------------------------------------------------------
    long Cstdlib::random( void )
	{
		__QCS_MEMBER_FCONTEXT( "Cstdlib::random" );
		errno = ENOSYS;
		return 0;
	}

	//--------------------------------------------------------------------------------
    void* Cstdlib::realloc( void* ptr, size_t size )
	{
		__QCS_MEMBER_FCONTEXT( "Cstdlib::realloc" );
		errno = ENOSYS;
		return 0;
	}

    //--------------------------------------------------------------------------------
    char* Cstdlib::realpath( const char* path, char* resolved_path )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::realpath" );
//			char cwd[ PATH_MAX ];
//			char* path_copy;
//			int res;
//
//			if( !*path )
//			{
//#pragma TODO( "Raise ENOENT" )
//				//errno = ENOENT; // SUSv2
//				return NULL;
//			}
//
//			if( !getcwd( cwd, sizeof( cwd ) ) )
//			{
//				return 0;
//			}
//
//			strcpy( resolved_path, "/" );
//
//			if( resolve_path( cwd, resolved_path, resolved_path ) )
//			{
//				return 0;
//			}
//
//			strcat( resolved_path, "/" );
//			path_copy = strdup( path );
//
//			if( !path_copy )
//			{
//				return 0;
//			}
//
//			res = resolve_path( path_copy, resolved_path, strchr( resolved_path, 0 ) );
//
//			free( path_copy );
//
//			if( res )
//			{
//				return 0;
//			}

        return resolved_path;
    }

    //--------------------------------------------------------------------------------
    unsigned short* Cstdlib::seed48( unsigned short seed16v[ 3 ] )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::seed48" );

        static unsigned short sseed[ 3 ];

        //_REENT_CHECK_RAND48(r);
        //sseed[ 0 ] = __rand48_seed[ 0 ];
        //sseed[ 1 ] = __rand48_seed[ 1 ];
        //sseed[ 2 ] = __rand48_seed[ 2 ];
        //__rand48_seed[ 0 ] = seed16v[ 0 ];
        //__rand48_seed[ 1 ] = seed16v[ 1 ];
        //__rand48_seed[ 2 ] = seed16v[ 2 ];
        //__rand48_mult[ 0 ] = _RAND48_MULT_0;
        //__rand48_mult[ 1 ] = _RAND48_MULT_1;
        //__rand48_mult[ 2 ] = _RAND48_MULT_2;
        //__rand48_add = _RAND48_ADD;
        return sseed;
    }

	//--------------------------------------------------------------------------------
    int Cstdlib::setenv( const char* envname, const char* envval, int overwrite )
	{
		__QCS_MEMBER_FCONTEXT( "Cstdlib::setenv" );
		errno = ENOSYS;
		return 0;
	}

	//--------------------------------------------------------------------------------
    void Cstdlib::setkey( const char* key )
	{
		__QCS_MEMBER_FCONTEXT( "Cstdlib::setkey" );
		errno = ENOSYS;
	}

	//--------------------------------------------------------------------------------
    char* Cstdlib::setstate( const char* )
	{
		__QCS_MEMBER_FCONTEXT( "Cstdlib::setstate" );
		errno = ENOSYS;
		return 0;
	}

    //--------------------------------------------------------------------------------
    void Cstdlib::srand( unsigned int /*seed*/ )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::srand" );
        //_REENT_CHECK_RAND48(_REENT);
        //_REENT_RAND_NEXT(_REENT) = seed;
    }

    //--------------------------------------------------------------------------------
    void Cstdlib::srand48( long /*seed*/ )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::srand48" );
        //_REENT_CHECK_RAND48(r);
        //__rand48_seed[ 0 ] = _RAND48_SEED_0;
        //__rand48_seed[ 1 ] = static_cast< unsigned short >( seed );
        //__rand48_seed[ 2 ] = static_cast< unsigned short >( static_cast< unsigned long >( seed >> 16 ) );
        //__rand48_mult[ 0 ] = _RAND48_MULT_0;
        //__rand48_mult[ 1 ] = _RAND48_MULT_1;
        //__rand48_mult[ 2 ] = _RAND48_MULT_2;
        //__rand48_add = _RAND48_ADD;
    }

	//--------------------------------------------------------------------------------
	void Cstdlib::srandom( unsigned int uiSeed )
	{
		__QCS_MEMBER_FCONTEXT( "Cstdlib::srandom" );
		errno = ENOSYS;
	}

    //--------------------------------------------------------------------------------
    double Cstdlib::strtod( const char* nptr, char** endptr )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::strtod" );
        return strtox(nptr, endptr, 1);
    }

    //--------------------------------------------------------------------------------
    float Cstdlib::strtof( const char* nptr, char** endptr )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::strtof" );
        double retval = strtod( /*_REENT,*/ nptr, endptr );
        /*
        if( isnan( retval ) )
        {
            return nanf( 0 );
        }
        */
        return static_cast< float >( retval );
    }

    //--------------------------------------------------------------------------------
    long int Cstdlib::strtol( const char* nptr, char** endptr, int base )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::strtol" );

        long int liResult = 0;
        long int liSign = 1;
        __QCS_PROTECT
        {
            while( *nptr == ' ' || *nptr == '\t' )
            {
                ++nptr;
            }

            if( *nptr == '-' )
            {
                liSign = -1;
                ++nptr;
            }
            else if( *nptr == '+' )
            {
                ++nptr;
            }

            bool bQuit = false;
            if( *nptr < '0' || *nptr > '9' )
            {
                if( endptr != 0 )
                {
                    *endptr = (char*) nptr;
                    liResult = 0;
                    bQuit = true;
                }
            }

            if( !bQuit )
            {
                //assert ( base == 0 );
                base = 10;
                if( *nptr == '0' )
                {
                    if( nptr[1] == 'x' || nptr[1] == 'X' )
                    {
                        base = 16;
                        nptr += 2;
                    }
                    else
                    {
                        base = 8;
                    }
                }

                while ( *nptr >= '0' && *nptr <= '9' && !bQuit )
                {
                    unsigned long int digval = *nptr - '0';
                    if( liResult > LONG_MAX / 10 || ( liSign > 0 ? liResult == LONG_MAX /10 && digval > LONG_MAX% 10 : ( liResult == ( (unsigned long int) LONG_MAX + 1 ) / 10 && digval > ( (unsigned long int) LONG_MAX + 1 ) % 10) ) )
                    {
                        errno = ERANGE;
                        liResult = liSign > 0 ? LONG_MAX : LONG_MIN;
                        bQuit = true;
                    }
                    if( !bQuit )
                    {
                        liResult *= base;
                        liResult += digval;
                        ++nptr;
                    }
                }
            }
        }__QCS_ENDPROTECT
        return liResult * liSign;
    }

	//--------------------------------------------------------------------------------
	long double Cstdlib::strtold( const char* nptr, char** endptr )
	{
		__QCS_MEMBER_FCONTEXT( "Cstdlib::strtold" );
		errno = ENOSYS;
		return 0;
	}

    //--------------------------------------------------------------------------------
    long long int Cstdlib::strtoll( const char* /*nptr*/, char** /*endptr*/, int /*base*/ )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::strtoll" );
		errno = ENOSYS;
        unsigned long long acc = 0;
/*            __QCS_PROTECT
        {
            const char* s = nptr;
            int c;
            unsigned long long cutoff;
            int neg = 0, any, cutlim;

            //Skip white space and pick up leading +/- sign if any.
            //If base is 0, allow 0x for hex and 0 for octal, else assume decimal;
            //if base is already 16, allow 0x.

            do
            {
                c = *s++;
            } while( isspace( c ) );

            if( c == '-' )
            {
                neg = 1;
                c = *s++;
            }
            else if ( c == '+' )
            {
                c = *s++;
            }

            if( ( base == 0 || base == 16 ) && c == '0' && ( *s == 'x' || *s == 'X' ) )
            {
                c = s[ 1 ];
                s += 2;
                base = 16;
            }

            if( base == 0 )
            {
                base = c == '0' ? 8 : 10;
            }

            * Compute the cutoff value between legal numbers and illegal
            * numbers.  That is the largest legal value, divided by the
            * base.  An input number that is greater than this value, if
            * followed by a legal input character, is too big.  One that
            * is equal to this value may be valid or not; the limit
            * between valid and invalid numbers is then based on the last
            * digit.  For instance, if the range for longs is
            * [-2147483648..2147483647] and the input base is 10,
            * cutoff will be set to 214748364 and cutlim to either
            * 7 (neg==0) or 8 (neg==1), meaning that if we have accumulated
            * a value > 214748364, or equal but the next digit is > 7 (or 8),
            * the number is too big, and we will return a range error.
            *
            * Set any if any `digits' consumed; make it negative to indicate
            * overflow.
                
            cutoff = neg ? - static_cast< unsigned long long >( LONG_LONG_MIN ) : LONG_LONG_MAX;
            cutlim = cutoff % static_cast< unsigned long long >( base );
            cutoff /= static_cast< unsigned long long >( base );
            for( acc = 0, any = 0;; c = *s++ )
            {
                if( isdigit( c ) )
                {
                    c -= '0';
                }
                else if( isalpha( c ) )
                {
                    c -= isupper( c ) ? 'A' - 10 : 'a' - 10;
                }
                else
                {
                    break;
                }

                if( c >= base )
                {
                    break;
                }

                if( any < 0 || acc > cutoff || ( acc == cutoff && c > cutlim ) )
                {
                    any = -1;
                }
                else
                {
                    any = 1;
                    acc *= base;
                    acc += c;
                }
            }

            if( any < 0 )
            {
                acc = neg ? LONG_LONG_MIN : LONG_LONG_MAX;
                errno = ERANGE;
                //rptr->_errno = ERANGE;
            }
            else if( neg )
            {
                acc = -acc;
            }

            if( endptr != 0 )
            {
                *endptr = (char *) (any ? s - 1 : nptr);
            }

        }__QCS_ENDPROTECT
*/
        return acc;
    }

    //--------------------------------------------------------------------------------
    unsigned long int Cstdlib::strtoul( const char* /*nptr*/, char** /*endptr*/, int /*base*/ )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::strtoul" );
		errno = ENOSYS;
        unsigned long acc = 0;

/*            __QCS_PROTECT
        {
            const char* s = nptr;
            int c;
            unsigned long cutoff;
            int neg = 0, any, cutlim;

            do
            {
                c = *s++;
            } while( isspace( c ) );

            if( c == '-' )
            {
                neg = 1;
                c = *s++;
            }
            else if( c == '+' )
            {
                c = *s++;
            }

            if( ( base == 0 || base == 16 ) && c == '0' && ( *s == 'x' || *s == 'X' ) )
            {
                c = s[ 1 ];
                s += 2;
                base = 16;
            }

            if( base == 0 )
            {
                base = c == '0' ? 8 : 10;
            }

            cutoff = static_cast< unsigned long >( ULONG_MAX ) / static_cast< unsigned long >( base );
            cutlim = static_cast< unsigned long >( ULONG_MAX ) % static_cast< unsigned long >( base );
            for( acc = 0, any = 0;; c = *s++ )
            {
                if( isdigit( c ) )
                {
                    c -= '0';
                }
                else if( isalpha( c ) )
                {
                    c -= isupper( c ) ? 'A' - 10 : 'a' - 10;
                }
                else
                {
                    break;
                }

                if( c >= base )
                {
                    break;
                }

                if( any < 0 || acc > cutoff || ( acc == cutoff && c > cutlim ) )
                {
                    any = -1;
                }
                else
                {
                    any = 1;
                    acc *= base;
                    acc += c;
                }
            }

            if( any < 0 )
            {
                acc = ULONG_MAX;
                errno = ERANGE;
                //rptr->_errno = ERANGE;
            }
            else if( neg )
            {
                acc = -acc;
            }

            if( endptr != 0 )
            {
                *endptr = (char *) (any ? s - 1 : nptr);
            }

        }__QCS_ENDPROTECT
*/
        return acc;
    }

	//--------------------------------------------------------------------------------
    unsigned long long int Cstdlib::strtoull( const char* /*nptr*/, char** /*endptr*/, int /*base*/ )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::strtoull" );
		errno = ENOSYS;
        unsigned long long int acc = 0;
/*
        __QCS_PROTECT
        {
            const char* s = nptr;
            int c;
            unsigned long long cutoff;
            int neg = 0, any, cutlim;

            //See strtol for comments as to the logic used.

            do
            {
                c = *s++;
            } while( isspace( c ) );

            if( c == '-' )
            {
                neg = 1;
                c = *s++;
            }
            else if ( c == '+' )
            {
                c = *s++;
            }

            if( ( base == 0 || base == 16 ) && c == '0' && ( *s == 'x' || *s == 'X' ) )
            {
                c = s[ 1 ];
                s += 2;
                base = 16;
            }

            if( base == 0 )
            {
                base = c == '0' ? 8 : 10;
            }

            cutoff = static_cast< unsigned long long >( ULONG_LONG_MAX ) / static_cast< unsigned long long >( base );
            cutlim = static_cast< unsigned long long >( ULONG_LONG_MAX ) % static_cast< unsigned long long >( base );
            for( acc = 0, any = 0;; c = *s++ )
            {
                if( isdigit( c ) )
                {
                    c -= '0';
                }
                else if( isalpha( c ) )
                {
                    c -= isupper( c ) ? 'A' - 10 : 'a' - 10;
                }
                else
                {
                    break;
                }

                if( c >= base )
                {
                    break;
                }

                if( any < 0 || acc > cutoff || ( acc == cutoff && c > cutlim ) )
                {
                    any = -1;
                }
                else
                {
                    any = 1;
                    acc *= base;
                    acc += c;
                }
            }

            if( any < 0 )
            {
                acc = ULONG_LONG_MAX;
                errno = ERANGE;
                //rptr->_errno = ERANGE;
            }
            else if( neg )
            {
                acc = -acc;
            }

            if( endptr != 0 )
            {
                *endptr = (char *) (any ? s - 1 : nptr);
            }

        }__QCS_ENDPROTECT
*/
        return acc;
    }

	//--------------------------------------------------------------------------------
    int Cstdlib::system( const char* string )
	{
		__QCS_MEMBER_FCONTEXT( "Cstdlib::system" );
		errno = ENOSYS;
		return 0;
	}

	//--------------------------------------------------------------------------------
    int Cstdlib::unlockpt( int )
	{
		__QCS_MEMBER_FCONTEXT( "Cstdlib::unlockpt" );
		errno = ENOSYS;
		return 0;
	}

    //--------------------------------------------------------------------------------
    int Cstdlib::unsetenv( const char* /*name*/ )
    {
        __QCS_MEMBER_FCONTEXT( "Cstdlib::unsetenv" );
		errno = ENOSYS;
        //register char** P;
        //int offset;

        //ENV_LOCK;

        //while( findenv( /*reent_ptr,*/ name, &offset ) )	// if set multiple times
        //{
        //	for( P = &(*p_environ)[ offset ];; ++P )
        //	{
        //		if( !( *P = *( P + 1 ) ) )
        //		{
        //			break;
        //		}
        //	}
        //}

        //ENV_UNLOCK;

        return 0;
    }

	//--------------------------------------------------------------------------------
    size_t Cstdlib::wcstombs( char* s, const wchar_t* pwcs, size_t n )
	{
        __QCS_MEMBER_FCONTEXT( "Cstdlib::wcstombs" );
		errno = ENOSYS;
		return 0;
	}

	//--------------------------------------------------------------------------------
    int Cstdlib::wctomb( char* s, wchar_t wchar )
	{
        __QCS_MEMBER_FCONTEXT( "Cstdlib::wcstomb" );
		errno = ENOSYS;
		return 0;
	}

	//--------------------------------------------------------------------------------
    errno_t Cstdlib::wcstombs_s( size_t* pReturnValue, char* mbstr, size_t sizeInBytes, const wchar_t* wcstr, size_t count )
	{
        __QCS_MEMBER_FCONTEXT( "Cstdlib::wcstombs_s" );
		errno = ENOSYS;
		return 0;
	}

	//--------------------------------------------------------------------------------
    errno_t Cstdlib::wctomb_s( int* pRetValue, char* mbchar, size_t sizeInBytes, wchar_t wchar )
	{
        __QCS_MEMBER_FCONTEXT( "Cstdlib::wctomb_s" );
		errno = ENOSYS;
		return 0;
	}

	//--------------------------------------------------------------------------------
    void Cstdlib::__dorand48( clib_execution_context* pEC, unsigned short xseed[3] )
    {
        unsigned long accu;
        unsigned short temp[2];

        accu = (unsigned long) pEC->_r48._mult[ 0 ] * (unsigned long) xseed[ 0 ] + (unsigned long) pEC->_r48._add;
        temp[ 0 ] = (unsigned short) accu;     // lower 16 bits
        accu >>= sizeof( unsigned short ) * 8;
        accu += (unsigned long) pEC->_r48._mult[ 0 ] * (unsigned long) xseed[ 1 ] + (unsigned long) pEC->_r48._mult[ 1 ] * (unsigned long) xseed[ 0 ];
        temp[ 1 ] = (unsigned short) accu;     // middle 16 bits
        accu >>= sizeof(unsigned short) * 8;
        accu += pEC->_r48._mult[ 0 ] * xseed[ 2 ] + pEC->_r48._mult[ 1 ] * xseed[ 1 ] + pEC->_r48._mult[ 2 ] * xseed[ 0 ];
        xseed[ 0 ] = temp[ 0 ];
        xseed[ 1 ] = temp[ 1 ];
        xseed[ 2 ] = (unsigned short) accu;
    }

	//internal

	//--------------------------------------------------------------------------------
    int Cstdlib::_gettemp( /*ptr,*/ char* /*path*/, int /*doopen*/ )
    {
//			char* start, *trv;
//			struct stat sbuf;
//			unsigned int pid;
//
//			pid = getpid( ptr );
//
//			for( trv = path; *trv; ++trv )		// extra X's get set to 0's
//			{
//				continue;
//			}
//
//			while( *--trv == 'X' )
//			{
//				*trv = (pid % 10) + '0';
//				pid /= 10;
//			}
//
//			//Check the target directory; if you have six X's and it
//			//doesn't exist this runs for a *very* long time.
//
//			for( start = trv + 1;; --trv )
//			{
//				if( trv <= path )
//				{
//					break;
//				}
//
//				if( *trv == '/' )
//				{
//					*trv = '\0';
//#ifdef __USE_INTERNAL_STAT64
//					if( stat64( /*ptr,*/ path, &sbuf ) )
//#else
//					if( stat( /*ptr,*/ path, &sbuf ) )
//#endif
//					{
//						return 0;
//					}
//
//					if( !( sbuf.st_mode & S_IFDIR ) )
//					{
//#pragma TODO ( "Raise ENOTDIR" )
//						//ptr->_errno = ENOTDIR;
//						return 0;
//					}
//					*trv = '/';
//					break;
//				}
//			}
//
//			for (;;)
//			{
//				if( doopen )
//				{
//					if( ( *doopen = open( /*ptr,*/ path, O_CREAT | O_EXCL | O_RDWR, 0600 ) ) >= 0 )
//					{
//						return 1;
//					}
//#if defined(__CYGWIN__)
//					if( ptr->_errno != EEXIST && ptr->_errno != EACCES )
//#else
//					if( ptr->_errno != EEXIST )
//#endif
//					{
//						return 0;
//					}
//				}
//#ifdef __USE_INTERNAL_STAT64
//				else if( stat64( /*ptr,*/ path, &sbuf ) )
//#else
//				else if( stat( /*ptr,*/ path, &sbuf ) )
//#endif
//				return( ptr->_errno == ENOENT ? 1 : 0 );
//
//				// tricky little algorithm for backward compatibility
//				for( trv = start;; )
//				{
//					if( !*trv )
//					{
//						return 0;
//					}
//					if( *trv == 'z' )
//					{
//						*trv++ = 'a';
//					}
//					else
//					{
//						if( isdigit( *trv ) )
//						{
//							*trv = 'a';
//						}
//						else
//						{
//							++ * trv;
//						}
//						break;
//					}
//				}
//			}
//			/*NOTREACHED*/
return 0;
    }

    //--------------------------------------------------------------------------------
    char* Cstdlib::_gcvt( double /*invalue*/, int /*ndigit*/, char* buf, char /*type*/, int /*dot*/ )
    {
        char* save = buf;

        //if( invalue < 0 )
        //{
        //	invalue = -invalue;
        //}

        //if( invalue == 0 )
        //{
        //	*buf++ = '0';
        //	*buf = '\0';
        //}
        //else
        //{
        //	/* Which one to print ?
        //	ANSI says that anything with more that 4 zeros after the . or more
        //	than precision digits before is printed in e with the qualification
        //	that trailing zeroes are removed from the fraction portion.  */

        //	if( 0.0001 >= invalue || invalue >= _mprec_log10( ndigit ) )
        //	{
        //		/* We subtract 1 from ndigit because in the 'e' format the precision is
        //		the number of digits after the . but in 'g' format it is the number
        //		of significant digits.

        //		We defer changing type to e/E so that print_e() can know it's us
        //		calling and thus should remove trailing zeroes.  */
        //		print_e( /*ptr,*/ buf, invalue, ndigit - 1, type, dot );
        //	}
        //	else
        //	{
        //		int decpt;
        //		int sign;
        //		char* end;
        //		char* p;

        //		if( invalue < 1.0 )
        //		{
        //			// what we want is ndigits after the point
        //			p = dtoa( /*ptr,*/ invalue, 3, ndigit, &decpt, &sign, &end );
        //		}
        //		else
        //		{
        //			p = dtoa( /*ptr,*/ invalue, 2, ndigit, &decpt, &sign, &end );
        //		}

        //		if( decpt == 9999 )
        //		{
        //			strcpy( buf, p );
        //			return save;
        //		}

        //		while( *p && decpt > 0 )
        //		{
        //			*buf++ = *p++;
        //			decpt--;
        //			ndigit--;
        //		}

        //		// Even if not in buffer
        //		while( decpt > 0 && ndigit > 0 )
        //		{
        //			*buf++ = '0';
        //			decpt--;
        //			ndigit--;
        //		}

        //		if( dot || *p )
        //		{
        //			if( buf == save )
        //			{
        //				*buf++ = '0';
        //			}
        //			*buf++ = '.';
        //			while( decpt < 0 && ndigit > 0 )
        //			{
        //				*buf++ = '0';
        //				decpt++;
        //				ndigit--;
        //			}

        //			// Print rest of stuff
        //			while( *p && ndigit > 0 )
        //			{
        //				*buf++ = *p++;
        //				ndigit--;
        //			}

        //			// And trailing zeros
        //			if( dot )
        //			{
        //				while( ndigit > 0 )
        //				{
        //					*buf++ = '0';
        //					ndigit--;
        //				}
        //			}
        //		}
        //		*buf++ = 0;
        //	}
        //}
        return save;
    }

	#define CVTBUFSIZE  2 * DBL_MAX_10_EXP + 10

	char* Cstdlib::cvt( double arg, int ndigits, int *decpt, int *sign, char *buf, int eflag )
	{
		int r2;
		double fi, fj;
		char* p, *p1;

		if( ndigits >= CVTBUFSIZE - 1 )
		{
				ndigits = CVTBUFSIZE - 2;
		}

		r2 = 0;
		*sign = 0;
		p = &buf[0];

		if( arg < 0 )
		{
			*sign = 1;
			arg = -arg;
		}

		arg = modf( arg, &fi );
		p1 = &buf[ CVTBUFSIZE ];

		if( fi != 0 )
		{
			p1 = &buf[ CVTBUFSIZE ];
			while( fi != 0 )
			{
				fj = modf( fi / 10, &fi );
				*--p1 = (int)( (fj + .03) * 10 ) + '0';
				r2++;
			}
			while( p1 < &buf[CVTBUFSIZE] )
			{
				*p++ = *p1++;
			}
		}
		else if( arg > 0 )
		{
			while( ( fj = arg * 10 ) < 1 )
			{
				arg = fj;
				r2--;
			}
		}

		p1 = &buf[ ndigits ];
		if( eflag == 0 )
		{
			p1 += r2;
		}

		*decpt = r2;
		if( p1 < &buf[ 0 ] )
		{
			buf[ 0 ] = '\0';
			return buf;
		}

		while( p <= p1 && p < &buf[ CVTBUFSIZE ] )
		{
			arg *= 10;
			arg = modf( arg, &fj );
			*p++ = (int) fj + '0';
		}

		if( p1 >= &buf[ CVTBUFSIZE ] )
		{
			buf[ CVTBUFSIZE - 1 ] = '\0';
			return buf;
		}

		p = p1;
		*p1 += 5;

		while( *p1 > '9' )
		{
			*p1 = '0';
			if( p1 > buf )
			{
				++*--p1;
			}
			else
			{
				*p1 = '1';
				(*decpt)++;
				if( eflag == 0 )
				{
					if( p > buf )
					{
						*p = '0';
					}
					p++;
				}
			}
		}
		*p = '\0';
		return buf;
	}


    //--------------------------------------------------------------------------------
    // Undocumented behaviour: when given NULL as a buffer, return a pointer to static space in
    //the rent structure.  This is only to support ecvt and fcvt, which aren't ANSI anyway.
    char* Cstdlib::fcvtbuf( double invalue, int ndigits, int* decpt, int* sign, char* fcvt_buf )
    {
		return cvt( invalue, ndigits, decpt, sign, fcvt_buf, 0 );
    }
    
    //--------------------------------------------------------------------------------
    char* Cstdlib::ecvtbuf( double /*invalue*/, int /*ndigit*/, int* /*decpt*/, int* /*sign*/, char* /*fcvt_buf*/ )
    {
        char* save = 0;
        /*
        char* p;
        char* end;
        int done = 0;

        if( fcvt_buf == NULL )
        {
            if( _REENT->_cvtlen <= ndigit )
            {
                if( ( fcvt_buf = (char*) _realloc_r( _REENT, _REENT->_cvtbuf, ndigit + 1 ) ) == NULL )
                {
                    return NULL;
                }
                _REENT->_cvtlen = ndigit + 1;
                _REENT->_cvtbuf = fcvt_buf;
            }

            fcvt_buf = _REENT->_cvtbuf ;
        }

        save = fcvt_buf;

        p = _dtoa_r( _REENT, invalue, 2, ndigit, decpt, sign, &end );

        // Now copy

        while( p < end )
        {
            *fcvt_buf++ = *p++;
            done++;
        }

        // And unsuppress the trailing zeroes
        while( done < ndigit )
        {
            *fcvt_buf++ = '0';
            done++;
        }

        *fcvt_buf++ = 0;
        */
        return save;
    }

    //--------------------------------------------------------------------------------
    void Cstdlib::swap( char* a, char* b, size_t width )
    {
        char tmp;

        if( a != b )
        {
            // Do the swap one character at a time to avoid potential alignment problems.
            while( width-- )
            {
                tmp = *a;
                *a++ = *b;
                *b++ = tmp;
            }
        }
    }

    //--------------------------------------------------------------------------------
    void Cstdlib::shortsort( char* lo, char* hi, size_t width, int (*comp)( const void*, const void* ) )
    {
        char* p;
        char* max;

        // Note: in assertions below, i and j are alway inside original bound of array to sort.

        while( hi > lo )
        {
            // A[i] <= A[j] for i <= j, j > hi
            max = lo;
            for( p = lo + width; p <= hi; p += width )
            {
                // A[i] <= A[max] for lo <= i < p
                if ( comp( p, max ) > 0 )
                {
                    max = p;
                }
                // A[i] <= A[max] for lo <= i <= p
            }

            // A[i] <= A[max] for lo <= i <= hi
            swap( max, hi, width );

            // A[i] <= A[hi] for i <= hi, so A[i] <= A[j] for i <= j, j >= hi
            hi -= width;

            // A[i] <= A[j] for i <= j, j > hi, loop top condition established
        }
        // A[i] <= A[j] for i <= j, j > lo, which implies A[i] <= A[j] for i < j, so array is sorted
    }

}//namespace nsBaseCRT
