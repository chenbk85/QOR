//ExceptionHandling.h

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef WINCMPSUPVC_EXCEPT_HANDLING_H_1
#define WINCMPSUPVC_EXCEPT_HANDLING_H_1

#include "../RTTI/RTTI.h"
#include "SEH/SEH.h"

/*  these types are known to MSVC without declaration */
#if ( __QCMP_COMPILER == __QCMP_INTEL )

typedef void(*pvfv)(void);

struct _s__CatchableType
{
    unsigned properties;
    _TypeDescriptor * pType;
    _PMD thisDisplacement;
    int sizeOrOffset;
    pvfv copyFunction;
};

struct _s__CatchableTypeArray
{
    int nCatchableTypes;
    const _s__CatchableType (* arrayOfCatchableTypes)[];
};

struct _s__ThrowInfo
{
    unsigned attributes;
    void * pmfnUnwind;
    void* pForwardCompat;//HandlerPtr pForwardCompat;
    const _s__CatchableTypeArray * pCatchableTypeArray;
};

#endif
//--------------------------------------------------------------------------------
namespace nsCompiler
{
	//--------------------------------------------------------------------------------
	namespace EH
	{
		extern const unsigned int CPP_EXCEPTION;
		extern const unsigned int MS_MAGIC;
		extern const unsigned int MS_MAGIC_MASK;

		//struct FuncInfo;
		typedef CCompilerBase::FuncInfo FuncInfo;
		struct HandlerType;

		class ExceptionRecord;
		class RegistrationNode;
		class BasicRegistrationNode;

		typedef SEH::Context Context;
		typedef ::_s__CatchableType CatchableType;
		typedef ::_s__CatchableTypeArray CatchableTypeArray;
		typedef ::_s__ThrowInfo ThrowInfo;
		typedef ::_PMD PMD;
		typedef ::_TypeDescriptor TypeDescriptor;

		typedef nsWin32::EXCEPTION_DISPOSITION ( __QCMP_CALLCON * HandlerPtr )(
							ExceptionRecord* pExcept, RegistrationNode* pRN,
							Context* pContext, void* pDC, const FuncInfo* pFuncInfo, int CatchDepth,
							BasicRegistrationNode* pMarkerRN, int recursive );
#pragma pack(push)
#pragma pack(8)


		//--------------------------------------------------------------------------------
		struct UnwindMapEntry
		{
			int toState;
			void (*action)(void);
		};

		//--------------------------------------------------------------------------------
		//describes a catch() block handler
		struct HandlerType
		{
			unsigned int adjectives;
			TypeDescriptor* pType;
			int dispCatchObj;
			void* addressOfHandler;
		};

		//--------------------------------------------------------------------------------
		struct TryBlockMapEntry
		{
			int tryLow;
			int tryHigh;
			int catchHigh;
			int nCatches;
			const HandlerType* pHandlerArray;
		};

		//--------------------------------------------------------------------------------

	/*
		struct FuncInfo
		{
			unsigned int magicNumber;
			int maxState;
			const UnwindMapEntry* pUnwindMap;
			unsigned int nTryBlocks;
			const TryBlockMapEntry* pTryBlockMap;
			unsigned int nIPMapEntries;
			void* pIPtoStateMap;
		};
	*/
		//--------------------------------------------------------------------------------
		class ThrownObject
		{
		public:

			//--------------------------------------------------------------------------------
			ThrownObject( void* pObject, const ThrowInfo* pObjectInfo ): m_pObject( pObject ), m_pObjectInfo( pObjectInfo )
			{
			}

			//--------------------------------------------------------------------------------
			int IsValid() const
			{
				return m_pObject != 0;
			}

			//--------------------------------------------------------------------------------
			HandlerPtr CustomHandler() const
			{
				return (HandlerPtr)( m_pObjectInfo->pForwardCompat );
			}

			//--------------------------------------------------------------------------------
			int operator == ( const ThrownObject& rhs ) const
			{
				return m_pObject == rhs.m_pObject;
			}

			const CatchableType* FindMatch( const HandlerType* pCatch );
			void Destruct( int fThrowNotAllowed );
			void Copy( void** pCatchBuffer, const HandlerType* pCatch, const CatchableType* pConv );

		private:

			static int TypeMatch( const HandlerType* pCatch, const CatchableType* pCatchable, const ThrowInfo* pThrow );

			void* m_pObject;
			const ThrowInfo* m_pObjectInfo;
		};

		//--------------------------------------------------------------------------------
		class ExceptionRecord : public SEH::ExceptionRecord
		{

		// Construction
		public:

			ExceptionRecord( ThrownObject& object, void* pExceptionAddress );

		// Accessors
		public:

			//--------------------------------------------------------------------------------
			const ThrownObject& Object() const
			{
				return *( ThrownObject* )&ExceptionInformation[1];
			}

			//--------------------------------------------------------------------------------
			ThrownObject& Object()
			{
				return *( ThrownObject* )&ExceptionInformation[1];
			}

			//--------------------------------------------------------------------------------
			int IsCpp() const
			{
				return ( IsCppCompatible() && NumberParameters == 3 );
			}

			//--------------------------------------------------------------------------------
			int IsCppCompatible() const
			{
				return ( ExceptionCode == CPP_EXCEPTION && Magic() == MS_MAGIC );
			}

			//--------------------------------------------------------------------------------
			void Throw() const
			{
				CExceptionFrame::RaiseException( this );
			}

			void CopyObject( RegistrationNode* pRN, const HandlerType* pCatch, const CatchableType* pConv );

			/*inline IsSelfHandled() const
			{
				return (pObjectInfo() != 0 && pObjectInfo()->pForwardCompat != 0);
			}*/

		private:

			//--------------------------------------------------------------------------------
			Cmp_ulong_ptr Magic() const
			{
				return ExceptionInformation[0];
			}
		};

		//--------------------------------------------------------------------------------
		class BasicRegistrationNode : public CExceptionFrame
		{
		public:

			//--------------------------------------------------------------------------------
			BasicRegistrationNode( void* pHandler ): CExceptionFrame( pHandler )
			{
			}

			//--------------------------------------------------------------------------------
			void* GetStack() const
			{
				return *( (void**)this - 1 );
			}

			//--------------------------------------------------------------------------------
			void SetStack( void* val ) const
			{
				*( (void**)this - 1 ) = val;
			}

		private:

			BasicRegistrationNode( const BasicRegistrationNode& );
			BasicRegistrationNode& operator = ( const BasicRegistrationNode& );
		};

		//--------------------------------------------------------------------------------
		class RegistrationNode : public BasicRegistrationNode
		{
		public:

			//--------------------------------------------------------------------------------
			void* GetStackFrame() const
			{
				return (void*)&m_ebp;
			}

			int state;

		private:

			void * m_ebp;

			//not to be implemented
			RegistrationNode();
			RegistrationNode( const RegistrationNode& );
			RegistrationNode& operator = ( const RegistrationNode& );
		};

		/*
		class TranslatorGuardRN : public BasicRegistrationNode
		{
		private:
			GuardDescriptor m_Descriptor;
			RegistrationNode * m_pMarkerRN;
			void * m_pContinue;
			void * m_ESP;
			void * m_EBP;
			int m_DidUnwind;

			//not to be implemented
			TranslatorGuardRN(const TranslatorGuardRN &);
			TranslatorGuardRN & operator=(const TranslatorGuardRN &);
		};
		*/

#pragma pack(pop)

		__QCMP_NORETURN void inconsistency();

	}//EH

} // nsCompiler

#endif//WINCMPSUPVC_EXCEPT_HANDLING_H_1
