//DynamicCast.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQL/WinQL.h"
#include "SystemQOR.h"
#include "WinQL/CodeServices/CriticalSection.h"
#include "../SystemQOR/MSWindows/WinCmpSupQORVC/include/RTTI/RTTI.h"
#include <algorithm>
#include <typeinfo>

using namespace std;

//--------------------------------------------------------------------------------
class MatchSIDownCast
{
public:

	//--------------------------------------------------------------------------------
	MatchSIDownCast( TypeDescriptor* pTargetType ): m_pTargetType( pTargetType )
	{
	}

	//--------------------------------------------------------------------------------
	int operator()( const BaseClassDescriptor* pBase )
	{
		return ( *( pBase->pTypeDescriptor ) == *m_pTargetType && ( pBase->attributes & 1 ) == 0 );
	}

private:

	TypeDescriptor * m_pTargetType;
};

//--------------------------------------------------------------------------------
class MatchCrossCast
{
public:

	//--------------------------------------------------------------------------------
	MatchCrossCast( TypeDescriptor* pTargetType ) : m_pTargetType( pTargetType )
	{
	}

	int operator()( const BaseClassDescriptor* pBase );

private:

	TypeDescriptor* m_pTargetType;
};

//--------------------------------------------------------------------------------
class MatchSubBase
{
public:

	//--------------------------------------------------------------------------------
	MatchSubBase( TypeDescriptor* pSrcType, void* pCompleteObject, Cmp__int3264 SrcOffset ): m_pSrcType( pSrcType ), m_pCompleteObject( pCompleteObject ), m_SrcOffset( SrcOffset )
	{
	}

	int operator()( const BaseClassDescriptor* pSubBase );

private:

	TypeDescriptor* m_pSrcType;
	void* m_pCompleteObject;
	Cmp__int3264 m_SrcOffset;
};

//--------------------------------------------------------------------------------
class MatchMIDownCast
{
public:

	//--------------------------------------------------------------------------------
	MatchMIDownCast( TypeDescriptor* pTargetType, TypeDescriptor* pSrcType, void* pCompleteObject, Cmp__int3264 SrcOffset ): m_pTargetType( pTargetType ), m_MatchSubBase( pSrcType, pCompleteObject, SrcOffset )
	{
	}

	int operator()( const BaseClassDescriptor* const * pBasePtr );

private:

	TypeDescriptor * m_pTargetType;
	MatchSubBase m_MatchSubBase;
};

//--------------------------------------------------------------------------------
int MatchCrossCast::operator()( const BaseClassDescriptor* pBase )
{
	return ( *( pBase->pTypeDescriptor ) == *m_pTargetType && ( pBase->attributes & 1 ) == 0 && ( pBase->attributes & 2 ) == 0 );
}

//--------------------------------------------------------------------------------
int MatchSubBase::operator()( const BaseClassDescriptor* pSubBase )
{
	if ( *( pSubBase->pTypeDescriptor ) == *m_pSrcType )
	{
		return ( AdjustPointer( m_pCompleteObject, pSubBase->where ) == ( unsigned char* )m_pCompleteObject + m_SrcOffset );
	}
	return false;
}

//--------------------------------------------------------------------------------
int MatchMIDownCast::operator()( const BaseClassDescriptor* const * pBasePtr )
{
	desc_ptr const pBase = *pBasePtr;
	if ( *( pBase->pTypeDescriptor ) == *m_pTargetType )
	{
		desc_ptr_ptr const pSubBegin = pBasePtr + 1;
		desc_ptr_ptr const pSubEnd = pSubBegin + pBase->numContainedBases;
		desc_ptr_ptr const pSubBasePtr = find_if( pSubBegin, pSubEnd, m_MatchSubBase );
		return ( pSubBasePtr != pSubEnd );
	}

	return false;
}

//--------------------------------------------------------------------------------
void* FindCompleteObject( void* pObject, CompleteObjectLocator* pCompleteLocator )
{
	unsigned char* pCompleteObject = ( unsigned char* )pObject - pCompleteLocator->offset;
	if ( pCompleteLocator->cdOffset != 0 )
	{
		pCompleteObject += *( unsigned long* )( ( unsigned char* )pObject - pCompleteLocator->cdOffset );
	}
	return pCompleteObject;
}

//--------------------------------------------------------------------------------
const BaseClassDescriptor* FindSITargetTypeInstance( void* /*pCompleteObject*/, const CompleteObjectLocator* pCompleteLocator, TypeDescriptor* /*pSrcType*/, Cmp__int3264 /*SrcOffset*/, TypeDescriptor* pTargetType )
{
	typedef const BaseClassDescriptor* const* desc_ptr_ptr;
	typedef const BaseClassDescriptor* desc_ptr;

	desc_ptr_ptr const pBegin = ( const desc_ptr_ptr )(pCompleteLocator->pClassDescriptor->pBaseClassArray->arrayOfBaseClassDescriptors);
	desc_ptr_ptr const pEnd =  pBegin + pCompleteLocator->pClassDescriptor->numBaseClasses;
	desc_ptr_ptr const pBasePtr = find_if( pBegin, pEnd, MatchSIDownCast( pTargetType ) );
	return ( pBasePtr != pEnd ? *pBasePtr : 0 );
}

//--------------------------------------------------------------------------------
const BaseClassDescriptor*  FindMITargetTypeInstance( void* pCompleteObject, const CompleteObjectLocator* pCompleteLocator, TypeDescriptor* pSrcType, Cmp__int3264 SrcOffset, TypeDescriptor* pTargetType )
{
	desc_ptr_ptr const pBegin =  ( const desc_ptr_ptr )(pCompleteLocator->pClassDescriptor->pBaseClassArray->arrayOfBaseClassDescriptors);
	desc_ptr_ptr const pEnd = pBegin + pCompleteLocator->pClassDescriptor->numBaseClasses;
	desc_ptr_ptr pBasePtr = find_if_ptr( pBegin, pEnd, MatchMIDownCast( pTargetType, pSrcType, pCompleteObject, SrcOffset ) );
	if ( pBasePtr != pEnd )
	{
		return *pBasePtr;
	}
	pBasePtr = find_if( pBegin, pEnd, MatchCrossCast( pTargetType ) );
	return ( pBasePtr != pEnd ? *pBasePtr : 0 );
}

//--------------------------------------------------------------------------------
const BaseClassDescriptor* FindVITargetTypeInstance( void* pCompleteObject, const CompleteObjectLocator* pCompleteLocator, TypeDescriptor* pSrcType, Cmp__int3264 SrcOffset, TypeDescriptor* pTargetType )
{
	desc_ptr_ptr const pBegin = ( const desc_ptr_ptr )(pCompleteLocator->pClassDescriptor->pBaseClassArray->arrayOfBaseClassDescriptors);
	desc_ptr_ptr const pEnd = pBegin + pCompleteLocator->pClassDescriptor->numBaseClasses;

	desc_ptr pResult = 0;
	{
		for( desc_ptr_ptr pBasePtr = pBegin; pBasePtr != pEnd; ++pBasePtr )
		{
			desc_ptr const pBase = *pBasePtr;
			if ( *( pBase->pTypeDescriptor ) == *pTargetType )
			{
				desc_ptr_ptr const pSubBegin = pBasePtr + 1;
				desc_ptr_ptr const pSubEnd = pSubBegin + pBase->numContainedBases;

				for( desc_ptr_ptr pSubBasePtr = pSubBegin; pSubBasePtr != pSubEnd; ++pSubBasePtr )
				{
					desc_ptr const pSubBase = *pSubBasePtr;

					if ( *( pSubBase->pTypeDescriptor ) == *pSrcType )
					{
						if ( AdjustPointer( pCompleteObject, pSubBase->where ) == ( unsigned char* )pCompleteObject + SrcOffset )
						{
							if ( pResult )
							{
								if ( AdjustPointer( pCompleteObject, pResult->where ) != AdjustPointer( pCompleteObject, pBase->where ) )
								{
									return 0;
								}
							}
							pResult = pBase;
						}
					}
				}
			}
		}
	}

	if ( pResult )
	{
		return pResult;
	}

	desc_ptr_ptr pBasePtr = find_if( pBegin, pEnd, MatchCrossCast( pTargetType ) );
	return ( pBasePtr != pEnd ? *pBasePtr : 0 );
}

//--------------------------------------------------------------------------------
__QCMP_LINKAGE_C void* __RTDynamicCast( void* inptr, long VfDelta, void* SrcType, void* TargetType, int isReference ) throw(...)
{
	typedef const BaseClassDescriptor* ( *FindTargetTypeInstance )( void* pCompleteObject, const CompleteObjectLocator* pCompleteLocator, TypeDescriptor* pSrcType, Cmp__int3264 SrcOffset, TypeDescriptor* pTargetType );

	if ( inptr == 0 )
	{
		return 0;
	}

	CompleteObjectLocator* pCompleteLocator = ( *( CompleteObjectLocator*** )inptr )[-1];
	void* pCompleteObject = FindCompleteObject( inptr, pCompleteLocator );
	inptr = ( unsigned char* )inptr - VfDelta;
	Cmp__int3264 inptr_delta = ( unsigned char* )inptr - ( unsigned char* )pCompleteObject;
	const BaseClassDescriptor* pBaseClass = 0;
	FindTargetTypeInstance Find = 0;

	if ( ( pCompleteLocator->pClassDescriptor->attributes & 1 ) == 0 )
	{
		Find = FindSITargetTypeInstance;
	}
	else if ( ( pCompleteLocator->pClassDescriptor->attributes & 2 ) == 0 )
	{
		Find = FindMITargetTypeInstance;
	}
	else
	{
		Find = FindVITargetTypeInstance;
	}

	pBaseClass = Find( pCompleteObject, pCompleteLocator, ( TypeDescriptor* )SrcType, inptr_delta, ( TypeDescriptor* )TargetType );

	if ( pBaseClass == 0 )
	{
		if ( isReference )
		{
#ifdef	_EXCEPTIONS
			throw bad_cast(/*"Bad dynamic_cast!"*/);
#endif//EXCEPTIONS
		}
		return 0;
	}

	return AdjustPointer( pCompleteObject, pBaseClass->where );
}
