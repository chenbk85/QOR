//SanQLProcessBootStrap.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Implements .exe startup and shutdown code for SanOS processes

#include "SanQL/SanQL.h"
//#include "WinQL/CodeServices/CriticalSection.h"
//#include "WinQAPI/Kernel32.h"
//#include "../SystemQOR/MSWindows/WinQAPI/include/ErrorDomain.h"
//#include "../SystemQOR/MSWindows/WinQAPI/include/DynamicLibrary.h"
//#include "WinQAPI/PSAPI.h"
#include "SanQL/SanQLProcessBootStrap.h"
//#include "WinQL/Definitions/IO.h"
//#include "WinQL/CodeServices/PerformanceHelper.h"
//#include "CodeQOR/ErrorSystem/ExpectedHandler.h"
//#include "WinQL/CodeServices/ErrorSystem/Win32ErrDomain.h"
//#include "WinQL/CodeServices/Time.h"
//#include "WinQL/CodeServices/Dll.h"
#include <limits.h>
#include "SanQAPI/SanQOS.h"

__QCMP_LINKAGE_C void InitThread( void );

//--------------------------------------------------------------------------------
namespace nsSanOS
{
	//--------------------------------------------------------------------------------
	CProcessBootStrap::CProcessBootStrap() : CModuleBootStrap(), m_szCommandLine( 0 )
	{
		InitStatic();//Initialise the process object and QOR library statics.
	}

	//--------------------------------------------------------------------------------
	CProcessBootStrap::~CProcessBootStrap()
	{

	}

	//--------------------------------------------------------------------------------
	void* CProcessBootStrap::GetEnvironmentA( void )
	{
		char *aEnv = NULL;
		return aEnv;
	}

	//--------------------------------------------------------------------------------
	void CProcessBootStrap::ParseCommandLine()
	{
	}

	//--------------------------------------------------------------------------------
	int CProcessBootStrap::setenvp( void )
	{
		return 0;
	}

	//--------------------------------------------------------------------------------
	void CProcessBootStrap::parse_cmdline( TCHAR* cmdstart, TCHAR** argv, TCHAR* args, int* numargs, int* numchars )
	{
	}

	//No wildcard narrow char
	int CProcessBootStrap::_setargv( void )
	{
        return 0;
	}

	//--------------------------------------------------------------------------------
	int CProcessBootStrap::GetMainArgs( int dowildcard )
	{
		int ret = 0;
		return ret;
	}

	//--------------------------------------------------------------------------------
	/*
	nsCodeQOR::CTLinkedList< nsWin32::CDll > CProcessBootStrap::GetModuleList( void )
	{
		nsWinQAPI::CPSAPI PSAPIHelper;
		nsCodeQOR::CTLinkedList< nsWin32::CDll > ModuleList;
		ModuleHandle nHandle;
		ModuleHandle* pHandles = 0;
		unsigned long ulByteCount = 0;
		PSAPIHelper.EnumProcessModules( reinterpret_cast< InstanceHandle >( nsWinQAPI::CKernel32::GetCurrentProcess() ), (HMODULE*)&nHandle, 1, &ulByteCount );
		unsigned long ulModuleCount = ( ulByteCount / sizeof( nsWin32::InstanceHandle ) );

		if( ulModuleCount > 0 )
		{
			pHandles = new ModuleHandle[ ulModuleCount ];
			memset( pHandles, 0, ulModuleCount * sizeof( nsWin32::InstanceHandle ) );
			PSAPIHelper.EnumProcessModules( reinterpret_cast< InstanceHandle >( nsWinQAPI::CKernel32::GetCurrentProcess() ), (HMODULE*)pHandles, ulByteCount, &ulByteCount );

			while( ulModuleCount > 0 )
			{
				if( pHandles[ --ulModuleCount ] != 0 )
				{
					nsWin32::CDll* pModule = new nsWin32::CDll( reinterpret_cast< void* >( pHandles[ ulModuleCount ] ), true );
					ModuleList.Append( pModule );
				}
			};
			delete [] pHandles;
		}

		return ModuleList;
	}
	*/
	//--------------------------------------------------------------------------------
	void CProcessBootStrap::InitStatic()
	{
		CProcessModuleInitializer Initializer;

		nsSanQAPI::COS& OS = nsSanQAPI::COS::Instance();

#ifndef	QOR_MONOLITHIC
		nsCodeQOR::mxGUID nullGUID = { 0x00000000, 0x0000, 0x0000, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } };
		nsCodeQOR::mxGUID aDependencies[][5] =
		{
			{
				{ 0xdb51fb8c, 0x4bef, 0x43f2, { 0xa4, 0x61, 0x7e, 0x49, 0x4f, 0xaf, 0xad, 0x75 } },
					{ 0x2c101426, 0x4e38, 0x49c0, { 0x91, 0xc8, 0x0c, 0xea, 0xf5, 0x14, 0xbc, 0x02 } }, nullGUID, nullGUID, nullGUID
			},

			{
				{ 0xa2250e96, 0xd07d, 0x4440, { 0xb3, 0xd7, 0xbd, 0x1, 0xc0, 0xc7, 0x7c, 0xef } },//WinQL is dependent on
					{ 0xdd8152fd, 0xcdd8, 0x4c26, { 0xb3, 0x55, 0x00, 0xd5, 0x79, 0x55, 0xb8, 0x7a } }, //ArchQOR
					nullGUID, nullGUID, nullGUID
			},

			{
				{ 0x74346fa1, 0xab39, 0x48b7, { 0xbe, 0x13, 0xe1, 0xdf, 0x5b, 0x7b, 0x22, 0xe6 } }, //SystemQOR  is dependent on
					{ 0xdd8152fd, 0xcdd8, 0x4c26, { 0xb3, 0x55, 0x0, 0xd5, 0x79, 0x55, 0xb8, 0x7a } }, //ArchQOR
					nullGUID, nullGUID, nullGUID
			},

			{
				{ 0xc20a868d, 0x9678, 0x4c61, { 0xa2, 0x5c, 0xb3, 0x1e, 0x89, 0xb8, 0xa8, 0xad } }, //Qurses  is dependent on
					{ 0xdd8152fd, 0xcdd8, 0x4c26, { 0xb3, 0x55, 0x0, 0xd5, 0x79, 0x55, 0xb8, 0x7a } }, //ArchQOR
					nullGUID, nullGUID, nullGUID
			},

			{
				{ 0xa2c43bf9, 0xc341, 0x447a, { 0xbe, 0xf5, 0xe0, 0xcf, 0x66, 0x3f, 0x3a, 0x31 } }, //stdQOR is dependent on
					{ 0xdd8152fd, 0xcdd8, 0x4c26, { 0xb3, 0x55, 0x0, 0xd5, 0x79, 0x55, 0xb8, 0x7a } }, //ArchQOR
					nullGUID, nullGUID, nullGUID
			},
			nullGUID,
		};
#endif//
		
		

		int iStdin = OS.__getstdhndl( 0 );
		int iStdout = OS.__getstdhndl( 1 );

		::hmodule_t QORStrata1Module = OS.getmodule( "qs1.dll" );

		nsSanQAPI::CLibrary::DefProc pVoidInit = reinterpret_cast< nsSanQAPI::CLibrary::DefProc >( OS.dlsym( QORStrata1Module, "QORinit" ) );		

		if( pVoidInit != 0 )
		{
			(*pVoidInit)();
		}

		/*
		//Get the Module list
		nsCodeQOR::CTLinkedList< nsWin32::CDll > ModuleList( GetModuleList() );
		//nsCodeQOR::CExpectedHandler ExpectingError( nsWinQAPI::GENERAL_API_ERROR );

		nsCodeQOR::CTLinkedList< nsCodeQOR::CTPair< nsCodeQOR::__mxGUID, nsWinQAPI::CLibrary::DefProc > > InitFuncList;

		//Strip out non QOR libraries and collect ids and entry points for the QOR libraries
		int iModule = 1;
		while( iModule <= static_cast< int >( ModuleList.GetCount() ) )
		{
			nsWin32::CDll* pModule = ModuleList.GetItem( iModule );
			nsWinQAPI::CLibrary::DefProc pIdentity = reinterpret_cast< nsWinQAPI::CLibrary::DefProc >( pModule->GetProcAddress( "QORidentity" ) );
			if( pIdentity == 0 )
			{
				ModuleList.Remove( iModule );
			}
			else
			{
				nsCodeQOR::CTPair< nsCodeQOR::__mxGUID, nsWinQAPI::CLibrary::DefProc >* pInitEntryPoint = new nsCodeQOR::CTPair< nsCodeQOR::__mxGUID, nsWinQAPI::CLibrary::DefProc >(
					*( ( pModule->Call< nsCodeQOR::mxGUID* >( pIdentity ) ) ),
					reinterpret_cast< nsWinQAPI::CLibrary::DefProc >( pModule->GetProcAddress( "QORinit" ) ) );
				InitFuncList.Append( pInitEntryPoint );
				iModule++;
			}
		};
		*/
#ifndef	QOR_MONOLITHIC
		//For each remaining library ensure all its static dependencies are higher up the list than it is by moving it to just after the last one

		bool bFinished = false;
		while( !bFinished )
		{
			bFinished = true;
			int iEntry = 1;
			while( iEntry <= static_cast< int >( InitFuncList.GetCount() ) )
			{
				//Find any static dependencies for the module
				int iMain = 0;
				nsCodeQOR::mxGUID* pMainGUID = aDependencies[iMain++];
				while( pMainGUID[0] != nullGUID && pMainGUID[ 0 ] != InitFuncList.GetItem(iEntry)->First() )
				{
					pMainGUID = aDependencies[iMain++];
				}

				if( pMainGUID != 0 && pMainGUID[0] != nullGUID )
				{
					int iDependency = 1;
					nsCodeQOR::__mxGUID DependentGUID = pMainGUID[iDependency++];
					while( DependentGUID != nullGUID )
					{
						//ensure MainGUID occurs after DependentGUID in InitFuncList;
						int iMainIndex = 1;
						int iSearchIndex = 1;
						int iDependsIndex = 1;
						int iTargetMainIndex = 1;
						while( iSearchIndex <= static_cast< int > ( InitFuncList.GetCount() ) )
						{
							if( InitFuncList.GetItem( iSearchIndex )->First() == pMainGUID[ 0 ] )
							{
								iMainIndex = iSearchIndex;
							}
							if( InitFuncList.GetItem( iSearchIndex )->First() == DependentGUID )
							{
								iDependsIndex = iSearchIndex;
							}
							iSearchIndex++;
						}
						if( iDependsIndex > iMainIndex )
						{
							iTargetMainIndex = iDependsIndex;
						}
						if( iTargetMainIndex > iMainIndex )
						{
							nsCodeQOR::CTPair< nsCodeQOR::__mxGUID, nsWinQAPI::CLibrary::DefProc >* pMainEntry = InitFuncList.GetItem( iMainIndex );
							InitFuncList.Drop( iMainIndex );
							InitFuncList.Insert( iTargetMainIndex, pMainEntry );
							bFinished = false;
						}

						DependentGUID = pMainGUID[iDependency++];
					}
				}
				if( !bFinished )
				{
					break;
				}
				iEntry++;
			};
		};

#endif//QOR_MONOLITHIC
		/*
		int iEntry = 1;
		while( iEntry <= static_cast< int >( InitFuncList.GetCount() ) )
		{
			nsCodeQOR::CTPair< nsCodeQOR::__mxGUID, nsWinQAPI::CLibrary::DefProc >* pEntry = InitFuncList.GetItem( iEntry++ );
			( pEntry->Second() )();
		}
		*/
	}

}//nsSanOS
