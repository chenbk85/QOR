//SanQLFile.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Implements the high level SanOS File class

#include "SanQL/CodeServices/File.h"
#include "SanQL/CodeServices/Handle.h"
#include "SanQAPI/SanQOS.h"

//------------------------------------------------------------------------------
namespace nsSanOS
{
	__QOR_IMPLEMENT_OCLASS_LUID( CFile );

	//--------------------------------------------------------------------------------
	CFile::CFile( CHandle* pHandle ) : m_Library( nsSanQAPI::COS::Instance() )
	,	m_pHandle( pHandle )
	{
	}

	//--------------------------------------------------------------------------------
	CFile::~CFile()
	{
		delete m_pHandle;
	}

	//--------------------------------------------------------------------------------
	int CFile::Sync( void )
	{
		int iResult = -1;
		if( m_pHandle )
		{
			iResult = m_Library.fsync( static_cast< ::handle_t >( m_pHandle->Use() ) );
		}
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CFile::Read( nsCodeQOR::CString< byte >& data )
	{
		int iResult = 0;
		if( m_pHandle )
		{
			iResult = m_Library.read( static_cast< ::handle_t >( m_pHandle->Use() ), data.GetBuffer(), data.Capacity() );
			data.ValidateBuffer( static_cast< unsigned short >( iResult ) );
		}
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CFile::Write( nsCodeQOR::CString< byte >& data )
	{
		int iResult = 0;
		if( m_pHandle )
		{
			iResult = m_Library.write( static_cast< ::handle_t >( m_pHandle->Use() ), data.GetBuffer(), data.Len() ); 
			data.ReleaseBuffer();
		}
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CFile::PositionalRead( nsCodeQOR::CString< byte >& data, off64_t offset )
	{
		int iResult = 0;
		if( m_pHandle )
		{
			iResult = m_Library.pread( static_cast< ::handle_t >( m_pHandle->Use() ), data.GetBuffer(), data.Capacity(), offset );
			data.ValidateBuffer( static_cast< unsigned short >( iResult ) );
		}
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CFile::PositionalWrite( nsCodeQOR::CString< byte >& data, off64_t offset )
	{
		int iResult = 0;
		if( m_pHandle )
		{
			iResult = m_Library.pwrite( static_cast< ::handle_t >( m_pHandle->Use() ), data.GetBuffer(), data.Len(), offset ); 
			data.ReleaseBuffer();
		}
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CFile::ReadVector( const struct iovec* iov, int count )
	{
		int iResult = m_Library.readv( static_cast< ::handle_t >( m_pHandle->Use() ), reinterpret_cast< const ::iovec* >( iov ), count ); 
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CFile::WriteVector( const struct iovec* iov, int count )
	{
		int iResult = m_Library.writev( static_cast< ::handle_t >( m_pHandle->Use() ), reinterpret_cast< const ::iovec* >( iov ), count );
		return iResult;
	}

	//--------------------------------------------------------------------------------
	loff_t CFile::Tell()
	{
		loff_t Result = m_Library.tell( static_cast< ::handle_t >( m_pHandle->Use() ) );
		return Result;
	}

	//--------------------------------------------------------------------------------
	off64_t CFile::Tell64()
	{
		off64_t Result = m_Library.tell64( static_cast< ::handle_t >( m_pHandle->Use() ) );
		return Result;
	}

	//--------------------------------------------------------------------------------
	loff_t CFile::Seek( loff_t offset, int origin )
	{
		loff_t Result = m_Library.lseek( static_cast< ::handle_t >( m_pHandle->Use() ), offset, origin );
		return Result;
	}

	//--------------------------------------------------------------------------------
	off64_t CFile::Seek64( off64_t offset, int origin )
	{
		off64_t Result = m_Library.lseek64( static_cast< ::handle_t >( m_pHandle->Use() ), offset, origin );
		return Result;
	}

	//--------------------------------------------------------------------------------
	int CFile::Truncate( loff_t size )
	{
		int iResult = m_Library.ftruncate( static_cast< ::handle_t >( m_pHandle->Use() ), size );
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CFile::Truncate64( off64_t size )
	{
		int iResult = m_Library.ftruncate64( static_cast< ::handle_t >( m_pHandle->Use() ), size );
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CFile::UpdateTime( utimbuf& times )
	{
		int iResult = m_Library.futime( static_cast< ::handle_t >( m_pHandle->Use() ), reinterpret_cast< ::utimbuf* >( &times ) );
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CFile::Stat( struct stat& buffer )
	{
		int iResult = m_Library.fstat( static_cast< ::handle_t >( m_pHandle->Use() ), reinterpret_cast< struct ::stat* >( &buffer ) );
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CFile::Stat64( struct stat64& buffer )
	{
		int iResult = m_Library.fstat64( static_cast< ::handle_t >( m_pHandle->Use() ), reinterpret_cast< struct ::stat64* >( &buffer ) );
		return iResult;
	}

	//--------------------------------------------------------------------------------
	loff_t CFile::Length( void )
	{
		loff_t Result = m_Library.filelength( static_cast< ::handle_t >( m_pHandle->Use() ) );
		return Result;
	}

	//--------------------------------------------------------------------------------
	off64_t CFile::Length64( void )
	{
		off64_t Result = m_Library.filelength64( static_cast< ::handle_t >( m_pHandle->Use() ) );
		return Result;
	}

	//--------------------------------------------------------------------------------
	bool CFile::IsATTY( void )
	{
		bool bResult = m_Library.isatty( static_cast< ::handle_t >( m_pHandle->Use() ) ) ? true : false;
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CFile::EoF( void )
	{
		bool bResult = m_Library.eof( static_cast< ::handle_t >( m_pHandle->Use() ) ) ? true : false;
		return bResult;
	}

	//--------------------------------------------------------------------------------
	int CFile::SetMode( int iMode )
	{
		int iResult = m_Library.setmode( static_cast< ::handle_t >( m_pHandle->Use() ), iMode );
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CFile::ChangeMode( int iMode )
	{
		int iResult = m_Library.fchmod( static_cast< ::handle_t >( m_pHandle->Use() ), iMode );
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CFile::ChangeOwner( int iOwner, int iGroup )
	{
		int iResult = m_Library.fchown( static_cast< ::handle_t >( m_pHandle->Use() ), iOwner, iGroup );
		return iResult;
	}

}//nsSanOS

