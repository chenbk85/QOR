//LIN_wordexp.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "SystemQOR.h"

#if		(QOR_SYS_OS == QOR_SYS_LINUX)

#include "SystemQOR/Linux/LIN_wordexp.h"
#include "CodeQOR/Tracing/FunctionContextBase.h"
#include <pthread.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <fcntl.h>
#include <signal.h>
#include "SystemQOR/Linux/sys/LIN_wait.h"
#include "SystemQOR/Linux/LIN_signal.h"

//--------------------------------------------------------------------------------
namespace nsLinux
{
	//--------------------------------------------------------------------------------
	Cwordexp::Cwordexp()
	{
		__QCS_MEMBER_FCONTEXT( "Cwordexp::Cwordexp" );
	}

	//--------------------------------------------------------------------------------
	Cwordexp::~Cwordexp()
	{
		__QCS_MEMBER_FCONTEXT( "Cwordexp::~Cwordexp" );
	}

	//--------------------------------------------------------------------------------
    int Cwordexp::wordexp( const char* words, wordexp_t* pwordexp, int flags )
    {
		__QCS_MEMBER_FCONTEXT( "Cwordexp::wordexp" );
        int r;
        int cs;
        pthread_setcancelstate( PTHREAD_CANCEL_DISABLE, &cs );
        r = do_wordexp( words, pwordexp, flags );
        pthread_setcancelstate( cs, 0 );
        return r;
    }

    //--------------------------------------------------------------------------------
    void Cwordexp::wordfree( wordexp_t* pwordexp )
    {
		__QCS_MEMBER_FCONTEXT( "Cwordexp::wordfree" );
        size_t i;
        if( !pwordexp->we_wordv )
        {
            return;
        }

        for( i = 0; i < pwordexp->we_wordc; i++ )
        {
            free( pwordexp->we_wordv[ pwordexp->we_offs + i ] );
        }

        free( pwordexp->we_wordv );
        pwordexp->we_wordv = 0;
        pwordexp->we_wordc = 0;
    }

    //--------------------------------------------------------------------------------
    void Cwordexp::reap( pid_t pid )
    {
		__QCS_MEMBER_FCONTEXT( "Cwordexp::reap" );
        int status;
        for(;;)
        {
            if( waitpid( pid, &status, 0 ) < 0 )
            {
                if( errno != EINTR )
                {
                    return;
                }
            }
            else
            {
                if( WIFEXITED( status ) )
                {
                    return;
                }
            }
        }
    }

    //--------------------------------------------------------------------------------
    char* Cwordexp::getword( FILE* f )
    {
		__QCS_MEMBER_FCONTEXT( "Cwordexp::getword" );
        char *s = 0;
        return getdelim( &s, (size_t[1]){0}, 0, f ) < 0 ? 0 : s;
    }

    //--------------------------------------------------------------------------------
    int Cwordexp::do_wordexp( const char* s, wordexp_t* we, int flags )
    {
		__QCS_MEMBER_FCONTEXT( "Cwordexp::do_wordexp" );
        size_t i, l;
        int sq = 0, dq = 0;
        size_t np = 0;
        char* w, **tmp;
        const char* redir = ( flags & WRDE_SHOWERR ) ? "" : "2>/dev/null";
        int err = 0;
        FILE* f;
        size_t wc = 0;
        char** wv = 0;
        int p[ 2 ];
        pid_t pid;
        sigset_t set;

        if( flags & WRDE_REUSE )
        {
            wordfree( we );
        }

        if( flags & WRDE_NOCMD )
        for( i = 0; s[ i] ; i++ )
        switch( s[ i ] )
        {
        case '\\':
            if( !sq ) i++;
            break;
        case '\'':
            if( !dq ) sq ^= 1;
            break;
        case '"':
            if( !sq ) dq ^= 1;
            break;
        case '(':
            if( np )
            {
                np++;
                break;
            }
        case ')':
            if( np )
            {
                np--;
                break;
            }
        case '\n':
        case '|':
        case '&':
        case ';':
        case '<':
        case '>':
        case '{':
        case '}':
            if( !( sq | dq | np ) )
            {
                return WRDE_BADCHAR;
            }
            break;
        case '$':
            if( s[ i + 1 ] == '(' && s[ i + 2 ] == '(' )
            {
                i += 2;
                np += 2;
                break;
            }
            else if( s[ i + 1 ] != '(' )
            {
                break;
            }
        case '`':
            if( sq )
            {
                break;
            }
            return WRDE_CMDSUB;
        }

        if( flags & WRDE_APPEND )
        {
            wc = we->we_wordc;
            wv = we->we_wordv;
        }

        i = wc;
        if( flags & WRDE_DOOFFS )
        {
            if( we->we_offs > SIZE_MAX / sizeof(void*) / 4 )
            {
                goto nospace;
            }
            i += we->we_offs;
        }
        else
        {
            we->we_offs = 0;
        }

        if( pipe2( p, O_CLOEXEC ) < 0 )
        {
            goto nospace;
        }
        __block_all_sigs( &set );
        pid = fork();
        __restore_sigs( &set );
        if( pid < 0 )
        {
            close( p[ 0 ] );
            close( p[ 1 ] );
            goto nospace;
        }
        if( !pid )
        {
            if( p[ 1 ] == 1 )
            {
                fcntl(1, F_SETFD, 0);
            }
            else
            {
                dup2(p[1], 1);
            }
            execl("/bin/sh", "sh", "-c", "eval \"printf %s\\\\\\\\0 x $1 $2\"", "sh", s, redir, (char *)0);
            _exit( 1 );
        }
        close( p[ 1 ] );

        f = fdopen( p[ 0 ], "r" );
        if( !f )
        {
            close( p[ 0 ] );
            kill( pid, SIGKILL );
            reap( pid );
            goto nospace;
        }

        l = wv ? i+1 : 0;

        free( getword( f ) );
        if( feof( f ) )
        {
            fclose( f );
            reap( pid );
            return WRDE_SYNTAX;
        }

        while ((w = getword(f)))
        {
            if (i+1 >= l)
            {
                l += l/2+10;
                tmp = reinterpret_cast< char** >( realloc(wv, l*sizeof(char *)) );
                if (!tmp) break;
                wv = tmp;
            }
            wv[i++] = w;
            wv[i] = 0;
        }

        if (!feof(f)) err = WRDE_NOSPACE;

        fclose(f);
        reap(pid);

        if (!wv) wv = reinterpret_cast< char** >( calloc(i+1, sizeof *wv) );

        we->we_wordv = wv;
        we->we_wordc = i;

        if (flags & WRDE_DOOFFS)
        {
            if (wv) for (i=we->we_offs; i; i--)
                we->we_wordv[i-1] = 0;
            we->we_wordc -= we->we_offs;
        }
        return err;

    nospace:

        if (!(flags & WRDE_APPEND))
        {
            we->we_wordc = 0;
            we->we_wordv = 0;
        }
        return WRDE_NOSPACE;
    }


}//nsLinux

#endif//(QOR_SYS_OS == QOR_SYS_LINUX)
