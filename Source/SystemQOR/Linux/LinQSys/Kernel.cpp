//Kernel.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Linux Kernel wrapper implementation

#include <errno.h>
//#include <unistd.h>
#include <limits.h>
#define __STDC_LIMIT_MACROS
#include <stdint.h>
#undef __STDC_LIMIT_MACROS

#ifndef INT64_MAX
#       if _QARCH_WORDSIZE == 64
#           define __INT64_C(c)	c ## L
#           define __UINT64_C(c)	c ## UL
#       else
#           define __INT64_C(c)	c ## LL
#           define __UINT64_C(c)	c ## ULL
#       endif

        // Maximum of signed integral types.
#       define INT8_MAX		    (127)
#       define INT16_MAX		(32767)
#       define INT32_MAX		(2147483647)
#       define INT64_MAX		(__INT64_C(9223372036854775807))

        // Maximum of unsigned integral types.
#       define UINT8_MAX		(255)
#       define UINT16_MAX		(65535)
#       define UINT32_MAX		(4294967295U)
#       define UINT64_MAX		(__UINT64_C(18446744073709551615))

#endif

#include "LinQSys/Kernel.h"
#include "SystemQOR/Posix/Baseerrno.h"

//------------------------------------------------------------------------------
namespace nsLinQSys
{
    //Implement a named wrapper for each available system call

    //------------------------------------------------------------------------------
    CKernel::CKernel()
    {

    }

    //------------------------------------------------------------------------------
    CKernel::~CKernel()
    {

    }

    //------------------------------------------------------------------------------
    CKernel& CKernel::Instance()
    {
        static CKernel _Kernel;
        return _Kernel;
    }

    //------------------------------------------------------------------------------
    int CKernel::adjtime( const struct timeval* in, struct timeval* out )
    {
        /*
        struct timex tx = { 0 };

        if (in)
        {
            if (in->tv_sec > 1000 || in->tv_usec > 1000000000)
            {
                errno = EINVAL;
                return -1;
            }
            tx.offset = in->tv_sec*1000000 + in->tv_usec;
            tx.modes = ADJ_OFFSET_SINGLESHOT;
        }

        if( syscall( SYS_adjtimex, &tx ) < 0 )
        {
            return -1;
        }

        if( out )
        {
            out->tv_sec = tx.offset / 1000000;
            if ((out->tv_usec = tx.offset % 1000000) < 0)
            {
                out->tv_sec--;
                out->tv_usec += 1000000;
            }
        }
        */
        return 0;
    }

    //------------------------------------------------------------------------------
    int CKernel::brk( void* end )
    {
        return 0;//-( syscall( SYS_brk, end ) != (unsigned long) end );
    }

    //------------------------------------------------------------------------------
    uintptr_t CKernel::__brk( uintptr_t newbrk )
    {
        return 0;//syscall( SYS_brk, newbrk );
    }

    //------------------------------------------------------------------------------
    void* CKernel::__mmap( void* start, size_t len, int prot, int flags, int fd, off_t off )
    {
        void *ret = 0;
/*
        if( off & OFF_MASK )
        {
            errno = EINVAL;
            return MAP_FAILED;
        }

        if( len >= PTRDIFF_MAX )
        {
            errno = ENOMEM;
            return MAP_FAILED;
        }

        if( flags & MAP_FIXED )
        {
            //TODO:__vm_lock( -1 );
        }

#ifdef SYS_mmap2
        ret = (void*)syscall( SYS_mmap2, start, len, prot, flags, fd, off >> 12 );
#else
        ret = (void*)syscall( SYS_mmap, start, len, prot, flags, fd, off );
#endif
        if( flags & MAP_FIXED )
        {
            //TODO:__vm_unlock();
        }
        */
        return ret;
    }

    //------------------------------------------------------------------------------
    int CKernel::__madvise( void* addr, size_t len, int advice )
    {
        return 0;//syscall( SYS_madvise, addr, len, advice );
    }

    //------------------------------------------------------------------------------
    void* CKernel::__mremap( void* old_addr, size_t old_len, size_t new_len, int flags, ... )
    {
    /*
        __builtin_va_list ap;
        void* new_addr;

        va_start( ap, flags );
        new_addr = va_arg( ap, void* );
        va_end( ap );

        return (void*)syscall( SYS_mremap, old_addr, old_len, new_len, flags, new_addr );
        */
        return 0;
    }

    //------------------------------------------------------------------------------
    int CKernel::__munmap( void* start, size_t len )
    {
    /*
        int ret;
        //TODO:__vm_lock(-1);
        ret = syscall( SYS_munmap, start, len );
        //TODO:__vm_unlock();
        return ret;
        */
        return 0;
    }

    //------------------------------------------------------------------------------
    void CKernel::__wake( void* addr, int cnt, int priv )
    {
        //__syscall( SYS_futex, addr, FUTEX_WAKE, ( cnt ) < 0 ? INT_MAX : ( cnt ) );
    }

    //------------------------------------------------------------------------------
    void CKernel::__wait( volatile int* addr, volatile int* waiters, int val, int priv )
    {
    /*
        int spins = 10000;
        if( priv )
        {
            priv = 128;
            priv = 0;
        }

        while( spins-- )
        {
            if( *addr == val )
            {
                a_spin();
            }
            else
            {
                return;
            }
        }

        if( waiters )
        {
            a_inc( waiters );
        }

        while( *addr == val )
        {
            __syscall( SYS_futex, (long)addr, FUTEX_WAIT | priv, val, 0 );
        }

        if( waiters )
        {
            a_dec( waiters );
        }
        */
    }

    //------------------------------------------------------------------------------
    long __syscall_ret( unsigned long r )
    {
        if (r > -4096UL)
        {
            //TODO: errno = -r;
            return -1;
        }
        return r;
    }

}//nsLinQSys


