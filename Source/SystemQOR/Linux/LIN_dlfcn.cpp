//LIN_dlfcn.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "SystemQOR.h"

#if		(QOR_SYS_OS == QOR_SYS_LINUX)

#include "SystemQOR/Linux/LIN_dlfcn.h"

//--------------------------------------------------------------------------------
namespace nsLinux
{
	//--------------------------------------------------------------------------------
	Cdlfcn::Cdlfcn()
	{
		//__QCS_MEMBER_FCONTEXT( "Cdlfcn::Cdlfcn" );
	}

	//--------------------------------------------------------------------------------
	Cdlfcn::~Cdlfcn()
	{
		//__QCS_MEMBER_FCONTEXT( "Cdlfcn::~Cdlfcn" );
	}

	//--------------------------------------------------------------------------------
    int Cdlfcn::dlclose( void* pLibrary )
    {
		//__QCS_MEMBER_FCONTEXT( "Cdlfcn::dlclose" );
		return 0;//invalid_dso_handle( pLibrary );
    }

    //--------------------------------------------------------------------------------
    char* Cdlfcn::dlerror( void )
    {
		//__QCS_MEMBER_FCONTEXT( "Cdlfcn::dlerror" );
		/*
		if( !errflag )
		{
			return 0;
		}
		errflag = 0;
		return errbuf;
		*/
		return 0;
    }

	//--------------------------------------------------------------------------------
	void* Cdlfcn::__tls_get_new(size_t *v)
	{
	/*
		pthread_t self = __pthread_self();

		// Block signals to make accessing new TLS async-signal-safe
		sigset_t set;
		__block_all_sigs( &set );
		if( v[ 0 ] <= (size_t)self->dtv[ 0 ] )
		{
			__restore_sigs( &set );
			return (char *)self->dtv[ v[ 0 ] ] +v[ 1 ];
		}

		// This is safe without any locks held because, if the caller is able to request the Nth entry of the DTV, the DSO list
        //must be valid at least that far out and it was synchronized at program startup or by an already-completed call to dlopen.
		dso* p;
		for( p = head; p->tls_id != v[ 0 ]; p = p->next );

		// Get new DTV space from new DSO if needed
		if( v[ 0 ] > (size_t)self->dtv[ 0 ] )
		{
			void** newdtv = p->new_dtv + ( v[ 0 ] + 1 ) * sizeof( void* ) * a_fetch_add( &p->new_dtv_idx, 1 );
			memcpy( newdtv, self->dtv, ( (size_t)self->dtv[ 0 ] + 1 ) * sizeof( void* ) );
			newdtv[ 0 ] = (void*)v[ 0 ];
			self->dtv = newdtv;
		}

		// Get new TLS memory from all new DSOs up to the requested one
		unsigned char* mem;
		for( p = head; ; p = p->next )
		{
			if( !p->tls_id || self->dtv[ p->tls_id ] )
			{
				continue;
			}
			mem = p->new_tls + ( p->tls_size + p->tls_align ) * a_fetch_add( &p->new_tls_idx, 1 );
			mem += ( (uintptr_t)p->tls_image - (uintptr_t)mem ) & ( p->tls_align - 1 );
			self->dtv[ p->tls_id ] = mem;
			memcpy( mem, p->tls_image, p->tls_len );
			if( p->tls_id == v[ 0 ] )
			{
				break;
			}
		}
		__restore_sigs( &set );
		return mem + v[ 1 ];
		*/
		return 0;
	}

	//--------------------------------------------------------------------------------
	void Cdlfcn::update_tls_size()
	{
		//libc.tls_size = ALIGN( (1 + tls_cnt ) * sizeof( void* ) + tls_offset + sizeof( pthread ) + tls_align * 2, tls_align );
	}

	//--------------------------------------------------------------------------------
	void* Cdlfcn::__dynlink( int argc, char** argv )
	{
	/*
		__QCS_MEMBER_FCONTEXT( "Cdlfcn::__dynlink" );
		size_t aux[ AUX_CNT ] = { 0 };
		size_t i;
		Phdr *phdr;
		Ehdr *ehdr;
		static dso builtin_dsos[ 3 ];
		dso* const app = builtin_dsos+0;
		dso* const lib = builtin_dsos+1;
		dso* const vdso = builtin_dsos+2;
		char* env_preload = 0;
		size_t vdso_base;
		size_t* auxv;
		char** envp = argv + argc + 1;
		void* initial_tls;

		// Find aux vector just past environ[]
		for( i = argc + 1; argv[ i ]; i++ )
		{
			if( !memcmp( argv[ i ], "LD_LIBRARY_PATH=", 16 ) )
			{
				env_path = argv[ i ] + 16;
			}
			else if( !memcmp( argv[ i ], "LD_PRELOAD=", 11 ) )
			{
				env_preload = argv[ i ]+11;
			}
		}

		auxv = (void *)( argv + i + 1 );

		decode_vec( auxv, aux, AUX_CNT );

		// Only trust user/env if kernel says we're not suid/sgid
		if( ( aux[ 0 ] & 0x7800 ) != 0x7800 || aux[ AT_UID ] != aux[ AT_EUID ] || aux[ AT_GID ] != aux[ AT_EGID ] || aux[ AT_SECURE ] )
		{
			env_path = 0;
			env_preload = 0;
			libc.secure = 1;
		}
		libc.page_size = aux[ AT_PAGESZ ];

		// If the dynamic linker was invoked as a program itself, AT_BASE will not be set. In that case, we assume the base address is
        //the start of the page containing the PHDRs; I don't know any better approach...
		if( !aux[ AT_BASE ] )
		{
			aux[ AT_BASE ] = aux[ AT_PHDR ] & -PAGE_SIZE;
			aux[ AT_PHDR ] = aux[ AT_PHENT ] = aux[ AT_PHNUM ] = 0;
		}

		// The dynamic linker load address is passed by the kernel in the AUX vector, so this is easy.
		lib->base = (void*)aux[ AT_BASE ];
		lib->name = lib->shortname = "libc.so";
		lib->global = 1;
		ehdr = (void *)lib->base;
		lib->phnum = ehdr->e_phnum;
		lib->phdr = (void *)( aux[ AT_BASE ] + ehdr->e_phoff );
		lib->phentsize = ehdr->e_phentsize;
		kernel_mapped_dso( lib );
		decode_dyn( lib );

		if( aux[ AT_PHDR ] )
		{
			size_t interp_off = 0;
			size_t tls_image = 0;
			// Find load address of the main program, via AT_PHDR vs PT_PHDR.
			app->phdr = phdr = (void *)aux[ AT_PHDR ];
			app->phnum = aux[ AT_PHNUM ];
			app->phentsize = aux[ AT_PHENT ];
			for( i = aux[ AT_PHNUM ]; i; i--, phdr=(void *)((char *)phdr + aux[ AT_PHENT ] ) )
			{
				if( phdr->p_type == PT_PHDR )
				{
					app->base = (void*)( aux[ AT_PHDR ] - phdr->p_vaddr );
				}
				else if( phdr->p_type == PT_INTERP )
				{
					interp_off = (size_t)phdr->p_vaddr;
				}
				else if( phdr->p_type == PT_TLS )
				{
					tls_image = phdr->p_vaddr;
					app->tls_len = phdr->p_filesz;
					app->tls_size = phdr->p_memsz;
					app->tls_align = phdr->p_align;
				}
			}

			if( app->tls_size )
			{
				app->tls_image = (char *)app->base + tls_image;
			}

			if( interp_off )
			{
				lib->name = (char *)app->base + interp_off;
			}

			if( ( aux[ 0 ] & ( 1UL << AT_EXECFN ) ) && strncmp( (char*)aux[ AT_EXECFN ], "/proc/", 6 ) )
			{
				app->name = (char *)aux[ AT_EXECFN ];
			}
			else
			{
				app->name = argv[ 0 ];
			}
			kernel_mapped_dso( app );
		}
		else
		{
			int fd;
			char* ldname = argv[ 0 ];
			size_t l = strlen( ldname );
			if( l >= 3 && !strcmp( ldname + l - 3, "ldd" ) )
			{
				ldd_mode = 1;
			}
			*argv++ = (void *)-1;
			while( argv[ 0 ] && argv[ 0 ][ 0 ]=='-' && argv[ 0 ][ 1 ] == '-' )
			{
				char* opt = argv[ 0 ] + 2;
				*argv++ = (void*)-1;
				if( !*opt )
				{
					break;
				}
				else if( !memcmp( opt, "list", 5 ) )
				{
					ldd_mode = 1;
				}
				else if( !memcmp( opt, "library-path", 12 ) )
				{
					if( opt[ 12 ] == '=' )
					{
						env_path = opt+13;
					}
					else if( opt[ 12 ] )
					{
						*argv = 0;
					}
					else if( *argv )
					{
						env_path = *argv++;
					}
				}
				else if( !memcmp( opt, "preload", 7 ) )
				{
					if( opt[ 7 ] == '=' )
					{
						env_preload = opt + 8;
					}
					else if( opt[ 7 ] )
					{
						*argv = 0;
					}
					else if( *argv )
					{
						env_preload = *argv++;
					}
				}
				else
				{
					argv[ 0 ] = 0;
				}
				argv[ -1 ] = (void*)-1;
			}

			if( !argv[ 0 ] )
			{
				dprintf( 2, "musl libc\n"
					"Version %s\n"
					"Dynamic Program Loader\n"
					"Usage: %s [options] [--] pathname%s\n",
					__libc_get_version(), ldname,
					ldd_mode ? "" : " [args]");
				_exit( 1 );
			}

			fd = open( argv[ 0 ], O_RDONLY );
			if( fd < 0 )
			{
				dprintf( 2, "%s: cannot load %s: %s\n", ldname, argv[ 0 ], strerror( errno ) );
				_exit( 1 );
			}

			runtime = 1;
			ehdr = (void *)map_library( fd, app );
			if( !ehdr )
			{
				dprintf( 2, "%s: %s: Not a valid dynamic program\n", ldname, argv[ 0 ] );
				_exit( 1 );
			}
			runtime = 0;
			close( fd );
			lib->name = ldname;
			app->name = argv[ 0 ];
			aux[ AT_ENTRY ] = (size_t)app->base + ehdr->e_entry;
			// Find the name that would have been used for the dynamic linker had ldd not taken its place.
			if( ldd_mode )
			{
				for( i = 0; i < app->phnum; i++ )
				{
					if( app->phdr[ i ].p_type == PT_INTERP )
					{
						lib->name = (void *)( app->base + app->phdr[ i ].p_vaddr );
					}
				}
				dprintf( 1, "\t%s (%p)\n", lib->name, lib->base );
			}
		}

		if( app->tls_size )
		{
			app->tls_id = tls_cnt = 1;
	#ifdef TLS_ABOVE_TP
			app->tls_offset = 0;
			tls_offset = app->tls_size + ( -( (uintptr_t)app->tls_image + app->tls_size ) & ( app->tls_align - 1 ) );
	#else
			tls_offset = app->tls_offset = app->tls_size + ( -((uintptr_t)app->tls_image + app->tls_size ) & (app->tls_align-1) );
	#endif
			tls_align = MAXP2( tls_align, app->tls_align );
		}

		app->global = 1;
		decode_dyn( app );

		// Attach to vdso, if provided by the kernel
		if( search_vec( auxv, &vdso_base, AT_SYSINFO_EHDR ) )
		{
			ehdr = (void *)vdso_base;
			vdso->phdr = phdr = (void *)( vdso_base + ehdr->e_phoff );
			vdso->phnum = ehdr->e_phnum;
			vdso->phentsize = ehdr->e_phentsize;
			for( i = ehdr->e_phnum; i; i--, phdr=(void *)((char *)phdr + ehdr->e_phentsize ) )
			{
				if( phdr->p_type == PT_DYNAMIC )
				{
					vdso->dynv = (void *)( vdso_base + phdr->p_offset );
				}
				if( phdr->p_type == PT_LOAD )
				{
					vdso->base = (void *)( vdso_base - phdr->p_vaddr + phdr->p_offset );
				}
			}
			vdso->name = "";
			vdso->shortname = "linux-gate.so.1";
			vdso->global = 1;
			decode_dyn( vdso );
			vdso->prev = lib;
			lib->next = vdso;
		}

		// Initial dso chain consists only of the app. We temporarily append the dynamic linker/libc so we can relocate it, then
        //restore the initial chain in preparation for loading third party libraries (preload/needed).
		head = tail = app;
		ldso = lib;
		app->next = lib;
		reloc_all( lib );
		app->next = 0;

		// PAST THIS POINT, ALL LIBC INTERFACES ARE FULLY USABLE.

		// Donate unused parts of app and library mapping to malloc
		reclaim_gaps( app );
		reclaim_gaps( lib );

		// Load preload/needed libraries, add their symbols to the global namespace, and perform all remaining relocations. The main
        //program must be relocated LAST since it may contain copy relocations which depend on libraries' relocations.
		if( env_preload )
		{
			load_preload( env_preload );
		}
		load_deps( app );
		make_global( app );

#ifndef DYNAMIC_IS_RO
		for( i = 0; app->dynv[ i ]; i += 2 )
		{
			if( app->dynv[ i ] == DT_DEBUG )
			{
				app->dynv[ i + 1 ] = (size_t)&debug;
			}
		}
#endif

		reloc_all( app->next );
		reloc_all( app );

		update_tls_size();
		if( libc.tls_size > sizeof builtin_tls )
		{
			initial_tls = calloc( libc.tls_size, 1 );
			if( !initial_tls )
			{
				dprintf( 2, "%s: Error getting %zu bytes thread-local storage: %m\n", argv[ 0 ], libc.tls_size );
				_exit( 127 );
			}
		}
		else
		{
			initial_tls = builtin_tls;
		}

		if( __init_tp( __copy_tls( initial_tls ) ) < 0 && tls_cnt )
		{
			dprintf( 2, "%s: Thread-local storage not supported by kernel.\n", argv[ 0 ] );
			_exit( 127 );
		}

		static_tls_cnt = tls_cnt;

		if( ldso_fail )
		{
			_exit( 127 );
		}

		if( ldd_mode )
		{
			_exit( 0 );
		}

		// Switch to runtime mode: any further failures in the dynamic linker are a reportable failure rather than a fatal startup
        //error. If the dynamic loader (dlopen) will not be used, free all memory used by the dynamic linker.
		runtime = 1;

		debug.ver = 1;
		debug.bp = _dl_debug_state;
		debug.head = head;
		debug.base = lib->base;
		debug.state = 0;
		_dl_debug_state();

		__init_libc( envp, argv[ 0 ] );
		atexit( do_fini );
		errno = 0;
		do_init_fini( tail );

		return (void *)aux[ AT_ENTRY ];
		*/
		return 0;
	}

    //--------------------------------------------------------------------------------
    void* Cdlfcn::dlopen( const char* file, int mode )
    {
    /*
		__QCS_MEMBER_FCONTEXT( "Cdlfcn::dlopen" );

		dso* volatile p, *orig_tail, *next;
		size_t orig_tls_cnt, orig_tls_offset, orig_tls_align;
		size_t i;
		int cs;
		jmp_buf jb;

		if( !file )
		{
			return head;
		}

		pthread_setcancelstate( PTHREAD_CANCEL_DISABLE, &cs );
		pthread_rwlock_wrlock( &lock );
		__inhibit_ptc();

		p = 0;
		orig_tls_cnt = tls_cnt;
		orig_tls_offset = tls_offset;
		orig_tls_align = tls_align;
		orig_tail = tail;
		noload = mode & RTLD_NOLOAD;

		rtld_fail = &jb;
		if( setjmp( *rtld_fail ) )
		{
			// Clean up anything new that was (partially) loaded
			if( p && p->deps )
			{
				for( i = 0; p->deps[ i ]; i++ )
				{
					if( p->deps[ i ]->global < 0 )
					{
						p->deps[ i ]->global = 0;
					}
				}
			}

			for( p = orig_tail->next; p; p = next )
			{
				next = p->next;
				munmap( p->map, p->map_len );
				while( p->td_index )
				{
					void* tmp = p->td_index->next;
					free( p->td_index );
					p->td_index = tmp;
				}
				free( p->deps );
				free( p );
			}

			tls_cnt = orig_tls_cnt;
			tls_offset = orig_tls_offset;
			tls_align = orig_tls_align;
			tail = orig_tail;
			tail->next = 0;
			p = 0;
			errflag = 1;
			goto end;
		}
		else
		{
			p = load_library( file, head );
		}

		if( !p )
		{
			snprintf( errbuf, sizeof errbuf, noload ? "Library %s is not already loaded" : "Error loading shared library %s: %m", file );
			errflag = 1;
			goto end;
		}

		// First load handling
		if( !p->deps )
		{
			load_deps( p );
			if( p->deps )
			{
				for( i = 0; p->deps[ i ]; i++ )
				{
					if( !p->deps[ i ]->global )
					{
						p->deps[ i ]->global = -1;
					}
				}
			}
			if( !p->global )
			{
				p->global = -1;
			}
			reloc_all( p );
			if( p->deps )
			{
				for( i = 0; p->deps[ i ]; i++ )
				{
					if( p->deps[ i ]->global < 0 )
					{
						p->deps[ i ]->global = 0;
					}
				}
			}
			if( p->global < 0 )
			{
				p->global = 0;
			}
		}

		if( mode & RTLD_GLOBAL )
		{
			if( p->deps )
			{
				for( i = 0; p->deps[ i ]; i++ )
				{
					p->deps[i]->global = 1;
				}
			}
			p->global = 1;
		}

		update_tls_size();
		_dl_debug_state();
		orig_tail = tail;

	end:
		__release_ptc();
		if( p )
		{
			gencnt++;
		}
		pthread_rwlock_unlock( &lock );
		if( p )
		{
			do_init_fini( orig_tail );
		}
		pthread_setcancelstate( cs, 0 );
		return p;
		*/
		return 0;
	}

	//--------------------------------------------------------------------------------
	int Cdlfcn::invalid_dso_handle( void* h )
	{
        /*
		dso* p;
		for( p = head; p; p = p->next )
		{
			if( h == p )
			{
				return 0;
			}
		}
		snprintf( errbuf, sizeof errbuf, "Invalid library handle %p", (void *)h );
		errflag = 1;
		*/
		return 1;
	}

	void *__tls_get_addr(size_t *);

	//--------------------------------------------------------------------------------
	void* Cdlfcn::dlsym( void* p, const char* s)
	{
		return 0;//__dlsym( p, s, 0 );
	}

	//--------------------------------------------------------------------------------
	void* Cdlfcn::do_dlsym( void* p, const char* s, void* ra )
	{
	/*
		size_t i;
		uint32_t h = 0, gh = 0;
		Sym *sym;
		if( p == head || p == RTLD_DEFAULT || p == RTLD_NEXT )
		{
			if( p == RTLD_DEFAULT )
			{
				p = head;
			}
			else if( p == RTLD_NEXT )
			{
				for( p = head; p && (unsigned char *)ra-p->map>p->map_len; p = p->next );
				if( !p )
				{
					p = head;
				}
				p = p->next;
			}
			symdef def = find_sym(p, s, 0);
			if (!def.sym) goto failed;
			if ((def.sym->st_info&0xf) == STT_TLS)
				return __tls_get_addr((size_t []){def.dso->tls_id, def.sym->st_value});
			return def.dso->base + def.sym->st_value;
		}

		if( p != RTLD_DEFAULT && p != RTLD_NEXT && invalid_dso_handle(p))
		{
			return 0;
		}

		if( p->ghashtab )
		{
			gh = gnu_hash(s);
			sym = gnu_lookup(s, gh, p);
		}
		else
		{
			h = sysv_hash(s);
			sym = sysv_lookup(s, h, p);
		}

		if (sym && (sym->st_info&0xf) == STT_TLS)
		{
			return __tls_get_addr((size_t []){p->tls_id, sym->st_value});
		}
		if( sym && sym->st_value && (1<<(sym->st_info&0xf) & OK_TYPES) )
		{
			return p->base + sym->st_value;
		}
		if( p->deps) for (i=0; p->deps[i]; i++ )
		{
			if( p->deps[i]->ghashtab)
			{
				if (!gh) gh = gnu_hash(s);
				sym = gnu_lookup(s, gh, p->deps[i]);
			}
			else
			{
				if (!h) h = sysv_hash(s);
				sym = sysv_lookup(s, h, p->deps[i]);
			}

			if (sym && (sym->st_info&0xf) == STT_TLS)
			{
				return __tls_get_addr((size_t []){p->deps[i]->tls_id, sym->st_value});
			}
			if (sym && sym->st_value && (1<<(sym->st_info&0xf) & OK_TYPES))
			{
				return p->deps[i]->base + sym->st_value;
			}
		}

	failed:

		errflag = 1;
		snprintf(errbuf, sizeof errbuf, "Symbol not found: %s", s);
		*/
		return 0;
	}

	//--------------------------------------------------------------------------------
	int Cdlfcn::__dladdr(const void *addr, Dl_info *info)
	{
	/*
		struct dso *p;
		Sym *sym;
		uint32_t nsym;
		char *strings;
		size_t i;
		void *best = 0;
		char *bestname;

		pthread_rwlock_rdlock(&lock);
		for (p=head; p && (unsigned char *)addr-p->map>p->map_len; p=p->next);
		pthread_rwlock_unlock(&lock);

		if (!p) return 0;

		sym = p->syms;
		strings = p->strings;
		if (p->hashtab) {
			nsym = p->hashtab[1];
		} else {
			uint32_t *buckets;
			uint32_t *hashval;
			buckets = p->ghashtab + 4 + (p->ghashtab[2]*sizeof(size_t)/4);
			sym += p->ghashtab[1];
			for (i = nsym = 0; i < p->ghashtab[0]; i++) {
				if (buckets[i] > nsym)
					nsym = buckets[i];
			}
			if (nsym) {
				nsym -= p->ghashtab[1];
				hashval = buckets + p->ghashtab[0] + nsym;
				do nsym++;
				while (!(*hashval++ & 1));
			}
		}

		for (; nsym; nsym--, sym++) {
			if (sym->st_value
			 && (1<<(sym->st_info&0xf) & OK_TYPES)
			 && (1<<(sym->st_info>>4) & OK_BINDS)) {
				void *symaddr = p->base + sym->st_value;
				if (symaddr > addr || symaddr < best)
					continue;
				best = symaddr;
				bestname = strings + sym->st_name;
				if (addr == symaddr)
					break;
			}
		}

		if (!best) return 0;

		info->dli_fname = p->name;
		info->dli_fbase = p->base;
		info->dli_sname = bestname;
		info->dli_saddr = best;
*/
		return 1;
	}

	//--------------------------------------------------------------------------------
	void* Cdlfcn::__dlsym( void* __restrict p, const char* __restrict s, void* __restrict ra )
	{
		void* res;
		/*
		pthread_rwlock_rdlock( &lock );
		res = do_dlsym( p, s, ra );
		pthread_rwlock_unlock( &lock );
		*/
		return res;
	}

	//--------------------------------------------------------------------------------
	//int Cdlfcn::dl_iterate_phdr( (int)(*callback)( void* , size_t , void* ), void* data )
	//{

		//dso* current;
		//dl_phdr_info info;
		//int ret = 0;
    /*
		for( current = head; current; )
		{
			info.dlpi_addr      = (uintptr_t)current->base;
			info.dlpi_name      = current->name;
			info.dlpi_phdr      = current->phdr;
			info.dlpi_phnum     = current->phnum;
			info.dlpi_adds      = gencnt;
			info.dlpi_subs      = 0;
			info.dlpi_tls_modid = current->tls_id;
			info.dlpi_tls_data  = current->tls_image;

			ret = (callback)( &info, sizeof(info), data );

			if( ret != 0 )
			{
				break;
			}

			pthread_rwlock_rdlock( &lock );
			current = current->next;
			pthread_rwlock_unlock( &lock );
		}
		*/
		//return ret;
	//}


}//nsLinux

#endif//(QOR_SYS_OS == QOR_SYS_LINUX)
