//LIN_aio.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "SystemQOR.h"

#if		(QOR_SYS_OS == QOR_SYS_LINUX)
#include <aio.h>
#include <errno.h>
#include <pthread.h>
#include "SystemQOR/Linux/LIN_aio.h"
#include "SystemQOR/Linux/types/aio_types.h"

//--------------------------------------------------------------------------------
namespace nsLinux
{
	//--------------------------------------------------------------------------------
    int Caio::cancel( int iFD, aiocb* paiocb )
    {
		if( !paiocb )
		{
			/*TODO: for correctness, we should return AIO_ALLDONE
			 * if there are no outstanding aio operations on this
			 * file descriptor, but that would require making aio
			 * much slower, and seems to have little advantage since
			 * we don't support cancellation anyway. */
			return AIO_NOTCANCELED;
		}
		return paiocb->__err == EINPROGRESS ? AIO_NOTCANCELED : AIO_ALLDONE;
    }

    //--------------------------------------------------------------------------------
    int Caio::error( const aiocb* paiocb )
    {
		return paiocb->__err;
    }

    //--------------------------------------------------------------------------------
    int Caio::read( aiocb* paiocb )
    {
		paiocb->aio_lio_opcode = LIO_READ;
		return new_req( paiocb );
    }

    //--------------------------------------------------------------------------------
    int Caio::write( aiocb* paiocb )
    {
		paiocb->aio_lio_opcode = LIO_WRITE;
		return new_req( paiocb );
    }

	//private:

    //--------------------------------------------------------------------------------
	int Caio::new_req( aiocb* cb )
	{
		int ret = 0;
		/*
		pthread_attr_t a;
		sigset_t set;
		pthread_t td;

		if( cb->aio_sigevent.sigev_notify == SIGEV_THREAD )
		{
			if (cb->aio_sigevent.sigev_notify_attributes)
			{
				a = *cb->aio_sigevent.sigev_notify_attributes;
			}
			else
			{
				pthread_attr_init(&a);
			}
		}
		else
		{
			pthread_attr_init(&a);
			pthread_attr_setstacksize(&a, PAGE_SIZE);
			pthread_attr_setguardsize(&a, 0);
		}

		pthread_attr_setdetachstate( &a, PTHREAD_CREATE_DETACHED );
		sigfillset( &set );
		pthread_sigmask( SIG_BLOCK, &set, &set );
		cb->__err = EINPROGRESS;
		if( pthread_create( &td, &a, io_thread, cb ) )
		{
			errno = EAGAIN;
			ret = -1;
		}
		pthread_sigmask( SIG_SETMASK, &set, 0 );
		cb->__td = (void*)td;
*/
		return ret;
	}

	//--------------------------------------------------------------------------------
	static void dummy(void)
	{
	}

	//weak_alias(dummy, __aio_wake);

    //--------------------------------------------------------------------------------
	void* Caio::io_thread( void* p )
	{
	/*
		aiocb* cb = reinterpret_cast< aiocb* >( p );
		int fd = cb->aio_fildes;
		void *buf = (void *)cb->aio_buf;
		size_t len = cb->aio_nbytes;
		off_t off = cb->aio_offset;
		int op = cb->aio_lio_opcode;
		struct sigevent sev = cb->aio_sigevent;
		ssize_t ret;

		if (op == LIO_WRITE)
		{
			if (  (fcntl(fd, F_GETFL) & O_APPEND) ||((ret = pwrite(fd, buf, len, off))<0 && errno==ESPIPE) )
			{
				ret = ::write(fd, buf, len);
			}
		}
		else if (op == LIO_READ)
		{
			if ( (ret = pread(fd, buf, len, off))<0 && errno==ESPIPE )
			{
				ret = ::read(fd, buf, len);
			}
		}
		else
		{
			ret = 0;
		}
		cb->__ret = ret;

		if (ret < 0 )
		{
			a_store(&cb->__err, errno);
		}
		else
		{
			a_store(&cb->__err, 0);
		}

		__aio_wake();

		switch (sev.sigev_notify)
		{
		case SIGEV_SIGNAL:
			notify_signal(&sev);
			break;
		case SIGEV_THREAD:
			sev.sigev_notify_function(sev.sigev_value);
			break;
		}
    */
		return 0;
	}
/*
	//--------------------------------------------------------------------------------
	void Caio::notify_signal( sigevent* sev )
	{
		siginfo_t si =
		{
			.si_signo = sev->sigev_signo,
			.si_value = sev->sigev_value,
			.si_code = SI_ASYNCIO,
			.si_pid = __pthread_self()->pid,
			.si_uid = getuid()
		};
		__syscall( SYS_rt_sigqueueinfo, si.si_pid, si.si_signo, &si );
	}
	*/

}//nsLinux

#endif//(QOR_SYS_OS == QOR_SYS_LINUX)
