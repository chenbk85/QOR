//Memory.h

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Memory

#ifndef LINQSYS_MEMORY_H_
#define LINQSYS_MEMORY_H_

#define __STDC_LIMIT_MACROS
#include <stdint.h>
#undef __STD_LIMIT_MACROS
#ifndef UINT64_MAX
#       if _QARCH_WORDSIZE == 64
#           define __INT64_C(c)	c ## L
#           define __UINT64_C(c)	c ## UL
#       else
#           define __INT64_C(c)	c ## LL
#           define __UINT64_C(c)	c ## ULL
#       endif

        // Maximum of signed integral types.
#       define INT8_MAX		    (127)
#       define INT16_MAX		(32767)
#       define INT32_MAX		(2147483647)
#       define INT64_MAX		(__INT64_C(9223372036854775807))

        // Maximum of unsigned integral types.
#       define UINT8_MAX		(255)
#       define UINT16_MAX		(65535)
#       define UINT32_MAX		(4294967295U)
#       define UINT64_MAX		(__UINT64_C(18446744073709551615))
#endif

#include "LinQSys/Kernel.h"

//------------------------------------------------------------------------------
namespace nsLinQSys
{
    //------------------------------------------------------------------------------
    class CMemory
    {
    public:

        //------------------------------------------------------------------------------
        struct chunk
        {
            size_t psize, csize;
            struct chunk *next, *prev;
        };

        //------------------------------------------------------------------------------
        struct bin
        {
            int lock[ 2 ];
            struct chunk *head;
            struct chunk *tail;
        };

        //------------------------------------------------------------------------------
        struct
        {
            uintptr_t brk;
            size_t* heap;
            uint64_t binmap;
            struct bin bins[ 64 ];
            int brk_lock[ 2 ];
            int free_lock[ 2 ];
        } mal;

        CMemory();
        ~CMemory();

        static CMemory& Instance( void );

        void* __simple_malloc( size_t n );

        inline void lock( volatile int* lk );
        inline void unlock( volatile int* lk );
        inline void lock_bin( int i );
        inline void unlock_bin( int i );
        static int first_set( uint64_t x );
        static int bin_index( size_t x );
        static int bin_index_up( size_t x );
        chunk* expand_heap( size_t n );
        int init_malloc( size_t n );
        static int adjust_size( size_t* n );
        void unbin( chunk* c, int i );
        int alloc_fwd( chunk* c );
        int alloc_rev( chunk* c );
        static int pretrim( chunk* self, size_t n, int i, int j );
        void trim( chunk* self, size_t n );

        void* malloc( size_t n );
        void* realloc( void* p, size_t n );
        void free( void* p );

    private:

        CMemory( const CMemory& src );
        CMemory& operator = ( const CMemory& src );


        CKernel m_Kernel;
        uintptr_t cur;
        uintptr_t brk;

        __QCMP_STATIC_CONSTANT( Cmp_unsigned_int, ALIGN = 16 );
        __QCMP_STATIC_CONSTANT( int, SIZE_ALIGN = ( 4 * sizeof( size_t ) ) );
        __QCMP_STATIC_CONSTANT( int, SIZE_MASK = ( -SIZE_ALIGN ) );
        __QCMP_STATIC_CONSTANT( int, OVERHEAD = ( 2 * sizeof( size_t ) ) );
        __QCMP_STATIC_CONSTANT( int, MMAP_THRESHOLD = ( 0x1c00 * SIZE_ALIGN ) );
        __QCMP_STATIC_CONSTANT( int, DONTCARE = 16 );
        __QCMP_STATIC_CONSTANT( int, RECLAIM = 163840 );

        __QCMP_STATIC_CONSTANT( size_t, C_INUSE = 1 );

    };

}//nsLinQSys


#endif//LINQSYS_FLOATSCAN_H_
