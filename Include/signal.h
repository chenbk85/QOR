//signal.h

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_SIGNAL_H_3
#define QOR_SIGNAL_H_3

#include <time.h>
#include "SystemQOR.h"
#include QOR_SYS_PLATFORMTYPES(signal)

#define SIG_DFL				( nsPlatform::SigDfl )			//Request for default signal handling. 
#define SIG_ERR				( nsPlatform::SigErr )			//Return value from signal() in case of error. 
#define SIG_HOLD			( nsPlatform::SigHold )			//[OB CX]  Request that signal be held.  
#define	SIG_IGN				( nsPlatform::SigIgn )			//Request that signal be ignored. 
#define SIG_GET				( nsPlatform::SigGet )			//(void (__cdecl *)(int))2           // return current value
#define SIG_SGE				( nsPlatform::SigSGE )			//(void (__cdecl *)(int))3           // signal gets error
#define SIG_ACK				( nsPlatform::SigAck )			//(void (__cdecl *)(int))4           // acknowledge

typedef nsPlatform::pthread_t pthread_t;
typedef nsPlatform::uid_t uid_t;
typedef nsPlatform::timespec timespec;
typedef nsPlatform::sig_atomic_t sig_atomic_t;
typedef nsPlatform::sigset_t sigset_t;
typedef nsPlatform::pid_t pid_t;
typedef nsPlatform::pthread_attr_t pthread_attr_t;
typedef nsPlatform::sigevent sigevent;

#define SIGEV_NONE		( nsPlatform::SigEventNone )	//No asynchronous notification is delivered when the event of interest occurs. 
#define SIGEV_SIGNAL	( nsPlatform::SigEventSignal )	//A queued signal, with an application-defined value, is generated when the event of interest occurs. 
#define SIGEV_THREAD	( nsPlatform::SigEventThread )	//A notification function is called to perform notification. 

typedef nsPlatform::sigval sigval;

#define	SIGRTMIN		( nsPlatform::SigRTMin )
#define SIGRTMAX		( nsPlatform::SigRTMax )

// Signals.
#define SIGABRT			( nsPlatform::SigAbort )		// A	// Process abort signal.
#define SIGALRM			( nsPlatform::SigAlarm )		// T	// Alarm clock.
#define SIGBUS			( nsPlatform::SigBus )			// A	// Access to an undefined portion of a memory object.
#define SIGCHLD			( nsPlatform::SigChild )		// I	// Child process terminated, stopped, [XSI] or continued. 
#define SIGCONT			( nsPlatform::SigContinue )		// C	// Continue executing, if stopped.
#define SIGFPE			( nsPlatform::SigFloatingPoint )// A	// Erroneous arithmetic operation. 
#define SIGHUP			( nsPlatform::SigHangup )		// T	// Hangup.
#define SIGILL			( nsPlatform::SigIllegal )		// A	// Illegal instruction. 
#define SIGINT			( nsPlatform::SigInterrupt )	// T	// Terminal interrupt signal.
#define SIGKILL			( nsPlatform::SigKill )			// T	// Kill (cannot be caught or ignored).
#define SIGPIPE			( nsPlatform::SigPipe )			// T	// Write on a pipe with no one to read it.
#define SIGQUIT			( nsPlatform::SigQuit )			// A	// Terminal quit signal.
#define SIGSEGV			( nsPlatform::SigSegV )			// A	// Invalid memory reference.
#define SIGSTOP			( nsPlatform::SigStop )			// S	// Stop executing (cannot be caught or ignored).
#define SIGTERM			( nsPlatform::SigTerm )			// T	// Termination signal.
#define SIGTSTP			( nsPlatform::SigTermStop )		// S	// Terminal stop signal.
#define SIGTTIN			( nsPlatform::SigTTIN )			// S	// Background process attempting read.
#define SIGTTOU			( nsPlatform::SigTTOU )			// S	// Background process attempting write.
#define SIGUSR1			( nsPlatform::SigUsr1 )			// T	// User-defined signal 1.
#define SIGUSR2			( nsPlatform::SigUsr2 )			// T	// User-defined signal 2. 
#define SIGPOLL			( nsPlatform::SigPoll )			// T	// Pollable event.  
#define SIGPROF			( nsPlatform::SigProf )			// T	// Profiling timer expired.  
#define SIGSYS			( nsPlatform::SigSys )			// A	// Bad system call. 
#define SIGTRAP			( nsPlatform::SigTrap )			// A	// Trace/breakpoint trap. 
#define SIGURG			( nsPlatform::SigUrg )			// I	// High bandwidth data is available at a socket.
#define SIGVTALRM		( nsPlatform::SigVTAlarm )		// T	// Virtual timer expired.
#define SIGXCPU			( nsPlatform::SigXCPU )			// A	// CPU time limit exceeded.
#define SIGXFSZ			( nsPlatform::SigXFSz )			// A	// File size limit exceeded. 
 


//typedef nsPlatform::sigaction sigaction;

#define SIG_BLOCK				0										//[CX]  The resulting set is the union of the current set and the signal set pointed to by the argument set.  
#define SIG_UNBLOCK				1										//[CX]  The resulting set is the intersection of the current set and the complement of the signal set pointed to by the argument set.  
#define SIG_SETMASK				2										//[CX]  The resulting set is the signal set pointed to by the argument set.  

#define SA_NOCLDSTOP			( nsPlatform::SANochildStop )			//[CX]  Do not generate SIGCHLD when children stop [XSI]   or stopped children continue.  
#define SA_ONSTACK				( nsPlatform::SAOnStack )				//[XSI]  Causes signal delivery to occur on an alternate stack.  
#define SA_RESETHAND			( nsPlatform::SAResetHanders )			//[CX]  Causes signal dispositions to be set to SIG_DFL on entry to signal handlers.  
#define SA_RESTART				( nsPlatform::SARestart )				//[CX]  Causes certain functions to become restartable.  
#define SA_SIGINFO				( nsPlatform::SASigInfo )				//[CX]  Causes extra information to be passed to signal handlers at the time of receipt of a signal.  
#define SA_NOCLDWAIT			( nsPlatform::SANoChildWait )			//[CX]  Causes implementations not to create zombie processes on child death.  
#define SA_NODEFER				( nsPlatform::SANoDefer )				//[CX]  Causes signal not to be automatically blocked on entry to signal handler.  
#define SS_ONSTACK				( nsPlatform::SSOnStack )				//[XSI]  Process is executing on an alternate signal stack.  
#define SS_DISABLE				( nsPlatform::SSDisable )				//[XSI]  Alternate signal stack is disabled.  
#define MINSIGSTKSZ				( nsPlatform::MinSigStackSize )			//[XSI]  Minimum stack size for a signal handler.  
#define SIGSTKSZ				( nsPlatform::SigStackSize )			//[XSI]  Default size in bytes for the alternate signal stack.  

typedef nsPlatform::mcontext_t mcontext_t;
typedef nsPlatform::ucontext_t ucontext_t;
typedef nsPlatform::stack_t stack_t;
typedef nsPlatform::siginfo_t siginfo_t;

//SIGILL Reason codes
#define ILL_ILLOPC				( nsPlatform::IllegalOpCode )			// Illegal opcode.
#define ILL_ILLOPN				( nsPlatform::IllegalOperand )			// Illegal operand.
#define ILL_ILLADR				( nsPlatform::IllegalAddrMode )			// Illegal addressing mode.
#define ILL_ILLTRP				( nsPlatform::IllegalTrap )				// Illegal trap.
#define ILL_PRVOPC				( nsPlatform::PrivilegedOpCode )		// Privileged opcode.
#define ILL_PRVREG				( nsPlatform::PrivilegedRegister )		// Privileged register.
#define ILL_COPROC				( nsPlatform::CoprocessorError )		// Coprocessor error.
#define ILL_BADSTK				( nsPlatform::InternalStackError )		// Internal stack error.

//SIGFPE Reason codes
#define FPE_INTDIV				( nsPlatform::IntegerDivideByZero )		// Integer divide by zero.
#define FPE_INTOVF				( nsPlatform::IntegerOverflow )			// Integer overflow.
#define FPE_FLTDIV				( nsPlatform::FloatingPntDivByZero )	// Floating-point divide by zero.
#define FPE_FLTOVF				( nsPlatform::FloatingPntOverflow )		// Floating-point overflow.
#define FPE_FLTUND				( nsPlatform::FloatingPntUnderflow )	// Floating-point underflow.
#define FPE_FLTRES				( nsPlatform::FloatingPntInexact )		// Floating-point inexact result.
#define FPE_FLTINV				( nsPlatform::InvalidFloatingPntOp )	// Invalid floating-point operation.
#define FPE_FLTSUB				( nsPlatform::SubscriptOutOfRange )		// Subscript out of range.

//SIGSEGV Reason codes
#define SEGV_MAPERR				( nsPlatform::AddrNotMappedtoObj )		// Address not mapped to object.
#define SEGV_ACCERR				( nsPlatform::InvalidPermForMapObj )	// Invalid permissions for mapped object.

//SIGBUS Reason codes
#define BUS_ADRALN				( nsPlatform::InvalidAddrAlignment )	// Invalid address alignment.
#define BUS_ADRERR				( nsPlatform::NonPhysicalAddr )			// Nonexistent physical address.
#define BUS_OBJERR				( nsPlatform::ObjectHardwareError )		// Object-specific hardware error. 
 
//SIGTRAP Reason codes
#define TRAP_BRKPT				( nsPlatform::TrapBreakPoint )			// Process breakpoint.
#define TRAP_TRACE				( nsPlatform::TrapTrace )				// Process trace trap.

//SIGCHLD Reason codes
#define CLD_EXITED				( nsPlatform::ChildHasExited )			// Child has exited.
#define CLD_KILLED				( nsPlatform::ChildKilled )				// Child has terminated abnormally and did not create a core file.
#define CLD_DUMPED				( nsPlatform::ChildDumped )				// Child has terminated abnormally and created a core file.
#define CLD_TRAPPED				( nsPlatform::ChildTrapped )			// Traced child has trapped.
#define CLD_STOPPED				( nsPlatform::ChildStopped )			// Child has stopped.
#define CLD_CONTINUED			( nsPlatform::ChildContinued )			// Stopped child has continued. 
 
//SIGPOLL Reason codes
#define POLL_IN					( nsPlatform::PollIn )					// Data input available.
#define POLL_OUT				( nsPlatform::PollOut )					// Output buffers available.
#define POLL_MSG				( nsPlatform::PollMsg )					// Input message available.
#define POLL_ERR				( nsPlatform::PollErr )					// I/O error.
#define POLL_PRI				( nsPlatform::PollPri )					// High priority input available.
#define POLL_HUP				( nsPlatform::PollHUp )					// Device disconnected. 
 
//Any Reason codes
#define SI_USER					( nsPlatform::SIUser )					// Signal sent by kill().
#define SI_QUEUE				( nsPlatform::SIQueue )					// Signal sent by the sigqueue().
#define SI_TIMER				( nsPlatform::SITimer )					// Signal generated by expiration of a timer set by timer_settime().
#define SI_ASYNCIO				( nsPlatform::SIAsyncIO )				// Signal generated by completion of an asynchronous I/O request
#define SI_MESGQ				( nsPlatform::SIMesgQ )					// Signal generated by arrival of a message on an empty message queue 

__QCMP_STARTLINKAGE_C

#ifndef OS_EXPORTS_SIGNAL_SIGNAL
	__QOR_INTERFACE( __CQOR ) void signal( int sig, void (*func)( int ) );
#endif

#ifndef OS_EXPORTS_SIGNAL_RAISE
    __QOR_INTERFACE( __CQOR ) int raise( int sig );
#endif

	__QOR_INTERFACE( __CQOR ) int kill( pid_t, int );
	__QOR_INTERFACE( __CQOR ) int killpg( pid_t, int );
	__QOR_INTERFACE( __CQOR ) void psiginfo( const siginfo_t*, const char * );
	__QOR_INTERFACE( __CQOR ) void psignal( int, const char * );
	__QOR_INTERFACE( __CQOR ) int pthread_kill( pthread_t, int );
	__QOR_INTERFACE( __CQOR ) int pthread_sigmask( int, const sigset_t* __QCMP_RESTRICT, sigset_t* __QCMP_RESTRICT );
	__QOR_INTERFACE( __CQOR ) int sigaction( int, const nsPlatform::sigaction* __QCMP_RESTRICT, nsPlatform::sigaction* __QCMP_RESTRICT );
	__QOR_INTERFACE( __CQOR ) int sigaddset( sigset_t*, int );
	__QOR_INTERFACE( __CQOR ) int sigaltstack( const stack_t* __QCMP_RESTRICT, stack_t* __QCMP_RESTRICT );
	__QOR_INTERFACE( __CQOR ) int sigdelset( sigset_t*, int );
	__QOR_INTERFACE( __CQOR ) int sigemptyset( sigset_t* );
	__QOR_INTERFACE( __CQOR ) int sigfillset( sigset_t* );
	__QOR_INTERFACE( __CQOR ) int sighold( int );
	__QOR_INTERFACE( __CQOR ) int sigignore( int );
	__QOR_INTERFACE( __CQOR ) int siginterrupt( int, int );
	__QOR_INTERFACE( __CQOR ) int sigismember( const sigset_t*, int );
	__QOR_INTERFACE( __CQOR ) int sigpause( int );
	__QOR_INTERFACE( __CQOR ) int sigpending( sigset_t* );
	__QOR_INTERFACE( __CQOR ) int sigprocmask( int, const sigset_t* __QCMP_RESTRICT, sigset_t* __QCMP_RESTRICT );
	__QOR_INTERFACE( __CQOR ) int sigqueue( pid_t, int, const sigval );
	__QOR_INTERFACE( __CQOR ) int sigrelse( int );
	__QOR_INTERFACE( __CQOR ) void sigset( nsPlatform::psig_func, int );
	__QOR_INTERFACE( __CQOR ) int sigsuspend( const sigset_t* __QCMP_RESTRICT );
	__QOR_INTERFACE( __CQOR ) int sigtimedwait( const sigset_t* __QCMP_RESTRICT, siginfo_t* __QCMP_RESTRICT, const timespec* __QCMP_RESTRICT );
	__QOR_INTERFACE( __CQOR ) int sigwait( const sigset_t* __QCMP_RESTRICT, int* __QCMP_RESTRICT );
	__QOR_INTERFACE( __CQOR ) int sigwaitinfo( const sigset_t* __QCMP_RESTRICT, siginfo_t* __QCMP_RESTRICT );

__QCMP_ENDLINKAGE_C

#endif //QOR_SIGNAL_H_3
