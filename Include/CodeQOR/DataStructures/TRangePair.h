//TRangePair.h

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Range Pair class template specifically for the use of memory page range maps
//Be very careful using this as the semantics are not likely to be what you want

#ifndef CODEQOR_TRANGEPAIR_H_2
#define CODEQOR_TRANGEPAIR_H_2

#include "CompilerQOR.h"

#ifdef	__QCMP_OPTIMIZEINCLUDE
#pragma	__QCMP_OPTIMIZEINCLUDE
#endif//__QCMP_OPTIMIZEINCLUDE

#include "CodeQOR/DataStructures/TPair.h"

//--------------------------------------------------------------------------------
namespace nsCodeQOR
{
    //--------------------------------------------------------------------------------
    template< typename TScalar >
    class CTRangePair : public CTPair< TScalar, TScalar >
    {
		typedef CTPair< TScalar, TScalar > BaseName;

    public:
			
		__QCMP_USING_BASE( m_first );
		__QCMP_USING_BASE( m_second );

        //--------------------------------------------------------------------------------              
        CTRangePair()
		{
		}

        //--------------------------------------------------------------------------------
        //Construct from first and second items
        CTRangePair( const TScalar& base, const TScalar& delta ) : CTPair< TScalar, TScalar >( base, delta )
        {
        }

        //--------------------------------------------------------------------------------
        //copy construct from a pair of identical type
        CTRangePair( const CTPair< TScalar, TScalar >& srcPair ) : CTPair< TScalar, TScalar >( srcPair )
        {
        }

        //--------------------------------------------------------------------------------
        //copy construct from a range pair of identical type
        CTRangePair( const CTRangePair< TScalar >& srcPair ) : CTPair< TScalar, TScalar >( srcPair )
        {
        }

        //--------------------------------------------------------------------------------
        virtual ~CTRangePair()
		{
		}

        //--------------------------------------------------------------------------------
        CTRangePair& operator = ( const CTPair< TScalar, TScalar >& src )
        {
            if( &src != this )
            {
                CTPair< TScalar, TScalar >* pPair = const_cast< CTPair< TScalar, TScalar >* >( &src );
                m_first = pPair->First();
                m_second = pPair->Second();
            }
            return *this;
        }

        //--------------------------------------------------------------------------------
        CTRangePair& operator = ( const CTRangePair< TScalar >& src )
        {
            if( &src != this )
            {
                CTRangePair< TScalar >* pPair = const_cast< CTRangePair< TScalar >* >( &src );
                m_first = pPair->First();
                m_second = pPair->Second();
            }
            return *this;
        }

        //--------------------------------------------------------------------------------
        //Not equal operator override for comparison with a range pair of identical type
        virtual bool operator != ( CTRangePair< TScalar >& aPair )
        {
			return ( aPair.First() <= m_first || ( ( aPair.First() + aPair.Second() ) >= ( m_first + m_second ) ) )? true : false;
        }

        //--------------------------------------------------------------------------------
        //Equal operator override for comparison with a pair or map pair of identical type
        virtual bool operator == ( CTPair< TScalar, TScalar >& aPair )
        {
			return ( aPair.First() <= m_first && ( ( aPair.First() + aPair.Second() ) >= ( m_first + m_second ) ) ) ? true : false;
        }

        //--------------------------------------------------------------------------------
        //equivalence means the value is in the range
        virtual bool operator == ( const TScalar& value )
        {
			return ( ( value >= m_first ) && ( value <= ( m_first + m_second ) ) ) ? true : false;
        }
                
        //--------------------------------------------------------------------------------
        //Greater than operator for comparison with a pair or map pair of identical type
        virtual bool operator > ( CTPair< TScalar, TScalar >& aPair )
        {
			return m_first > aPair.First();
        }

        //--------------------------------------------------------------------------------
        //Greater than operator for comparison with a range size
        virtual bool operator > ( const TScalar& value )
        {
			return m_second > value;
        }

        //--------------------------------------------------------------------------------
        //Less than operator for comparison with a pair or map pair of identical type
        virtual bool operator < ( CTPair< TScalar, TScalar >& aPair )
        {
			return m_first < aPair.First();
        }

        //--------------------------------------------------------------------------------
        //Less than operator for comparison with a range size
        virtual bool operator < ( const TScalar& value )
        {
			return m_second < value;
        }

    };

}//nsCodeQOR

#endif//CODEQOR_TRANGEPAIR_H_2
