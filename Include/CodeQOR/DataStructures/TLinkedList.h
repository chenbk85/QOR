//TLinkedList.h

// Copyright Querysoft Limited 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Linked list template
//NOTE: This is terrible, 1 based and very old, deprecate in favour of std::list

#ifndef CODEQOR_DATASTRUCTS_TLINKEDLIST_H_1
#define CODEQOR_DATASTRUCTS_TLINKEDLIST_H_1

#include "CompilerQOR.h"

#ifdef	__QCMP_OPTIMIZEINCLUDE
#pragma	__QCMP_OPTIMIZEINCLUDE
#endif//__QCMP_OPTIMIZEINCLUDE

//--------------------------------------------------------------------------------
namespace nsCodeQOR
{
    //--------------------------------------------------------------------------------
    //A heap based doubly linked pointer list
    //NOT to be used across threads as there is no asynchronous access protection
	//NOTE: List access is 1 based not the usual 0 based
    template < class T >
    class CTLinkedList
    {

    protected:

        //--------------------------------------------------------------------------------
        //A node class for containing a list node
        //embedded because it's type is dependent on the parents template
        class CTNode
        {

        public:

            T* pItem;
            CTNode* pNext;
            CTNode* pPrev;
        };

        CTNode* pHead;		//Pointer to the head of the list
        CTNode* pTail;		//Pointer to the tail of the list
        unsigned int m_itemCount;	//The number of items in the list

    public:

        //--------------------------------------------------------------------------------
        CTLinkedList()
        {
            m_itemCount = 0;
            pHead = 0;
            pTail = 0;
        }

        //--------------------------------------------------------------------------------
        CTLinkedList( const CTLinkedList<T>& Src )
        {
            m_itemCount = 0;
            pHead = 0;
            pTail = 0;
            int iItem  = 1;
            T* pItem = Src.GetHead();
            while( pItem != 0 )
            {
                Append( pItem );
                pItem = Src.GetItem( ++iItem );
            }
			const_cast< CTLinkedList<T>& >( Src ).DropAll();
        }

        //--------------------------------------------------------------------------------
        virtual ~CTLinkedList()
        {
            Clear();
        }

        //--------------------------------------------------------------------------------
        ///Add an item to the end of the list
        __QCMP_NOINLINE int Append( T* pNewItem )
        {
            if( pTail != 0 && m_itemCount != 0 )
            {
                pTail->pNext = new CTNode;
                pTail->pNext->pItem = pNewItem;
                pTail->pNext->pPrev = pTail;
                pTail = pTail->pNext;
                pTail->pNext = 0;
                m_itemCount++;
            }
            else if( m_itemCount == 0 )
            {
                pHead = new CTNode;
                pHead->pItem = pNewItem;
                pHead->pPrev = 0;
                pHead->pNext = 0;
                pTail = pHead;
                m_itemCount = 1;
            }
            else
            {
                //fatal error
                m_itemCount = 0;
            }
            return m_itemCount;
        }

		//--------------------------------------------------------------------------------
		bool Insert( unsigned int uiItemIndex, T* pNewItem )
		{
			bool bResult = false;
            if( uiItemIndex >0 && uiItemIndex <= m_itemCount )
            {
				CTNode* pNewNode = new CTNode();
				pNewNode->pItem = pNewItem;

				CTNode* pPrevNode = pHead;
                for( unsigned int uiCount = 1; uiCount < uiItemIndex && pPrevNode != 0; uiCount++, pPrevNode = pPrevNode->pNext )
                {
                }

				pNewNode->pPrev = pPrevNode;

				if( pPrevNode != 0 )
				{					
					pNewNode->pNext = pPrevNode->pNext;
					pPrevNode->pNext = pNewNode;
				}
				else
				{
					pNewNode->pNext = pHead;
					pHead = pNewNode;
				}

				if( pNewNode->pNext != 0 )
				{
					pNewNode->pNext->pPrev = pNewNode;
				}
				else
				{
					pTail = pNewNode;
				}

				m_itemCount++;
				bResult = true;
			}
			else if( uiItemIndex > m_itemCount )
			{
				Append( pNewItem );
				bResult = true;
			}
			return bResult;
		}

        //--------------------------------------------------------------------------------
        //Remove an item from the list
        bool Remove( unsigned int uiItemIndex )
        {
            CTNode* pNode;
            unsigned int uiCount;

            if( uiItemIndex >0 && uiItemIndex <= m_itemCount )
            {
                for( uiCount = 1, pNode = pHead; uiCount < uiItemIndex && pNode != 0; uiCount++, pNode = pNode->pNext )
                {
                }

                if( pNode != 0 )
                {
                    if( pNode->pPrev != 0 )
                    {
                        pNode->pPrev->pNext = pNode->pNext;
                    }
					else
					{
						pHead = pHead->pNext;
					}

                    if( pNode->pNext != 0 )
                    {
                        pNode->pNext->pPrev = pNode->pPrev;
                    }
					else
					{
						pTail = pTail->pPrev;
					}

                    if( pNode->pItem != 0 )
                    {
                        delete pNode->pItem;
                    }

                    delete pNode;
                    m_itemCount--;
                    return true;
                }
            }
            return false;
        }

        //--------------------------------------------------------------------------------
        //Drop an item from the list without deleting it
        bool Drop( unsigned int uiItemIndex )
        {
            CTNode* pNode;
            unsigned int uiCount;

            if( uiItemIndex > 0 && uiItemIndex <= m_itemCount )
            {
                for( uiCount = 1, pNode = pHead; uiCount < uiItemIndex && pNode != 0; uiCount++, pNode = pNode->pNext )
                {
                }

                if( pNode != 0 )
                {
                    if( pNode->pPrev != 0 )
                    {
                        pNode->pPrev->pNext = pNode->pNext;
                    }
					else
					{
						pHead = pHead->pNext;
					}

                    if( pNode->pNext != 0 )
                    {
                        pNode->pNext->pPrev = pNode->pPrev;
                    }
					else
					{
						pTail = pNode;
					}

					pNode->pItem = 0;
                    delete pNode;
                    m_itemCount--;
                    return true;
                }
            }
            return false;
        }

        //--------------------------------------------------------------------------------
        //Return the item at the head pointer
        T* GetHead(void) const
        {
            if( pHead != 0 )
            {
                return pHead->pItem;
            }
            return 0;
        }

        //--------------------------------------------------------------------------------
        //Return the item at the tail pointer
        T* GetTail( void ) const
        {
            if( pTail != 0 )
            {
                return pTail->pItem;
            }
            return 0;
        }

        //--------------------------------------------------------------------------------
        //Return the item at the given list index (1 based)
        T* GetItem( unsigned int uiItemIndex ) const
        {
            unsigned int uiCount;
            CTNode* pNode;

            if( uiItemIndex > 0 && uiItemIndex <= m_itemCount )
            {
                for( uiCount = 1, pNode = pHead; uiCount < uiItemIndex && pNode != 0; uiCount++, pNode = pNode->pNext )
                {
                }
                return pNode ? pNode->pItem : 0;
            }
            else
            {
                return 0;
            }
        }

        //--------------------------------------------------------------------------------
        //Deallocate and clean up the lists nodes and items
        void Clear( void )
        {
            CTNode* pNode;

            while( pTail != 0 && m_itemCount > 0 )
            {
                pNode = pTail;
                if( pNode->pItem != 0 )
                {
                    delete pNode->pItem;
                }
                pNode = pNode->pPrev;
                delete pTail;
                pTail = pNode;
                m_itemCount--;
            }
            pHead = 0;
        }

        //--------------------------------------------------------------------------------
        //Drop all the nodes from the list without deleting the items
        void DropAll( void )
        {
            CTNode* pNode;

            while( pTail != 0 )
            {
                pNode = pTail;
                pNode = pNode->pPrev;
                delete pTail;
                pTail = pNode;
                m_itemCount--;
            }
            pHead = 0;
        }

        //--------------------------------------------------------------------------------
        //Return the number of items in the list
        unsigned int GetCount(void)
        {
            return m_itemCount;
        }

        //--------------------------------------------------------------------------------
        //Insert an item at the head of the list
        unsigned int Grow( T* pNewItem )
        {
            if( pHead != 0 )
            {
                pHead->pPrev = new CTNode;
                pHead->pPrev->pNext = pHead;
                pHead = pHead->pPrev;
                pHead->pItem = pNewItem;
                pHead->pPrev = 0;
                m_itemCount++;
            }
            else if( m_itemCount == 0 )
            {
                pHead = new CTNode;
                pHead->pItem = pNewItem;
                pHead->pPrev = 0;
                pHead->pNext = 0;
                pTail = pHead;
                m_itemCount = 1;
            }
            return m_itemCount;
        }

        //--------------------------------------------------------------------------------
        //Chop off the tail and return its item
        T* Dock( void )
        {
            CTNode* pNode = pTail;
            T* pItem = 0;

            if( pNode != 0 )
            {
                pTail = pNode->pPrev;
                if( pTail != 0 )
                {
                    pTail->pNext = 0;
                }
                pNode->pPrev = 0;
                pItem = pNode->pItem;
                delete pNode;
                m_itemCount--;
                if( m_itemCount < 2 )
                {
                    pHead = pTail;
                }
            }

            return pItem;
        }

        //--------------------------------------------------------------------------------
        //Chop off the head and return its item
        T* Behead(void)
        {
            CTNode* pNode = pHead;
            T* pItem = 0;

            if( pNode != 0 )
            {
                pHead = pHead->pNext;
                if(pHead != 0)
                {
                    pHead->pPrev = 0;
                }
                pNode->pNext = 0;
                pItem = pNode->pItem;
                delete pNode;
                m_itemCount--;
                if( m_itemCount < 2 )
                {
                    pTail = pHead;
                }
            }

            return pItem;
        }

        //--------------------------------------------------------------------------------
        //Walk the list calling a function for each item
        bool Walk( bool(*pWalkCallback)(T*) )
        {
            bool bResult = true;

            CTNode* pNode = pHead;

            while( pNode != 0 && bResult )
            {
                bResult = (pWalkCallback)(pNode->pItem);
                pNode = pNode->pNext;
            }

            return bResult;
        }

        //--------------------------------------------------------------------------------
        ///Walk the list calling a function for each item with 1 extra parameter
        bool Walk( bool(*pWalkCallback)(T*, void*), void* pExtra1 )
        {
            bool bResult = true;

            CTNode* pNode = pHead;

            while( pNode != 0 && bResult )
            {
                bResult = (pWalkCallback)( pNode->pItem, pExtra1 );
                pNode = pNode->pNext;
            }

            return bResult;
        }

    };

}//nsCodeQOR

#endif//CODEQOR_DATASTRUCTS_TLINKEDLIST_H_1
