//TIndexedArray.h

// Copyright Querysoft Limited 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Indexed array template based on CTArray<>
//The index type is always an unsigned long
//Index is a second CTArray with the same number of elements as the primary array but containing initially sequential integers
//Access is via lookup of the Index which is itself sorted according to the corresponding primary array values.
//Use an indexed array to maintain an ordered list of objects that are complex, expensive or impossible to duplicate or move.

#ifndef CODEQOR_DATASTRUCTS_INDEXEDARRAY_H_1
#define CODEQOR_DATASTRUCTS_INDEXEDARRAY_H_1

#include "CompilerQOR.h"

#ifdef	__QCMP_OPTIMIZEINCLUDE
#pragma __QCMP_OPTIMIZEINCLUDE
#endif//__QCMP_OPTIMIZEINCLUDE

#include "TArray.h"

//--------------------------------------------------------------------------------
namespace nsCodeQOR
{
    //--------------------------------------------------------------------------------
    //A dual array class, one for the data, a parallel one for the index
    //Index is automatically maintained and ordered by quicksort on the data array
    template < class Type, class TPolicy, class TAllocator = __QCMP_FEATURE_TONDTIDTP( typename ) mem_traits< Type >::CTAllocator >
    class CTIndexedArray : public CTArray < Type, TPolicy, TAllocator >
    {
		typedef CTArray< Type, TPolicy, TAllocator > BaseName;

	protected:

        //constants for sort algorithms
        __QCMP_STATIC_CONSTANT( unsigned char, CUTOFF = 8 );
        __QCMP_STATIC_CONSTANT( unsigned char, STKSIZ = ( 8 * sizeof( void* ) -2 ) );

        //The index of the indexed array is just another array
        CTArray < unsigned long, TPolicy, nsCodeQOR::mem_traits< unsigned long >::CTAllocator > m_Index;

        //Flag to record whether the index has been updated since the last change to the array
        bool m_bIndexValid;

    public:

		__QCMP_USING_BASE( m_ulMaxSize );
		__QCMP_USING_BASE( m_ulCurrentSize );
		__QCMP_USING_BASE( m_ArrayData );
		__QCMP_USING_BASE( m_ThreadSyncPrimitive );

        //--------------------------------------------------------------------------------
        //Indexed arrays are equal if the data arrays are equal and the index arrays are equal
        template< class APolicy, class AAllocator >
        bool operator == ( CTIndexedArray < Type, APolicy, AAllocator > & Comperand )
        {
			return ( CTArray < Type, TPolicy, TAllocator > ::operator ==(Comperand) && m_Index == Comperand.m_Index );
        }

        //--------------------------------------------------------------------------------
        //Construct an indexed array
        CTIndexedArray() : CTArray< Type, TPolicy, TAllocator >()
        {
            //The capacity of the index should be the same as for the data
            m_Index.SetCapacity( m_ulMaxSize );

            //No indexing has been done yet so the index is initially invalid
            m_bIndexValid = false;
        }

        //--------------------------------------------------------------------------------
        //Construct an indexed array with an initial size
        CTIndexedArray( int size ) : CTArray< Type, TPolicy, TAllocator >( size )
        {
            //The capacity of the index should be the same as for the data
            m_Index.SetCapacity( m_ulMaxSize );

            //No indexing has been done yet so the index is initially invalid
            m_bIndexValid = false;
        }

        //--------------------------------------------------------------------------------
        //Copy construct an indexed array by copying
        CTIndexedArray( CTIndexedArray< Type, TPolicy, TAllocator > const & srcArray )
        {
			srcArray.AcquireAccess();
            m_ulCurrentSize = srcArray.m_ulCurrentSize;
            m_ulMaxSize = srcArray.m_ulMaxSize;
            m_ArrayData =  TAllocator::Allocate( m_ulMaxSize );

            //Copy the data form the source array
            unsigned long k = 0;
            while( k < m_ulCurrentSize )
            {
				m_ArrayData[ k ] = srcArray.m_ArrayData[ k++ ];
            }

            //Copy the index from the source array
            m_Index = srcArray.m_Index;

            //This index is valid if the source index was valid
            m_bIndexValid = srcArray.m_bIndexValid;
            srcArray.ReleaseAccess();
		}

		//--------------------------------------------------------------------------------
		//Assign one indexed array from another
		template< class APolicy, class AAllocator >
		CTIndexedArray const & operator = ( CTIndexedArray< Type, APolicy, AAllocator > const & srcArray )
		{
			srcArray.AcquireAccess();
			typename BaseName::CLockPrimitive Lock( m_ThreadSyncPrimitive );

			//Set the size to the source size
			m_ulCurrentSize = srcArray.m_ulCurrentSize;

			//Throw away any current data
			if( m_ArrayData != 0 )
			{
				delete [] m_ArrayData;
			}

			//Set up the allocation to be same size as the source
			m_ulMaxSize = srcArray.m_ulMaxSize;
			m_ArrayData = new Type[ m_ulMaxSize] ;

			//Copy the data from the source
			unsigned long k;
			for( k = 0; k < srcArray.m_ulCurrentSize; k++ )
			{
				m_ArrayData[ k ] = srcArray.m_ArrayData[ k ];
			}

			//Copy the index from the source
			m_Index = srcArray.m_Index;

			//This index is valid of the source index was valid
			m_bIndexValid = srcArray.m_bIndexValid;
			srcArray.ReleaseAccess();
			return *this;
		}

        //--------------------------------------------------------------------------------
        //Destruct an indexed array
        virtual ~CTIndexedArray()
        {
			Free();
        }

        //--------------------------------------------------------------------------------
        //Free the array data and the index data
        virtual void Free()
        {
            typename BaseName::CLockPrimitive Lock( m_ThreadSyncPrimitive );
            CTArray< Type, TPolicy, TAllocator >::Free();
            m_Index.Free();
            m_bIndexValid = false;
        }

        //--------------------------------------------------------------------------------
        //return a reference to the item at a given indexed position
        //The caller should acquire access to this array before calling the [] operator
        Type & operator[]( unsigned long k )
        {
			return m_ArrayData[ Lookup( k ) ];
        }

        //--------------------------------------------------------------------------------
        //Append an item to the array
        unsigned long Append( Type& newInfo )
        {
            typename BaseName::CLockPrimitive Lock( m_ThreadSyncPrimitive );
            unsigned long ulResult = CTArray< Type, TPolicy, TAllocator >::Append( newInfo );			//Append the data
            m_Index.SetCapacity( m_ulMaxSize );															//Grow the index if needed
            m_bIndexValid = false;																		//Set the index to invalid so we will reindex next time.
			return ulResult;
        }

        //--------------------------------------------------------------------------------
        //Append an array of items to this array
        template< class APolicy, class AAllocator >
        void Append( const CTArray< Type, APolicy, AAllocator > & ArrayToAdd )
        {
            ArrayToAdd.AcquireAccess();
            typename BaseName::CLockPrimitive Lock( m_ThreadSyncPrimitive );
            CTArray< Type, TPolicy, TAllocator >::Append( ArrayToAdd );             //Append the data
            ArrayToAdd.ReleaseAccess();
            m_Index.SetCapacity( m_ulMaxSize );                                                             //Grow the index
            m_bIndexValid = false;                                                                                  //Set the index to invalid so we will reindex next time.
        }

        //--------------------------------------------------------------------------------
        //Append a pointed to array of items to this array
        virtual void Append(const CTArray< Type, TPolicy, TAllocator >* const pArrayToAdd )
        {
            pArrayToAdd->AcquireAccess();
            typename BaseName::CLockPrimitive Lock( m_ThreadSyncPrimitive );
            CTArray< Type, TPolicy, TAllocator >::Append( pArrayToAdd );    //Append the data
            pArrayToAdd->ReleaseAccess();
            m_Index.SetCapacity( m_ulMaxSize );                                                             //Grow the index
            m_bIndexValid = false;                                                                                  //Set the index to invalid so we will reindex next time.
        }


        //--------------------------------------------------------------------------------
        //Swap two indexed elements in the array
        virtual void SwapTwoElements( unsigned long first , unsigned long second )
        {
            typename BaseName::CLockPrimitive Lock( m_ThreadSyncPrimitive );

            unsigned long iIndexfirst = Lookup( first );                                    //Find the items refered to by index
            unsigned long iIndexSecond = Lookup( second );

            Type temp = m_ArrayData[ iIndexfirst ];                                                 //Swap the data items over
            m_ArrayData[ iIndexfirst ] = m_ArrayData[ iIndexSecond ];
            m_ArrayData[ iIndexSecond ] = temp;

            m_bIndexValid = false;                                                                                  //The index is no longer valid so flag it
	    }

        //--------------------------------------------------------------------------------
        //Swap an indexed element in the array with an item outside the array
        virtual void Swap( unsigned long first, Type& _t )
        {
            typename BaseName::CLockPrimitive Lock( m_ThreadSyncPrimitive );

            unsigned int iIndexfirst = Lookup( first );                                                             //Find the item refered to by index
            Type temp = m_ArrayData[ iIndexfirst ];																	//Swap the data with the _t parameter value
            m_ArrayData[ iIndexfirst ] = _t;
            _t = temp;

            m_bIndexValid = false;                                                                                  //The index is no longer valid so flag it
        }

        //--------------------------------------------------------------------------------
        //Clear the array without affecting allocation
        virtual void Clear()
        {
            typename BaseName::CLockPrimitive Lock( m_ThreadSyncPrimitive );

            CTArray< Type, TPolicy, TAllocator >::Clear();
            m_Index.Clear();
            m_bIndexValid = false;
        }

        //--------------------------------------------------------------------------------
        //Remove an indexed item from the array
        virtual void RemoveAt( unsigned long ulPosition )
        {
            typename BaseName::CLockPrimitive Lock( m_ThreadSyncPrimitive );

            unsigned long ulIndex = Lookup( ulPosition );

            //Shuffle all the following items up the array simply overwriting the one we want to remove
            for ( unsigned long k = ulIndex; k < ( m_ulCurrentSize - 1 ); k++ )
            {
				m_ArrayData[ k ] = m_ArrayData[ k + 1 ];
            }

            m_ulCurrentSize--;              //The in use size is now one less
            m_bIndexValid = false;          //And the index is invalid
        }

		//------------------------------------------------------------------------------
		//Remove ulSize array elements shuffling all subsequent elements down and
		// reducing the in use count by ulSize
		virtual void RemoveAt( const unsigned long ulPosition, const unsigned long ulSize )
		{
			typename BaseName::CLockPrimitive Lock( m_ThreadSyncPrimitive );

			unsigned long ulIndex = Lookup( ulPosition );
			unsigned long ulActualSize = ulSize;

			if( ulActualSize > ( m_ulCurrentSize - ulIndex ) )
			{
				ulActualSize = ( m_ulCurrentSize - ulIndex );
			}

			for ( unsigned long k = ulIndex; k < m_ulCurrentSize - ( ulActualSize + 1 ); k++ )
			{
				m_ArrayData[ k ] = m_ArrayData[ k + ulActualSize ];
			}
			m_ulCurrentSize -= ulActualSize;
			m_bIndexValid = false;
		}

        //--------------------------------------------------------------------------------
        //Set the array and index allocation sizes
        virtual void SetCapacity( const unsigned long newSize )
        {
            typename BaseName::CLockPrimitive Lock( m_ThreadSyncPrimitive );

            CTArray< Type, TPolicy, TAllocator >::SetCapacity( newSize );           //Set the Data capacity
            m_Index.SetCapacity( newSize );                                         //Set the Index capacity
            m_bIndexValid = false;                                                  //Flag the index as no longer valid
        }

        //--------------------------------------------------------------------------------
        //Find the index of an item by value
        unsigned long Find( Type& _t )
        {
            typename BaseName::CLockPrimitive Lock( m_ThreadSyncPrimitive );

            if( !m_bIndexValid )
            {
                Index();													//If the index is not valid rebuild it
            }

            if( m_bIndexValid )                                             //Binary chop search through the index
            {
                unsigned long ulLow = 0;
                unsigned long ulHigh = m_ulCurrentSize - 1;
                unsigned long ulLookup = m_ulCurrentSize / 2;
                unsigned long ulIndex = Lookup( ulLookup );
                Type _temp = m_ArrayData[ ulIndex ];
                while( ulHigh > ulLow && _temp != _t )						//while there is still more to search
                {
                    if( m_ArrayData[ Lookup( ulLookup ) ] > _t )
                    {
                        ulHigh = ulLookup;									//If it's there it's in the bottom half
                        ulLookup = ulLow + ( ( ( ulHigh - ulLow ) / 2 ) );
                    }
                    else
                    {
                        ulLow = ulLookup + 1;								//If it's there it's in the top half
                        ulLookup = ulHigh - ( ( ( ulHigh - ulLow ) / 2 ) );
                    }

                    if( ulHigh >= ulLow )
                    {
                        ulIndex = Lookup( ulLookup );						//Get the array offset of the index
                        _temp = m_ArrayData[ ulIndex ];						//Get the item at the array offset
                    }
                }
                if( _temp != _t )
                {
                    ulLookup = (unsigned long)(-1);							//Item not found
                }
                return ulLookup;											//return the index of the item or the item not found value
            }
            return (unsigned long)(-1);										//Indexing failed
        }

        //--------------------------------------------------------------------------------
        //Lookup the data element at the given index
        unsigned long Lookup( unsigned long ulIndex )
        {
            typename BaseName::CLockPrimitive Lock( m_ThreadSyncPrimitive );

            if( !m_bIndexValid )
            {
                Index();													//Make sure we have a valid index
            }

            return m_Index[ ulIndex ];                                      //Return the array offset from the index
        }

	protected:

        //--------------------------------------------------------------------------------
        //Quicksort function for sorting arrays
		void Qsort( byte* base, size_t num, size_t width )
        {
            // Note: the number of stack entries required is no more than 1 + log2(num), so 30 is sufficient for any array
            byte* lo, *hi;              // ends of sub-array currently sorting
            byte* mid;                  // points to middle of subarray
            byte* loguy, *higuy;        // traveling pointers for partition step
            unsigned int size;          // size of the sub-array
            byte* lostk[ STKSIZ ];
			byte* histk[ STKSIZ ];
            int stkptr;                 // stack for saving sub-array to be processed

            if( num < 2 || width == 0 )
            {
                return;                 // nothing to do
            }

            stkptr = 0;                 // initialize stack

            lo = base;
            hi = (byte*)base + width * (num-1);        // initialize limits

            //this entry point is for pseudo-recursion calling: setting
            //lo and hi and jumping to here is like recursion, but stkptr is
            //preserved, locals aren't, so we preserve stuff on the stack
            recurse:

            size = static_cast< size_t >( ( hi - lo) / width + 1 );        // number of elements to sort

            // below a certain size, it is faster to use a O(n^2) sorting method
            if( size <= CUTOFF )
            {
				Shortsort( lo, hi, width );
            }
            else
            {
                mid = lo + ( size / 2 ) * width;      // find middle element

                // Sort the first, middle, last elements into order
                if ( Compare( lo, mid ) > 0 )
                {
                    Swap( lo, mid, width );
                }

                if ( Compare( lo, hi ) > 0 )
                {
                    Swap( lo, hi, width );
                }

                if ( Compare( mid, hi ) > 0 )
                {
                    Swap( mid, hi, width );
                }

                loguy = lo;
                higuy = hi;

                for (;;)
                {

                    if ( mid > loguy )
                    {
                        do
                        {
                            loguy += width;
                        } while ( loguy < mid && Compare( loguy, mid ) <= 0 );
                    }

                    if ( mid <= loguy )
                    {
                        do
                        {
                            loguy += width;
		                } while ( loguy <= hi && Compare( loguy, mid ) <= 0 );
	                }

                    do
                    {
                            higuy -= width;
                    } while ( higuy > mid && Compare( higuy, mid ) > 0);

                    if ( higuy < loguy )
                    {
                            break;
                    }

                    Swap( loguy, higuy, width );

                    if ( mid == higuy )
                    {
                            mid = loguy;
                    }

                }

                higuy += width;

                if ( mid < higuy )
                {
                    do
                    {
                        higuy -= width;
                    } while ( higuy > mid && Compare( higuy, mid ) == 0 );
                }

                if ( mid >= higuy )
                {
                    do
                    {
                        higuy -= width;
                    } while ( higuy > lo && Compare( higuy, mid ) == 0 );
                }

                if ( higuy - lo >= hi - loguy )
                {
                    if ( lo < higuy )
                    {
                        lostk[ stkptr ] = lo;
                        histk[ stkptr ] = higuy;
                        ++stkptr;
                    }                           /* save big recursion for later */

                    if (loguy < hi)
                    {
                        lo = loguy;
                        goto recurse;           /* do small recursion */
                    }
                }
                else
                {
                    if ( loguy < hi )
                    {
                        lostk[ stkptr ] = loguy;
                        histk[ stkptr ] = hi;
                        ++stkptr;               /* save big recursion for later */
                    }

                    if ( lo < higuy )
                    {
                        hi = higuy;
                        goto recurse;           /* do small recursion */
                    }
                }
            }

            // We have sorted the array, except for any pending sorts on the stack.
            //Check if there are any, and do them.

            --stkptr;
            if ( stkptr >= 0 )
            {
                lo = lostk[ stkptr ];
                hi = histk[ stkptr ];
                goto recurse;           // pop subarray from stack
            }
            else
            {
                return;                 // all subarrays done
            }
        }


        //--------------------------------------------------------------------------------
        //Shortsort(hi, lo, width) - insertion sort for sorting short arrays
        void Shortsort ( byte* lo, byte* hi, size_t width )
        {
            byte *p, *max;

            while( hi > lo )
            {
                max = lo;
                for ( p = lo + width; p <= hi; p += width )
                {
                    if ( Compare( p, max ) > 0 )
                    {
                        max = p;
                    }
                }
                Swap( max, hi, width );
                hi -= width;
            }
        }

        //--------------------------------------------------------------------------------
        //Swap(a, b, width) - swap two elements
        void Swap ( byte* a, byte* b, size_t width )
        {
            byte tmp;

            if ( a != b )
            {
                // Do the swap one byte at a time to avoid potential alignment problems.
                while ( width-- )
                {
                    tmp = *a;
                    *a++ = *b;
                    *b++ = tmp;
                }
            }
        }

        //--------------------------------------------------------------------------------
        //Compare two indexes by comparing the items they index
        int Compare( const void* arg1, const void* arg2 )
        {
            unsigned long ulP1 = *( reinterpret_cast< const unsigned long* >( arg1 ) );
            unsigned long ulP2 = *( reinterpret_cast< const unsigned long* >( arg2 ) );

            Type* pT1 = & m_ArrayData[ ulP1 ];
            Type* pT2 = & m_ArrayData[ ulP2 ];

            return ( *pT1 ) == ( *pT2 ) ? 0 : ( ( *pT1 ) < ( *pT2 ) ? -1 : 1 );
        }

        //--------------------------------------------------------------------------------
        //Generate the array index sequence ordered by the array item values
        void Index()
        {
            if( m_ulCurrentSize > 0 )
            {
                //Initially create a simple linear index
                m_Index.Clear();
                for( unsigned long ulCount = 0; ulCount < m_ulCurrentSize; ulCount++ )
                {
                    m_Index.Append( ulCount );
                }
                //resort the index according to the values of the actual data while leaving the data where it is
                Qsort( reinterpret_cast< byte* >( m_Index.GetAddressOfData() ), m_ulCurrentSize, sizeof( unsigned long ) );
                m_bIndexValid = true;
            }
        }

	};

}//nsCodeQOR

#endif//CODEQOR_DATASTRUCTS_INDEXEDARRAY_H_1
