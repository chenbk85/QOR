//UTF16String.h

// Copyright Querysoft Limited 2015 - . All rights reserved.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//UTF-16 String class

#ifndef CODEQOR_STRINGS_UTF16_H_3
#define CODEQOR_STRINGS_UTF16_H_3

#include "CodeQOR/Text/Char16.h"
#include "CodeQOR/CodePages/CodePage.h"
#include "CodeQOR/Text/UTF16Char.h"

//------------------------------------------------------------------------------
namespace nsCodeQOR
{
	class __QOR_INTERFACE( __CODEQOR ) CUTF8String;
	class __QOR_INTERFACE( __CODEQOR ) CUTF16String;
	class __QOR_INTERFACE( __CODEQOR ) CUTF32String;

	//------------------------------------------------------------------------------
	class __QOR_INTERFACE( __CODEQOR ) CUTF16String
	{
	public:

		typedef CTString< CChar16, CDefaultSource > _tString;
		typedef CChar16 _tChar;

		//--------------------------------------------------------------------------------
		struct __QOR_INTERFACE( __CODEQOR ) CCharProcessorFunctor
		{
			//--------------------------------------------------------------------------------
			eProcessResult operator()( CUTF16String&, CUTF16Char Char )
			{
				return eProcessResultEnd;
			}
		};

		//--------------------------------------------------------------------------------
		struct __QOR_INTERFACE( __CODEQOR ) CTrimLeftFunctor : public CCharProcessorFunctor
		{
			//--------------------------------------------------------------------------------
			eProcessResult operator()( CUTF16String& strResult, CUTF16Char Char )
			{
				if( Char.IsSpace() )
				{
					return eProcessResultMore;
				}
				else
				{
					strResult.m_String.Remove( 0, static_cast< unsigned short >( Char.ptr() - strResult.begin() ) );
					return eProcessResultEnd;
				}
			}
		};

		//--------------------------------------------------------------------------------
		struct __QOR_INTERFACE( __CODEQOR ) CTrimRightFunctor : public CCharProcessorFunctor
		{
			//--------------------------------------------------------------------------------
			eProcessResult operator()( CUTF16String& strResult, CUTF16Char Char )
			{
				if( Char.IsSpace() )
				{
					return eProcessResultMore;
				}
				else
				{
					strResult.m_String.Remove( static_cast< unsigned short >( Char.ptr() - strResult.begin() ), strResult.m_String.Len() );
					strResult.m_String.ReleaseBuffer();
					return eProcessResultEnd;
				}
			}
		};

		//--------------------------------------------------------------------------------
		struct __QOR_INTERFACE( __CODEQOR ) CStringProcessorFunctor
		{
			//--------------------------------------------------------------------------------
			eProcessResult operator()( CUTF16String& str )
			{
				return eProcessResultEnd;
			}
		};

		//--------------------------------------------------------------------------------
		enum eConstants
		{
			eUTF16MaxBytes = 4,
		};

        //--------------------------------------------------------------------------------
        CUTF16String();																							//Construct empty string
        CUTF16String( const CChar16* cpString, unsigned short usSrcLen = 0 );									//Construct from well formed UTF-16 array
        CUTF16String( const CChar16* cpString, unsigned short usSrcLen, unsigned short usInitialBufferSize );	//Construct from well formed UTF-16 array with space reservation
		CUTF16String( const CUTF16String& Src );																//Copy construct
		CUTF16String( const CUTF8String& Src );
		CUTF16String( const CUTF32String& Src );
        CUTF16String( nsCodeQOR::CTLRef< CChar16 > Src );														//Construct from well formed UTF-16 array by reference
		CUTF16String( CChar16 c );																				//Construct from single 16-bit Character
		CUTF16String( _tString::ref_type Src );																	//Construct from a reference to the underlying buffer
        CUTF16String( const _tString& Src );																	//Construct from an underlying Buffer
		
		CUTF16String& operator = ( const CUTF16String& Src );
        CUTF16String& operator = ( const _tString& Src );
		CUTF16String& operator = ( _tString::ref_type Src );
		CUTF16String& operator = ( CChar16 c );
		unsigned short GetCodePage() const;
        unsigned short Length() const;
		bool IsEmpty( void ) const;
        bool operator == ( const _tString& Src ) const;
        bool operator < ( const _tString& Cmp ) const;
        virtual ~CUTF16String();
		CUTF16Char At( unsigned short usPos );
		bool Set( unsigned short usPos, CUTF16Char ch );
		CUTF16String& Insert(  unsigned short usPos, CUTF16String& Src );
		CUTF16String& Remove( unsigned short usPos, unsigned short usCount );
		CUTF16String& Clear( void );
		CUTF16String& Append( CChar16 ch );
        CUTF16String& Append( const CChar16* cpString, unsigned short usSrcLen );
		CUTF16String& Append( const CUTF16String& Str );
		CUTF16String Left( unsigned short usLen );
		CUTF16String Right( unsigned short usLen );
		CUTF16String Mid( unsigned short usPos, short usLen );
		CUTF16String TrimLeft();
		CUTF16String TrimRight();
		CUTF16String ProcessByChar( CCharProcessorFunctor& ProcessFunctor, unsigned short usPos = 0 );//Process the string through a functor one character at a time
		CUTF16String ReverseProcessByChar( CCharProcessorFunctor& ProcessFunctor, unsigned short usPos = 0 );//Process the string through a functor one character at a time in reverse
		void ProcessForSubString( CCharProcessorFunctor& CharFunctor, CStringProcessorFunctor& StringFunctor, unsigned short usPos = 0 );	//Process the string through a functor to find the beginning and end of substrings and then process each substring through a second functor. This can be used as the basis for tokenizing a string, the beginning of language parsing.
		void Reserve( unsigned short usCharCount );					//Reserve memory for the string in advance if you plan to make many small appends
		unsigned short BufferByteCount( void );

		CUTF16Char begin( void );
		CUTF16Char end( void );

		CUTF32String ToUTF32String( void );
		CUTF8String ToUTF8String( void );

	protected:

		bool ValidateReference( CUTF16Char Ch );
		void CountChars( void );
		CUTF16Char CharAt( unsigned short usPos );

		_tString m_String;
		unsigned short m_usCharCount;
		bool m_bEncodingValidated;
	};

}//nsCodeQOR


#endif//CODEQOR_STRINGS_UTF8_H_3
