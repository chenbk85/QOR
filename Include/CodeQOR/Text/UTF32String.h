//UTF32String.h

// Copyright Querysoft Limited 2015 - . All rights reserved.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//UTF-32 String class

#ifndef CODEQOR_STRINGS_UTF32_H_3
#define CODEQOR_STRINGS_UTF32_H_3

#include "CodeQOR/Text/Char32.h"

//------------------------------------------------------------------------------
namespace nsCodeQOR
{
	class __QOR_INTERFACE( __CODEQOR ) CUTF32String;

	//------------------------------------------------------------------------------
	class __QOR_INTERFACE( __CODEQOR ) CUTF32String
	{
	public:

		typedef CChar32 _tChar;
		typedef CTString< CChar32, CDefaultSource > _tString;

		//--------------------------------------------------------------------------------
		struct __QOR_INTERFACE( __CODEQOR ) CCharProcessorFunctor
		{
			//--------------------------------------------------------------------------------
			eProcessResult operator()( CUTF32String&, CChar32 Char )
			{
				return eProcessResultEnd;
			}
		};

		//--------------------------------------------------------------------------------
		struct __QOR_INTERFACE( __CODEQOR ) CStringProcessorFunctor
		{
			//--------------------------------------------------------------------------------
			eProcessResult operator()( CUTF32String& str )
			{
				return eProcessResultEnd;
			}
		};

		//--------------------------------------------------------------------------------
		enum eConstants
		{
			eUTF32MaxBytes = 4,
		};

        //--------------------------------------------------------------------------------
        CUTF32String();																							//Construct empty string
        CUTF32String( const CChar32* cpString, unsigned short usSrcLen = 0 );									//Construct from well formed UTF-16 array
        CUTF32String( const CChar32* cpString, unsigned short usSrcLen, unsigned short usInitialBufferSize );	//Construct from well formed UTF-16 array with space reservation
		CUTF32String( const CUTF32String& Src );																//Copy construct
		CUTF32String( const CUTF16String& Src );
		CUTF32String( const CUTF8String& Src );
        CUTF32String( nsCodeQOR::CTLRef< CChar32 > Src );														//Construct from well formed UTF-16 array by reference
		CUTF32String( CChar32 c );																				//Construct from single 16-bit Character
		CUTF32String( _tString::ref_type Src );																	//Construct from a reference to the underlying buffer
        CUTF32String( const _tString& Src );																	//Construct from an underlying Buffer
		
		CUTF32String& operator = ( const CUTF32String& Src );
        CUTF32String& operator = ( const _tString& Src );
		CUTF32String& operator = ( _tString::ref_type Src );
		CUTF32String& operator = ( CChar32 c );
		unsigned short GetCodePage() const;
        unsigned short Length() const;
		bool IsEmpty( void ) const;
        bool operator == ( const _tString& Src ) const;//Two Strings are equal if they contain equal data
        bool operator < ( const _tString& Cmp ) const;
        virtual ~CUTF32String();
		CChar32* At( unsigned short usPos );
		bool Set( unsigned short usPos, CChar32 ch );
		CUTF32String& Insert(  unsigned short usPos, CUTF32String& Src );
		CUTF32String& Remove( unsigned short usPos, unsigned short usCount );
		CUTF32String& Clear( void );
		CUTF32String& Append( CChar32 ch );
        CUTF32String& Append( const CChar32* cpString, unsigned short usSrcLen );
		CUTF32String& Append( const CUTF32String& Str );
		CUTF32String Left( unsigned short usLen );
		CUTF32String Right( unsigned short usLen );
		CUTF32String Mid( unsigned short usPos, short usLen );
		CUTF32String TrimLeft();
		CUTF32String TrimRight();
		CUTF32String ProcessByChar( CCharProcessorFunctor& ProcessFunctor, unsigned short usPos = 0 );//Process the string through a functor one character at a time
		CUTF32String ReverseProcessByChar( CCharProcessorFunctor& ProcessFunctor, unsigned short usPos = 0 );//Process the string through a functor one character at a time in reverse
		void ProcessForSubString( CCharProcessorFunctor& CharFunctor, CStringProcessorFunctor& StringFunctor, unsigned short usPos = 0 );	//Process the string through a functor to find the beginning and end of substrings and then process each substring through a second functor. This can be used as the basis for tokenizing a string, the beginning of language parsing.
		void Reserve( unsigned short usCharCount );					//Reserve memory for the string in advance if you plan to make many small appends
		unsigned short BufferByteCount( void );

		CChar32* begin( void );
		CChar32* end( void );

		CUTF16String ToUTF16String( void );
		CUTF8String ToUTF8String( void );

	protected:

		CChar32* CharAt( unsigned short usPos );

		CTString< _tChar, CDefaultSource > m_String;
	};

}//nsCodeQOR


#endif//CODEQOR_STRINGS_UTF32_H_3
