//UTF8String.h

// Copyright Querysoft Limited 2015 - . All rights reserved.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//UTF-8 String class

#ifndef CODEQOR_STRINGS_UTF8_H_3
#define CODEQOR_STRINGS_UTF8_H_3

#include "CodeQOR/Text/Char8.h"
#include "CodeQOR/CodePages/CodePage.h"
#include "CodeQOR/Text/UTF8Char.h"

//------------------------------------------------------------------------------
namespace nsCodeQOR
{
	class __QOR_INTERFACE( __CODEQOR ) CUTF16String;
	class __QOR_INTERFACE( __CODEQOR ) CUTF32String;

	//------------------------------------------------------------------------------
	class __QOR_INTERFACE( __CODEQOR ) CUTF8String
	{
	public:

		typedef CTString< CChar8, CDefaultSource > _tString;
		typedef CChar8 _tChar;

		//--------------------------------------------------------------------------------
		struct __QOR_INTERFACE( __CODEQOR ) CCharProcessorFunctor
		{
			//--------------------------------------------------------------------------------
			eProcessResult operator()( CUTF8String&, CUTF8Char Char )
			{
				return eProcessResultEnd;
			}
		};

		//--------------------------------------------------------------------------------
		struct __QOR_INTERFACE( __CODEQOR ) CTrimLeftFunctor : public CCharProcessorFunctor
		{
			//--------------------------------------------------------------------------------
			eProcessResult operator()( CUTF8String& strResult, CUTF8Char Char )
			{
				if( Char.IsSpace() )
				{
					return eProcessResultMore;
				}
				else
				{
					strResult.m_String.Remove( 0, static_cast< unsigned short >( Char.ptr() - strResult.begin() ) );
					return eProcessResultEnd;
				}
			}
		};

		//--------------------------------------------------------------------------------
		struct __QOR_INTERFACE( __CODEQOR ) CTrimRightFunctor : public CCharProcessorFunctor
		{
			//--------------------------------------------------------------------------------
			eProcessResult operator()( CUTF8String& strResult, CUTF8Char Char )
			{
				if( Char.IsSpace() )
				{
					return eProcessResultMore;
				}
				else
				{
					strResult.m_String.Remove( static_cast< unsigned short >( Char.ptr() - strResult.begin() ), strResult.m_String.Len() );
					strResult.m_String.ReleaseBuffer();
					return eProcessResultEnd;
				}
			}
		};

		//--------------------------------------------------------------------------------
		struct __QOR_INTERFACE( __CODEQOR ) CStringProcessorFunctor
		{
			//--------------------------------------------------------------------------------
			eProcessResult operator()( CUTF8String& str )
			{
				return eProcessResultEnd;
			}
		};

		//--------------------------------------------------------------------------------
		enum eConstants
		{
			eUTF8MaxBytes = 4,
		};

        //--------------------------------------------------------------------------------
        CUTF8String();																							//Construct empty string
        CUTF8String( const CChar8* cpString, unsigned short usSrcLen = 0 );										//Construct from well formed UTF-8 array
        CUTF8String( const CChar8* cpString, unsigned short usSrcLen, unsigned short usInitialBufferSize );		//Construct from well formed UTF-8 array with space reservation
		CUTF8String( const CUTF8String& Src );																	//Copy construct
		CUTF8String( const CUTF16String& Src );																	//Construct from a UTF-16 string
		CUTF8String( const CUTF32String& Src );																	//Construct from a UTF-32 string
        CUTF8String( nsCodeQOR::CTLRef< CChar8 > Src );															//Construct from well formed UTF-8 array by reference
		CUTF8String( CChar8 c );																				//Construct from single 8-bit Character
		CUTF8String( _tString::ref_type Src );																	//Construct from a reference to the underlying buffer
        CUTF8String( const _tString& Src );																		//Construct from an underlying Buffer
		
		CUTF8String& operator = ( const CUTF8String& Src );
        CUTF8String& operator = ( const _tString& Src );
		CUTF8String& operator = ( _tString::ref_type Src );
		CUTF8String& operator = ( CChar8 c );
		unsigned short GetCodePage() const;
        unsigned short Length() const;
		bool IsEmpty( void ) const;
        bool operator == ( const _tString& Src ) const;
        bool operator < ( const _tString& Cmp ) const;
        virtual ~CUTF8String();
		CUTF8Char At( unsigned short usPos );
		bool Set( unsigned short usPos, CUTF8Char ch );
		CUTF8String& Insert(  unsigned short usPos, CUTF8String& Src );
		CUTF8String& Remove( unsigned short usPos, unsigned short usCount );
		CUTF8String& Clear( void );
		CUTF8String& Append( CChar8 ch );
        CUTF8String& Append( const CChar8* cpString, unsigned short usSrcLen );
		CUTF8String& Append( const CUTF8String& Str );
		CUTF8String Left( unsigned short usLen );
		CUTF8String Right( unsigned short usLen );
		CUTF8String Mid( unsigned short usPos, short usLen );
		CUTF8String TrimLeft();
		CUTF8String TrimRight();
		CUTF8String ProcessByChar( CCharProcessorFunctor& ProcessFunctor, unsigned short usPos = 0 );//Process the string through a functor one character at a time
		CUTF8String ReverseProcessByChar( CCharProcessorFunctor& ProcessFunctor, unsigned short usPos = 0 );//Process the string through a functor one character at a time in reverse
		void ProcessForSubString( CCharProcessorFunctor& CharFunctor, CStringProcessorFunctor& StringFunctor, unsigned short usPos = 0 );	//Process the string through a functor to find the beginning and end of substrings and then process each substring through a second functor. This can be used as the basis for tokenizing a string, the beginning of language parsing.
		void Reserve( unsigned short usCharCount );					//Reserve memory for the string in advance if you plan to make many small appends
		unsigned short BufferByteCount( void );

		CUTF8Char begin( void );
		CUTF8Char end( void );

		CUTF32String ToUTF32String( void );
		CUTF16String ToUTF16String( void );

	protected:

		bool ValidateReference( CUTF8Char Ch );
		void CountChars( void );
		CUTF8Char CharAt( unsigned short usPos );

		_tString m_String;
		unsigned short m_usCharCount;
		bool m_bEncodingValidated;
	};

}//nsCodeQOR


#endif//CODEQOR_STRINGS_UTF8_H_3
