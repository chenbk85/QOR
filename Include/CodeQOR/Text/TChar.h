//TChar.h

// Copyright Querysoft Limited 2015 - . All rights reserved.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Character template base class

#ifndef CODEQOR_TCHAR_H_3
#define CODEQOR_TCHAR_H_3

#include "CodeQOR/DataTypes/OTypes.h"
#include "CodeQOR/Text/unicodedata.h"

//--------------------------------------------------------------------------------
namespace nsCodeQOR
{
	//--------------------------------------------------------------------------------
	static inline unsigned int Flag( int x )
	{
		return ( 1 << ( x ) );
	}

	static inline unsigned int SurrogateToUcs4( unsigned short high, unsigned short low );
	extern const unsigned short* __QCMP_FASTCALL DecompositionHelper( unsigned int ucs4, int* length, int* tag, unsigned short* buffer );

    //--------------------------------------------------------------------------------
    template< typename TType >
    struct CChar : public PrimitiveInt< CChar< TType >, TType > 
    {       
		typedef PrimitiveInt< CChar< TType >, TType > BaseName;

	public:

		//------------------------------------------------------------------------------
		template< typename LType = TType >
		struct sLookupType
		{
			typedef TType UnicodeLookupType;
		};

		//------------------------------------------------------------------------------
		template<>
		struct sLookupType< byte >
		{
			typedef unsigned short UnicodeLookupType;
		};

		typedef typename sLookupType< TType >::UnicodeLookupType ULookupType;

		//------------------------------------------------------------------------------
		enum eSpecialCharacter 
		{
			Null = 0x0000,
			Nbsp = 0x00a0,
			ReplacementCharacter = 0xfffd,
			ObjectReplacementCharacter = 0xfffc,
			ByteOrderMark = 0xfeff,
			ByteOrderSwapped = 0xfffe,
			ParagraphSeparator = 0x2029,
			LineSeparator = 0x2028
		};

		//------------------------------------------------------------------------------
		enum eCategory
		{
			NoCategory,    // ### Qt 5: replace with Other_NotAssigned

			Mark_NonSpacing,          //   Mn
			Mark_SpacingCombining,    //   Mc
			Mark_Enclosing,           //   Me

			Number_DecimalDigit,      //   Nd
			Number_Letter,            //   Nl
			Number_Other,             //   No

			Separator_Space,          //   Zs
			Separator_Line,           //   Zl
			Separator_Paragraph,      //   Zp

			Other_Control,            //   Cc
			Other_Format,             //   Cf
			Other_Surrogate,          //   Cs
			Other_PrivateUse,         //   Co
			Other_NotAssigned,        //   Cn

			Letter_Uppercase,         //   Lu
			Letter_Lowercase,         //   Ll
			Letter_Titlecase,         //   Lt
			Letter_Modifier,          //   Lm
			Letter_Other,             //   Lo

			Punctuation_Connector,    //   Pc
			Punctuation_Dash,         //   Pd
			Punctuation_Open,         //   Ps
			Punctuation_Close,        //   Pe
			Punctuation_InitialQuote, //   Pi
			Punctuation_FinalQuote,   //   Pf
			Punctuation_Other,        //   Po

			Symbol_Math,              //   Sm
			Symbol_Currency,          //   Sc
			Symbol_Modifier,          //   Sk
			Symbol_Other,             //   So

			Punctuation_Dask = Punctuation_Dash // ### Qt 5: remove
		};

		//------------------------------------------------------------------------------
		enum eDirection
		{
			DirL, DirR, DirEN, DirES, DirET, DirAN, DirCS, DirB, DirS, DirWS, DirON,
			DirLRE, DirLRO, DirAL, DirRLE, DirRLO, DirPDF, DirNSM, DirBN
		};

		//------------------------------------------------------------------------------
		enum eDecomposition
		{
			NoDecomposition,
			Canonical,
			Font,
			NoBreak,
			Initial,
			Medial,
			Final,
			Isolated,
			Circle,
			Super,
			Sub,
			Vertical,
			Wide,
			Narrow,
			Small,
			Square,
			Compat,
			Fraction
		};

		//------------------------------------------------------------------------------
		enum eJoining
		{
			OtherJoining, Dual, Right, Center
		};

		//------------------------------------------------------------------------------
		enum eCombiningClass
		{
			Combining_BelowLeftAttached       = 200,
			Combining_BelowAttached           = 202,
			Combining_BelowRightAttached      = 204,
			Combining_LeftAttached            = 208,
			Combining_RightAttached           = 210,
			Combining_AboveLeftAttached       = 212,
			Combining_AboveAttached           = 214,
			Combining_AboveRightAttached      = 216,

			Combining_BelowLeft               = 218,
			Combining_Below                   = 220,
			Combining_BelowRight              = 222,
			Combining_Left                    = 224,
			Combining_Right                   = 226,
			Combining_AboveLeft               = 228,
			Combining_Above                   = 230,
			Combining_AboveRight              = 232,

			Combining_DoubleBelow             = 233,
			Combining_DoubleAbove             = 234,
			Combining_IotaSubscript           = 240
		};

		//------------------------------------------------------------------------------
		enum eUnicodeVersion 
		{
			Unicode_Unassigned,
			Unicode_1_1,
			Unicode_2_0,
			Unicode_2_1_2,
			Unicode_3_0,
			Unicode_3_1,
			Unicode_3_2,
			Unicode_4_0,
			Unicode_4_1,
			Unicode_5_0
		};

		//--------------------------------------------------------------------------------
		enum eHangul
		{
			Hangul_SBase = 0xac00,
			Hangul_LBase = 0x1100,
			Hangul_VBase = 0x1161,
			Hangul_TBase = 0x11a7,
			Hangul_SCount = 11172,
			Hangul_LCount = 19,
			Hangul_VCount = 21,
			Hangul_TCount = 28,
			Hangul_NCount = 21*28
		};

		__QCMP_USING_BASE( m );

		//------------------------------------------------------------------------------
		CChar() 
		{ 
			m = 0; 
		}

		//------------------------------------------------------------------------------
        CChar( const CChar& x ) 
		{ 
			m = x.m; 
		}

		//------------------------------------------------------------------------------
        CChar( const TType& x ) 
		{ 
			m = x; 
		}

		//------------------------------------------------------------------------------
		CChar& operator = ( const CChar& src )
		{
			m = src.m;
			return *this;
		}

		//------------------------------------------------------------------------------
		static eUnicodeVersion __QCMP_FASTCALL CurrentUnicodeVersion( void )
		{
			return UNICODE_DATA_VERSION;
		}

		//--------------------------------------------------------------------------------
		eCategory Category() const
		{
			return static_cast< eCategory >( UnicodeGetProp( static_cast< ULookupType >( m ) )->category );
		}

		//--------------------------------------------------------------------------------
		eDirection Direction() const
		{
			return static_cast< eDirection >( UnicodeGetProp( static_cast< ULookupType >( m ) )->direction );
		}

		//--------------------------------------------------------------------------------
		eJoining Joining() const
		{
			return static_cast< eJoining >( UnicodeGetProp( static_cast< ULookupType >( m ) )->joining );
		}

		//--------------------------------------------------------------------------------
		bool HasMirrored() const
		{
			return UnicodeGetProp( static_cast< ULookupType >( m ) )->mirrorDiff != 0;
		}

		//--------------------------------------------------------------------------------
		unsigned char CombiningClass() const
		{
			return (unsigned char) UnicodeGetProp( static_cast< ULookupType >( m ) )->combiningClass;
		}

		//--------------------------------------------------------------------------------
		int DigitValue() const
		{
			return UnicodeGetProp( static_cast< ULookupType >( m ) )->digitValue;
		}

		//--------------------------------------------------------------------------------
		eUnicodeVersion UnicodeVersion() const
		{
			return static_cast< eUnicodeVersion >( UnicodeGetProp( static_cast< ULookupType >( m ) )->unicodeVersion );
		}

		//--------------------------------------------------------------------------------
		bool IsNull() const
		{
			return ( m == 0 );
		}

		//--------------------------------------------------------------------------------
		bool IsPrint() const
		{
			const int test = Flag( Other_Control ) | Flag( Other_NotAssigned );
			return !( Flag( UnicodeGetProp( static_cast< ULookupType >( m ) )->category ) & test );
		}

		//--------------------------------------------------------------------------------
		bool IsPunct() const
		{
			const int test = Flag( Punctuation_Connector ) | Flag( Punctuation_Dash ) | Flag( Punctuation_Open ) | Flag( Punctuation_Close ) | Flag( Punctuation_InitialQuote ) |
							 Flag( Punctuation_FinalQuote ) | Flag( Punctuation_Other );
			return Flag( UnicodeGetProp( static_cast< ULookupType >( m ) )->category) & test ? true : false;
		}

		//--------------------------------------------------------------------------------
		bool IsSpace() const
		{
			if( m >= 9 && m <= 13 )
			{
				return true;
			}
			const int test = Flag( Separator_Space ) | Flag( Separator_Line ) | Flag( Separator_Paragraph );
			return Flag( UnicodeGetProp( static_cast< ULookupType >( m ) )->category ) & test ? true : false;
		}

		//--------------------------------------------------------------------------------
		bool IsMark() const
		{
			const int test = Flag( Mark_NonSpacing ) | Flag( Mark_SpacingCombining ) | Flag( Mark_Enclosing );
			return Flag( UnicodeGetProp( static_cast< ULookupType >( m ) )->category ) & test ? true : false;
		}

		//--------------------------------------------------------------------------------
		bool IsLetter() const
		{
			const int test = Flag( Letter_Uppercase ) | Flag( Letter_Lowercase ) | Flag( Letter_Titlecase ) | Flag( Letter_Modifier ) | Flag( Letter_Other );
			return Flag( UnicodeGetProp( static_cast< ULookupType >( m ) )->category ) & test ? true : false;
		}

		//--------------------------------------------------------------------------------
		bool IsNumber() const
		{
			const int test = Flag( Number_DecimalDigit ) | Flag( Number_Letter ) | Flag( Number_Other );
			return Flag( UnicodeGetProp( static_cast< ULookupType >( m ) )->category ) & test ? true : false;
		}

		//--------------------------------------------------------------------------------
		bool IsLetterOrNumber() const
		{
			const int test = Flag(Letter_Uppercase) | Flag(Letter_Lowercase) | Flag(Letter_Titlecase) | Flag(Letter_Modifier) | Flag(Letter_Other) | Flag(Number_DecimalDigit) | Flag(Number_Letter) | Flag(Number_Other);
			return Flag( UnicodeGetProp( static_cast< ULookupType >( m ) )->category ) & test ? true : false;
		}

		//--------------------------------------------------------------------------------
		bool IsDigit() const
		{
			return ( UnicodeGetProp( static_cast< ULookupType >( m ) )->category == Number_DecimalDigit );
		}

		//--------------------------------------------------------------------------------
		bool IsSymbol() const
		{
			const int test = Flag(Symbol_Math) | Flag(Symbol_Currency) | Flag(Symbol_Modifier) | Flag(Symbol_Other); 
			return Flag( UnicodeGetProp( static_cast< ULookupType >( m ) )->category ) & test ? true : false;
		}

		//--------------------------------------------------------------------------------
		inline bool IsLower() const
		{
			return Category() == Letter_Lowercase;
		}

		//--------------------------------------------------------------------------------
		inline bool IsUpper() const
		{
			return Category() == Letter_Uppercase;
		}

		//--------------------------------------------------------------------------------
		inline bool IsTitleCase() const
		{
			return Category() == Letter_Titlecase;
		}

		//--------------------------------------------------------------------------------
		eDecomposition DecompositionTag() const
		{
			const unsigned short index = GET_DECOMPOSITION_INDEX( static_cast< unsigned int >( m ) );
			if( index == 0xffff )
			{
				return NoDecomposition;
			}
			return static_cast< eDecomposition >( uc_decomposition_map[ index ] & 0xff );
		}

	private:

	}; 

}//nsCodeQOR

#endif//CODEQOR_TCHAR_H_3

