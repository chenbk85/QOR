//TExtString.h

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//String support and extension functions

#ifndef CODEQOR_DATASTRUCTURES_TEXTSTRING_H_1
#define CODEQOR_DATASTRUCTURES_TEXTSTRING_H_1

//--------------------------------------------------------------------------------
namespace nsCodeQOR
{
	//These functions must be external to the string class because they need to know the size of the 
	//character type in use. The CTString class itself must remain agnostic to that type

	//--------------------------------------------------------------------------------
	//Get the length of NULL terminated constant strings only to enable assignment
	template< typename _tChar >
	unsigned short ExtSysLen( const _tChar* cpString )
	{
		unsigned short usLen = 0;
		_tChar* cp = const_cast< _tChar* >( cpString );
		while( ( cp != 0 ) && ( ( *cp != 0 ) && usLen < USHRT_MAX ) )
		{
			usLen++;
			cp++;
		}
		return usLen;
	}

	//--------------------------------------------------------------------------------
	template< typename _tChar, class _tRawAllocator >
	void ExtWriteBuffer( CTString< _tChar, _tRawAllocator >& String, const _tChar* cpString, unsigned short usSrcLen, _tChar* pInternalBuffer )
	{
		unsigned short usCounter = 0;
		while( usCounter < usSrcLen && String.Len() < String.Capacity() )
		{
			pInternalBuffer[ String.InternalLen()++ ] = cpString[ usCounter++ ];
		}
	}

	//--------------------------------------------------------------------------------
	template< typename _tChar, class _tRawAllocator >
	void ExtSetSize( CTString< _tChar, _tRawAllocator >& String, unsigned short usCharCount )
	{
        //Allocate new memory
		_tRawAllocator allocator;
        unsigned short usSize = ( String.ClassHeaderByteSize() + String.ClassFooterByteSize() + ( sizeof( _tChar ) * usCharCount ) );
        byte* pAlloc = allocator.Source( usSize );
		memset( pAlloc, 0, usSize );

		//Get a byte pointer to the new string memory, after the header
		byte* pNewString = pAlloc + String.ClassHeaderByteSize();

        //Write the new header
		sHeader* pNewHeader = ( reinterpret_cast< sHeader* >( pNewString ) ) - 1;
        pNewHeader->usAlloc = usSize;
        pNewHeader->usLen = 0;
		pNewHeader->usHeaderLen = String.ClassHeaderByteSize();

		//Write the new footer
        sFooter* pNewFooter = ( reinterpret_cast< sFooter* >( pAlloc + usSize  ) -1 );
		//Initial reference count of 1
		pNewFooter->usRefCount = 1;	
		pNewFooter->usFooterLen = String.ClassFooterByteSize();

		//Get the bytes of the old string
        byte* pOldString  = reinterpret_cast< byte* >( String.m_p );

		//Defer any extra header in derived classes to a handler function they will need to override
        String.HeaderOnResize( pOldString, pNewString );
                                
		//Defer any extra footer in derived classes to a handler function they will need to provide
		String.FooterOnResize( pOldString, pNewString );

        //Copy data bytes from the old string
        if( pOldString )
        {				
			//Only copy up to the length of the shorter of the two strings
            unsigned short usShorter = usCharCount > String.Len() ? String.Len() : usCharCount;						

            for( byte* pCopy = pOldString; pCopy < ( pOldString + ( usShorter * sizeof( _tChar ) ) ); pCopy++ )
            {
				pNewString[ pCopy - pOldString ] = *pCopy;
            }
            pNewHeader->usLen = usShorter;				
			String.Release();
        }

		//The new string becomes The String here.
        String.m_p = reinterpret_cast< _tChar* >( pNewString );
	}

	//--------------------------------------------------------------------------------
	/*
	template< typename _tChar, class _tRawAllocator > 
	void ExtAssignFromAString( CTString< _tChar, _tRawAllocator >& String, const nsCodeQOR::CACodeString& aSrc )
	{
		unsigned short usSrcLen = ExtSysLen( reinterpret_cast< _tChar* >( aSrc.str().operator CChar8*() ) );
		if( sizeof( _tChar ) == 1 )
		{
			String.Init( reinterpret_cast< _tChar* >( aSrc.str().operator CChar8*() ), usSrcLen, usSrcLen | 128 );
		}
		else
		{
			nsCodeQOR::CChar8* pSrcChar = aSrc.str();
			while( ( usSrcLen > 0 ) && ( pSrcChar != 0 ) && ( *pSrcChar != 0 ) )
			{
				_tChar tmpChar( pSrcChar->Unicode() );
				String.Append( tmpChar );
				usSrcLen--;
				pSrcChar++;
			}
		}
	}
	*/
	//--------------------------------------------------------------------------------
	template< typename _tChar, class _tRawAllocator >
	bool ExtIsStringEqual( const CTString< _tChar, _tRawAllocator >& Cmp1, const CTString< _tChar, _tRawAllocator >& Cmp2 )
    {
		bool bResult = ( Cmp1.Len() == Cmp2.Len() ) ? true : false;
		unsigned int uiCounter = 0;
		while( bResult == true && ( uiCounter < Cmp1.Len() ) && ( uiCounter < Cmp2.Len() ) )
		{
			if( Cmp1.m_p[ uiCounter ] != Cmp2.m_p[ uiCounter ] )
			{
				bResult = false;
			}
			uiCounter++;
		}
		return bResult;
    }

#ifdef QOR_MONOLITHIC
	template class CTString< char >;
	template class CTString< wchar_t >;
	template unsigned short ExtSysLen< char >(const char* cpString);
	template unsigned short ExtSysLen< wchar_t >(const wchar_t* cpString);
	template void ExtWriteBuffer< char >(CTString< char >& String, const char* cpString, unsigned short usSrcLen, char* pInternalBuffer);
	template void ExtWriteBuffer< wchar_t >( CTString< wchar_t >& String, const wchar_t* cpString, unsigned short usSrcLen, wchar_t* pInternalBuffer);
	template void ExtSetSize< char >(CTString< char >& String, unsigned short usCharCount);
	template void ExtSetSize< wchar_t >(CTString< wchar_t >& String, unsigned short usCharCount);
	//template void ExtAssignFromAString< char >( CTString< char >& String, const nsCodeQOR::CACodeString& aSrc );
	//template void ExtAssignFromAString< wchar_t >( CTString< wchar_t >& String, const nsCodeQOR::CACodeString& aSrc );
	template bool ExtIsStringEqual< char >( const CTString< char >& Cmp1, const CTString< char >& Cmp2 );
	template bool ExtIsStringEqual< wchar_t >( const CTString< wchar_t >& Cmp1, const CTString< wchar_t >& Cmp2 );
#endif

}//nsCodeQOR

#endif//CODEQOR_DATASTRUCTURES_TEXTSTRING_H_1
