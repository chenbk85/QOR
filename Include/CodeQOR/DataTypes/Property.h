//Property.h

// Copyright Querysoft Limited 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Declares property templates for adding properties to classes

#ifndef CODEQOR_PROPERTY_H_2
#define CODEQOR_PROPERTY_H_2

#ifdef	__QCMP_OPTIMIZEINCLUDE
#pragma	__QCMP_OPTIMIZEINCLUDE
#endif//__QCMP_OPTIMIZEINCLUDE

//Add a class property to a class definition
#define __QCS_CLASS_PROP( _CLASS, _TYPE_, _NAME ) static nsCodeQOR::CProperty< _CLASS, _TYPE > _NAME;
//Add a class property implementation to a class implementation
#define __QCS_IMPL_CLASS_PROP( _CLASS, _TYPE, _NAME, _VALUE ) _TYPE _CLASS##::##_NAME = _VALUE;

//Add class member properties to a class definition
#define __QCS_VAL_PROP( _CLASS, _TYPE, _NAME ) nsCodeQOR::CProperty< _CLASS, _TYPE > _NAME;
#define __QCS_REF_PROP( _CLASS, _TYPE, _NAME) nsCodeQOR::CRefProperty< _CLASS, _TYPE > _NAME;
#define __QCS_VOL_REF_PROP( _CLASS, _TYPE, _NAME ) nsCodeQOR::CVolRefProperty< _CLASS, _TYPE > _NAME;
#define __QCS_ATTACH_REF_PROP( _CLASS, _NAME, _GETFUNC, _SETFUNC ) _NAME.Attach( this, &_CLASS::_GETFUNC, &_CLASS::_SETFUNC );
#define __QCS_ATTACH_REF_PROP_RO( _CLASS, _NAME, _GETFUNC ) _NAME.Attach( this, &_CLASS::_GETFUNC, 0 );
#define __QCS_ATTACH_REF_PROP_WO( _CLASS, _NAME, _SETFUNC ) _NAME.Attach( this, 0, &_CLASS::_SETFUNC );

//--------------------------------------------------------------------------------
namespace nsCodeQOR
{
	//------------------------------------------------------------------------------
	///A contained value property template
	template< class TContainer, typename t >
	class CProperty
	{

	private:

		t m_Value;
		
	public:

		//------------------------------------------------------------------------------
		CProperty() : m_Value(0)
		{
		}

		//------------------------------------------------------------------------------
		CProperty( CProperty const& prop ) : m_Value( prop.m_Value )
		{
		}

		//------------------------------------------------------------------------------
		virtual ~CProperty()
		{
		}

		//------------------------------------------------------------------------------
		CProperty& operator = ( CProperty& source )
		{		
			m_Value = source.m_Value;
		}

		//------------------------------------------------------------------------------
		bool operator = ( const t& newValue )
		{
			m_Value = newValue;
			return true;
		}

		//------------------------------------------------------------------------------
		t operator()(void)
		{
			return m_Value;
		}

		//------------------------------------------------------------------------------
		t Get(void)
		{
			return m_Value;
		}

		//------------------------------------------------------------------------------
		bool Set( const t& newValue )
		{		
			m_Value = newValue;
			return true;
		}
	};

	//------------------------------------------------------------------------------
	//Reference Property
	//Use these where the container implements the Getter and Setter
	//for example when attaching a property to an existing class hierarchy
	template< class TContainer, typename t >
	class CRefProperty
	{
	public:

		typedef t( TContainer::*Getter )(void);
		typedef bool( TContainer::*Setter )(const t&);

	protected:

		Getter m_pGet;
		Setter m_pSet;
		TContainer* m_pContainer;

	public:

		//------------------------------------------------------------------------------
		CRefProperty() : m_pContainer(0), m_pGet(0), m_pSet(0)
		{
		}

		//------------------------------------------------------------------------------
		CRefProperty(CRefProperty const& RefProp) : m_pContainer(RefProp.m_pContainer), m_pGet(RefProp.m_pGet), m_pSet(RefProp.m_pSet)
		{
		}

		//------------------------------------------------------------------------------
		CRefProperty(TContainer* pContainer, Getter pGet, Setter pSet) : m_pContainer(pContainer), m_pGet(pGet), m_pSet(pSet)
		{
		}

		//------------------------------------------------------------------------------
		virtual ~CRefProperty()
		{
		}

		//------------------------------------------------------------------------------
		CRefProperty& operator=(CRefProperty& source)
		{
			m_pContainer = source.m_pContainer;
			m_pGet = source.m_pGet;
			m_pSet = source.m_pSet;		
			return *this;
		}

		//------------------------------------------------------------------------------
		bool operator=(const t& newValue)
		{
			return Set(newValue);
		}

		//------------------------------------------------------------------------------
		t operator()(void)
		{
			return Get();
		}

		//------------------------------------------------------------------------------
		void Attach(TContainer* pContainer, Getter pGet, Setter pSet)
		{
			m_pContainer = pContainer;
			m_pGet = pGet;
			m_pSet = pSet;
		}

		//------------------------------------------------------------------------------
		void Detach()
		{
			m_pContainer = 0;
			m_pGet = 0;
			m_pSet = 0;
		}

		//------------------------------------------------------------------------------
		t Get(void)
		{
			if( m_pGet && m_pContainer )//Readable indirect property
			{			
				return ( m_pContainer->*m_pGet )();
			}

			//Write only or unattached indirect property
			t Uninitialised;
			return Uninitialised;
		}

		//------------------------------------------------------------------------------
		bool Set( const t& newValue )
		{		

			if( m_pSet && m_pContainer )//Writable indirect property
			{
				return ( ( m_pContainer->*m_pSet )(newValue) );
			}

			return false;
		}
	};

	//------------------------------------------------------------------------------
	//Volatile Reference Property
	//Use these where the Getter may change the value
	template<class TContainer, typename t>
	class CVolRefProperty
	{
	public:

		typedef t( TContainer::*Getter )(void);
		typedef bool ( TContainer::*Setter )(t&);

	protected:

		Getter m_pGet;
		Setter m_pSet;
		TContainer* m_pContainer;

	public:

		//------------------------------------------------------------------------------
		CVolRefProperty() : m_pContainer(0), m_pGet(0), m_pSet(0)
		{
		}

		//------------------------------------------------------------------------------
		CVolRefProperty(CVolRefProperty const& RefProp) : m_pContainer(RefProp.m_pContainer), m_pGet(RefProp.m_pGet), m_pSet(RefProp.m_pSet)
		{
		}

		//------------------------------------------------------------------------------
		CVolRefProperty(TContainer* pContainer, Getter pGet, Setter pSet) : m_pContainer(pContainer), m_pGet(pGet), m_pSet(pSet)
		{
		}

		//------------------------------------------------------------------------------
		virtual ~CVolRefProperty()
		{
		}

		//------------------------------------------------------------------------------
		CVolRefProperty& operator=(CVolRefProperty& source)
		{
			m_pContainer = source.m_pContainer;
			m_pGet = source.m_pGet;
			m_pSet = source.m_pSet;
		}

		//------------------------------------------------------------------------------
		bool operator=(t& newValue)
		{
			return Set(newValue);
		}

		//------------------------------------------------------------------------------
		t operator()(void)
		{
			return Get();
		}

		//------------------------------------------------------------------------------
		void Attach(TContainer* pContainer, Getter pGet, Setter pSet)
		{
			m_pContainer = pContainer;
			m_pGet = pGet;
			m_pSet = pSet;
		}

		//------------------------------------------------------------------------------
		void Detach()
		{
			m_pContainer = 0;
			m_pGet = 0;
			m_pSet = 0;
		}

		//------------------------------------------------------------------------------
		t Get(void)
		{
			if( m_pGet && m_pContainer )//Readable indirect property
			{			
				return (m_pContainer->*m_pGet)();
			}

			//Write only or unattached indirect property
			t Uninitialised;
			return Uninitialised;
		}

		//------------------------------------------------------------------------------
		bool Set( t& newValue )
		{		

			if( m_pSet && m_pContainer )//Writable indirect property
			{
				return ( (m_pContainer->*m_pSet)( newValue ) );
			}

			return false;
		}
	};

}//nsCodeQOR

#endif//CODEQOR_PROPERTY_H_2
