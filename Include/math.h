//math.h

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef QOR_MATH_H_3
#define QOR_MATH_H_3

#include "SystemQOR.h"
#include QOR_SYS_PLATFORMTYPES(math)
#include QOR_SYS_PLATFORMTYPES(_Complex)

typedef nsPlatform::double_complex double_complex;

__QCMP_STATIC_CONSTANT( Cmp_double, M_E =			2.7182818284590452354 );			//[XSI]  Value of e
__QCMP_STATIC_CONSTANT( Cmp_double, M_LOG2E	=		1.4426950408889634074 );			//Value of log2e
__QCMP_STATIC_CONSTANT( Cmp_double, M_LOG10E =		0.43429448190325182765 );			//Value of log10e
__QCMP_STATIC_CONSTANT( Cmp_double, M_LN2 =			0.69314718055994530942 );			//Value of loge2
__QCMP_STATIC_CONSTANT( Cmp_double, M_LN10 =		2.30258509299404568402 );			//Value of loge10
__QCMP_STATIC_CONSTANT( Cmp_double, M_PI =			3.14159265358979323846 );			//Value of pi
__QCMP_STATIC_CONSTANT( Cmp_double, M_PI_2 = 		1.57079632679489661923 );			//Value of pi/2
__QCMP_STATIC_CONSTANT( Cmp_double, M_PI_4 = 		0.78539816339744830962 );			//Value of pi/4
__QCMP_STATIC_CONSTANT( Cmp_double, M_1_PI =		0.31830988618379067154 );			//Value of 1/pi
__QCMP_STATIC_CONSTANT( Cmp_double, M_2_PI = 		0.63661977236758134308 );			//Value of 2/pi
__QCMP_STATIC_CONSTANT( Cmp_double, M_2_SQRTPI = 	1.12837916709551257390 );			//Value of 2/sqrt pi
__QCMP_STATIC_CONSTANT( Cmp_double, M_SQRT2	=		1.41421356237309504880 );			//Value of sqrt 2
__QCMP_STATIC_CONSTANT( Cmp_double, M_SQRT1_2 =		0.70710678118654752440 );			//Value of sqrt 1/2

__QCMP_STATIC_CONSTANT( float, MAXFLOAT	=			3.402823466e+38F );					// Value of maximum non-infinite single-precision floating-point number.

#ifndef FLT_EVAL_METHOD
#	define FLT_EVAL_METHOD 0
#endif//FLT_EVAL_METHOD

#if		( FLT_EVAL_METHOD == 0 )
	typedef Cmp_float float_t;
	typedef Cmp_double double_t;
#elif	( FLT_EVAL_METHOD == 1 )
	typedef Cmp_double float_t;
	typedef Cmp_double double_t;
#elif	( FLT_EVAL_METHOD == 2 )
	typedef Cmp_long_double float_t;
	typedef Cmp_long_double double_t;
#endif//( FLT_EVAL_METHOD == ? )


#define NAN					( nsPlatform::NaN )				//A constant expression of type float representing a quiet NaN. This symbolic constant is only defined if the implementation supports quiet NaNs for the float type.
#define HUGE_VAL			( nsPlatform::HugeValue )		//A positive double expression, not necessarily representable as a float. Used as an error value returned by the mathematics library. HUGE_VAL evaluates to +infinity on systems supporting IEEE Std 754-1985.
#define HUGE_VALF			( nsPlatform::HugeValueF )		//A positive float constant expression. Used as an error value returned by the mathematics library. HUGE_VALF evaluates to +infinity on systems supporting IEEE Std 754-1985.
#define HUGE_VALL			( nsPlatform::HugeValueLL )		//A positive long double constant expression. Used as an error value returned by the mathematics library. HUGE_VALL evaluates to +infinity on systems supporting IEEE Std 754-1985.
#define INFINITY			( nsPlatform::HugeValueF )		//A constant expression of type float representing positive or unsigned infinity, if available; else a positive constant of type float that overflows at translation time.

//The following macros shall be defined for number classification.
//They represent the mutually-exclusive kinds of floating-point values.
//They expand to integer constant expressions with distinct values.
//Additional implementation-defined floating-point classifications, with macro definitions beginning with FP_ and an uppercase letter, may also be specified by the implementation.

#define FP_INFINITE			( nsPlatform::FpInfinite )
#define FP_NAN				( nsPlatform::FpNAN )
#define FP_NORMAL			( nsPlatform::FpNormal )
#define FP_SUBNORMAL		( nsPlatform::FpSubNormal )
#define FP_ZERO				( nsPlatform::FpZero )

//The following optional macros indicate whether the fma() family of functions are fast compared with direct code:

//FP_FAST_FMA
//FP_FAST_FMAF
//FP_FAST_FMAL

//If defined, the FP_FAST_FMA macro shall indicate that the fma() function generally executes about as fast as, or faster than, a multiply and an add of double operands. If undefined, the speed of execution is unspecified. The other macros have the equivalent meaning for the float and long double versions.
//The following macros shall expand to integer constant expressions whose values are returned by ilogb( x) if x is zero or NaN, respectively. The value of FP_ILOGB0 shall be either {INT_MIN} or - {INT_MAX}. The value of FP_ILOGBNAN shall be either {INT_MAX} or {INT_MIN}.
//FP_ILOGB0
//FP_ILOGBNAN

//The following macros shall expand to the integer constants 1 and 2, respectively;
#define MATH_ERRNO			1
#define MATH_ERREXCEPT		2

//The following macro shall expand to an expression that has type int and the value MATH_ERRNO, MATH_ERREXCEPT, or the bitwise-inclusive OR of both:

#define math_errhandling		( nsPlatform::MathErrorHandling() )

/*
The value of math_errhandling is constant for the duration of the program.
It is unspecified whether math_errhandling is a macro or an identifier with external linkage.
If a macro definition is suppressed or a program defines an identifier with the name math_errhandling , the behavior is undefined.
If the expression (math_errhandling & MATH_ERREXCEPT) can be non-zero, the implementation shall define the macros FE_DIVBYZERO, FE_INVALID, and FE_OVERFLOW in <fenv.h>.
*/

extern int __isinff (float x);
extern int __isinfd (double x);
extern int __isnanf (float x);
extern int __isnand (double x);
extern int __fpclassifyf (float x);
extern int __fpclassifyd (double x);
extern int __signbitf (float x);
extern int __signbitd (double x);

__QCMP_STARTLINKAGE_C

    __QOR_INTERFACE( __CQOR ) int fpclassify(long double x);
    __QOR_INTERFACE( __CQOR ) int isfinite(long double x);
    __QOR_INTERFACE( __CQOR ) int isinf(long double x);
    __QOR_INTERFACE( __CQOR ) int isnan(long double x);
    __QOR_INTERFACE( __CQOR ) int isnormal(long double x);
    __QOR_INTERFACE( __CQOR ) int signbit(long double x);
    __QOR_INTERFACE( __CQOR ) double acos(double x);
    __QOR_INTERFACE( __CQOR ) float acosf(float x);
    __QOR_INTERFACE( __CQOR ) double acosh(double x);
    __QOR_INTERFACE( __CQOR ) float acoshf(float x);
    __QOR_INTERFACE( __CQOR ) long double acoshl(long double x);
    __QOR_INTERFACE( __CQOR ) long double acosl(long double x);
    __QOR_INTERFACE( __CQOR ) double asin(double x);
    __QOR_INTERFACE( __CQOR ) float asinf(float x);
    __QOR_INTERFACE( __CQOR ) double asinh(double x);
    __QOR_INTERFACE( __CQOR ) float asinhf(float x);
    __QOR_INTERFACE( __CQOR ) long double asinhl(long double x);
    __QOR_INTERFACE( __CQOR ) long double asinl(long double x);
    __QOR_INTERFACE( __CQOR ) double atan(double x);
    __QOR_INTERFACE( __CQOR ) double atan2(double y, double x);
    __QOR_INTERFACE( __CQOR ) float atan2f(float y, float x);
    __QOR_INTERFACE( __CQOR ) long double atan2l(long double y, long double x);
    __QOR_INTERFACE( __CQOR ) float atanf(float x);
    __QOR_INTERFACE( __CQOR ) double atanh(double x);
    __QOR_INTERFACE( __CQOR ) float atanhf(float x);
    __QOR_INTERFACE( __CQOR ) long double atanhl(long double x);
    __QOR_INTERFACE( __CQOR ) long double atanl(long double x);
    __QOR_INTERFACE( __CQOR ) double cbrt( double x );
    __QOR_INTERFACE( __CQOR ) float cbrtf(float x);
    __QOR_INTERFACE( __CQOR ) long double cbrtl(long double x);
    __QOR_INTERFACE( __CQOR ) double ceil(double x);
    __QOR_INTERFACE( __CQOR ) float ceilf(float x);
    __QOR_INTERFACE( __CQOR ) long double ceill(long double x);
    __QOR_INTERFACE( __CQOR ) double copysign(double x, double y);
    __QOR_INTERFACE( __CQOR ) float copysignf(float x, float y);
    __QOR_INTERFACE( __CQOR ) long double copysignl(long double x, long double y);
    __QOR_INTERFACE( __CQOR ) double cos(double x);
    __QOR_INTERFACE( __CQOR ) float cosf(float x);
    __QOR_INTERFACE( __CQOR ) double cosh(double x);
    __QOR_INTERFACE( __CQOR ) float coshf(float x);
    __QOR_INTERFACE( __CQOR ) long double coshl(long double x);
    __QOR_INTERFACE( __CQOR ) long double cosl(long double x);
    __QOR_INTERFACE( __CQOR ) double erf(double x);
    __QOR_INTERFACE( __CQOR ) double erfc(double x);
    __QOR_INTERFACE( __CQOR ) float erfcf(float x);
    __QOR_INTERFACE( __CQOR ) long double erfcl(long double x);
    __QOR_INTERFACE( __CQOR ) float erff(float x);
    __QOR_INTERFACE( __CQOR ) long double erfl(long double x);
    __QOR_INTERFACE( __CQOR ) double exp(double x);
    __QOR_INTERFACE( __CQOR ) double exp2(double x);
    __QOR_INTERFACE( __CQOR ) float exp2f(float x);
    __QOR_INTERFACE( __CQOR ) long double exp2l(long double x);
    __QOR_INTERFACE( __CQOR ) float expf(float x);
    __QOR_INTERFACE( __CQOR ) long double expl(long double x);
    __QOR_INTERFACE( __CQOR ) double expm1(double x);
    __QOR_INTERFACE( __CQOR ) float expm1f(float x);
    __QOR_INTERFACE( __CQOR ) long double expm1l(long double x);
    __QOR_INTERFACE( __CQOR ) double fabs(double x);
    __QOR_INTERFACE( __CQOR ) float fabsf(float x);
    __QOR_INTERFACE( __CQOR ) long double fabsl(long double x);
    __QOR_INTERFACE( __CQOR ) double fdim(double x, double y);
    __QOR_INTERFACE( __CQOR ) float fdimf(float x, float y);
    __QOR_INTERFACE( __CQOR ) long double fdiml(long double x, long double y);
    __QOR_INTERFACE( __CQOR ) double floor(double x);
    __QOR_INTERFACE( __CQOR ) float floorf(float x);
    __QOR_INTERFACE( __CQOR ) long double floorl(long double x);
    __QOR_INTERFACE( __CQOR ) double fma(double x, double y, double z);
    __QOR_INTERFACE( __CQOR ) float fmaf(float x, float y, float z);
    __QOR_INTERFACE( __CQOR ) long double fmal(long double x, long double y, long double z);
    __QOR_INTERFACE( __CQOR ) double fmax(double x, double y);
    __QOR_INTERFACE( __CQOR ) float fmaxf(float x, float y);
    __QOR_INTERFACE( __CQOR ) long double fmaxl(long double x, long double y);
    __QOR_INTERFACE( __CQOR ) double fmin(double x, double y);
    __QOR_INTERFACE( __CQOR ) float fminf(float x, float y);
    __QOR_INTERFACE( __CQOR ) long double fminl(long double x, long double y);
    __QOR_INTERFACE( __CQOR ) double fmod(double x, double y);
    __QOR_INTERFACE( __CQOR ) float fmodf(float x, float y);
    __QOR_INTERFACE( __CQOR ) long double fmodl(long double x, long double y);
    __QOR_INTERFACE( __CQOR ) double frexp(double value, int *exp);
    __QOR_INTERFACE( __CQOR ) float frexpf(float value, int *exp);
    __QOR_INTERFACE( __CQOR ) long double frexpl(long double value, int *exp);
    __QOR_INTERFACE( __CQOR ) double hypot(double x, double y);
    __QOR_INTERFACE( __CQOR ) float hypotf(float x, float y);
    __QOR_INTERFACE( __CQOR ) long double hypotl(long double x, long double y);
    __QOR_INTERFACE( __CQOR ) int ilogb(double x);
    __QOR_INTERFACE( __CQOR ) int ilogbf(float x);
    __QOR_INTERFACE( __CQOR ) int ilogbl(long double x);
    __QOR_INTERFACE( __CQOR ) double ldexp(double x, int exp);
    __QOR_INTERFACE( __CQOR ) float ldexpf(float x, int exp);
    __QOR_INTERFACE( __CQOR ) long double ldexpl(long double x, int exp);
    __QOR_INTERFACE( __CQOR ) double lgamma(double x);
    __QOR_INTERFACE( __CQOR ) float lgammaf(float x);
    __QOR_INTERFACE( __CQOR ) long double lgammal(long double x);
    __QOR_INTERFACE( __CQOR ) long long int llrint(double x);
    __QOR_INTERFACE( __CQOR ) long long int llrintf(float x);
    __QOR_INTERFACE( __CQOR ) long long int llrintl(long double x);
    __QOR_INTERFACE( __CQOR ) long long int llround(double x);
    __QOR_INTERFACE( __CQOR ) long long int llroundf(float x);
    __QOR_INTERFACE( __CQOR ) long long int llroundl(long double x);
    __QOR_INTERFACE( __CQOR ) double log(double x);
    __QOR_INTERFACE( __CQOR ) double log10(double x);
    __QOR_INTERFACE( __CQOR ) float log10f(float x);
    __QOR_INTERFACE( __CQOR ) long double log10l(long double x);
    __QOR_INTERFACE( __CQOR ) double log1p(double x);
    __QOR_INTERFACE( __CQOR ) float log1pf(float x);
    __QOR_INTERFACE( __CQOR ) long double log1pl(long double x);
    __QOR_INTERFACE( __CQOR ) double log2(double x);
    __QOR_INTERFACE( __CQOR ) float log2f(float x);
    __QOR_INTERFACE( __CQOR ) long double log2l(long double x);
    __QOR_INTERFACE( __CQOR ) double logb(double x);
    __QOR_INTERFACE( __CQOR ) float logbf(float x);
    __QOR_INTERFACE( __CQOR ) long double logbl(long double x);
    __QOR_INTERFACE( __CQOR ) float logf(float x);
    __QOR_INTERFACE( __CQOR ) long double logl(long double x);
    __QOR_INTERFACE( __CQOR ) long int lrint(double x);
    __QOR_INTERFACE( __CQOR ) long int lrintf(float x);
    __QOR_INTERFACE( __CQOR ) long int lrintl(long double x);
    __QOR_INTERFACE( __CQOR ) long int lround(double x);
    __QOR_INTERFACE( __CQOR ) long int lroundf(float x);
    __QOR_INTERFACE( __CQOR ) long int lroundl(long double x);
    __QOR_INTERFACE( __CQOR ) double modf(double value, double *iptr);
    __QOR_INTERFACE( __CQOR ) float modff(float value, float *iptr);
    __QOR_INTERFACE( __CQOR ) long double modfl(long double value, long double *iptr);
    __QOR_INTERFACE( __CQOR ) double nan(const char *tagp);
    __QOR_INTERFACE( __CQOR ) float nanf(const char *tagp);
    __QOR_INTERFACE( __CQOR ) long double nanl(const char *tagp);
    __QOR_INTERFACE( __CQOR ) double nearbyint(double x);
    __QOR_INTERFACE( __CQOR ) float nearbyintf(float x);
    __QOR_INTERFACE( __CQOR ) long double nearbyintl(long double x);
    __QOR_INTERFACE( __CQOR ) double nextafter(double x, double y);
    __QOR_INTERFACE( __CQOR ) float nextafterf(float x, float y);
    __QOR_INTERFACE( __CQOR ) long double nextafterl(long double x, long double y);
    __QOR_INTERFACE( __CQOR ) double nexttoward(double x, long double y);
    __QOR_INTERFACE( __CQOR ) float nexttowardf(float x, long double y);
    __QOR_INTERFACE( __CQOR ) long double nexttowardl(long double x, long double y);
    __QOR_INTERFACE( __CQOR ) double pow(double x, double y);
    __QOR_INTERFACE( __CQOR ) float powf(float x, float y);
    __QOR_INTERFACE( __CQOR ) long double powl(long double x, long double y);
    __QOR_INTERFACE( __CQOR ) double remainder(double x, double y);
    __QOR_INTERFACE( __CQOR ) float remainderf(float x, float y);
    __QOR_INTERFACE( __CQOR ) long double remainderl(long double x, long double y);
    __QOR_INTERFACE( __CQOR ) double remquo(double x, double y, int *quo);
    __QOR_INTERFACE( __CQOR ) float remquof(float x, float y, int *quo);
    __QOR_INTERFACE( __CQOR ) long double remquol(long double x, long double y, int *quo);
    __QOR_INTERFACE( __CQOR ) double rint(double x);
    __QOR_INTERFACE( __CQOR ) float rintf(float x);
    __QOR_INTERFACE( __CQOR ) long double rintl(long double x);
    __QOR_INTERFACE( __CQOR ) double round(double x);
    __QOR_INTERFACE( __CQOR ) float roundf(float x);
    __QOR_INTERFACE( __CQOR ) long double roundl(long double x);
    __QOR_INTERFACE( __CQOR ) double scalbln(double x, long int n);
    __QOR_INTERFACE( __CQOR ) float scalblnf(float x, long int n);
    __QOR_INTERFACE( __CQOR ) long double scalblnl(long double x, long int n);
    __QOR_INTERFACE( __CQOR ) double scalbn(double x, int n);
    __QOR_INTERFACE( __CQOR ) float scalbnf(float x, int n);
    __QOR_INTERFACE( __CQOR ) long double scalbnl(long double x, int n);
    __QOR_INTERFACE( __CQOR ) double sin(double x);
    __QOR_INTERFACE( __CQOR ) float sinf(float x);
    __QOR_INTERFACE( __CQOR ) double sinh(double x);
    __QOR_INTERFACE( __CQOR ) float sinhf(float x);
    __QOR_INTERFACE( __CQOR ) long double sinhl(long double x);
    __QOR_INTERFACE( __CQOR ) long double sinl(long double x);
    __QOR_INTERFACE( __CQOR ) double sqrt(double x);
    __QOR_INTERFACE( __CQOR ) float sqrtf(float x);
    __QOR_INTERFACE( __CQOR ) long double sqrtl(long double x);
    __QOR_INTERFACE( __CQOR ) double tan(double x);
    __QOR_INTERFACE( __CQOR ) float tanf(float x);
    __QOR_INTERFACE( __CQOR ) double tanh(double x);
    __QOR_INTERFACE( __CQOR ) float tanhf(float x);
    __QOR_INTERFACE( __CQOR ) long double tanhl(long double x);
    __QOR_INTERFACE( __CQOR ) long double tanl(long double x);
    __QOR_INTERFACE( __CQOR ) double tgamma(double x);
    __QOR_INTERFACE( __CQOR ) float tgammaf(float x);
    __QOR_INTERFACE( __CQOR ) long double tgammal(long double x);
    __QOR_INTERFACE( __CQOR ) double trunc(double x);
    __QOR_INTERFACE( __CQOR ) float truncf(float x);
    __QOR_INTERFACE( __CQOR ) long double truncl(long double x);
    __QOR_INTERFACE( __CQOR ) int isgreater(long double x, long double y);
    __QOR_INTERFACE( __CQOR ) int isgreaterequal(long double x, long double y);
    __QOR_INTERFACE( __CQOR ) int isless(long double x, long double y);
    __QOR_INTERFACE( __CQOR ) int islessequal(long double x, long double y);
    __QOR_INTERFACE( __CQOR ) int islessgreater(long double x, long double y);
    __QOR_INTERFACE( __CQOR ) int isunordered(long double x, long double y);

    __QOR_INTERFACE( __CQOR ) double j0(double);
    __QOR_INTERFACE( __CQOR ) double j1(double);
    __QOR_INTERFACE( __CQOR ) double jn(int, double);
    __QOR_INTERFACE( __CQOR ) double scalb(double, double);
    __QOR_INTERFACE( __CQOR ) double y0( double );
    __QOR_INTERFACE( __CQOR ) double y1( double );
    __QOR_INTERFACE( __CQOR ) double yn( int, double );

	__QOR_INTERFACE( __CQOR ) int _set_SSE2_enable( int flag );
	__QOR_INTERFACE( __CQOR ) double _scalb(double, double);

	__QOR_INTERFACE( __CQOR ) double _j0( double x );
	__QOR_INTERFACE( __CQOR ) double _j1( double x );
	__QOR_INTERFACE( __CQOR ) double _jn( int n, double x );
	__QOR_INTERFACE( __CQOR ) int _isnan( double x );
	__QOR_INTERFACE( __CQOR ) double _hypot( double x, double y );
	__QOR_INTERFACE( __CQOR ) double _cabs( ::double_complex z );
	//__QOR_INTERFACE( __CQOR ) void __setusermatherr( _HANDLE_MATH_ERROR pf );


__QCMP_ENDLINKAGE_C

#endif //QOR_MATH_H_3

