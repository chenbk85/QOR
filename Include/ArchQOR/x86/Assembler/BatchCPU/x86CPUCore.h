//x86CPUCore.h

// Copyright (c) 2008-2010, Petr Kobalicek <kobalicek.petr@gmail.com>
// Copyright (c) Querysoft Limited 2012
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef ARCHQOR_X86PC_ASSEMBLERCORE_H_2
#define ARCHQOR_X86PC_ASSEMBLERCORE_H_2

#include "CompilerQOR.h"
#include "ArchQOR/x86/Assembler/Operands/Operand.h"
#include "ArchQOR/Common/Assembler/BatchCPU/CPUBase.h"
#include "ArchQOR/x86/Assembler/Defs.h"
#include "TrampolineWriter.h"

//------------------------------------------------------------------------------
namespace nsArch
{
//------------------------------------------------------------------------------
namespace nsx86
{
	class __QOR_INTERFACE( __ARCHQOR ) Cx86CPUCore;

	//--------------------------------------------------------------------------
	//Data structure used to link linked-labels.
	struct LabelLink
	{
		LabelLink* prev;			//Previous link.
		Cmp_int_ptr offset;			//Offset.
		Cmp_int_ptr displacement;	//Inlined displacement.
		Cmp_int_ptr relocId;		//RelocId if link must be absolute when relocated.
	};

	//--------------------------------------------------------------------------
	// Label data.
	struct LabelData
	{
		Cmp_int_ptr offset;		//Label offset.
		LabelLink* links;		//Label links chain.
	};

	// --------------------------------------------------------------------------
	// RelocData

	// X86 architecture uses 32-bit absolute addressing model by memory operands,
	// but 64-bit mode uses relative addressing model (RIP + displacement). In
	// code we are always using relative addressing model for referencing labels
	// and embedded data. In 32-bit mode we must patch all references to absolute
	// address before we can call generated function. We are patching only memory
	// operands.

	//------------------------------------------------------------------------------
	//Code relocation data (relative vs absolute addresses).
	struct RelocData
	{
		//------------------------------------------------------------------------------
		enum Type
		{
			ABSOLUTE_TO_ABSOLUTE = 0,
			RELATIVE_TO_ABSOLUTE = 1,
			ABSOLUTE_TO_RELATIVE = 2,
			ABSOLUTE_TO_RELATIVE_TRAMPOLINE = 3
		};

		Cmp_unsigned__int32 type;			//Type of relocation.
		Cmp_unsigned__int32 size;			//Size of relocation (4 or 8 bytes).
		Cmp_int_ptr offset;					//Offset from code begin address.

		//------------------------------------------------------------------------------
		union							//Relative displacement or absolute address.
		{
			Cmp_int_ptr destination;	//Relative displacement from code begin address (not to @c offset).
			void* address;				//Absolute address where to jump;
		};
	};

	//------------------------------------------------------------------------------
	class __QOR_INTERFACE( __ARCHQOR ) Cx86CPUCore : public CCPUBase
	{
		friend class CInstEmitter;

	public:

		Cx86CPUCore( nsArch::CCodeGeneratorBase* codeGenerator ) __QCMP_THROW;	  
		virtual ~Cx86CPUCore() __QCMP_THROW;

		//Properties
		Cmp_unsigned__int32 getProperty( Cmp_unsigned__int32 propertyId );					//Get assembler property.
		void setProperty( Cmp_unsigned__int32 propertyId, Cmp_unsigned__int32 value );		//Set assembler property.


		//------------------------------------------------------------------------------
		//Return current offset in buffer (same as getOffset() + getTramplineSize()).
		inline Cmp_int_ptr getCodeSize() const __QCMP_THROW
		{ 
			return m_Buffer.getOffset() + getTrampolineSize(); 
		}

		//------------------------------------------------------------------------------
		//Get size of all possible trampolines needed to successfuly generate
		//relative jumps to absolute addresses. This value is only non-zero if jmp
		//of call instructions were used with immediate operand (this means jump or
		//call absolute address directly).
		//Currently only _emitJmpOrCallReloc() method can increase trampoline size
		//value.
		inline Cmp_int_ptr getTrampolineSize() const __QCMP_THROW
		{ 
			return m_iTrampolineSize; 
		}

		
		void clear() __QCMP_THROW;							//Clear everything, but not deallocate buffers.
		void free() __QCMP_THROW;							//Free internal buffer and NULL all pointers.
		Cmp_unsigned__int8* takeCode() __QCMP_THROW;		//Take internal code buffer and NULL all pointers (you take the ownership).


		//Set custom variable imm at position pos.
		//This function is used to patch existing code.
		void setVarAt( Cmp_int_ptr pos, Cmp_int_ptr i, Cmp_unsigned__int8 isUnsigned, Cmp_unsigned__int32 size ) __QCMP_THROW;

		// Assembler Emitters
		//
		// These emitters are not protecting buffer from overrun, this must be 
		// done in emitX86() methods by:
		//   if (!canEmit()) return;

		//Get whether next instruction can be emitted.
		//This function behaves like ensureSpace(), but it also checks if
		//assembler is in error state and in that case it returns false.
		//Assembler internally always uses this function before new instruction is
		//emitted.
		//
		//It's implemented like:
		//  <code>return ensureSpace() && !getError();</code>
		//bool canEmit() __QCMP_THROW;

		//------------------------------------------------------------------------------
		//Emit single opCode without operands.
		inline void _emitOpCode( Cmp_unsigned__int32 opCode ) __QCMP_THROW
		{
			// instruction prefix
			if( opCode & 0xFF000000 )
			{
				_emitByte( (Cmp_unsigned__int8)( ( opCode & 0xFF000000 ) >> 24 ) );
			}

			// instruction opcodes
			if( opCode & 0x00FF0000 )
			{
				_emitByte((Cmp_unsigned__int8)( ( opCode & 0x00FF0000 ) >> 16 ) );
			}

			if( opCode & 0x0000FF00 )
			{
				_emitByte((Cmp_unsigned__int8)(( opCode & 0x0000FF00 ) >>  8 ) );
			}
			// last opcode is always emitted (can be also 0x00)
			_emitByte((Cmp_unsigned__int8)( opCode & 0x000000FF ) );
		}

		//Emit CS (code segmend) prefix.
		//Behavior of this function is to emit code prefix only if memory operand
		//address uses code segment. Code segment is used through memory operand
		//with attached CLabel.
		void _emitSegmentPrefix( const COperand* prm ) __QCMP_THROW;

		//------------------------------------------------------------------------------
		//Emit MODR/M byte.
		inline void _emitMod( Cmp_unsigned__int8 m, Cmp_unsigned__int8 o, Cmp_unsigned__int8 r ) __QCMP_THROW
		{ 
			_emitByte( ( ( m & 0x03 ) << 6 ) | ( ( o & 0x07 ) << 3 ) | ( r & 0x07 ) ); 
		}

		//------------------------------------------------------------------------------
		//Emit SIB byte.
		inline void _emitSib( Cmp_unsigned__int8 s, Cmp_unsigned__int8 i, Cmp_unsigned__int8 b ) __QCMP_THROW
		{ 
			_emitByte( ( ( s & 0x03 ) << 6 ) | ( ( i & 0x07 ) << 3 ) | ( b & 0x07 ) ); 
		}

		//------------------------------------------------------------------------------
		//Emit REX prefix (64-bit mode only).
		inline void _emitRexR( Cmp_unsigned__int8 w, Cmp_unsigned__int8 opReg, Cmp_unsigned__int8 regCode, bool forceRexPrefix ) __QCMP_THROW
		{
#if ( QOR_ARCH_WORDSIZE == 64 )
			Cmp_unsigned__int8 r = (opReg & 0x8) != 0;
			Cmp_unsigned__int8 b = (regCode & 0x8) != 0;

			// w Default operand size(0=Default, 1=64-bit).
			// r Register field (1=high bit extension of the ModR/M REG field).
			// x Index field not used in RexR
			// b Base field (1=high bit extension of the ModR/M or SIB Base field).
			if( w || r || b || forceRexPrefix )
			{
				_emitByte( 0x40 | ( w << 3 ) | ( r << 2 ) | b );
			}
#else
			QOR_PP_UNREF4( w, opReg, regCode, forceRexPrefix );
#endif // ASMJIT_X64
		}

		//Emit REX prefix (64-bit mode only).
		void _emitRexRM( Cmp_unsigned__int8 w, Cmp_unsigned__int8 opReg, const COperand& rm, bool forceRexPrefix ) __QCMP_THROW;

		//------------------------------------------------------------------------------
		//Emit Register / Register - calls _emitMod( 3, opReg, r )
		inline void _emitModR( Cmp_unsigned__int8 opReg, Cmp_unsigned__int8 r ) __QCMP_THROW
		{ 
			_emitMod( 3, opReg, r ); 
		}

		//Emit Register / Register - calls _emitMod( 3, opReg, r.code() )
		inline void _emitModR( Cmp_unsigned__int8 opReg, const CBaseReg& r ) __QCMP_THROW;

		//Emit register / memory address combination to buffer.
		//This method can handle addresses from simple to complex ones with
		//index and displacement.
		void _emitModM( Cmp_unsigned__int8 opReg, const CMem* mem, Cmp_int_ptr immSize ) __QCMP_THROW;

		//Emit Reg<-Reg or Reg<-Reg|Mem ModRM (can be followed by SIB 
		//and displacement) to buffer.
		//
		//This function internally calls _emitModM() or _emitModR() that depends on op type.
		//opReg is usually real register ID (see R) but some instructions
		//have specific format and in that cases opReg is part of opcode.
		void _emitModRM( Cmp_unsigned__int8 opReg, const COperand* pop, Cmp_int_ptr immSize ) __QCMP_THROW;

		void _emitX86Inl( Cmp_unsigned__int32 opCode, Cmp_unsigned__int8 i16bit, Cmp_unsigned__int8 rexw, Cmp_unsigned__int8 reg, bool forceRexPrefix ) __QCMP_THROW; // Emit instruction where register is inlined to opcode.
		void _emitX86RM( Cmp_unsigned__int32 opCode, Cmp_unsigned__int8 i16bit, Cmp_unsigned__int8 rexw, Cmp_unsigned__int8 o, const COperand* op, Cmp_int_ptr immSize, bool forceRexPrefix ) __QCMP_THROW; // Emit instruction with reg/memory operand.
		void _emitFpu( Cmp_unsigned__int32 opCode ) __QCMP_THROW;		// Emit FPU instruction with no operands.
		void _emitFpuSTI( Cmp_unsigned__int32 opCode, Cmp_unsigned__int32 sti ) __QCMP_THROW;		// Emit FPU instruction with one operand sti (index of FPU register).
		void _emitFpuMEM( Cmp_unsigned__int32 opCode, Cmp_unsigned__int8 opReg, const CMem* pmem ) __QCMP_THROW;		// Emit FPU instruction with one operand opReg and memory operand mem.
		void _emitMmu( Cmp_unsigned__int32 opCode, Cmp_unsigned__int8 rexw, Cmp_unsigned__int8 opReg, const COperand* psrc, Cmp_int_ptr immSize ) __QCMP_THROW;		// Emit MMX/SSE instruction.

		LabelLink* _emitDisplacement( LabelData& l_data, Cmp_int_ptr inlinedDisplacement, int size ) __QCMP_THROW;	// Emit displacement.

		// Emit relative relocation to absolute pointer @a target. It's needed
		// to add what instruction is emitting this, because in x64 mode the relative
		// displacement can be impossible to calculate and in this case the trampoline
		// is used.
		void _emitJmpOrCallReloc(Cmp_unsigned__int32 instruction, void* target) __QCMP_THROW;

		// Helpers to decrease binary code size. These four emit methods are just
		// helpers thats used by assembler. They call emitX86() adding NULLs
		// to first, second and third operand, if needed.

		void _emitInstruction(Cmp_unsigned__int32 code) __QCMP_THROW;		// Emit X86/FPU or MM/XMM instruction.
		void _emitInstruction(Cmp_unsigned__int32 code, const COperand* o0) __QCMP_THROW;		// Emit X86/FPU or MM/XMM instruction.
		void _emitInstruction(Cmp_unsigned__int32 code, const COperand* o0, const COperand* o1) __QCMP_THROW;		// Emit X86/FPU or MM/XMM instruction.

		//Emit X86/FPU or MM/XMM instruction.
		//Operands o1, o2 or o3 can be NULL if they are not used.
		//Hint: Use emitX86() helpers to emit instructions.
		void _emitInstruction( Cmp_unsigned__int32 code, const COperand* o0, const COperand* o1, const COperand* o2 ) __QCMP_THROW;
		bool BeginEmitInstruction( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed ) __QCMP_THROW;
		bool PrepareEmitInstruction( const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, const COperand** _loggerOperands, Cmp_unsigned__int32& forceRexPrefix ) __QCMP_THROW;
		bool LockInstruction( const InstructionDescription* id, bool& assertIllegal, Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, 
			const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset ) __QCMP_THROW;
		void EmitInstructionImmediate( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset ) __QCMP_THROW;
		void EndEmitInstruction( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset ) __QCMP_THROW;
		void CleanupEmitInstruction( void );
		void EmitInstructionIllegal( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset ) __QCMP_THROW;

		void EmitInstructionG_EMIT( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id ) __QCMP_THROW;
		void EmitInstructionG_ALU( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_BSWAP( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_BT( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_CALL( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_CRC32( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_ENTER( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_IMUL( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_INC_DEC( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_J( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_JMP( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_LEA( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_M( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_MOV( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_MOV_PTR( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_MOVSX_MOVZX( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
#		if ( QOR_ARCH_WORDSIZE == 64 )
		void EmitInstructionG_MOVSXD( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
#		endif
		void EmitInstructionG_PUSH( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_POP( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_R_RM( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_RM_B( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_RM( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_RM_R( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_REP( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_RET( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_ROT( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_SHLD_SHRD( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_TEST( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_XCHG( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_MOVBE( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_X87_FPU( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_X87_STI( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_X87_FSTSW( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_X87_MEM_STI( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_X87_MEM( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_MMU_MOV( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_MMU_MOVD( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_MMU_MOVQ( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_MMU_PREFETCH( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_MMU_PEXTR( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_MMU_RMI( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_MMU_RM_IMM8( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;
		void EmitInstructionG_MMU_RM_3DNOW( Cmp_unsigned__int32 code, const COperand*& o0, const COperand*& o1, const COperand*& o2, Cmp_unsigned__int32& bLoHiUsed, bool& assertIllegal, const COperand** _loggerOperands, const CImm* immOperand, Cmp_unsigned__int32 immSize, Cmp_uint_ptr beginOffset, const InstructionDescription* id, Cmp_unsigned__int32 forceRexPrefix )  __QCMP_THROW;

		// Private method for emitting jcc.
		void _emitJcc( Cmp_unsigned__int32 code, const CLabel* label, Cmp_unsigned__int32 hint ) __QCMP_THROW;

		//------------------------------------------------------------------------------
		// Private method for emitting short jcc.
		inline void _emitShortJcc( Cmp_unsigned__int32 code, const CLabel* label, Cmp_unsigned__int32 hint )
		{
			m_uiEmitOptions |= EMIT_OPTION_SHORT_JUMP;
			_emitJcc( code, label, hint );
		}

		// Relocation helpers

		// Relocate code to a given address dst.
		//
		// dst Where the relocated code should me stored. The pointer can be
		// address returned by virtual memory allocator or your own address if you
		// want only to store the code for later reuse (or load, etc...).
		// addressBase Base address used for relocation. When using JIT code
		// generation, this will be the same as dst, only casted to system
		// integer type. But when generating code for remote process then the value
		// can be different.
		//
		// returns the bytes used. Code-generator can create trampolines which are
		// used when calling other functions inside the JIT code. However, these
		// trampolines can be unused so the relocCode() returns the exact size needed
		// for the function.
		//
		// A given buffer will be overwritten, to get number of bytes required use getCodeSize() .
		virtual Cmp_uint_ptr relocCode( void* dst, Cmp_uint_ptr addressBase ) const __QCMP_THROW;

		//------------------------------------------------------------------------------
		// Simplifed version of relocCode() method.
		inline Cmp_uint_ptr relocCode( void* dst ) const __QCMP_THROW
		{
			return relocCode( dst, (Cmp_uint_ptr)dst );
		}

		// Embed

		//void embed( const void* data, Cmp_uint_ptr length ) __QCMP_THROW;//Embed data into instruction stream.
		void embedLabel( const CLabel& label ) __QCMP_THROW;//Embed absolute label pointer (4 or 8 bytes).

		// Align

		//Align target buffer to m bytes.
		//Typical usage of this is to align labels at start of the inner loops.
		//Inserts nop() instructions or CPU optimized NOPs.
		void align( Cmp_unsigned__int32 m ) __QCMP_THROW;

		// Label

		// Create and return new label.
		CLabel newLabel() __QCMP_THROW;

		// Register labels (used by HLA).
		void registerLabels( Cmp_uint_ptr count ) __QCMP_THROW;

		// Bind label to the current offset.
		// Label can be bound only once!
		void bind( const CLabel& label ) __QCMP_THROW;

		//Make is convenience method to make currently serialized code and
		//return pointer to generated function.
		//
		//What you need is only to cast this pointer to your function type and call
		//it. Note that if there was an error and calling getError() method not
		//returns ERROR_NONE (zero) then this function always return NULL and
		//error value remains the same.
		virtual void* make() __QCMP_THROW;

		// Links

		LabelLink* _newLabelLink() __QCMP_THROW;

		//------------------------------------------------------------------------------
		inline void SetEmitOptions( Cmp_unsigned__int32 EmitOptions )
		{
			m_uiEmitOptions = EmitOptions;
		}

		//------------------------------------------------------------------------------
		inline void SetProperties( Cmp_unsigned__int32 Properties )
		{
			m_uiProperties = Properties;
		}

		// Emit Options

		//Assert LOCK# Signal Prefix.
		//
		// This instruction causes the processor's LOCK# signal to be asserted
		// during execution of the accompanying instruction (turns the
		// instruction into an atomic instruction). In a multiprocessor environment,
		// the LOCK# signal insures that the processor has exclusive use of any shared
		// memory while the signal is asserted.
		//
		// The LOCK prefix can be prepended only to the following instructions and
		// to those forms of the instructions that use a memory operand: ADD, ADC,
		// AND, BTC, BTR, BTS, CMPXCHG, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD,
		// and XCHG. An undefined opcode exception will be generated if the LOCK
		// prefix is used with any other instruction. The XCHG instruction always
		// asserts the LOCK# signal regardless of the presence or absence of the LOCK
		// prefix.
		inline void lock()
		{
			m_uiEmitOptions |= EMIT_OPTION_LOCK_PREFIX;
		}

		//------------------------------------------------------------------------------
		//Force REX prefix to be emitted.
		// This option should be used carefully, because there are unencodable
		// combinations. If you want to access ah, bh, ch or dh registers then you
		// can't emit REX prefix and it will cause an illegal instruction error.
		// Note REX prefix is only valid for X64/AMD64 platform.
		inline void rex()
		{
			m_uiEmitOptions |= EMIT_OPTION_REX_PREFIX;
		}

	protected:

		Cmp_unsigned__int32 m_uiProperties;		//Properties.
		Cmp_unsigned__int32 m_uiEmitOptions;	//Emit flags for next instruction (cleared after emit).

		Cmp_int_ptr m_iTrampolineSize;			//Size of possible trampolines.
		LabelLink* m_pUnusedLinks;				//Linked list of unused links (LabelLink* structures)


	public:

		nsCodeQOR::PodVector< LabelData > m_LabelData;		//Labels data.
		nsCodeQOR::PodVector< RelocData > m_RelocData;		//Relocations data.

		static const CGPReg no_reg;		// No register, can be used only in Mem operand.

	//Registers - 8-bit

		static const CGPReg al;				// 8-bit General purpose register.
		static const CGPReg cl;				// 8-bit General purpose register.
		static const CGPReg dl;				// 8-bit General purpose register.	
		static const CGPReg bl;				// 8-bit General purpose register.

		const CGPReg& reg_cl(void) const;

#if ( QOR_ARCH_WORDSIZE == 64 )
	
		static const CGPReg spl;			// 8-bit General purpose register (64-bit mode only).
		static const CGPReg bpl;			// 8-bit General purpose register (64-bit mode only).
		static const CGPReg sil;			// 8-bit General purpose register (64-bit mode only).
		static const CGPReg dil;			// 8-bit General purpose register (64-bit mode only).	
		static const CGPReg r8b;			// 8-bit General purpose register (64-bit mode only).	
		static const CGPReg r9b;			// 8-bit General purpose register (64-bit mode only).
		static const CGPReg r10b;			// 8-bit General purpose register (64-bit mode only).
		static const CGPReg r11b;			// 8-bit General purpose register (64-bit mode only).
		static const CGPReg r12b;			// 8-bit General purpose register (64-bit mode only).
		static const CGPReg r13b;			// 8-bit General purpose register (64-bit mode only).
		static const CGPReg r14b;			// 8-bit General purpose register (64-bit mode only).
		static const CGPReg r15b;			// 8-bit General purpose register (64-bit mode only).

#endif // ASMJIT_X64

		static const CGPReg ah;				// 8-bit General purpose register.
		static const CGPReg ch;				// 8-bit General purpose register.
		static const CGPReg dh;				// 8-bit General purpose register.
		static const CGPReg bh;				// 8-bit General purpose register.

	//Registers - 16-bit

		static const CGPReg ax;				// 16-bit General purpose register.
		static const CGPReg cx;				// 16-bit General purpose register.
		static const CGPReg dx;				// 16-bit General purpose register.
		static const CGPReg bx;				// 16-bit General purpose register.
		static const CGPReg sp;				// 16-bit General purpose register.
		static const CGPReg bp;				// 16-bit General purpose register.
		static const CGPReg si;				// 16-bit General purpose register.
		static const CGPReg di;				// 16-bit General purpose register.

#if ( QOR_ARCH_WORDSIZE == 64 )
	
		static const CGPReg r8w;			// 16-bit General purpose register (64-bit mode only).
		static const CGPReg r9w;			// 16-bit General purpose register (64-bit mode only).
		static const CGPReg r10w;			// 16-bit General purpose register (64-bit mode only).
		static const CGPReg r11w;			// 16-bit General purpose register (64-bit mode only).
		static const CGPReg r12w;			// 16-bit General purpose register (64-bit mode only).
		static const CGPReg r13w;			// 16-bit General purpose register (64-bit mode only).
		static const CGPReg r14w;			// 16-bit General purpose register (64-bit mode only).
		static const CGPReg r15w;			// 16-bit General purpose register (64-bit mode only).

#endif // ASMJIT_X64

	//Registers - 32-bit
	
		static const CGPReg eax;			// 32-bit General purpose register.
		static const CGPReg ecx;			// 32-bit General purpose register.
		static const CGPReg edx;			// 32-bit General purpose register.
		static const CGPReg ebx;			// 32-bit General purpose register.
		static const CGPReg esp;			// 32-bit General purpose register.
		static const CGPReg ebp;			// 32-bit General purpose register.
		static const CGPReg esi;			// 32-bit General purpose register.
		static const CGPReg edi;			// 32-bit General purpose register.
		
		const CGPReg& reg_eax( void ) const;
		const CGPReg& reg_ecx( void ) const;
		const CGPReg& reg_edx( void ) const;
		const CGPReg& reg_ebx( void ) const;
		const CGPReg& reg_esp( void ) const;
		const CGPReg& reg_ebp( void ) const;
		const CGPReg& reg_esi( void ) const;
		const CGPReg& reg_edi( void ) const;

#if ( QOR_ARCH_WORDSIZE == 64 )

		static const CGPReg r8d;			// 32-bit General purpose register.
		static const CGPReg r9d;			// 32-bit General purpose register.
		static const CGPReg r10d;			// 32-bit General purpose register.
		static const CGPReg r11d;			// 32-bit General purpose register.
		static const CGPReg r12d;			// 32-bit General purpose register.
		static const CGPReg r13d;			// 32-bit General purpose register.
		static const CGPReg r14d;			// 32-bit General purpose register.
		static const CGPReg r15d;			// 32-bit General purpose register.

#endif

	//Registers - 64-bit

#if ( QOR_ARCH_WORDSIZE == 64 )
	
		static const CGPReg rax;			// 64-bit General purpose register (64-bit mode only).
		static const CGPReg rcx;			// 64-bit General purpose register (64-bit mode only).
		static const CGPReg rdx;			// 64-bit General purpose register (64-bit mode only).
		static const CGPReg rbx;			// 64-bit General purpose register (64-bit mode only).
		static const CGPReg rsp;			// 64-bit General purpose register (64-bit mode only).
		static const CGPReg rbp;			// 64-bit General purpose register (64-bit mode only).
		static const CGPReg rsi;			// 64-bit General purpose register (64-bit mode only).
		static const CGPReg rdi;			// 64-bit General purpose register (64-bit mode only).
		static const CGPReg r8;				// 64-bit General purpose register (64-bit mode only).
		static const CGPReg r9;				// 64-bit General purpose register (64-bit mode only).
		static const CGPReg r10;			// 64-bit General purpose register (64-bit mode only).
		static const CGPReg r11;			// 64-bit General purpose register (64-bit mode only).
		static const CGPReg r12;			// 64-bit General purpose register (64-bit mode only).
		static const CGPReg r13;			// 64-bit General purpose register (64-bit mode only).
		static const CGPReg r14;			// 64-bit General purpose register (64-bit mode only).
		static const CGPReg r15;			// 64-bit General purpose register (64-bit mode only).

#endif

	//Registers - Native

		static const CGPReg nax;			// 32-bit General purpose register.
		static const CGPReg ncx;			// 32-bit General purpose register.
		static const CGPReg ndx;			// 32-bit General purpose register.
		static const CGPReg nbx;			// 32-bit General purpose register.
		static const CGPReg nsp;			// 32-bit General purpose register.
		static const CGPReg nbp;			// 32-bit General purpose register.
		static const CGPReg nsi;			// 32-bit General purpose register.
		static const CGPReg ndi;			// 32-bit General purpose register.

	//Registers - MM

		static const CMMReg mm0;			// 64-bit MM register.
		static const CMMReg mm1;			// 64-bit MM register.
		static const CMMReg mm2;			// 64-bit MM register.
		static const CMMReg mm3;			// 64-bit MM register.
		static const CMMReg mm4;			// 64-bit MM register.
		static const CMMReg mm5;			// 64-bit MM register.
		static const CMMReg mm6;			// 64-bit MM register.
		static const CMMReg mm7;			// 64-bit MM register.

	//Registers - XMM
	
		static const CXMMReg xmm0;			// 128-bit XMM register.
		static const CXMMReg xmm1;			// 128-bit XMM register.
		static const CXMMReg xmm2;			// 128-bit XMM register.
		static const CXMMReg xmm3;			// 128-bit XMM register.
		static const CXMMReg xmm4;			// 128-bit XMM register.
		static const CXMMReg xmm5;			// 128-bit XMM register.
		static const CXMMReg xmm6;			// 128-bit XMM register.
		static const CXMMReg xmm7;			// 128-bit XMM register.

#if ( QOR_ARCH_WORDSIZE == 64 )
	
		static const CXMMReg xmm8;			// 128-bit XMM register (64-bit mode only).
		static const CXMMReg xmm9;			// 128-bit XMM register (64-bit mode only).
		static const CXMMReg xmm10;			// 128-bit XMM register (64-bit mode only).
		static const CXMMReg xmm11;			// 128-bit XMM register (64-bit mode only).
		static const CXMMReg xmm12;			// 128-bit XMM register (64-bit mode only).
		static const CXMMReg xmm13;			// 128-bit XMM register (64-bit mode only).
		static const CXMMReg xmm14;			// 128-bit XMM register (64-bit mode only).
		static const CXMMReg xmm15;			// 128-bit XMM register (64-bit mode only).

#endif //

		static const CSegmentReg cs;
		static const CSegmentReg ss;
		static const CSegmentReg ds;
		static const CSegmentReg es;
		static const CSegmentReg fs;
		static const CSegmentReg gs;

	private:

		Cx86CPUCore( const Cx86CPUCore& src );//no copy constructor
		Cx86CPUCore& operator = ( const Cx86CPUCore& src );//no assignment

	};


	__QCMP_LOCAL char* dumpRegister( char* buf, Cmp_unsigned__int32 type, Cmp_unsigned__int32 index ) __QCMP_THROW;
	__QCMP_LOCAL char* dumpOperand( char* buf, const COperand* op, Cmp_unsigned__int32 uiMemRegType ) __QCMP_THROW;
	char* dumpInstruction( char* buf, Cmp_unsigned__int32 code, Cmp_unsigned__int32 emitOptions, const COperand* o0, const COperand* o1, const COperand* o2, Cmp_unsigned__int32 uiMemRegType ) __QCMP_THROW;
	char* dumpComment( char* buf, Cmp_uint_ptr len, const Cmp_unsigned__int8* binaryData, Cmp_uint_ptr binaryLen, const char* comment );
	char* dumpInstructionName( char* buf, Cmp_unsigned__int32 code ) __QCMP_THROW;

}//nsx86
}//nsArch

#endif//ARCHQOR_X86PC_ASSEMBLERCORE_H_2
