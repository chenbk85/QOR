//i086CPU.h

// Copyright (c) 2008-2010, Petr Kobalicek <kobalicek.petr@gmail.com>
// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Not really an 8086 16bit target, just the 8086 inherited instructions for 32 and 64 bit x86 targets.
//Breaks up x86 classes that would otherwise be too large.

#ifndef ARCHQOR_X86PC_I086CPU_H_2
#define ARCHQOR_X86PC_I086CPU_H_2

#include "x86CPUCore.h"
#include "ArchQOR/x86/Assembler/Operands/Registers/MMReg.h"
#include "ArchQOR/x86/Assembler/Operands/Registers/XMMReg.h"
#include "ArchQOR/x86/Assembler/Operands/Registers/GPReg.h"
#include "ArchQOR/x86/Assembler/Operands/Mem.h"
#include "ArchQOR/x86/Assembler/Operands/Registers/X87Reg.h"
#include "ArchQOR/x86/Assembler/Operands/Registers/SegmentReg.h"
#include "ArchQOR/x86/Assembler/Operands/Imm.h"
#include "ArchQOR/x86/Assembler/Operands/Label.h"
#include "x86ISetExtension.h"

//------------------------------------------------------------------------------
namespace nsArch
{
//------------------------------------------------------------------------------
namespace nsx86
{
	//------------------------------------------------------------------------------
	//8086/8088
	class __QOR_INTERFACE( __ARCHQOR ) Ci086CPU : public Cx86CPUCore
	{
	public:

		Ci086CPU( CCodeGeneratorBase* codeGenerator ) __QCMP_THROW;
		virtual ~Ci086CPU() __QCMP_THROW;
		void adc( const CGPReg& dst, const CGPReg& src );
		void adc( const CGPReg& dst, const CMem& src );
		void adc( const CGPReg& dst, const CImm& src );
		void adc( const CMem& dst, const CGPReg& src );
		void adc( const CMem& dst, const CImm& src );
		void add( const CGPReg& dst, const CGPReg& src );
		void add( const CGPReg& dst, const CMem& src );
		void add( const CGPReg& dst, const CImm& src );
		void add( const CMem& dst, const CGPReg& src );
		void add( const CMem& dst, const CImm& src );
		void and_( const CGPReg& dst, const CGPReg& src );
		void and_( const CGPReg& dst, const CMem& src );
		void and_( const CGPReg& dst, const CImm& src );
		void and_( const CMem& dst, const CGPReg& src );
		void and_( const CMem& dst, const CImm& src );
		void call( const CGPReg& dst );
		void call( const CMem& dst );
		void call( const CImm& dst );
		void call( void* dst );
		void call( const CLabel& label );
		void cbw();
		void clc();
		void cld();
		void cmc();
		void cmp( const CGPReg& dst, const CGPReg& src );
		void cmp( const CGPReg& dst, const CMem& src );
		void cmp( const CGPReg& dst, const CImm& src );
		void cmp( const CMem& dst, const CGPReg& src );
		void cmp( const CMem& dst, const CImm& src );

#if	( QOR_ARCH_WORDSIZE == 32 )
		void daa();
#endif

#if	( QOR_ARCH_WORDSIZE == 32 )
		void das();
#endif

		void dec( const CGPReg& dst );
		void dec( const CMem& dst );
		void div( const CGPReg& src );
		void div( const CMem& src );
		void idiv( const CGPReg& src );
		void idiv( const CMem& src );
		void imul( const CGPReg& src );
		void imul( const CMem& src );
		void imul( const CGPReg& dst, const CGPReg& src );
		void imul( const CGPReg& dst, const CMem& src );
		void imul( const CGPReg& dst, const CImm& src );
		void imul( const CGPReg& dst, const CGPReg& src, const CImm& imm );
		void imul( const CGPReg& dst, const CMem& src, const CImm& imm );
		void inc( const CGPReg& dst );
		void inc( const CMem& dst );
		void int3();

		void j( CONDITION cc, const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void ja( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void jae( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void jb( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void jbe( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void jc( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void je( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void jg( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void jge( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void jl( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void jle( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void jna( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void jnae( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void jnb( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void jnbe( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void jnc( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void jne( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void jng( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void jnge( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void jnl( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void jnle( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void jno( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void jnp( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void jns( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void jnz( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void jo( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void jp( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void jpe( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void jpo( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void js( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void jz( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_j( CONDITION cc, const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_ja( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_jae( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_jb( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_jbe( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_jc( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_je( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_jg( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_jge( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_jl( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_jle( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_jna( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_jnae( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_jnb( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_jnbe( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_jnc( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_jne( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_jng( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_jnge( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_jnl( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_jnle( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_jno( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_jnp( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_jns( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_jnz( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_jo( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_jp( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_jpe( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_jpo( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_js( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void short_jz( const CLabel& label, Cmp_unsigned__int32 hint = HINT_NONE );
		void jmp( const CGPReg& dst );
		void jmp( const CMem& dst );
		void jmp( const CImm& dst );
		void jmp( void* dst );
		void jmp( const CLabel& label );
		void short_jmp( const CLabel& label );
		void lea( const CGPReg& dst, const CMem& src );
		void mov( const CGPReg& dst, const CGPReg& src );
		void mov( const CGPReg& dst, const CMem& src );
		void mov( const CGPReg& dst, const CImm& src );
		void mov( const CMem& dst, const CGPReg& src );
		void mov( const CMem& dst, const CImm& src );
		void mov( const CGPReg& dst, const CSegmentReg& src );
		void mov( const CMem& dst, const CSegmentReg& src );
		void mov( const CSegmentReg& dst, const CGPReg& src );
		void mov( const CSegmentReg& dst, const CMem& src );
		void mov_ptr( const CGPReg& dst, void* src );
		void mov_ptr( void* dst, const CGPReg& src );
		void movsx( const CGPReg& dst, const CGPReg& src );
		void movsx( const CGPReg& dst, const CMem& src );
		void mul( const CGPReg& src );
		void mul( const CMem& src );
		void neg( const CGPReg& dst );
		void neg( const CMem& dst );
		void nop();
		void not_( const CGPReg& dst );
		void not_( const CMem& dst );
		void or_( const CGPReg& dst, const CGPReg& src );
		void or_( const CGPReg& dst, const CMem& src );
		void or_( const CGPReg& dst, const CImm& src );
		void or_( const CMem& dst, const CGPReg& src );
		void or_( const CMem& dst, const CImm& src );
		void pop( const CGPReg& dst );
		void pop( const CMem& dst );
		void push( const CGPReg& src );
		void push( const CMem& src );
		void push( const CImm& src );
		void rcl( const CGPReg& dst, const CGPReg& src );
		void rcl( const CGPReg& dst, const CImm& src );
		void rcl( const CMem& dst, const CGPReg& src );
		void rcl( const CMem& dst, const CImm& src );
		void rcr( const CGPReg& dst, const CGPReg& src );
		void rcr( const CGPReg& dst, const CImm& src );
		void rcr( const CMem& dst, const CGPReg& src );
		void rcr( const CMem& dst, const CImm& src );
		void rep_lodsb();
		void rep_lodsd();
		void rep_movsb();
		void rep_movsd();
		void rep_stosb();
		void rep_stosd();
		void repe_cmpsb();
		void repe_cmpsd();
		void repe_scasb();
		void repe_scasd();
		void repne_cmpsb();
		void repne_cmpsd();
		void repne_scasb();
		void repne_scasd();
		void ret();
		void ret( const CImm& imm16 );
		void rol( const CGPReg& dst, const CGPReg& src );
		void rol( const CGPReg& dst, const CImm& src );
		void rol( const CMem& dst, const CGPReg& src );
		void rol( const CMem& dst, const CImm& src );
		void ror( const CGPReg& dst, const CGPReg& src );
		void ror( const CGPReg& dst, const CImm& src );
		void ror( const CMem& dst, const CGPReg& src );
		void ror( const CMem& dst, const CImm& src );

#if	( QOR_ARCH_WORDSIZE == 32 )
		void sahf();
#endif // ( QOR_ARCH_WORDSIZE == 32 )

		void sbb( const CGPReg& dst, const CGPReg& src );
		void sbb( const CGPReg& dst, const CMem& src );
		void sbb( const CGPReg& dst, const CImm& src );
		void sbb( const CMem& dst, const CGPReg& src );
		void sbb( const CMem& dst, const CImm& src );
		void sal( const CGPReg& dst, const CGPReg& src );
		void sal( const CGPReg& dst, const CImm& src );
		void sal( const CMem& dst, const CGPReg& src );
		void sal( const CMem& dst, const CImm& src );
		void sar( const CGPReg& dst, const CGPReg& src );
		void sar( const CGPReg& dst, const CImm& src );
		void sar( const CMem& dst, const CGPReg& src );
		void sar( const CMem& dst, const CImm& src );
		void shl( const CGPReg& dst, const CGPReg& src );
		void shl( const CGPReg& dst, const CImm& src );
		void shl( const CMem& dst, const CGPReg& src );
		void shl( const CMem& dst, const CImm& src );
		void shr( const CGPReg& dst, const CGPReg& src );
		void shr( const CGPReg& dst, const CImm& src );
		void shr( const CMem& dst, const CGPReg& src );
		void shr( const CMem& dst, const CImm& src );
		void stc();
		void std();
		void sub( const CGPReg& dst, const CGPReg& src );
		void sub( const CGPReg& dst, const CMem& src );
		void sub( const CGPReg& dst, const CImm& src );
		void sub( const CMem& dst, const CGPReg& src );
		void sub( const CMem& dst, const CImm& src );
		void test( const CGPReg& op1, const CGPReg& op2 );
		void test( const CGPReg& op1, const CImm& op2 );
		void test( const CMem& op1, const CGPReg& op2 );
		void test( const CMem& op1, const CImm& op2 );
		void xchg( const CGPReg& dst, const CGPReg& src );
		void xchg( const CMem& dst, const CGPReg& src );
		void xchg( const CGPReg& dst, const CMem& src );
		void xor_( const CGPReg& dst, const CGPReg& src );
		void xor_( const CGPReg& dst, const CMem& src );
		void xor_( const CGPReg& dst, const CImm& src );
		void xor_( const CMem& dst, const CGPReg& src );
		void xor_( const CMem& dst, const CImm& src );

	private:

		Ci086CPU( const Ci086CPU& src );//no copy constructor
		Ci086CPU& operator = ( const Ci086CPU& src );//no assignment
	
		/*
AAA		ASCII adjust AL after addition used with unpacked binary coded decimal
AAD		ASCII adjust AX before division
8086/8088 datasheet documents only base 10 version of the AAD instruction (opcode 0xD5 0x0A), but any other base will work. Later Intel's documentation has the generic form too. NEC V20 and V30 (and possibly other NEC V-series CPUs) always use base 10, and ignore the argument, causing a number of incompatibilities
AAM		ASCII adjust AX after multiplication. Only base 10 version is documented, see notes for AAD
AAS		ASCII adjust AL after subtraction
CLI		Clear interrupt flag
CMPSB	Compare bytes in memory
CMPSW	Compare words
CWD		Convert word to doubleword
ESC		Used with floating-point unit
HLT		Enter halt state
IN		Input from port. (1) AL = port[imm]; (2) AL = port[DX]; (3) AX = port[DX];
INTO	Call to interrupt if overflow
IRET	Return from interrupt
LAHF	Load flags into AH register
LDS		Load pointer using DS
LES		Load ES with pointer
LOCK	Assert BUS LOCK# signal (for multiprocessing)
LODSB	Load string byte 
LODSW	Load string word
LOOP/LOOPx		Loop control. (LOOPE, LOOPNE, LOOPNZ, LOOPZ) if (x && --CX) goto lbl;
OUT		Output to port. (1) port[imm] = AL; (2) port[DX] = AL; (3) port[DX] = AX;
SCASB	Compare byte string
SCASW	Compare word string
STI		Set interrupt flag
STOSB	Store byte in string
STOSW	Store word in string
WAIT	Wait until not busy. Waits until BUSY# pin is inactive (used with floating-point unit)
XLAT	Table look-up translation, behaves like MOV AL, [BX+AL]
*/

	};

}//nsx86
}//nsArch

#endif//ARCHQOR_X86PC_I086CPU_H_2
