//EFunction.h

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Function emittable used to generate C/C++ functions.

#ifndef ARCHQOR_X86PC_HLASSEMBLER_EFUNCTION_H_2
#define ARCHQOR_X86PC_HLASSEMBLER_EFUNCTION_H_2

#include "CompilerQOR.h"
#include "../FunctionPrototype.h"
#include "EProlog.h"
#include "EEpilog.h"
#include "ArchQOR/Common/HLAssembler/Emittables/EFunctionEnd.h"
#include "ArchQOR/x86/Assembler/Operands/Label.h"

//------------------------------------------------------------------------------
namespace nsArch
{
//------------------------------------------------------------------------------
namespace nsx86
{
	class __QOR_INTERFACE( __ARCHQOR ) Cx86HLAIntrinsics;
	class __QOR_INTERFACE( __ARCHQOR ) Cx86HLAContext;
	struct VarData;

	//------------------------------------------------------------------------------
	// Functions are base blocks for generating assembler output. Each generated
	// assembler stream needs standard entry and leave sequences thats compatible
	// to the operating system conventions - Application Binary Interface (ABI).
	//
	// Function class can be used to generate entry (prolog) and leave (epilog)
	// sequences that is compatible to a given calling convention and to allocate
	// and manage variables that can be allocated to registers or spilled.
	//
	// Note To create function use HLA::newFunction() method, do
	// not create EFunction instances using other ways.
	class __QOR_INTERFACE( __ARCHQOR ) CEFunction : public nsArch::CEmittable
	{

	public:

		// Create new Function instance. Note Always use newFunction() to create Function instance.
		CEFunction( nsArch::CHighLevelAssemblerBase* c ) __QCMP_THROW;
		virtual ~CEFunction() __QCMP_THROW;

		virtual void prepare( CHLAssemblerContextBase& cc ) __QCMP_THROW;
		virtual int getMaxSize() const __QCMP_THROW;

		//------------------------------------------------------------------------------
		//Function Prototype (Calling Convention + Arguments) / Return Value
		inline const CFunctionPrototype& getPrototype() const __QCMP_THROW
		{
			return m_FunctionPrototype;
		}

		//------------------------------------------------------------------------------
		inline Cmp_unsigned__int32 getHint( Cmp_unsigned__int32 hint ) __QCMP_THROW
		{
			return m_auiHints[ hint ];
		}

		void setPrototype( Cmp_unsigned__int32 callingConvention, const Cmp_unsigned__int32* arguments, Cmp_unsigned__int32 argumentsCount, Cmp_unsigned__int32 returnValue ) __QCMP_THROW;
		void setHint( Cmp_unsigned__int32 hint, Cmp_unsigned__int32 value ) __QCMP_THROW;

		//------------------------------------------------------------------------------
		inline CEProlog* getProlog() const __QCMP_THROW
		{
			return m_pProlog;
		}

		//------------------------------------------------------------------------------
		inline CEEpilog* getEpilog() const __QCMP_THROW
		{
			return m_pEpilog;
		}

		//------------------------------------------------------------------------------
		inline CEFunctionEnd* getEnd() const __QCMP_THROW
		{
			return m_pEnd;
		}

		void _createVariables() __QCMP_THROW;							// Create variables from CFunctionPrototype declaration. This is just parsing what FunctionPrototype generated for current function calling convention and arguments.
		void _prepareVariables( CEmittable* first ) __QCMP_THROW;		// Prepare variables (ids, names, scope, registers).
		void _allocVariables( Cx86HLAContext& cc ) __QCMP_THROW;		// Allocate variables (setting correct state, changing masks, etc).
		void _preparePrologEpilog( Cx86HLAContext& cc ) __QCMP_THROW;
		void _dumpFunction( Cx86HLAContext& cc ) __QCMP_THROW;
		void _emitProlog( Cx86HLAContext& cc ) __QCMP_THROW;
		void _emitEpilog( Cx86HLAContext& cc ) __QCMP_THROW;
		void reserveStackForFunctionCall( Cmp__int32 size );			// Reserve stack for calling other function and mark function as callee.

		//------------------------------------------------------------------------------
		// Get function entry label. Entry label can be used to call this function from another code that's being generated.
		inline const CLabel& getEntryLabel() const __QCMP_THROW
		{
			return m_EntryLabel;
		}

		//------------------------------------------------------------------------------
		// Get function exit label. Use exit label to jump to function epilog.
		inline const CLabel& getExitLabel() const __QCMP_THROW
		{
			return m_ExitLabel;
		}

		//------------------------------------------------------------------------------
		// Set the m_bIsEspAdjusted member to true.
		// This method is used to tell compiler that the ESP/RSP must be adjusted in
		// function prolog/epilog, because the stack is manipulated (usually caused
		// by the function call, see ECall).
		inline void mustAdjustEsp()
		{
			m_bIsEspAdjusted = true;
		}

		//------------------------------------------------------------------------------
		// Get whether the emittable was translated.
		inline bool isCaller() const __QCMP_THROW
		{
			return m_bIsCaller;
		}

		//------------------------------------------------------------------------------
		//Get whether function is finished
		inline bool isFinished() const __QCMP_THROW
		{
			return m_bFinished;
		}

		//------------------------------------------------------------------------------
		inline void Finish( void ) __QCMP_THROW
		{
			m_bFinished = true;
		}

		//------------------------------------------------------------------------------
		inline VarData* getVariableArgument( Cmp_unsigned__int32 uiIndex )
		{
			VarData* pVarData = 0;
			if( uiIndex < m_FunctionPrototype.getArgumentsCount() )
			{
				pVarData = m_paArgumentVariables[ uiIndex ];
			}
			return pVarData;
		}

	protected:

		CFunctionPrototype m_FunctionPrototype;			// Function prototype.
		VarData** m_paArgumentVariables;				// Function arguments (variable IDs).
		Cmp_unsigned__int32 m_auiHints[ 16 ];			// Function hints.
		bool m_bIsStackAlignedByOsTo16Bytes;			// Whether the function stack is aligned by 16-bytes by OS. This is always true for 64-bit mode and for linux.

		// Whether the function stack (for variables) is aligned manually
		// by function to 16-bytes.
		//
		// This makes sense only if _isStackAlignedByOsTo16Bytes is false and MOVDQA
		// instruction or other SSE/SSE2 instructions are used to work with variable
		// stored on the stack.
		//
		// Value is determined automatically by these factors, expectations are:
		//
		//   1. There is 16-byte wide variable which address was used (alloc, spill, op).
		//   2. Function can't be naked.
		bool m_bIsStackAlignedByFnTo16Bytes;

		// Whether the function is using naked prolog / epilog
		// Naked prolog / epilog means to omit saving and restoring EBP.
		bool m_bIsNaked;

		// Whether the ESP register is adjusted by the stack size needed
		// to save registers and function variables.
		// Esp is adjusted by 'sub' instruction in prolog and by add function in
		// epilog (only if function is not naked).
		bool m_bIsEspAdjusted;

		// Whether another function is called from this function.
		// If another function is called from this function, it's needed to prepare
		// stack for it. If this member is true then it's likely that true will be also m_bIsEspAdjusted one.
		bool m_bIsCaller;
		bool m_bPePushPop;											// Whether to emit prolog / epilog sequence using push & pop instructions (the default).
		bool m_bEmitEMMS;											// Whether to emit EMMS instruction in epilog (auto-detected).
		bool m_bEmitSFence;											// Whether to emit SFence instruction in epilog (auto-detected). Note Combination of @c _emitSFence and @c _emitLFence will result in emitting mfence.
		bool m_bEmitLFence;											// Whether to emit LFence instruction in epilog (auto-detected).Note Combination of _emitSFence and _emitLFence will result in emitting mfence.
		bool m_bFinished;											// Whether the function is finished using @c Compiler::endFunction().
		Cmp_unsigned__int32 m_uiModifiedAndPreservedGP;				// Bitfield containing modified and preserved GP registers.
		Cmp_unsigned__int32 m_uiModifiedAndPreservedMM;				// Bitfield containing modified and preserved MM registers.
		Cmp_unsigned__int32 m_uiModifiedAndPreservedXMM;			// Bitfield containing modified and preserved XMM registers.

		// ID mov movdqa instruction (INST_MOVDQA or INST_MOVDQU).
		// The value is based on stack alignment. If it's guaranteed that stack
		// is aligned to 16-bytes then INST_MOVDQA instruction is used, otherwise
		// the INST_MOVDQU instruction is used for 16-byte mov.
		Cmp_unsigned__int32 m_uiMovDqaInstruction;

		Cmp__int32 m_iPePushPopStackSize;			// Prolog / epilog stack size for PUSH/POP sequences.
		Cmp__int32 m_iPeMovStackSize;				// Prolog / epilog stack size for MOV sequences.
		Cmp__int32 m_iPeAdjustStackSize;			// Prolog / epilog stack adjust size (to make it 16-byte aligned).
		Cmp__int32 m_iMemStackSize;					// Memory stack size (for all variables and temporary memory).
		Cmp__int32 m_iMemStackSize16;				// Like _memStackSize, but aligned to 16-bytes.
		Cmp__int32 m_iFunctionCallStackSize;		// Stack size needed to call other functions.

		CLabel m_EntryLabel;						// Function entry label.
		CLabel m_ExitLabel;							// Function exit label.
		CEProlog* m_pProlog;						// Function prolog emittable.
		CEEpilog* m_pEpilog;						// Function epilog emittable.
		CEFunctionEnd* m_pEnd;						// Dummy emittable, signalizes end of function.

	};

}//nsx86
}//nsArch

#endif//ARCHQOR_X86PC_HLASSEMBLER_EFUNCTION_H_2
