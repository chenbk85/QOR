//x86HLAContext.h

// Copyright Querysoft Limited 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef ARCHQOR_X86PC_HLASSEMBLER_CONTEXT_H_2
#define ARCHQOR_X86PC_HLASSEMBLER_CONTEXT_H_2

#include "CompilerQOR.h"
#include "ArchQOR/Common/HLAssembler/Emittables/Emittable.h"
#include "HLAssembler.h"
#include "ArchQOR/Common/Assembler/Zone.h"
#include "CodeQOR/DataStructures/PODVector.h"
#include "ArchQOR/Common/HLAssembler/HLAssemblerContext.h"

//------------------------------------------------------------------------------
namespace nsArch
{
//------------------------------------------------------------------------------
namespace nsx86
{	
	class __QOR_INTERFACE( __ARCHQOR ) CEJmp;

	//------------------------------------------------------------------------------
	// HLA context is used during assembly and normally developer doesn't
	// need access to it. The context is used per function (it's reset after each
	// function is generated).
	class __QOR_INTERFACE( __ARCHQOR ) Cx86HLAContext : public CHLAssemblerContextBase
	{
	public:

		Cx86HLAContext( nsArch::CHighLevelAssemblerBase* compiler ) __QCMP_THROW;
		~Cx86HLAContext() __QCMP_THROW;

		void _clear() __QCMP_THROW;																					// Clear context, preparing it for next function generation.
		void allocVar( VarData* vdata, Cmp_unsigned__int32 regMask, Cmp_unsigned__int32 vflags ) __QCMP_THROW;		// Allocate variable. Calls allocGPVar, allocMMVar or allocXMMVar methods.
		void saveVar( VarData* vdata ) __QCMP_THROW;																// Save variable. Calls saveGPVar, saveMMVar or saveXMMVar methods.
		void spillVar( VarData* vdata ) __QCMP_THROW;																// Spill variable. Calls spillGPVar, spillMMVar or spillXMMVar methods.
		void unuseVar( VarData* vdata, Cmp_unsigned__int32 toState ) __QCMP_THROW;									// Unuse variable (didn't spill, just forget about it).

		//------------------------------------------------------------------------------
		// Helper method that is called for each variable per emittable.
		inline void _unuseVarOnEndOfScope( nsArch::CEmittable* e, VarData* v )
		{
			if( v->lastEmittable == e )
			{
				unuseVar( v, VARIABLE_STATE_UNUSED );
			}
		}

		//------------------------------------------------------------------------------
		inline void _unuseVarOnEndOfScope( nsArch::CEmittable* e, VarAllocRecord* rec )
		{
			VarData* v = rec->vdata;
			if( v->lastEmittable == e || ( rec->vflags & VARIABLE_ALLOC_UNUSE_AFTER_USE ) )
			{
				unuseVar( v, VARIABLE_STATE_UNUSED );
			}
		}

		//------------------------------------------------------------------------------
		inline void _unuseVarOnEndOfScope( nsArch::CEmittable* e, VarCallRecord* rec )
		{
			VarData* v = rec->vdata;
			if( v->lastEmittable == e || ( rec->flags & VarCallRecord::FLAG_UNUSE_AFTER_USE ) )
			{
				unuseVar( v, VARIABLE_STATE_UNUSED );
			}
		}
		
		void allocGPVar( VarData* vdata, Cmp_unsigned__int32 regMask, Cmp_unsigned__int32 vflags ) __QCMP_THROW;		// Allocate variable (GP).		
		void saveGPVar( VarData* vdata ) __QCMP_THROW;																	// Save variable (GP).		
		void spillGPVar( VarData* vdata ) __QCMP_THROW;																	// Spill variable (GP).
		void allocMMVar( VarData* vdata, Cmp_unsigned__int32 regMask, Cmp_unsigned__int32 vflags ) __QCMP_THROW;		// Allocate variable (MM).
		void saveMMVar( VarData* vdata ) __QCMP_THROW;																	// Save variable (MM).
		void spillMMVar( VarData* vdata ) __QCMP_THROW;																	// Spill variable (MM).
		void allocXMMVar( VarData* vdata, Cmp_unsigned__int32 regMask, Cmp_unsigned__int32 vflags ) __QCMP_THROW;		// Allocate variable (XMM).
		void saveXMMVar( VarData* vdata ) __QCMP_THROW;																	// Save variable (XMM).
		void spillXMMVar( VarData* vdata ) __QCMP_THROW;																// Spill variable (XMM).
		void emitLoadVar( VarData* vdata, Cmp_unsigned__int32 regIndex ) __QCMP_THROW;									// Emit load variable instruction(s).
		void emitSaveVar( VarData* vdata, Cmp_unsigned__int32 regIndex ) __QCMP_THROW;									// Emit save variable instruction(s).
		void emitMoveVar( VarData* vdata, Cmp_unsigned__int32 regIndex, Cmp_unsigned__int32 vflags ) __QCMP_THROW;		// Emit move variable instruction(s).
		void emitExchangeVar( VarData* vdata, Cmp_unsigned__int32 regIndex, Cmp_unsigned__int32 vflags, VarData* other ) __QCMP_THROW;	// Emit exchange variable instruction(s).
		void _postAlloc( VarData* vdata, Cmp_unsigned__int32 vflags ) __QCMP_THROW;										// Called each time a variable is alloceted.		
		void _markMemoryUsed( VarData* vdata ) __QCMP_THROW;															// Marks variable home memory as used (must be called at least once for each variable that uses function local memory - stack).
		CMem _getVarMem( VarData* vdata ) __QCMP_THROW;

		VarData* _getSpillCandidateGP() __QCMP_THROW;
		VarData* _getSpillCandidateMM() __QCMP_THROW;
		VarData* _getSpillCandidateXMM() __QCMP_THROW;
		VarData* _getSpillCandidateGeneric( VarData** varArray, Cmp_unsigned__int32 count ) __QCMP_THROW;

		//------------------------------------------------------------------------------
		inline bool _isActive( VarData* vdata ) __QCMP_THROW 
		{ 
			return vdata->nextActive != 0; 
		}

		void _addActive( VarData* vdata ) __QCMP_THROW;
		void _freeActive( VarData* vdata ) __QCMP_THROW;
		void _freeAllActive() __QCMP_THROW;
		void _allocatedVariable( VarData* vdata ) __QCMP_THROW;

		//------------------------------------------------------------------------------
		inline void _allocatedGPRegister( Cmp_unsigned__int32 index ) __QCMP_THROW 
		{ 
			m_pState.usedGP |= nsCodeQOR::maskFromIndex( index ); m_uiModifiedGPRegisters |= nsCodeQOR::maskFromIndex( index ); 
		}

		//------------------------------------------------------------------------------
		inline void _allocatedMMRegister( Cmp_unsigned__int32 index ) __QCMP_THROW 
		{ 
			m_pState.usedMM |= nsCodeQOR::maskFromIndex( index ); m_uiModifiedMMRegisters |= nsCodeQOR::maskFromIndex( index ); 
		}

		//------------------------------------------------------------------------------
		inline void _allocatedXMMRegister( Cmp_unsigned__int32 index ) __QCMP_THROW 
		{ 
			m_pState.usedXMM |= nsCodeQOR::maskFromIndex( index ); m_uiModifiedXMMRegisters |= nsCodeQOR::maskFromIndex( index ); 
		}

		//------------------------------------------------------------------------------
		inline void _freedGPRegister( Cmp_unsigned__int32 index ) __QCMP_THROW 
		{ 
			m_pState.usedGP &= ~nsCodeQOR::maskFromIndex( index ); 
		}

		//------------------------------------------------------------------------------
		inline void _freedMMRegister( Cmp_unsigned__int32 index ) __QCMP_THROW 
		{ 
			m_pState.usedMM &= ~nsCodeQOR::maskFromIndex( index ); 
		}

		//------------------------------------------------------------------------------
		inline void _freedXMMRegister( Cmp_unsigned__int32 index ) __QCMP_THROW 
		{ 
			m_pState.usedXMM &= ~nsCodeQOR::maskFromIndex( index ); 
		}

		//------------------------------------------------------------------------------
		inline void _markGPRegisterModified( Cmp_unsigned__int32 index ) __QCMP_THROW 
		{ 
			m_uiModifiedGPRegisters |= nsCodeQOR::maskFromIndex( index ); 
		}

		//------------------------------------------------------------------------------
		inline void _markMMRegisterModified( Cmp_unsigned__int32 index ) __QCMP_THROW 
		{ 
			m_uiModifiedMMRegisters |= nsCodeQOR::maskFromIndex( index ); 
		}

		//------------------------------------------------------------------------------
		inline void _markXMMRegisterModified( Cmp_unsigned__int32 index ) __QCMP_THROW 
		{ 
			m_uiModifiedXMMRegisters |= nsCodeQOR::maskFromIndex( index ); 
		}

		//------------------------------------------------------------------------------
		// TODO: Find code which uses this and improve.
		inline void _newRegisterHomeIndex( VarData* vdata, Cmp_unsigned__int32 idx )
		{
			if( vdata->homeRegisterIndex == INVALID_VALUE )
			{
				vdata->homeRegisterIndex = idx;
			}
			vdata->prefRegisterMask |= ( 1U << idx );
		}

		//------------------------------------------------------------------------------
		// TODO: Find code which uses this and improve.
		inline void _newRegisterHomeMask( VarData* vdata, Cmp_unsigned__int32 mask )
		{
			vdata->prefRegisterMask |= mask;
		}

		//Operand Patcher
		void translateOperands( COperand** operands, Cmp_unsigned__int32 count ) __QCMP_THROW;

		//------------------------------------------------------------------------------
		inline nsArch::CHighLevelAssemblerBase* getHighLevelAssembler() const __QCMP_THROW 
		{ 
			return m_pHLA; 
		}

		//------------------------------------------------------------------------------
		inline CCPU* getAssembler() const __QCMP_THROW 
		{ 
			return m_pCPU; 
		}

		//------------------------------------------------------------------------------
		inline void setAssembler( CCPU* pCPU ) __QCMP_THROW 
		{ 
			m_pCPU = pCPU; 
		}

		//------------------------------------------------------------------------------
		inline CEFunction* getFunction() const __QCMP_THROW 
		{ 
			return m_pFunction; 
		}

		//------------------------------------------------------------------------------
		inline void setFunction( CEFunction* pFunction ) __QCMP_THROW
		{
			m_pFunction = pFunction;
		}

		//------------------------------------------------------------------------------
		inline nsArch::CEmittable* getStart( void ) const __QCMP_THROW
		{
			return m_pStart;
		}

		//------------------------------------------------------------------------------
		inline void setStart( nsArch::CEmittable* pStart ) __QCMP_THROW
		{
			m_pStart = pStart;
		}

		//------------------------------------------------------------------------------
		inline nsArch::CEmittable* getStop( void ) const __QCMP_THROW
		{
			return m_pStop;
		}

		//------------------------------------------------------------------------------
		inline void setStop( nsArch::CEmittable* pStop ) __QCMP_THROW
		{
			m_pStop = pStop;
		}

		//------------------------------------------------------------------------------
		inline nsArch::CEmittable* getExtraBlock() const __QCMP_THROW 
		{ 
			return m_pExtraBlock; 
		}

		//------------------------------------------------------------------------------
		inline void setExtraBlock( nsArch::CEmittable* e ) __QCMP_THROW 
		{ 
			m_pExtraBlock = e; 
		}

		//------------------------------------------------------------------------------
		inline VarData* getActive( void ) const __QCMP_THROW 
		{
			return m_pActive;
		}

		//------------------------------------------------------------------------------
		inline ForwardJumpData* getForwardJumps( void ) const __QCMP_THROW
		{
			return m_pForwardJumps;
		}

		//------------------------------------------------------------------------------
		inline Cmp_unsigned__int32 getUnreachable( void ) const __QCMP_THROW
		{
			return m_uiUnreachable;
		}

		//------------------------------------------------------------------------------
		inline void setUnreachable( Cmp_unsigned__int32 uiUnreachable ) __QCMP_THROW
		{
			m_uiUnreachable = uiUnreachable;
		}

		//------------------------------------------------------------------------------
		inline Cmp_unsigned__int32 getModifiedGPRegisters( void ) const __QCMP_THROW
		{
			return m_uiModifiedGPRegisters;
		}

		//------------------------------------------------------------------------------
		inline Cmp_unsigned__int32 getModifiedMMRegisters( void ) const __QCMP_THROW
		{
			return m_uiModifiedMMRegisters;
		}

		//------------------------------------------------------------------------------
		inline Cmp_unsigned__int32 getModifiedXMMRegisters( void ) const __QCMP_THROW
		{
			return m_uiModifiedXMMRegisters;
		}

		//------------------------------------------------------------------------------
		inline Cmp_unsigned__int32 getArgumentsBaseReg( void ) const __QCMP_THROW
		{
			return m_uiArgumentsBaseReg;
		}

		//------------------------------------------------------------------------------
		inline void setArgumentsBaseReg( Cmp_unsigned__int32 uiBaseReg ) __QCMP_THROW
		{
			m_uiArgumentsBaseReg = uiBaseReg;
		}

		//------------------------------------------------------------------------------
		inline Cmp__int32 getArgumentsBaseOffset( void ) const __QCMP_THROW
		{
			return m_iArgumentsBaseOffset;
		}

		//------------------------------------------------------------------------------
		inline void setArgumentsBaseOffset( Cmp__int32 iOffset ) __QCMP_THROW
		{
			m_iArgumentsBaseOffset = iOffset;
		}

		//------------------------------------------------------------------------------
		inline Cmp_unsigned__int32 getVariablesBaseReg( void ) const __QCMP_THROW
		{
			return m_uiVariablesBaseReg;
		}

		//------------------------------------------------------------------------------
		inline void setVariablesBaseReg( Cmp_unsigned__int32 uiBaseReg ) __QCMP_THROW
		{
			m_uiVariablesBaseReg = uiBaseReg;
		}

		//------------------------------------------------------------------------------
		inline Cmp__int32 getVariablesBaseOffset( void ) const __QCMP_THROW
		{
			return m_iVariablesBaseOffset;
		}

		//------------------------------------------------------------------------------
		inline void setVariablesBaseOffset( Cmp__int32 iOffset ) __QCMP_THROW
		{
			m_iVariablesBaseOffset = iOffset;
		}

		//------------------------------------------------------------------------------
		// Count of 4-byte memory blocks used by the function.
		inline Cmp_unsigned__int32 getMem4ClockCount( void ) const __QCMP_THROW
		{
			return m_uiMem4BlocksCount;
		}

		//------------------------------------------------------------------------------
		// Count of 8-byte memory blocks used by the function.
		inline Cmp_unsigned__int32 getMem8BlocksCount( void ) const __QCMP_THROW
		{
			return m_uiMem8BlocksCount;
		}

		//------------------------------------------------------------------------------
		// Count of 16-byte memory blocks used by the function.
		inline Cmp_unsigned__int32 getMem16BlocksCount( void ) const __QCMP_THROW
		{
			return m_uiMem16BlocksCount;		
		}

		//------------------------------------------------------------------------------
		inline Cmp_unsigned__int32 getMemBytesTotal( void ) const __QCMP_THROW
		{
			return m_uiMemBytesTotal;
		}

		//------------------------------------------------------------------------------
		nsCodeQOR::PodVector< CEJmp* >& getVecBackCode( void ) __QCMP_THROW
		{
			return m_VecBackCode;	// List of emittables which need to be translated. These emittables are filled by addBackwardCode().
		}

		//------------------------------------------------------------------------------
		inline Cmp_uint_ptr getBackPos( void ) const __QCMP_THROW
		{
			return m_uiBackPos;						// Backward code position (starts at 0).
		}

		//------------------------------------------------------------------------------
		inline Cmp_uint_ptr IncrementBackPos( void ) __QCMP_THROW
		{
			return m_uiBackPos++;
		}

		//Backward Code
		void addBackwardCode( CEJmp* from ) __QCMP_THROW;
		void addForwardJump( CEJmp* inst ) __QCMP_THROW;

		//State
		StateData* _saveState() __QCMP_THROW;
		void _assignState( StateData* state ) __QCMP_THROW;
		void _restoreState( StateData* state, Cmp_unsigned__int32 targetOffset = INVALID_VALUE ) __QCMP_THROW;

		//Memory Allocator

		VarMemBlock* _allocMemBlock( Cmp_unsigned__int32 size ) __QCMP_THROW;
		void _freeMemBlock( VarMemBlock* mem ) __QCMP_THROW;
		void _allocMemoryOperands() __QCMP_THROW;
		void _patchMemoryOperands( nsArch::CEmittable* start, nsArch::CEmittable* stop ) __QCMP_THROW;
		
	protected:

		CZone m_Zone;									// Zone memory manager.
		nsArch::CHighLevelAssemblerBase* m_pHLA;		// HLA instance.
		CCPU* m_pCPU;									// Assembler instance.
		CEFunction* m_pFunction;						// Function emittable.
		nsArch::CEmittable* m_pStart;					// Current active scope start emittable.
		nsArch::CEmittable* m_pStop;					// Current active scope end emittable.
		nsArch::CEmittable* m_pExtraBlock;				// Emittable that is used to insert some code after the function body.
	public:
		StateData m_pState;								// Current state (register allocator).
	protected:
		VarData* m_pActive;								// Link to circullar double-linked list containing all active variables (for current state).
		ForwardJumpData* m_pForwardJumps;				// Forward jumps (single linked list).		
		Cmp_unsigned__int32 m_uiUnreachable;			// Whether current code is unrecheable.
		Cmp_unsigned__int32 m_uiModifiedGPRegisters;	// Global modified GP registers mask (per function).
		Cmp_unsigned__int32 m_uiModifiedMMRegisters;	// Global modified MM registers mask (per function).
		Cmp_unsigned__int32 m_uiModifiedXMMRegisters;	// Global modified XMM registers mask (per function).
		Cmp_unsigned__int32 m_uiAllocableEBP;			// Whether the EBP/RBP register can be used by register allocator.

		int m_iAdjustESP;								// ESP adjust constant (changed during PUSH/POP or when using stack ).
		Cmp_unsigned__int32 m_uiArgumentsBaseReg;		// Function arguments base pointer (register).
		Cmp__int32 m_iArgumentsBaseOffset;				// Function arguments base offset.
		Cmp__int32 m_iArgumentsActualDisp;				// Function arguments displacement.
		Cmp_unsigned__int32 m_uiVariablesBaseReg;		// Function variables base pointer (register).
		Cmp__int32 m_iVariablesBaseOffset;				// Function variables base offset.
		Cmp__int32 m_iVariablesActualDisp;				// Function variables displacement.
		VarMemBlock* m_pMemUsed;						// Used memory blocks (for variables, here is each created mem block that can be also in m_pMemFree list).
		VarMemBlock* m_pMemFree;						// Free memory blocks (freed, prepared for another allocation).
		
		Cmp_unsigned__int32 m_uiMem4BlocksCount;		// Count of 4-byte memory blocks used by the function.
		Cmp_unsigned__int32 m_uiMem8BlocksCount;		// Count of 8-byte memory blocks used by the function.
		Cmp_unsigned__int32 m_uiMem16BlocksCount;		// Count of 16-byte memory blocks used by the function.
		Cmp_unsigned__int32 m_uiMemBytesTotal;			// Count of total bytes of stack memory used by the function.
		bool m_bEmitComments;							// Whether to emit comments.
		nsCodeQOR::PodVector< CEJmp* > m_VecBackCode;	// List of emittables which need to be translated. These emittables are filled by addBackwardCode().
		Cmp_uint_ptr m_uiBackPos;						// Backward code position (starts at 0).

	private:

		__QCS_DECLARE_NONCOPYABLE( Cx86HLAContext );

	};

}//nsx86
}//nsArch

#endif//ARCHQOR_X86PC_HLASSEMBLER_CONTEXT_H_2
