//HLAssembler.h

// Copyright Querysoft Limited 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef ARCHQOR_X86PC_HLASSEMBLERDEFS_H_2
#define ARCHQOR_X86PC_HLASSEMBLERDEFS_H_2

#include "ArchQOR/Common/Assembler/Logger.h"
#include "ArchQOR/Common/HLAssembler/BaseVarData.h"
//#include "ArchQOR/Defs.h"
#include "ArchQOR/Common/HLAssembler/HighLevelAssembler.h"
#include "x86HLAssembler.h"
#include <new>
#include <string.h>

//------------------------------------------------------------------------------
namespace nsArch
{
	//------------------------------------------------------------------------------
	namespace nsx86
	{

		class __QOR_INTERFACE( __ARCHQOR ) CEJmp;
		class __QOR_INTERFACE( __ARCHQOR ) CEFunction;
		class __QOR_INTERFACE( __ARCHQOR ) CECall;

		//------------------------------------------------------------------------------
		// Variable data (used internally by High Level Assembler).
		struct __QOR_INTERFACE( __ARCHQOR ) VarData : public nsArch::CommonVarData
		{
			CEFunction* scope;						// Scope (NULL if variable is global).
			nsArch::CEmittable* firstEmittable;		// The first emittable where the variable is accessed. Note If this member is NULL then variable is unused.
			CECall* firstCallable;					// The first callable (ECall) which is after the firstEmittable.
			nsArch::CEmittable* lastEmittable;		// The last emittable where the variable is accessed.
	
			const char* name;						// Variable name.
			Cmp_unsigned__int32 id;					// Variable id.
			Cmp_unsigned__int32 type;				// Variable type.
			Cmp_unsigned__int32 size;				// Variable size.

			Cmp_unsigned__int32 homeRegisterIndex;	// Home register index or INVALID_VALUE (used by register allocator).	
			Cmp_unsigned__int32 prefRegisterMask;	// Preferred register index.

			Cmp__int32 homeMemoryOffset;			// Home memory address offset.	
			void* homeMemoryData;					// Used by Cx86HLAContext, do not touch (NULL when created).

			Cmp_unsigned__int32 registerIndex;		// Actual register index (connected with actual StateData).
			Cmp_unsigned__int32 workOffset;			// Actual working offset. This member is set before register allocator is called. If workOffset is same as Cx86HLAContext::_currentOffset then this variable is probably used in next instruction and can't be spilled.

			VarData* nextActive;					// Next active variable in circullar double-linked list.
			VarData* prevActive;					// Previous active variable in circullar double-linked list.
	
			Cmp_unsigned__int8 priority;			// Variable priority.

			// Whether variable content can be calculated by simple instruction. This is used mainly by mmx or sse2 code and variable allocator will
			// never reserve space for this variable. Calculated variables are for example all zeros, all ones, etc.
			Cmp_unsigned__int8 calculated;
			Cmp_unsigned__int8 isRegArgument;			// Whether variable is argument passed through register.
			Cmp_unsigned__int8 isMemArgument;			// Whether variable is argument passed through memory.
			Cmp_unsigned__int8 state;					// Variable state (connected with actual @c StateData).
			Cmp_unsigned__int8 changed;					// Whether variable was changed (connected with actual @c StateData).
			Cmp_unsigned__int8 saveOnUnuse;				// Save on unuse (at end of the variable scope).
	
			// [Statistics]
			Cmp_unsigned__int32 registerReadCount;		// Register read statistics (used by instructions where this variable needs to be read only).
			Cmp_unsigned__int32 registerWriteCount;		// Register write statistics (used by instructions where this variable needs to be write only).
			Cmp_unsigned__int32 registerRWCount;		// Register read+write statistics (used by instructions where this variable needs to be read and write).	
			Cmp_unsigned__int32 registerGPBLoCount;		// Register GPB.LO statistics (for code generator).
			Cmp_unsigned__int32 registerGPBHiCount;		// Register GPB.HI statistics (for code generator).
			Cmp_unsigned__int32 memoryReadCount;		// Memory read statistics.
			Cmp_unsigned__int32 memoryWriteCount;		// Memory write statistics.
			Cmp_unsigned__int32 memoryRWCount;			// Memory read+write statistics.

			//------------------------------------------------------------------------------
			// Temporary data that can be used in prepare/translate stage.
			// Initial value is NULL and each emittable/code that will use it must also
			// clear it.
			// This temporary data is designed to be used by algorithms that need to
			// set some state into the variables, do something and then cleanup. See
			// state-switch and function call.
			union
			{
				void* tempPtr;
				Cmp_int_ptr tempInt;
			};
		};
	

		//------------------------------------------------------------------------------
		struct VarMemBlock
		{
			Cmp__int32 offset;
			Cmp_unsigned__int32 size;

			VarMemBlock* nextUsed;
			VarMemBlock* nextFree;
		};

		//------------------------------------------------------------------------------
		// Variable alloc record (for each instruction that uses variables).
		// Variable record contains pointer to variable data and register allocation
		// flags. These flags are important to determine the best alloc instruction.
		struct VarAllocRecord
		{
			VarData* vdata;							// Variable data ( the structure owned by HLA ).
			Cmp_unsigned__int32 vflags;				// Variable alloc flags, see VARIABLE_ALLOC.
			Cmp_unsigned__int32 regMask;			// Register mask (default is 0).
		};

		//------------------------------------------------------------------------------
		// Variable call-fn record (for each callable that uses variables).
		//
		// This record contains variables that are used to call a function (using 
		// CECall emittable). Each variable contains the registers where it must
		// be and registers where the value will be returned.
		struct VarCallRecord
		{	
			VarData* vdata;						// Variable data (the structure owned by HLA).
			Cmp_unsigned__int32 flags;
			Cmp_unsigned__int8 inCount;
			Cmp_unsigned__int8 inDone;
			Cmp_unsigned__int8 outCount;
			Cmp_unsigned__int8 outDone;

			//------------------------------------------------------------------------------
			enum FLAGS
			{
				FLAG_IN_GP = 0x0001,
				FLAG_IN_MM = 0x0002,
				FLAG_IN_XMM = 0x0004,
				FLAG_IN_STACK = 0x0008,

				FLAG_OUT_EAX = 0x0010,
				FLAG_OUT_EDX = 0x0020,
				FLAG_OUT_ST0 = 0x0040,
				FLAG_OUT_ST1 = 0x0080,
				FLAG_OUT_MM0 = 0x0100,
				FLAG_OUT_XMM0 = 0x0400,
				FLAG_OUT_XMM1 = 0x0800,

				FLAG_IN_MEM_PTR = 0x1000,
				FLAG_CALL_OPERAND_REG = 0x2000,
				FLAG_CALL_OPERAND_MEM = 0x4000,

				FLAG_UNUSE_AFTER_USE = 0x8000
			};
		};

		//------------------------------------------------------------------------------
		struct VarHintRecord
		{
			VarData* vdata;
			Cmp_unsigned__int32 hint;
		};

		//------------------------------------------------------------------------------
		// State data.
		class __QOR_INTERFACE( __ARCHQOR ) StateData
		{
		public:

			//------------------------------------------------------------------------------
			StateData()
			{
			}

			//------------------------------------------------------------------------------
			~StateData()
			{
			}

			//------------------------------------------------------------------------------
			StateData( const StateData& src )
			{
				*this = src;
			}

			//------------------------------------------------------------------------------
			StateData& operator = ( const StateData& src )
			{
				usedGP = src.usedGP;
				usedMM = src.usedMM;
				usedXMM = src.usedXMM;
				changedGP = src.changedGP;
				changedMM = src.changedMM;
				changedXMM = src.changedXMM;
				memVarsCount = src.memVarsCount;
				memcpy( regs, src.regs, sizeof( VarData* ) * NUM_REGS );
				memcpy( memVarsData, src.memVarsData, sizeof( src.memVarsData ) );
				return *this;
			}

			//------------------------------------------------------------------------------
			enum 
			{ 
				NUM_REGS = 16 + 8 + 16 
			};

			void clear() __QCMP_THROW;

	__QCMP_WARNING_PUSH
	__QCMP_WARNING_DISABLE( __QCMP_WARN_NAMELESS_STRUCTUNION, "Deliberate use of Microsoft extension" )

			//------------------------------------------------------------------------------
			union
			{		
				VarData* regs[ NUM_REGS ];						// All allocated variables in one array.

				struct
				{
					VarData* gp[ 16 ];							// Allocated GP registers.
					VarData* mm[ 8 ];							// Allocated MM registers.
					VarData* xmm[ 16 ];							// Allocated XMM registers.
				};
			};

	__QCMP_WARNING_POP

			Cmp_unsigned__int32 usedGP;							// Used GP registers bitmask.
			Cmp_unsigned__int32 usedMM;							// Used MM registers bitmask.
			Cmp_unsigned__int32 usedXMM;						// Used XMM registers bitmask.
			Cmp_unsigned__int32 changedGP;						// Changed GP registers bitmask.
			Cmp_unsigned__int32 changedMM;						// Changed MM registers bitmask.
			Cmp_unsigned__int32 changedXMM;						// Changed XMM registers bitmask.
			Cmp_unsigned__int32 memVarsCount;					// Count of variables in @c memVarsData.

			// Variables stored in memory (VARIABLE_STATE_MEMORY).
			//
			// When saving / restoring state it's important to keep registers which are
			// still in memory. Register is always unused when it is going out-of-scope.
			// All variables which are not here are unused (VARIABLE_STATE_UNUSED).
			VarData* memVarsData[ 1 ];
		};

		//------------------------------------------------------------------------------
		struct ForwardJumpData
		{
			CEJmp* inst;
			StateData* state;
			ForwardJumpData* next;
		};

		//------------------------------------------------------------------------------
		// Static class that contains utility methods.
		struct __QOR_INTERFACE( __ARCHQOR ) CompilerUtil
		{
			static bool isStack16ByteAligned();
		};

		//------------------------------------------------------------------------------
		struct VariableInfo
		{
			//------------------------------------------------------------------------------
			enum CLASS_INFO
			{
				CLASS_NONE   = 0x00,
				CLASS_GP     = 0x01,
				CLASS_X87    = 0x02,
				CLASS_MM     = 0x04,
				CLASS_XMM    = 0x08,
			};

			//------------------------------------------------------------------------------
			enum FLAGS
			{
				FLAG_SP_FP  = 0x10,
				FLAG_DP_FP  = 0x20,
				FLAG_VECTOR = 0x40
			};

			Cmp_unsigned__int32 code;
			Cmp_unsigned__int8 size;
			Cmp_unsigned__int8 clazz;
			Cmp_unsigned__int8 flags;
			Cmp_unsigned__int8 reserved_0;
			char name[8];
		};

	#	define C(c) VariableInfo::CLASS_##c
	#	define F(f) VariableInfo::FLAG_##f

		//------------------------------------------------------------------------------
		static const VariableInfo variableInfo[] =
		{
		  /*  0 */ { REG_TYPE_GPD   , 4 , C(GP) , 0                   , 0, "GP.D"        },
		  /*  1 */ { REG_TYPE_GPQ   , 8 , C(GP) , 0                   , 0, "GP.Q"        },
		  /*  2 */ { REG_TYPE_X87   , 4 , C(X87), F(SP_FP)            , 0, "X87"         },
		  /*  3 */ { REG_TYPE_X87   , 4 , C(X87), F(SP_FP)            , 0, "X87.1F"      },
		  /*  4 */ { REG_TYPE_X87   , 8 , C(X87), F(DP_FP)            , 0, "X87.1D"      },
		  /*  5 */ { REG_TYPE_MM    , 8 , C(MM) ,            F(VECTOR), 0, "MM"          },
		  /*  6 */ { REG_TYPE_XMM   , 16, C(XMM), 0                   , 0, "XMM"         },
		  /*  7 */ { REG_TYPE_XMM   , 4 , C(XMM), F(SP_FP)            , 0, "XMM.1F"      },
		  /*  8 */ { REG_TYPE_XMM   , 8 , C(XMM), F(DP_FP)            , 0, "XMM.1D"      },
		  /*  9 */ { REG_TYPE_XMM   , 16, C(XMM), F(SP_FP) | F(VECTOR), 0, "XMM.4F"      },
		  /* 10 */ { REG_TYPE_XMM   , 16, C(XMM), F(DP_FP) | F(VECTOR), 0, "XMM.2D"      }
		};
	#	undef F
	#	undef C

		Cmp_unsigned__int32 getVariableClass( Cmp_unsigned__int32 type );
		bool isVariableInteger( Cmp_unsigned__int32 type );
		bool isVariableFloat( Cmp_unsigned__int32 type );
		Cmp_unsigned__int32 getVariableSize( Cmp_unsigned__int32 type );
		Cmp_unsigned__int32 getVariableRegisterCode( Cmp_unsigned__int32 type, Cmp_unsigned__int32 index );
		CGPVar GPVarFromData( VarData* vdata );
	
	}//nsx86
}//nsArch

#endif//ARCHQOR_X86PC_HLASSEMBLERDEFS_H_2
