//Defs.h

// Copyright (c) 2008-2010, Petr Kobalicek <kobalicek.petr@gmail.com>
// Copyright (c) Querysoft Limited 2013-2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Fundamental definitions, dimensions, limits and ontology for the Z assembler domain

#ifndef ARCHQOR_Z_ASSEMBLERDEFS_H_1
#define ARCHQOR_Z_ASSEMBLERDEFS_H_1

#include "CompilerQOR.h"
#include "ArchQOR/Common/HLAssembler/Defs.h"

//------------------------------------------------------------------------------
namespace nsArch
{
//------------------------------------------------------------------------------
namespace nsZ
{
/*	
	//------------------------------------------------------------------------------
	// Operand types that can be encoded.
	enum OPERAND_TYPE
	{
		OPERAND_NONE = 0x00,		// Operand is none, used only internally (not initialized Operand). This operand is not valid.
		OPERAND_REG = 0x01,			// Operand is register.
		OPERAND_MEM = 0x02,			// Operand is memory.
		OPERAND_IMM = 0x04,			// Operand is immediate.
		OPERAND_LABEL = 0x08,		// Operand is label.
		OPERAND_VAR = 0x10			// Operand is variable.
	};
*/	
	//------------------------------------------------------------------------------
	// Type of memory operand.
	enum OPERAND_MEM_TYPE
	{
		OPERAND_MEM_NATIVE = 0,		// Operand is combination of register(s) and displacement (native).
		OPERAND_MEM_LABEL = 1,		// Operand is label.
		OPERAND_MEM_ABSOLUTE = 2,	// Operand is absolute memory location (supported mainly in 32-bit mode)
	};
	
	//------------------------------------------------------------------------------
	// Assembler/HLA properties.
	enum PROPERTY
	{
		PROPERTY_OPTIMIZE_ALIGN = 0,		// Optimize align for current processor.Default: true.
		PROPERTY_JUMP_HINTS = 1				// Emit hints added to jcc() instructions. Default: true.
	};
	
	//------------------------------------------------------------------------------
	// Size of registers and pointers.
	enum SIZE
	{
		SIZE_BYTE   = 1,		// 1 byte size.
		SIZE_WORD   = 2,		// 2 bytes size.
		SIZE_DWORD  = 4,		// 4 bytes size.
		SIZE_QWORD  = 8,		// 8 bytes size.
		SIZE_TWORD  = 10,		// 10 bytes size.
		SIZE_DQWORD = 16		// 16 bytes size.
	};
	
		
	//------------------------------------------------------------------------------
	// Arguments direction used by Function call.
	enum ARGUMENT_DIR
	{
		// Arguments are passed left to right. This arguments direction is unusual to C programming, it's used by pascal compilers and in some calling conventions by Borland compiler.
		ARGUMENT_DIR_LEFT_TO_RIGHT = 0,		
		ARGUMENT_DIR_RIGHT_TO_LEFT = 1		// Arguments are passer right ro left. This is default argument direction in C programming.
	};

	/*
	// Translates error code (see ERROR_CODE) into text representation.
	//__QOR_INTERFACE( __ARCHQOR ) const char* getErrorCodeAsString(Cmp_unsigned__int32 error) __QCMP_THROW;

	// Count of General purpose registers and XMM registers.
	//
	// Count of general purpose registers and XMM registers depends to current
	// bit-mode. If application is compiled for 32-bit platform then this number
	// is 8, 64-bit platforms have 8 extra general purpose and xmm registers (16
	// total).
	*/

	//------------------------------------------------------------------------------
	// Count of registers. Used by x86 HLA
	enum REG_NUM
	{
		// Count of general purpose registers and XMM registers depends on current
		// bit-mode. If application is compiled for 32-bit platform then this number
		// is 8, 64-bit platforms have 8 extra general purpose and xmm registers (16
		// total).
#if	( QOR_ARCH_WORDSIZE == 32 )
		REG_NUM_BASE = 8,
#else
		REG_NUM_BASE = 16,
#endif //

		REG_NUM_GP = REG_NUM_BASE,				// Count of general purpose registers. 8 in 32-bit mode and 16 in 64-bit mode.
		REG_NUM_MM = 8,							// Count of MM registers (always 8).
		REG_NUM_FPU = 8,						// Count of FPU stack registers (always 8).
		REG_NUM_XMM = REG_NUM_BASE,				// Count of XMM registers. 8 in 32-bit mode and 16 in 64-bit mode.
		REG_NUM_SEGMENT = 7
	};
	
	//------------------------------------------------------------------------------
	// Valid Z register indexes.
	// These codes are real, don't mess with REG enum! and don't use these
	// values if you are not writing ArchQOR code.
	enum REG_INDEX
	{
		REG_INDEX_MASK = 0x00FF,		// Mask for register code (index).
		REG_INDEX_EAX = 0,				// ID for AX/EAX/RAX registers.
		
		REG_INDEX_MM0 = 0,				// ID for mm0 register.

		REG_INDEX_ES = 0,				//ID for ES segment register.
		REG_INDEX_CS = 1,				//ID for CS segment register.
		REG_INDEX_SS = 2,				//ID for SS segment register.
		REG_INDEX_DS = 3,				//ID for DS segment register.
		REG_INDEX_FS = 4,				//ID for FS segment register.
		REG_INDEX_GS = 5,				//ID for GS segment register.
	};
	
	//------------------------------------------------------------------------------
	// Pseudo (not real X86) register types.
	enum REG_TYPE
	{
		// Mask for register type.
		REG_TYPE_MASK = 0xFF00,			// First byte contains register type (mask 0xFF00), Second byte contains register index code.

		// GP Register Types		
		REG_TYPE_GPB_LO = 0x0100,		// 8-bit general purpose register type (LO).
		REG_TYPE_GPB_HI = 0x0200,		// 8-bit general purpose register type (HI, only AH, BH, CH, DH).
		REG_TYPE_GPW = 0x1000,			// 16-bit general purpose register type.
		REG_TYPE_GPD = 0x2000,			// 32-bit general purpose register type.
		REG_TYPE_GPQ = 0x3000,			// 64-bit general purpose register type.

		// native 32-bit or 64-bit register type (depends to x86 or x64 mode).
#if	( QOR_ARCH_WORDSIZE == 32 )
		REG_TYPE_GPN = REG_TYPE_GPD,
#else
		REG_TYPE_GPN = REG_TYPE_GPQ,
#endif
		
		REG_TYPE_X87 = 0x5000,			// X87 (FPU) register type.
		REG_TYPE_MM = 0x6000,			// 64-bit MM register type.
		REG_TYPE_XMM = 0x7000,			// 128-bit XMM register type.
		REG_TYPE_YMM = 0x8000,			// 256-bit YMM register type
		REG_TYPE_SEGMENT = 0xD000		// 16-bit srgment register type
	};
	
	//------------------------------------------------------------------------------
	// Pseudo register codes used for generating opcodes.
	// From this register code can be generated real Z register ID, type of
	// register and size of register.
	enum REG_CODE
	{
		// 8-bit Registers

		REG_AL = REG_TYPE_GPB_LO,
		REG_CL,
		REG_DL,
		REG_BL,
#if ( QOR_ARCH_WORDSIZE == 64 )
		REG_SPL,
		REG_BPL,
		REG_SIL,
		REG_DIL,
#endif

#if ( QOR_ARCH_WORDSIZE == 64 )
		REG_R8B,
		REG_R9B,
		REG_R10B,
		REG_R11B,
		REG_R12B,
		REG_R13B,
		REG_R14B,
		REG_R15B,
#endif


	};
	
	//------------------------------------------------------------------------------
	// Segment override prefixes.
	enum SEGMENT_PREFIX
	{
		// DO NOT MODIFY INDEX CODES - They are used by logger in this order.

		SEGMENT_ES = 0,
		SEGMENT_NONE = 0xF,
	};
	/*
	//------------------------------------------------------------------------------
	// Prefetch hints.
	enum PREFETCH_HINT
	{
		PREFETCH_T0  = 1,		// Prefetch to L0 cache.
		PREFETCH_T1  = 2,		// Prefetch to L1 cache.
		PREFETCH_T2  = 3,		// Prefetch to L2 cache.
		PREFETCH_NTA = 0		// Prefetch using NT hint.
	};
	*/
	//------------------------------------------------------------------------------
	// Condition codes.
	enum CONDITION
	{
		// No condition code.
		C_NO_CONDITION  = -1,

		// Condition codes from processor manuals.
		C_A             = 0x7,
		C_FP_NOT_UNORDERED = 17
	};
	
	//------------------------------------------------------------------------------
	//  Returns the equivalent of !cc.
	// Negation of the default no_condition (-1) results in a non-default
	// no_condition value (-2). As long as tests for no_condition check
	// for condition < 0, this will work as expected.
	static inline CONDITION negateCondition( CONDITION cc )
	{
		return static_cast< CONDITION >( cc ^ 1 );
	}

	//------------------------------------------------------------------------------
	// Corresponds to transposing the operands of a comparison.
	//static inline CONDITION reverseCondition( CONDITION cc )
	
	//------------------------------------------------------------------------------
	struct __QOR_INTERFACE( __ARCHQOR ) ConditionToInstruction
	{
		
		static const Cmp_unsigned__int32 _jcctable[ 16 ];		// Used to map condition code to jcc instructions.
		static const Cmp_unsigned__int32 _cmovcctable[ 16 ];	// Used to map condition code to cmovcc instructions.
		static const Cmp_unsigned__int32 _setcctable[ 16 ];		// Used to map condition code to setcc instructions.

		static Cmp_unsigned__int32 toJCC( CONDITION cc ) __QCMP_THROW;
		static Cmp_unsigned__int32 toCMovCC( CONDITION cc ) __QCMP_THROW;
		static Cmp_unsigned__int32 toSetCC( CONDITION cc ) __QCMP_THROW;

	};
	/*
	//------------------------------------------------------------------------------
	// Scale, can be used for addressing.
	// See Op and addressing methods like byte_ptr(), word_ptr(), dword_ptr(), etc...
	enum SCALE
	{
		TIMES_1 = 0,		// Scale 1 times (no scale).
		TIMES_2 = 1,		// Scale 2 times (same as shifting to left by 1).
		TIMES_4 = 2,		// Scale 4 times (same as shifting to left by 2).		
		TIMES_8 = 3			// Scale 8 times (same as shifting to left by 3).
	};
	*/
	//------------------------------------------------------------------------------
	// Condition hint, see Assembler::jz(), HLA::jz() and friends.
	enum HINT
	{		
		HINT_NONE = 0x00,		// No hint.		
		HINT_TAKEN = 0x01,		// Condition will be taken (likely).		
		HINT_NOT_TAKEN = 0x02	// Condition will be not taken (unlikely).
	};
	
	//------------------------------------------------------------------------------
	// Hint byte value is the byte that will be emitted if hint flag is specified by HINT.
	enum HINT_BYTE_VALUE
	{
		HINT_BYTE_VALUE_TAKEN = 0x3E,		// Condition will be taken (likely).
		HINT_BYTE_VALUE_NOT_TAKEN = 0x2E	// Condition will be not taken (unlikely).
	};
	/*
	//------------------------------------------------------------------------------
	// Floating point status.
	enum FP_STATUS
	{
		FP_C0 = 0x100,
		FP_C1 = 0x200,
		FP_C2 = 0x400,
		FP_C3 = 0x4000,
		FP_CC_MASK = 0x4500
	};

	//------------------------------------------------------------------------------
	// Floating point control word.
	enum FP_CW
	{
		FP_CW_INVOPEX_MASK  = 0x001,
		FP_CW_DENOPEX_MASK  = 0x002,
		FP_CW_ZERODIV_MASK  = 0x004,
		FP_CW_OVFEX_MASK    = 0x008,
		FP_CW_UNDFEX_MASK   = 0x010,
		FP_CW_PRECEX_MASK   = 0x020,
		FP_CW_PRECC_MASK    = 0x300,
		FP_CW_ROUNDC_MASK   = 0xC00,

		// Values for precision control.
		FP_CW_PREC_SINGLE   = 0x000,
		FP_CW_PREC_DOUBLE   = 0x200,
		FP_CW_PREC_EXTENDED = 0x300,

		// Values for rounding control.
		FP_CW_ROUND_NEAREST = 0x000,
		FP_CW_ROUND_DOWN    = 0x400,
		FP_CW_ROUND_UP      = 0x800,
		FP_CW_ROUND_TOZERO  = 0xC00
	};
	*/
	//------------------------------------------------------------------------------
	// Instruction codes.
	// Note that these instruction codes are ArchQOR specific. Each instruction is
	// unique ID into instruction table. Instruction codes are used together
	// with Assembler and you can also use instruction codes to serialize
	// instructions by Cx86CPUCore::_emitInstruction() or Cx86HLAssembler::_emitInstruction()
	enum INST_CODE
	{
	};
	
	//------------------------------------------------------------------------------
	// Instruction names.
	extern __QOR_INTERFACE( __ARCHQOR ) const char instructionName[];
	
	//------------------------------------------------------------------------------
	struct InstructionDescription
	{
		//------------------------------------------------------------------------------
		// Instruction groups.
		// This should be only used by assembler, because it's Assembler
		// specific grouping. Each group represents one 'case' in the Assembler's 
		// main emit method.
		enum G
		{
			// Group categories.
			G_EMIT,
			G_ALU,
			G_BSWAP,
		};

		//------------------------------------------------------------------------------
		// Instruction core flags.
		enum F
		{
			F_NONE = 0x00,		// No flags.
			F_JUMP = 0x01,		// Instruction is jump, conditional jump, call or ret.
		};

		// --------------------------------------------------------------------------
		// Instruction operand flags.
		enum O
		{
			// X86, MM, XMM
			O_GB          = 0x0001,
			O_GW          = 0x0002,
		};

		
		Cmp_unsigned__int16 code;				// Instruction code.		
		Cmp_unsigned__int16 nameIndex;			// Instruction name index in instructionName[] array.
		Cmp_unsigned__int8 group;				// Instruction group, used also by HLA
		Cmp_unsigned__int8 flags;				// Instruction type flags.		
		Cmp_unsigned__int16 oflags[ 2 ];		// First and second operand flags (some groups depends to these settings, used also by HLA).		
		Cmp_unsigned__int16 opCodeR;			// If instruction has only memory operand, this is register opcode.		
		Cmp_unsigned__int32 opCode[ 2 ];		// Primary and secondary opcodes.

		//------------------------------------------------------------------------------
		// Get the instruction name (null terminated string).
		inline const char* getName() const 
		{ 
			return instructionName + nameIndex; 
		}

		//------------------------------------------------------------------------------
		// Get whether the instruction is conditional or standard jump.
		inline bool isJump() const 
		{ 
			return ( flags & F_JUMP ) != 0; 
		}

		//------------------------------------------------------------------------------
		// Get whether the instruction is MOV type.
		inline bool isMov() const 
		{ 
			return false;
		}

		//------------------------------------------------------------------------------
		// Get whether the instruction is X87 FPU type.
		inline bool isFPU() const 
		{ 
			return false;
		}

		//------------------------------------------------------------------------------
		// Get whether the instruction can be prefixed by LOCK prefix.
		inline bool isLockable() const 
		{ 
			return false;
		}

		//------------------------------------------------------------------------------
		// Get whether the instruction is special type (this is used by HLA to manage additional variables or functionality).
		inline bool isSpecial() const 
		{ 
			return false;
		}

		//------------------------------------------------------------------------------
		// Get whether the instruction is special type and it performs memory access.
		inline bool isSpecialMem() const 
		{ 
			return false;
		}
	};

	extern __QOR_INTERFACE( __ARCHQOR ) const InstructionDescription instructionDescription[];
	
	//------------------------------------------------------------------------------
	// Emit options, mainly for internal purposes.
	enum EMIT_OPTIONS
	{
	};
	
	enum CALL_CONV
	{
		// Calling convention is invalid (can't be used).
		CALL_CONV_NONE = 0,

	};
		

}//nsZ
}//nsArch

#endif//ARCHQOR_Z_ASSEMBLERDEFS_H_1
