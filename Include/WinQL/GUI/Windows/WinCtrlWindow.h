//WinCtrlWindow.h

// Copyright Querysoft Limited 2013, 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Built in Windows Control window

#ifndef WINQL_WND_WINCTRL_H_3
#define WINQL_WND_WINCTRL_H_3

#include "WinQL/GUI/MessageHandler.h"
#include "WinQL/GUI/Windows/SubclassWindow.h"
#include "WinQL/GUI/WindowClass.h"

//--------------------------------------------------------------------------------
namespace nsWin32
{

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE( __WINQL_GUI ) CWinCtrlWindow : public CSubclassWindow
	{
	public:

		//--------------------------------------------------------------------------------
		typedef struct tagNMOBJECTNOTIFY : public NotificationMessageHeader
		{
			//NMHDR   hdr;
			int     iItem;
#ifdef __IID_DEFINED__
			const GUID* piid;
#else
			const void* piid;
#endif
			void* pObject;
			long hResult;
			unsigned long dwFlags;    // control specific flags (hints as to where in iItem it hit)
		} NMOBJECTNOTIFY, *LPNMOBJECTNOTIFY;

#define HINST_COMMCTRL	( (InstanceHandle) -1 )

		__QCMP_STATIC_CONSTANT( unsigned long, CLR_NONE                = 0xFFFFFFFFL );
		__QCMP_STATIC_CONSTANT( unsigned long, CLR_DEFAULT             = 0xFF000000L );

		__QCMP_STATIC_CONSTANT( int, IMAGE_BITMAP			= 0 );
		__QCMP_STATIC_CONSTANT( int, IMAGE_ICON				= 1 );
		__QCMP_STATIC_CONSTANT( int, IMAGE_CURSOR			= 2 );

		__QCMP_STATIC_CONSTANT( unsigned long, CDRF_DODEFAULT          = 0x00000000 );
		__QCMP_STATIC_CONSTANT( unsigned long, CDRF_NEWFONT            = 0x00000002 );
		__QCMP_STATIC_CONSTANT( unsigned long, CDRF_SKIPDEFAULT        = 0x00000004 );
		__QCMP_STATIC_CONSTANT( unsigned long, CDRF_DOERASE            = 0x00000008 );// draw the background
		__QCMP_STATIC_CONSTANT( unsigned long, CDRF_SKIPPOSTPAINT      = 0x00000100 );// don't draw the focus rect

		__QCMP_STATIC_CONSTANT( unsigned long, CDRF_NOTIFYPOSTPAINT    = 0x00000010 );
		__QCMP_STATIC_CONSTANT( unsigned long, CDRF_NOTIFYITEMDRAW     = 0x00000020 );
#if (_WIN32_IE >= 0x0400)
		__QCMP_STATIC_CONSTANT( unsigned long, CDRF_NOTIFYSUBITEMDRAW  = 0x00000020 );  // flags are the same, we can distinguish by context
#endif
		__QCMP_STATIC_CONSTANT( unsigned long, CDRF_NOTIFYPOSTERASE    = 0x00000040 );

		//Common notification codes

		__QCMP_STATIC_CONSTANT( int, NM_FIRST                = (0U-  0U) );       // generic to all controls
		__QCMP_STATIC_CONSTANT( int, NM_LAST                 = (0U- 99U) );

		__QCMP_STATIC_CONSTANT( int, NM_OUTOFMEMORY          = (NM_FIRST-1) );
		__QCMP_STATIC_CONSTANT( int, NM_CLICK                = (NM_FIRST-2) );    // uses NMCLICK struct
		__QCMP_STATIC_CONSTANT( int, NM_DBLCLK               = (NM_FIRST-3) );
		__QCMP_STATIC_CONSTANT( int, NM_RETURN               = (NM_FIRST-4) );
		__QCMP_STATIC_CONSTANT( int, NM_RCLICK               = (NM_FIRST-5) );    // uses NMCLICK struct
		__QCMP_STATIC_CONSTANT( int, NM_RDBLCLK              = (NM_FIRST-6) );
		__QCMP_STATIC_CONSTANT( int, NM_SETFOCUS             = (NM_FIRST-7) );
		__QCMP_STATIC_CONSTANT( int, NM_KILLFOCUS            = (NM_FIRST-8) );
#if (_WIN32_IE >= 0x0300)
		__QCMP_STATIC_CONSTANT( int, NM_CUSTOMDRAW           = (NM_FIRST-12) );
		__QCMP_STATIC_CONSTANT( int, NM_HOVER                = (NM_FIRST-13) );
#endif
#if (_WIN32_IE >= 0x0400)
		__QCMP_STATIC_CONSTANT( int, NM_NCHITTEST            = (NM_FIRST-14) );   // uses NMMOUSE struct
		__QCMP_STATIC_CONSTANT( int, NM_KEYDOWN              = (NM_FIRST-15) );   // uses NMKEY struct
		__QCMP_STATIC_CONSTANT( int, NM_RELEASEDCAPTURE      = (NM_FIRST-16) );
		__QCMP_STATIC_CONSTANT( int, NM_SETCURSOR            = (NM_FIRST-17) );   // uses NMMOUSE struct
		__QCMP_STATIC_CONSTANT( int, NM_CHAR                 = (NM_FIRST-18) );   // uses NMCHAR struct
#endif
#if (_WIN32_IE >= 0x0401)
		__QCMP_STATIC_CONSTANT( int, NM_TOOLTIPSCREATED      = (NM_FIRST-19) );   // notify of when the tooltips window is create
#endif
#if (_WIN32_IE >= 0x0500)
		__QCMP_STATIC_CONSTANT( int, NM_LDOWN                = (NM_FIRST-20) );
		__QCMP_STATIC_CONSTANT( int, NM_RDOWN                = (NM_FIRST-21) );
		__QCMP_STATIC_CONSTANT( int, NM_THEMECHANGED         = (NM_FIRST-22) );
#endif

#if _WIN32_WINNT >= 0x0600
		__QCMP_STATIC_CONSTANT( int, NM_FONTCHANGED          = (NM_FIRST-23) );
		__QCMP_STATIC_CONSTANT( int, NM_CUSTOMTEXT           = (NM_FIRST-24) );  // uses NMCUSTOMTEXT struct
		__QCMP_STATIC_CONSTANT( int, NM_TVSTATEIMAGECHANGING = (NM_FIRST-24) );  // uses NMTVSTATEIMAGECHANGING struct, defined after HTREEITEM
#endif

		//Common Messages

		__QCMP_STATIC_CONSTANT( int, CCM_FIRST               = 0x2000 );      // Common control shared messages
		__QCMP_STATIC_CONSTANT( int, CCM_LAST                = (CCM_FIRST + 0x200) );

		__QCMP_STATIC_CONSTANT( int, CCM_SETBKCOLOR          = (CCM_FIRST + 1) ); // lParam is bkColor
		__QCMP_STATIC_CONSTANT( int, CCM_SETCOLORSCHEME      = (CCM_FIRST + 2) ); // lParam is color scheme
		__QCMP_STATIC_CONSTANT( int, CCM_GETCOLORSCHEME      = (CCM_FIRST + 3) ); // fills in COLORSCHEME pointed to by lParam
		__QCMP_STATIC_CONSTANT( int, CCM_GETDROPTARGET       = (CCM_FIRST + 4) );
		__QCMP_STATIC_CONSTANT( int, CCM_SETUNICODEFORMAT    = (CCM_FIRST + 5) );
		__QCMP_STATIC_CONSTANT( int, CCM_GETUNICODEFORMAT    = (CCM_FIRST + 6) );
		__QCMP_STATIC_CONSTANT( int, CCM_SETVERSION          = (CCM_FIRST + 0x7) );
		__QCMP_STATIC_CONSTANT( int, CCM_GETVERSION          = (CCM_FIRST + 0x8) );
		__QCMP_STATIC_CONSTANT( int, CCM_SETNOTIFYWINDOW     = (CCM_FIRST + 0x9) ); // wParam == hwndParent.
#if (_WIN32_WINNT >= 0x0501)
		__QCMP_STATIC_CONSTANT( int, CCM_SETWINDOWTHEME      = (CCM_FIRST + 0xb) );
		__QCMP_STATIC_CONSTANT( int, CCM_DPISCALE            = (CCM_FIRST + 0xc) ); // wParam == Awareness
#endif

		//--------------------------------------------------------------------------------
		typedef struct tagCOLORSCHEME 
		{
			unsigned long         dwSize;
			unsigned long         clrBtnHighlight;       // highlight color
			unsigned long         clrBtnShadow;          // shadow color
		} COLORSCHEME, *LPCOLORSCHEME;

		//--------------------------------------------------------------------------------
		CWinCtrlWindow() : CSubclassWindow()
		{
		}

		//--------------------------------------------------------------------------------
		CWinCtrlWindow( CWindowClass* pClass, void* pParam ) : CSubclassWindow( pClass, pParam )
		{				
		}

		//--------------------------------------------------------------------------------
		virtual ~CWinCtrlWindow()
		{
		}

		virtual void Create( const TCHAR* lpWindowName, InstanceHandle hInstance, unsigned long dwStyle, unsigned long dwExStyle, int x, int y, int nWidth, int nHeight, CWindowHandle::refType hWndParent, CMenuHandle::refType hMenu );

		//--------------------------------------------------------------------------------
		virtual CBrush::refType OnCtlColour( CDeviceContext::refType DC )
		{
			return CBrush::FromHandle( CBrushHandle( 0, (void*)( DefProc( COSWindow::wmCtlColorEdit, (Cmp_uint_ptr)( DC->Handle()->Use() ), (Cmp_long_ptr)( Handle()->Use() ) ) ) ).Ref() );
		}

		//--------------------------------------------------------------------------------
		virtual void OnDrawItem( DrawItemStruct* pItemStruct )
		{
			QOR_PP_UNREF( pItemStruct );
		}

		//--------------------------------------------------------------------------------
		virtual long OnCompareItem( nsWin32::ComparisonItem* pItemStruct )
		{
			QOR_PP_UNREF( pItemStruct );
			return 0;//Default to equality
		}

		//--------------------------------------------------------------------------------
		virtual void OnMeasureItem( nsWin32::MeasureItemStruct* pItemStruct )
		{
			QOR_PP_UNREF( pItemStruct );
		}

		//--------------------------------------------------------------------------------
		virtual void OnDeleteItem( nsWin32::DeleteItemStruct* pItemStruct )
		{
			QOR_PP_UNREF( pItemStruct );
		}

		//--------------------------------------------------------------------------------
		virtual long OnVKeyToItem( unsigned short wVKey, unsigned short wPos )
		{
			QOR_PP_UNREF2( wPos, wVKey );
			return 0;
		}

		//--------------------------------------------------------------------------------
		virtual long OnCharToItem( unsigned short wKey, unsigned short wPos )
		{
			QOR_PP_UNREF2( wPos, wKey );
			return 0;
		}

		//--------------------------------------------------------------------------------
		virtual void OnCommand( unsigned short wCtrlID, unsigned short wCode )
		{
			QOR_PP_UNREF2( wCode, wCtrlID );
		}

		//--------------------------------------------------------------------------------
		virtual long OnNotify( NotificationMessageHeader* pHdr )
		{
			QOR_PP_UNREF( pHdr );
			long lResult = 0;
			return lResult;
		}

	protected:

		CMessageHandler m_Win32MsgHandler;

	};

}//nsWin32

#endif//WINQL_WND_WINCTRL_H_3
