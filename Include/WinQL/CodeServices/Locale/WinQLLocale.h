//WinQLLocale.h

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Win32 Locale

#ifndef WINQL_CS_LOCALE_H_3
#define WINQL_CS_LOCALE_H_3

#include "WinQL/WinQL.h"
//#include "WinQL/Constants.h"
//#include "../Text/StringHelper.h"
//#include "../Text/CodePage.h"
#include "WinQL/Application/Threading/WinQLCriticalSection.h"
//#include "LocaleConv.h"
//#include "LocaleDateTime.h"
//#include "MBCInfo.h"
//#include "../Thread.h"
#include "WinQL/CodeServices/Locale/WinQLThreadLocaleInfo.h"
#include "WinQL/CodeServices/Text/WinString.h"
#include "WinQL/CodeServices/Text/WinQLStringServices.h"
#include <stdlib.h>

#define USE_A 1
#define USE_W 2


//--------------------------------------------------------------------------------
namespace nsWin32
{

	class __QOR_INTERFACE( __WINQL ) CLocaleThreadData;
	class __QOR_INTERFACE( __WINQL ) CCodePage;
	class __QOR_INTERFACE( __WINQL ) CLocaleDateTime;
	class __QOR_INTERFACE( __WINQL ) CMBCInfo;

	typedef bool ( __QCMP_STDCALLCONVENTION *CODEPAGE_ENUMCALLBACK )( CCodePage* );

	template< typename TP, typename TS > unsigned short MakeLangID( TP p, TS s ){ return (((( unsigned short )(s)) << 10) | ( unsigned short )(p)); }
	template< typename T, typename S > unsigned long MakeLcId( T lgid, S srtid ){ return ((unsigned long)((((unsigned long)(( unsigned short )(srtid))) << 16) | ((unsigned long)(( unsigned short )(lgid))))); }
	template< typename L, typename S, typename V > unsigned long MakeSortLcId( L lgid, S strid, V ver ){ return ((unsigned long)((MakeLcId(lgid, strid)) | (((unsigned long)(( unsigned short )(ver))) << 20))); }
	template< typename T > unsigned short LangIdFromLcId( T lcid ){ return (( unsigned short )(lcid)); }
	template< typename T > unsigned short SortIdFromLcId( T lcid ){ return (( unsigned short )((((unsigned long)(lcid)) >> 16) & 0xf)); }
	template< typename T > unsigned short SortVersionFromLcId( T lcid ){ return (( unsigned short )((((unsigned long)(lcid)) >> 20) & 0xf)); }

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE( __WINQL ) CLocale
	{
	public:		

		__QCMP_STATIC_CONSTANT( int, Str_Char_Int = 4 );
		__QCMP_STATIC_CONSTANT( int, Str_Char_Cnt = 128 );

		//------------------------------------------------------------------------------
		class __QOR_INTERFACE( __WINQL ) CLOCALETAB
		{
		public:
			char*	szName;
			char	chAbbrev[4];
		};

		__QCMP_STATIC_CONSTANT( int, _CLOCALEHANDLE = 0 ); // "C" locale handle
		static const char* _clocalestr;// = "C";

		__QCMP_STATIC_CONSTANT( int, Sort_Default                     = 0x0 );    // sorting default
		__QCMP_STATIC_CONSTANT( int, Sort_INVARIANT_MATH              = 0x1 );    // Invariant (Mathematical Symbols)
		__QCMP_STATIC_CONSTANT( int, Sort_JAPANESE_XJIS               = 0x0  );   // Japanese XJIS order
		__QCMP_STATIC_CONSTANT( int, Sort_JAPANESE_UNICODE            = 0x1 );    // Japanese Unicode order (no longer supported)
		__QCMP_STATIC_CONSTANT( int, Sort_JAPANESE_RADICALSTROKE      = 0x4 );    // Japanese radical/stroke order
		__QCMP_STATIC_CONSTANT( int, Sort_CHINESE_BIG5                = 0x0 );    // Chinese BIG5 order
		__QCMP_STATIC_CONSTANT( int, Sort_CHINESE_PRCP                = 0x0 );    // PRC Chinese Phonetic order
		__QCMP_STATIC_CONSTANT( int, Sort_CHINESE_UNICODE             = 0x1 );    // Chinese Unicode order (no longer supported)
		__QCMP_STATIC_CONSTANT( int, Sort_CHINESE_PRC                 = 0x2 );    // PRC Chinese Stroke Count order
		__QCMP_STATIC_CONSTANT( int, Sort_CHINESE_BOPOMOFO            = 0x3 );    // Traditional Chinese Bopomofo order
		__QCMP_STATIC_CONSTANT( int, Sort_CHINESE_RADICALSTROKE       = 0x4 );    // Traditional Chinese radical/stroke order.
		__QCMP_STATIC_CONSTANT( int, Sort_KOREAN_KSC                  = 0x0 );    // Korean KSC order
		__QCMP_STATIC_CONSTANT( int, Sort_KOREAN_UNICODE              = 0x1 );    // Korean Unicode order (no longer supported)
		__QCMP_STATIC_CONSTANT( int, Sort_GERMAN_PHONE_BOOK           = 0x1 );    // German Phone Book order
		__QCMP_STATIC_CONSTANT( int, Sort_HUNGARIAN_DEFAULT           = 0x0 );    // Hungarian Default order
		__QCMP_STATIC_CONSTANT( int, Sort_HUNGARIAN_TECHNICAL         = 0x1 );    // Hungarian Technical order
		__QCMP_STATIC_CONSTANT( int, Sort_GEORGIAN_TRADITIONAL        = 0x0 );    // Georgian Traditional order
		__QCMP_STATIC_CONSTANT( int, Sort_GEORGIAN_MODERN             = 0x1 );    // Georgian Modern order

		__QCMP_STATIC_CONSTANT( int, LCALL = 0 );
		__QCMP_STATIC_CONSTANT( int, LCCOLLATE = 1 );
		__QCMP_STATIC_CONSTANT( int, LCCTYPE = 2 );
		__QCMP_STATIC_CONSTANT( int, LCMESSAGES = 3 );
		__QCMP_STATIC_CONSTANT( int, LCMONETARY = 4 );
		__QCMP_STATIC_CONSTANT( int, LCNUMERIC = 5 );
		__QCMP_STATIC_CONSTANT( int, LCTIME = 6 );
		__QCMP_STATIC_CONSTANT( int, LCMIN = LCALL );
		__QCMP_STATIC_CONSTANT( int, LCMAX = LCTIME );

		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SDayName1              = 0x0000002A );  // long name for Monday
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SDayName2              = 0x0000002B );  // long name for Tuesday
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SDayName3              = 0x0000002C );  // long name for Wednesday
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SDayName4              = 0x0000002D );  // long name for Thursday
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SDayName5              = 0x0000002E );  // long name for Friday
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SDayName6              = 0x0000002F );  // long name for Saturday
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SDayName7              = 0x00000030 );  // long name for Sunday
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SAbbrevDayName1        = 0x00000031 );  // abbreviated name for Monday
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SAbbrevDayName2        = 0x00000032 );  // abbreviated name for Tuesday
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SAbbrevDayName3        = 0x00000033 );  // abbreviated name for Wednesday
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SAbbrevDayName4        = 0x00000034 );  // abbreviated name for Thursday
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SAbbrevDayName5        = 0x00000035 );  // abbreviated name for Friday
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SAbbrevDayName6        = 0x00000036 );  // abbreviated name for Saturday
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SAbbrevDayName7        = 0x00000037 );  // abbreviated name for Sunday
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SMonthName1            = 0x00000038 );  // long name for January
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SMonthName2            = 0x00000039 );  // long name for February
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SMonthName3            = 0x0000003A );  // long name for March
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SMonthName4            = 0x0000003B );  // long name for April
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SMonthName5            = 0x0000003C );  // long name for May
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SMonthName6            = 0x0000003D );  // long name for June
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SMonthName7            = 0x0000003E );  // long name for July
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SMonthName8            = 0x0000003F );  // long name for August
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SMonthName9            = 0x00000040 );  // long name for September
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SMonthName10           = 0x00000041 );  // long name for October
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SMonthName11           = 0x00000042 );  // long name for November
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SMonthName12           = 0x00000043 );  // long name for December
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SMonthName13           = 0x0000100E );  // long name for 13th month (if exists)
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SAbbrevMonthName1      = 0x00000044 );  // abbreviated name for January
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SAbbrevMonthName2      = 0x00000045 );  // abbreviated name for February
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SAbbrevMonthName3      = 0x00000046 );  // abbreviated name for March
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SAbbrevMonthName4      = 0x00000047 );  // abbreviated name for April
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SAbbrevMonthName5      = 0x00000048 );  // abbreviated name for May
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SAbbrevMonthName6      = 0x00000049 );  // abbreviated name for June
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SAbbrevMonthName7      = 0x0000004A );  // abbreviated name for July
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SAbbrevMonthName8      = 0x0000004B );  // abbreviated name for August
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SAbbrevMonthName9      = 0x0000004C );  // abbreviated name for September
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SAbbrevMonthName10     = 0x0000004D );  // abbreviated name for October
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SAbbrevMonthName11     = 0x0000004E );  // abbreviated name for November
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SAbbrevMonthName12     = 0x0000004F );  // abbreviated name for December
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SAbbrevMonthName13     = 0x0000100F );  // abbreviated name for 13th month (if exists)

		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SPositiveSign          = 0x00000050 );  // positive sign, eg ""
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SNegativeSign          = 0x00000051 );  // negative sign, eg "-"
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_IPosSignPosn           = 0x00000052 );  // positive sign position (derived from INEGCURR)
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_INegSignPosn           = 0x00000053 );  // negative sign position (derived from INEGCURR)
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_IPosSyMPrecedes        = 0x00000054 );  // mon sym precedes pos amt (derived from ICURRENCY)
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_IPosSepBySpace         = 0x00000055 );  // mon sym sep by space from pos amt (derived from ICURRENCY)
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_INegSymPrecedes        = 0x00000056 );  // mon sym precedes neg amt (derived from INEGCURR)
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_INegSepBySpace         = 0x00000057 );  // mon sym sep by space from neg amt (derived from INEGCURR)

		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SLIST                  = 0x0000000C );  // list item separator, eg "," for "1,2,3,4"
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_IMEASURE               = 0x0000000D );  // 0 = metric, 1 = US measurement system

		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SDecimal               = 0x0000000E );  // decimal separator, eg "." for 1,234.00
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SThousand              = 0x0000000F );  // thousand separator, eg "," for 1,234.00
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SGrouping              = 0x00000010 );  // digit grouping, eg "3;0" for 1,000,000
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_IDIGITS                = 0x00000011 );  // number of fractional digits eg 2 for 1.00
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_ILZERO                 = 0x00000012 );  // leading zeros for decimal, 0 for .97, 1 for 0.97
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_INEGNUMBER             = 0x00001010 );  // negative number mode, 0-4, see documentation
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SNATIVEDIGITS          = 0x00000013 );  // native digits for 0-9, eg "0123456789"

		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SCurrency              = 0x00000014 );  // local monetary symbol, eg "$"
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SIntlSymbol            = 0x00000015 );  // intl monetary symbol, eg "USD"
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SMonDecimalSep         = 0x00000016 );  // monetary decimal separator, eg "." for $1,234.00
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SMonThousandSep        = 0x00000017 );  // monetary thousand separator, eg "," for $1,234.00
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SMonGrouping           = 0x00000018 );  // monetary grouping, eg "3;0" for $1,000,000.00
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_ICurrDigits            = 0x00000019 );  // # local monetary digits, eg 2 for $1.00
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_IIntlCurrDigits        = 0x0000001A );  // # intl monetary digits, eg 2 for $1.00
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_ICURRENCY              = 0x0000001B );  // positive currency mode, 0-3, see documenation
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_INEGCURR               = 0x0000001C );  // negative currency mode, 0-15, see documentation

		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SDATE                  = 0x0000001D );  // date separator (derived from Locale_SShortDate, use that instead)
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_STIME                  = 0x0000001E );  // time separator (derived from Locale_STimeFormat, use that instead)
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SShortDate             = 0x0000001F );  // short date format string, eg "MM/dd/yyyy"
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SLongDate              = 0x00000020 );  // long date format string, eg "dddd, MMMM dd, yyyy"
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_STimeFormat            = 0x00001003 );  // time format string, eg "HH:mm:ss"
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_IDATE                  = 0x00000021 );  // short date format ordering (derived from Locale_SShortDate, use that instead)
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_ILDATE                 = 0x00000022 );  // long date format ordering (derived from Locale_SLongDate, use that instead)
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_ITIME                  = 0x00000023 );  // time format specifier (derived from Locale_STimeFormat, use that instead)
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_ITIMEMARKPOSN          = 0x00001005 );  // time marker position (derived from Locale_STimeFormat, use that instead)
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_ICENTURY               = 0x00000024 );  // century format specifier (short date, Locale_SShortDate is preferred)
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_ITLZERO                = 0x00000025 );  // leading zeros in time field (derived from Locale_STimeFormat, use that instead)
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_IDAYLZERO              = 0x00000026 );  // leading zeros in day field (short date, Locale_SShortDate is preferred)
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_IMONLZERO              = 0x00000027 );  // leading zeros in month field (short date, Locale_SShortDate is preferred)
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_S1159                  = 0x00000028 );  // AM designator, eg "AM"
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_S2359                  = 0x00000029 );  // PM designator, eg "PM"

		__QCMP_STATIC_CONSTANT( unsigned long, Locale_ICalendarType          = 0x00001009 );  // type of calendar specifier, eg CAL_GREGORIAN
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_IOPTIONALCALENDAR      = 0x0000100B );  // additional calendar types specifier, eg CAL_GREGORIAN_US
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_IFIRSTDAYOFWEEK        = 0x0000100C );  // first day of week specifier, 0-6, 0=Monday, 6=Sunday
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_IFIRSTWEEKOFYEAR       = 0x0000100D );  // first week of year specifier, 0-2, see documentation

		__QCMP_STATIC_CONSTANT( unsigned long, Locale_IDEFAULTLANGUAGE       = 0x00000009 );  // default language id, deprecated
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_IDEFAULTCOUNTRY        = 0x0000000A );  // default country code, deprecated
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_IDefaultCodePage       = 0x0000000B );  // default oem code page (use of Unicode is recommended instead)
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_IDefaultANSICodePage   = 0x00001004 );  // default ansi code page (use of Unicode is recommended instead)
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_IDEFAULTMACCODEPAGE    = 0x00001011 );   // default mac code page (use of Unicode is recommended instead)

		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SEngLanguage           = 0x00001001 );  // English name of language, eg "German"
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SNATIVELANGNAME        = 0x00000004 );  // native name of language, eg "Deutsch"
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SCOUNTRY               = 0x00000006 );  // localized name of country, eg "Germany" in UI language
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SEngCountry            = 0x00001002 );  // English name of country, eg "Germany"
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SNATIVECTRYNAME        = 0x00000008 );  // native name of country, eg "Deutschland"

		__QCMP_STATIC_CONSTANT( unsigned long, Locale_ILanguage              = 0x00000001 );// language id, Locale_SNAME preferred
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SAbbrevLangName        = 0x00000003 );  // arbitrary abbreviated language name, Locale_SISO639LANGNAME preferred

		__QCMP_STATIC_CONSTANT( unsigned long, Locale_ICOUNTRY               = 0x00000005 );  // country code, eg 1, Locale_SISO3166CTRYNAME may be more useful.
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SAbbrevCtryName        = 0x00000007 );  // arbitrary abbreviated country name, Locale_SISO3166CTRYNAME preferred
		__QCMP_STATIC_CONSTANT( unsigned long, Locale_IGEOID                 = 0x0000005B );  // geographical location id, eg "244"

		//  Locale Enumeration Flags.
		__QCMP_STATIC_CONSTANT( unsigned long, LcId_Installed            = 0x00000001 ); // installed locale ids
		__QCMP_STATIC_CONSTANT( unsigned long, LcId_Supported            = 0x00000002 ); // supported locale ids
		__QCMP_STATIC_CONSTANT( unsigned long, LcId_Alternate_Sorts      = 0x00000004 ); // alternate sort locale ids

		__QCMP_STATIC_CONSTANT( int, _COFFSET = 127 );			// offset to where ctype will point, look in initctype on how it is being used

		__QCMP_STATIC_CONSTANT( int, __LCID_DEFAULT = 0x1 );     //  default language locale for country
		__QCMP_STATIC_CONSTANT( int, __LCID_PRIMARY = 0x2 );     //  primary language locale for country
		__QCMP_STATIC_CONSTANT( int, __LCID_FULL = 0x4 );		//  fully matched language locale for country
		__QCMP_STATIC_CONSTANT( int, __LCID_LANGUAGE = 0x100 );  //  language default seen
		__QCMP_STATIC_CONSTANT( int, __LCID_EXISTS = 0x200 );	//  language is installed

		__QCMP_STATIC_CONSTANT( int, CATNAMES_LEN = 57 );		// "LC_COLLATE=;LC_CTYPE=;..." length

		static const CLOCALETAB s_aCountry[];
		static const unsigned int s_NumCountries;
		static const CLOCALETAB s_aLanguage[];
		static const unsigned int s_NumLangs;

		static const unsigned short* _ctype_loc_style;			// = _wctype+2;

		__QCMP_STATIC_CONSTANT( unsigned long, Locale_SSCRIPTS = 0x0000006c );  // Typical scripts in the locale: ; delimited script codes, eg "Latn;"

		enum SYSNLS_FUNCTION
		{
			COMPARE_STRING    =  0x0001,
		};

		__QCMP_STATIC_CONSTANT( unsigned long, CP_Installed               = 0x00000001  );// installed code page ids
		__QCMP_STATIC_CONSTANT( unsigned long, CP_Supported               = 0x00000002  );// supported code page ids

		static const char* CLocale::CLocaleStr();
		static const unsigned short* CTypeLocStyle();
		static CLocaleConv& ConvC();
		static CLocaleDateTime& TimeC();

		typedef int ( __QCMP_STDCALLCONVENTION * CodePage_EnumProc )( TCHAR* );
		typedef int ( __QCMP_STDCALLCONVENTION * Locale_EnumProcEx )( wchar_t*, unsigned long, Cmp_long_ptr );
		typedef int ( __QCMP_STDCALLCONVENTION * Locale_EnumProc )( TCHAR* );
		typedef int ( __QCMP_STDCALLCONVENTION * LanguageGroup_EnumProc )( unsigned long, TCHAR*, TCHAR*, unsigned long, Cmp_long_ptr );
		typedef int ( __QCMP_STDCALLCONVENTION * Geo_EnumProc )( long );

		//--------------------------------------------------------------------------------
		CLocale( unsigned short usPrimaryLanguage = Lang_Neutral, unsigned short usSubLanguage = Sublang_Neutral, unsigned short wSortID = 0 ) : m_ID( MakeLcId( MakeLangID( usPrimaryLanguage, usSubLanguage ) , wSortID ) )
		{
		}

		//--------------------------------------------------------------------------------
		~CLocale()
		{
		}

		//--------------------------------------------------------------------------------
		unsigned short SubLangID( unsigned short langId )
		{
			return ( langId >> 10 );
		}

		//--------------------------------------------------------------------------------
		unsigned short SubLangID()
		{
			return SubLangID( LangID() );
		}

		//--------------------------------------------------------------------------------
		static unsigned short PrimaryLangID( unsigned short langId )
		{
			return ( langId & 0x3ff );
		}

		//--------------------------------------------------------------------------------
		unsigned short PrimaryLangID()
		{
			return PrimaryLangID( LangID() );
		}

		//--------------------------------------------------------------------------------
		unsigned short LangID()
		{
			return LangIdFromLcId( m_ID );
		}

		//--------------------------------------------------------------------------------
		unsigned short SortOrderID()
		{
			return SortIdFromLcId( m_ID );
		}

		//--------------------------------------------------------------------------------
		unsigned long ID()
		{
			return m_ID;
		}

		//--------------------------------------------------------------------------------
		//Returns ansi codepage for a given Locale
		static CCodePage ANSI_CodePage( unsigned long id );

		//--------------------------------------------------------------------------------
		static CLocale* FromName( wchar_t* /*lpName*/, unsigned long /*dwFlags*/ )
		{
			//TODO:
			CLocale* pLocale = 0;
			//__QCMPInline unsigned long LocaleNameToLCID( wchar_t* lpName, unsigned long dwFlags )
			return pLocale;
		}

		//--------------------------------------------------------------------------------
		static bool IsValidName( const wchar_t* lpLocaleName )
		{
			CLocaleHelper Win32LocaleHelper;
			bool bResult = Win32LocaleHelper.IsValidLocaleName( lpLocaleName ) ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		int GetInfo( unsigned long LCType, CTStringRef strLCData, int cchData )
		{
			int iResult = m_Win32LocaleHelper.GetLocaleInfoT( m_ID, LCType, strLCData );
			return iResult;
		}

		//__QCMPInline int GetLocaleInfoEx ( const wchar_t* lpLocaleName, unsigned long LCType, wchar_t* lpLCData, int cchData )

		//--------------------------------------------------------------------------------
		bool SetInfo( unsigned long LCType, const TCHAR* lpLCData )
		{
			bool bResult = m_Win32LocaleHelper.SetLocaleInfoT( m_ID, LCType, lpLCData ) ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		int MapString( unsigned long dwMapFlags, const TCHAR* lpSrcStr, int cchSrc, CTStringRef strDest, int cchDest )
		{
			int iResult = m_Win32LocaleHelper.LCMapStringT( m_ID, dwMapFlags, lpSrcStr, cchSrc, strDest );
			return iResult;
		}

		//__QCMPInline int LCMapStringEx( const wchar_t* lpLocaleName, unsigned long dwMapFlags, const wchar_t* lpSrcStr, int cchSrc, wchar_t* lpDestStr, int cchDest, LPNLSVERSIONINFO lpVersionInformation, void* lpReserved, Cmp_long_ptr lParam )

		//--------------------------------------------------------------------------------
		int Name( CWStringRef strName, unsigned long dwFlags )
		{
			int iResult = m_Win32LocaleHelper.LCIDToLocaleName( m_ID, strName, dwFlags );
			return iResult;
		}

		//--------------------------------------------------------------------------------
		bool IsValid( unsigned long dwFlags )
		{
			bool bResult = m_Win32LocaleHelper.IsValidLocale( m_ID, dwFlags ) ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		int GetNumberFormat( unsigned long dwFlags, const TCHAR* lpValue, const NUMBERFMT& Format, CTStringRef NumberStr )
		{
			int iResult = m_Win32LocaleHelper.GetNumberFormatT( m_ID, dwFlags, lpValue, Format, NumberStr );
			return iResult;
		}

		//--------------------------------------------------------------------------------
		int GetCurrencyFormat( unsigned long dwFlags, const TCHAR* lpValue, const CURRENCYFMT& Format, CTStringRef CurrencyStr )
		{
			int iResult = m_Win32LocaleHelper.GetCurrencyFormatT( m_ID, dwFlags, lpValue, Format, CurrencyStr );
			return iResult;
		}

		//__QCMPInline int GetCurrencyFormatEx ( const wchar_t* lpLocaleName, unsigned long dwFlags, const wchar_t* lpValue, const CURRENCYFMT* lpFormat, wchar_t* lpCurrencyStr, int cchCurrency )

		//--------------------------------------------------------------------------------
		bool GetNLSVersion( NLSVersionInfo& VersionInformation, unsigned long Function = COMPARE_STRING )
		{
			bool bResult = m_Win32LocaleHelper.GetNLSVersion( Function, m_ID, VersionInformation ) ? true : false;
			return bResult;
		}

		//__QCMPInline BOOL GetNLSVersionEx( NLS_FUNCTION function, const wchar_t* lpLocaleName, LPNLSVERSIONINFOEX lpVersionInformation )

		//--------------------------------------------------------------------------------
		int FindNLSString( unsigned long dwFindNLSStringFlags, const wchar_t* lpStringSource, int cchSource, const wchar_t* lpStringValue, int cchValue, int* pcchFound )
		{
			int iResult = m_Win32LocaleHelper.FindNLSString( m_ID, dwFindNLSStringFlags, lpStringSource, cchSource, lpStringValue, cchValue, pcchFound );
			return iResult;
		}

		//__QCMPInline int FindNLSStringEx ( const wchar_t* lpLocaleName, unsigned long dwFindNLSStringFlags, const wchar_t* lpStringSource, int cchSource, const wchar_t* lpStringValue, int cchValue, int* pcchFound, LPNLSVERSIONINFO lpVersionInformation, void* lpReserved, Cmp_long_ptr lParam )
		/*
		//--------------------------------------------------------------------------------
		bool IsUpper( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharType( *this, tCh );
			bool bResult = ( wType & C1_Upper ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsUpperA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharTypeA( *this, Ch );
			bool bResult = ( wType & C1_Upper ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsUpperW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharTypeW( wCh );
			bool bResult= ( wType & C1_Upper ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsLower( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharType( *this, tCh );
			bool bResult = ( wType & C1_Lower ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsLowerA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharTypeA( *this, Ch );
			bool bResult = ( wType & C1_Lower ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsLowerW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharTypeW( wCh );
			bool bResult = ( wType & C1_Lower ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsDigit( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharType( *this, tCh );
			bool bResult = ( wType & C1_Digit ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsDigitA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharTypeA( *this, Ch );
			bool bResult = ( wType & C1_Digit ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsDigitW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharTypeW( wCh );
			bool bResult = ( wType & C1_Digit ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsSpace( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharType( *this, tCh );
			bool bResult = ( wType & C1_Space ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsSpaceA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharTypeA( *this, Ch );
			bool bResult = ( wType & C1_Space ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsSpaceW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharTypeW( wCh );
			bool bResult = ( wType & C1_Space ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsPunctuation( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharType( *this, tCh );
			bool bResult = ( wType & C1_Punct ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsPunctuationA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharTypeA( *this, Ch );
			bool bResult = ( wType & C1_Punct ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsPunctuationW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharTypeW( wCh );
			bool bResult = ( wType & C1_Punct ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsControl( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharType( *this, tCh );
			bool bResult = ( wType & C1_Cntrl ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsControlA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharTypeA( *this, Ch );
			bool bResult = ( wType & C1_Cntrl ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsControlW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharTypeW( wCh );
			bool bResult = ( wType & C1_Cntrl ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsBlank( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharType( *this, tCh );
			bool bResult = ( wType & C1_Blank ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsBlankA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharTypeA( *this, Ch );
			bool bResult = ( wType & C1_Blank ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsBlankW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharTypeW( wCh );
			bool bResult = ( wType & C1_Blank ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsXDigit( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharType( *this, tCh );
			bool bResult = ( wType & C1_XDigit ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsXDigitA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharTypeA( *this, Ch );
			bool bResult = ( wType & C1_XDigit ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsXDigitW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharTypeW( wCh );
			bool bResult = ( wType & C1_XDigit ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsAlpha( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharType( *this, tCh );
			bool bResult = ( wType & C1_Alpha ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsAlphaA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharTypeA( *this, Ch );
			bool bResult = ( wType & C1_Alpha ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsAlphaW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharTypeW( wCh );
			bool bResult = ( wType & C1_Alpha ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsDefined( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharType( *this, tCh );
			bool bResult = ( wType & C1_Defined ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsDefinedA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharTypeA( *this, Ch );
			bool bResult = ( wType & C1_Defined ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsDefinedW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel1CharTypeW( wCh );
			bool bResult = ( wType & C1_Defined ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsLeftToRight( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharType( *this, tCh );
			bool bResult = ( wType & C2_LeftToRight ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsLeftToRightA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharTypeA( *this, Ch );
			bool bResult = ( wType & C2_LeftToRight ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsLeftToRightW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharTypeW( wCh );
			bool bResult = ( wType & C2_LeftToRight ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsRightToLeft( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharType( *this, tCh );
			bool bResult = ( wType & C2_RightToLeft ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsRightToLeftA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharTypeA( *this, Ch );
			bool bResult = ( wType & C2_RightToLeft ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsRightToLeftW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharTypeW( wCh );
			bool bResult = ( wType & C2_RightToLeft ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsEuropeanDigit( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharType( *this, tCh );
			bool bResult = ( wType & C2_EuropeNumber ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsEuropeanDigitA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharTypeA( *this, Ch );
			bool bResult = ( wType & C2_EuropeNumber ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsEuropeanDigitW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharTypeW( wCh );
			bool bResult = ( wType & C2_EuropeNumber ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsEuropeanSeparator( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharType( *this, tCh );
			bool bResult = ( wType & C2_EuropeSeparator ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsEuropeanSeparatorA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharTypeA( *this, Ch );
			bool bResult = ( wType & C2_EuropeSeparator ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsEuropeanSeparatorW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharTypeW( wCh );
			bool bResult = ( wType & C2_EuropeSeparator ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsEuropeanTerminator( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharType( *this, tCh );
			bool bResult = ( wType & C2_EuropeTerminator ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsEuropeanTerminatorA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharTypeA( *this, Ch );
			bool bResult = ( wType & C2_EuropeTerminator ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsEuropeanTerminatorW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharTypeW( wCh );
			bool bResult = ( wType & C2_EuropeTerminator ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsArabicNumber( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharType( *this, tCh );
			bool bResult = ( wType & C2_ArabicNumber ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsArabicNumberA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharTypeA( *this, Ch );
			bool bResult = ( wType & C2_ArabicNumber ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsArabicNumberW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharTypeW( wCh );
			bool bResult = ( wType & C2_ArabicNumber ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsCommonSeparator( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharType( *this, tCh );
			bool bResult = ( wType & C2_CommonSeparator ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsCommonSeparatorA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharTypeA( *this, Ch );
			bool bResult = ( wType & C2_CommonSeparator ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsCommonSeparatorW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharTypeW( wCh );
			bool bResult = ( wType & C2_CommonSeparator ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsBlockSeparator( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharType( *this, tCh );
			bool bResult = ( wType & C2_BlockSeparator ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsBlockSeparatorA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharTypeA( *this, Ch );
			bool bResult = ( wType & C2_BlockSeparator ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsBlockSeparatorW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharTypeW( wCh );
			bool bResult = ( wType & C2_BlockSeparator ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsSegmentSeparator( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharType( *this, tCh );
			bool bResult = ( wType & C2_SegmentSeparator ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsSegmentSeparatorA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharTypeA( *this, Ch );
			bool bResult = ( wType & C2_SegmentSeparator ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsSegmentSeparatorW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharTypeW( wCh );
			bool bResult = ( wType & C2_SegmentSeparator ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsWhiteSpace( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharType( *this, tCh );
			bool bResult = ( wType & C2_WhiteSpace ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsWhiteSpaceA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharTypeA( *this, Ch );
			bool bResult = ( wType & C2_WhiteSpace ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsWhiteSpaceW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharTypeW( wCh );
			bool bResult = ( wType & C2_WhiteSpace ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsOtherNeutral( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharType( *this, tCh );
			bool bResult = ( wType & C2_OtherNeutral ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsOtherNeutralA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharTypeA( *this, Ch );
			bool bResult = ( wType & C2_OtherNeutral ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsOtherNeutralW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel2CharTypeW( wCh );
			bool bResult = ( wType & C2_OtherNeutral ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsNonSpacing( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharType( *this, tCh );
			bool bResult = ( wType & C3_NonSpacing ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsNonSpacingA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharTypeA( *this, Ch );
			bool bResult = ( wType & C3_NonSpacing ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsNonSpacingW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharTypeW( wCh );
			bool bResult = ( wType & C3_NonSpacing ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsDiacritic( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharType( *this, tCh );
			bool bResult = ( wType & C3_Diacritic ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsDiacriticA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharTypeA( *this, Ch );
			bool bResult = ( wType & C3_Diacritic ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsDiacriticW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharTypeW( wCh );
			bool bResult = ( wType & C3_Diacritic ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsVowelMark( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharType( *this, tCh );
			bool bResult = ( wType & C3_VowelMark ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsVowelMarkA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharTypeA( *this, Ch );
			bool bResult = ( wType & C3_VowelMark ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsVowelMarkW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharTypeW( wCh );
			bool bResult = ( wType & C3_VowelMark ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsSymbol( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharType( *this, tCh );
			bool bResult = ( wType & C3_Symbol ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsSymbolA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharTypeA( *this, Ch );
			bool bResult = ( wType & C3_Symbol ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsSymbolW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharTypeW( wCh );
			bool bResult = ( wType & C3_Symbol ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsKatakana( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharType( *this, tCh );
			bool bResult = ( wType & C3_Katakana ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsKatakanaA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharTypeA( *this, Ch );
			bool bResult = ( wType & C3_Katakana ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsKatakanaW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharTypeW( wCh );
			bool bResult = ( wType & C3_Katakana ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsHirigana( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharType( *this, tCh );
			bool bResult = ( wType & C3_Hiragana ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsHiriganaA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharTypeA( *this, Ch );
			bool bResult = ( wType & C3_Hiragana ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsHiriganaW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharTypeW( wCh );
			bool bResult = ( wType & C3_Hiragana ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsHalfWidth( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharType( *this, tCh );
			bool bResult = ( wType & C3_HalfWidth ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsHalfWidthA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharTypeA( *this, Ch );
			bool bResult = ( wType & C3_HalfWidth ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsHalfWidthW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharTypeW( wCh );
			bool bResult = ( wType & C3_HalfWidth ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsFullWidth( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharType( *this, tCh );
			bool bResult = ( wType & C3_FullWidth ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsFullWidthA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharTypeA( *this, Ch );
			bool bResult = ( wType & C3_FullWidth ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsFullWidthW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharTypeW( wCh );
			bool bResult = ( wType & C3_FullWidth ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsIdeograph( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharType( *this, tCh );
			bool bResult = ( wType & C3_Ideograph ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsIdeographA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharTypeA( *this, Ch );
			bool bResult = ( wType & C3_Ideograph ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsIdeographW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharTypeW( wCh );
			bool bResult = ( wType & C3_Ideograph ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsKashida( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharType( *this, tCh );
			bool bResult = ( wType & C3_Kashida ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsKashidaA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharTypeA( *this, Ch );
			bool bResult = ( wType & C3_Kashida ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsKashidaW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharTypeW( wCh );
			bool bResult = ( wType & C3_Kashida ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsLexical( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharType( *this, tCh );
			bool bResult = ( wType & C3_Lexical ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsLexicalA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharTypeA( *this, Ch );
			bool bResult = ( wType & C3_Lexical ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsLexicalW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharTypeW( wCh );
			bool bResult = ( wType & C3_Lexical ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsAlpha3( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharType( *this, tCh );
			bool bResult = ( wType & C3_Alpha ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsAlpha3A( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharTypeA( *this, Ch );
			bool bResult = ( wType & C3_Alpha ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsAlpha3W( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharTypeW( wCh );
			bool bResult = ( wType & C3_Alpha ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsHighSurrogate( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharType( *this, tCh );
			bool bResult = ( wType & C3_HighSurrogate ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsHighSurrogateA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharTypeA( *this, Ch );
			bool bResult = ( wType & C3_HighSurrogate ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsHighSurrogateW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharTypeW( wCh );
			bool bResult = ( wType & C3_HighSurrogate ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsLowSurrogate( TCHAR tCh )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharType( *this, tCh );
			bool bResult = ( wType & C3_LowSurrogate ) > 0 ? true : false;
			return bResult;
		}
		
		//--------------------------------------------------------------------------------
		bool IsLowSurrogateA( char Ch )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharTypeA( *this, Ch );
			bool bResult = ( wType & C3_LowSurrogate ) > 0 ? true : false;
			return bResult;
		}

		//--------------------------------------------------------------------------------
		bool IsLowSurrogateW( wchar_t wCh )
		{
			unsigned short wType = m_StringHelper.GetLevel3CharTypeW( wCh );
			bool bResult = ( wType & C3_LowSurrogate ) > 0 ? true : false;
			return bResult;
		}
		*/
		//--------------------------------------------------------------------------------
		int CompareStringEx( unsigned long dwCmpFlags, const wchar_t* lpString1, int cchCount1, const wchar_t* lpString2, int cchCount2, NLSVersionInfo* lpVersionInformation, void* lpReserved, Cmp_long_ptr lParam )
		{
			CWString strLocaleName;
			strLocaleName.Reserve( 128 );
			int iResult = m_Win32LocaleHelper.LCIDToLocaleName( m_ID, strLocaleName(), 0 );

			iResult = m_StringHelper.CompareStringEx( strLocaleName, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2, lpVersionInformation, lpReserved, lParam );

			return iResult;
		}

		//--------------------------------------------------------------------------------
		int CompareString( unsigned long dwCmpFlags, const TCHAR* lpString1, int cchCount1, const TCHAR* lpString2, int cchCount2 )
		{
			int iResult = m_StringHelper.CompareStringT( m_ID, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2 );
			return iResult;
		}

		//--------------------------------------------------------------------------------
		bool EnumSystemCodePages( CODEPAGE_ENUMCALLBACK pEnumProc, unsigned long dwFlags )
		{
			SetCPEnumCallback ( pEnumProc );
			bool bResult = m_Win32LocaleHelper.EnumSystemCodePagesT( (CodePage_EnumProc)&CodePageEnumProc, dwFlags ) ? true : false;
			ClearCPEnumProc();
			return bResult;
		}		

		//--------------------------------------------------------------------------------
		bool VerifyScripts( unsigned long dwFlags, const wchar_t* lpTestScripts, int cchTestScripts )
		{
			bool bResult = false;
#if		( WINVER >= 0x0600 )
			wchar_t pLocaleScripts[ 2048 ];
			int iResult = 0;//GetInfoW( Locale_SSCRIPTS, pLocaleScripts, 2048 );//Seems to require something else, maybe 64bit Compiler, maybe 7.1 SDK 
			if( iResult != 0 )
			{
				bResult = m_Win32LocaleHelper.VerifyScripts( dwFlags, pLocaleScripts, iResult, lpTestScripts, cchTestScripts ) ? true : false;
			}
#else
			__QCMP_UNREF( cchTestScripts );
			__QCMP_UNREF( lpTestScripts );
			__QCMP_UNREF( dwFlags );
			bResult = true;
#endif//( WINVER >= 0x0600 )
			return bResult;
		}

		//------------------------------------------------------------------------------
		static nsWin32::CThread* _getptd();

		static int __crtLCMapStringAA( CLocaleThreadData* plocinfo, unsigned long Locale, unsigned long dwMapFlags, const char* lpSrcStr, int cchSrc, CAStringRef lpDestStr, CCodePage& code_page, bool bError );
		static int __crtLCMapStringAW( CLocaleThreadData* plocinfo, unsigned long Locale, unsigned long dwMapFlags, const char* lpSrcStr, int cchSrc, CAStringRef lpDestStr, CCodePage& code_page, bool bError );
		static int __crtLCMapStringA( CLocaleThreadData* plocinfo, unsigned long Locale, unsigned long dwMapFlags, const char* lpSrcStr, int cchSrc, CAStringRef lpDestStr, CCodePage& code_page, bool bError );

		static bool GetStringTypeT( CLocaleThreadData* plocinfo, unsigned long dwInfoType, const char* lpSrcStr, int cchSrc, unsigned short* lpCharType, CCodePage& code_page, int lcid, bool bError );
		static int __crtGetLocaleInfoW( CLocaleThreadData* plocinfo, unsigned long Locale, unsigned long LCType, CWStringRef lpLCData, CCodePage& code_page );
		static int GetLocaleInfoT( CLocaleThreadData* plocinfo, unsigned long Locale, unsigned long LCType, CAString lpLCData, CCodePage& code_page );
		static int GetLocaleString( CLocaleThreadData* plocinfo, unsigned long localehandle, unsigned long fieldtype, void* address );
		static int GetLocaleInt ( CLocaleThreadData* plocinfo, unsigned long localehandle, unsigned long fieldtype, void* address );
		static size_t strncnt( const char* _String, size_t _Cnt );
		static CThreadLocaleInfo*& PtrThreadLocaleInfo();
		static int GlobalLocaleStatus();
		static void GlobalLocaleStatus(int iStatus);
		static CMBCInfo* GlobalMBCInfoPtr();
		static void GlobalMBCInfoPtr( CMBCInfo* pMBCInfo );
		static int mb_cur_max(void);
		static unsigned long* LocaleHandles();

		bool TranslateName ( const CLocale::CLOCALETAB* lpTable, int iHigh, const char** ppchName );

	protected:

		void SetCPEnumCallback( CODEPAGE_ENUMCALLBACK pCallback );
		void ClearCPEnumProc();
		static int __QCMP_STDCALLCONVENTION CodePageEnumProc( TCHAR* /*strCodePage*/ );

		CLocaleHelper m_Win32LocaleHelper;
		unsigned long m_ID;
		CStringHelper m_StringHelper;

	protected:

		static CODEPAGE_ENUMCALLBACK spEnumProc;
		CCriticalSection m_CSCodePageProc;

		static CLocaleConv s_ConvC;// locale conversion settings for "C" locale
		static CLocaleDateTime s_TimeC;
		static CThreadLocaleInfo* s_pThreadLocaleInfo;
		static int s_GlobalLocaleStatus;// = -1 ;	
		static CMBCInfo* s_pGlobalMBCInfo;	
		static unsigned long s_aLocaleHandle[];

	};

}//nsWin32

#endif//WINQL_CS_LOCALE_H_3
