//WinQLAllocator.h

// Copyright Querysoft Limited 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//An Allocator class for Win32

#ifndef WINQL_MEM_ALLOCATOR_H_2
#define WINQL_MEM_ALLOCATOR_H_2

#ifdef	__QCMP_OPTIMIZEINCLUDE
#pragma	__QCMP_OPTIMIZEINCLUDE
#endif//__QCMP_OPTIMIZEINCLUDE

//--------------------------------------------------------------------------------
namespace nsWin32
{
	__QCMP_STATIC_CONSTANT( unsigned long, HeapNoSerialize				= 0x00000001 );
	__QCMP_STATIC_CONSTANT( unsigned long, HeapGrowable					= 0x00000002 );
	__QCMP_STATIC_CONSTANT( unsigned long, HeapGenerateExceptions		= 0x00000004 );
	__QCMP_STATIC_CONSTANT( unsigned long, HeapZeroMemory				= 0x00000008 );
	__QCMP_STATIC_CONSTANT( unsigned long, HeapReallocInPlaceOnly		= 0x00000010 );
	__QCMP_STATIC_CONSTANT( unsigned long, HeapTailCheckingEnabled		= 0x00000020 );
	__QCMP_STATIC_CONSTANT( unsigned long, HeapFreeCheckingEnabled		= 0x00000040 );
	__QCMP_STATIC_CONSTANT( unsigned long, HeapDisableCoalesceOnFree	= 0x00000080 );
	__QCMP_STATIC_CONSTANT( unsigned long, HeapCreateAlign16			= 0x00010000 );
	__QCMP_STATIC_CONSTANT( unsigned long, HeapCreateEnableTracing		= 0x00020000 );
	__QCMP_STATIC_CONSTANT( unsigned long, HeapCreateEnableExecute		= 0x00040000 );
	__QCMP_STATIC_CONSTANT( unsigned long, HeapMaximumTag				= 0x0FFF );
	__QCMP_STATIC_CONSTANT( unsigned long, HeapPseudoTagFlag			= 0x8000 );
	__QCMP_STATIC_CONSTANT( unsigned long, HeapTagShift					= 18 );

	//------------------------------------------------------------------------------
	class __QOR_INTERFACE( __WINQL ) CWin32Allocator
	{
	public:

		__QOR_DECLARE_OCLASS_ID( CWin32Allocator );

		CWin32Allocator();
		virtual ~CWin32Allocator();
		virtual void* Allocate( unsigned long ulCount, unsigned long ulFlags = 0 );
		virtual void Free( void* p );

	protected:

		void* m_hProcessHeap;
			
	};

	//--------------------------------------------------------------------------------
	template< typename TInstancer, typename T >
	class CDefaultAllocator
	{
	public:

		//--------------------------------------------------------------------------------		
		static T* Allocate( unsigned int uiCount = 1 )
		{
			T* pResult = 0;
			if( uiCount == 1 )
			{
				pResult = TInstancer::Instance();
			}
			else
			{
				unsigned char* pMemory = TInstancer::CTSource::Source( sizeof( unsigned int ) + ( sizeof( T ) * uiCount ) );
				*( reinterpret_cast< unsigned int* >( pMemory ) ) = uiCount;
				pResult = reinterpret_cast< T* >( pMemory + sizeof( unsigned int ) );
				T* pInit = pResult;

				for( unsigned int uiLoop = 0; uiLoop < uiCount; uiLoop++ )
				{
					new (pInit)T;
					pInit++;
				}
			}
			return pResult;
		}

		//--------------------------------------------------------------------------------
		static T* Reallocate( T* pT, unsigned long ulOldCount, unsigned long ulNewCount, bool bPreserve )
		{
			if( !bPreserve )
			{
				Free( pT, ulOldCount );
				return Allocate( ulNewCount );
			}

			T* pNewT = Allocate( ulNewCount );
			unsigned long ulCount = 0;
			while( ulCount < ulOldCount )
			{
				pNewT[ulCount] = pT[ulCount];
				ulCount++;
			}
			Free( pT, ulOldCount );
			return pNewT;
		}


		//--------------------------------------------------------------------------------
		static void Free( T* pT, unsigned int uiCount = 1 )
		{
			if( uiCount == 1 )
			{
				TInstancer::Release( pT );
			}
			else
			{
				unsigned char* pMemory = reinterpret_cast< unsigned char* >( pT );
				unsigned int uiCount = *( reinterpret_cast< unsigned int* >( pMemory - sizeof( unsigned int ) ) );
			
				for( unsigned int uiLoop = 0; uiLoop < uiCount; uiLoop++ )
				{
					pT->T::~T();					
					pT++;
				}
				TInstancer::CTSource::Free( pMemory - sizeof( unsigned int ), sizeof(unsigned int) + ( sizeof( T ) * uiCount ) );
			}
		}

	private:

		//--------------------------------------------------------------------------------
		CDefaultAllocator()
		{
		}

		//--------------------------------------------------------------------------------
		~CDefaultAllocator()
		{
		}
	};

}//nsWin32

#endif//WINQL_MEM_ALLOCATOR_H_2
