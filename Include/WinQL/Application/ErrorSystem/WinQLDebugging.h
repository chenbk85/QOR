//Debugging.h

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Win32 Code Services Debugging

#ifndef WINQL_DEBUGGING_H_2
#define WINQL_DEBUGGING_H_2

#ifdef  __QCMP_OPTIMIZEINCLUDE
#pragma __QCMP_OPTIMIZEINCLUDE
#endif//__QCMP_OPTIMIZEINCLUDE

#include "WinQL/Definitions/Data.h"
#include "WinQL/Application/Threading/WinQLThread.h"
#include "SEH.h"
#include "WinQL/Definitions/Constants.h"

//--------------------------------------------------------------------------------
namespace nsWin32
{
	//--------------------------------------------------------------------------------
	typedef struct _EXCEPTION_DEBUG_INFO 
	{
		EXCEPTION_RECORD ExceptionRecord;
		unsigned long dwFirstChance;
	} EXCEPTION_DEBUG_INFO, *LPEXCEPTION_DEBUG_INFO;

	//--------------------------------------------------------------------------------
	typedef struct _CREATE_THREAD_DEBUG_INFO 
	{
		void* hThread;
		void* lpThreadLocalBase;
		LPTHREAD_START_ROUTINE lpStartAddress;
	} CREATE_THREAD_DEBUG_INFO, *LPCREATE_THREAD_DEBUG_INFO;

	//--------------------------------------------------------------------------------
	typedef struct _CREATE_PROCESS_DEBUG_INFO 
	{
		void* hFile;
		void* hProcess;
		void* hThread;
		void* lpBaseOfImage;
		unsigned long dwDebugInfoFileOffset;
		unsigned long nDebugInfoSize;
		void* lpThreadLocalBase;
		LPTHREAD_START_ROUTINE lpStartAddress;
		void* lpImageName;
		unsigned short fUnicode;
	} CREATE_PROCESS_DEBUG_INFO, *LPCREATE_PROCESS_DEBUG_INFO;

	//--------------------------------------------------------------------------------
	typedef struct _EXIT_THREAD_DEBUG_INFO 
	{
		unsigned long dwExitCode;
	} EXIT_THREAD_DEBUG_INFO, *LPEXIT_THREAD_DEBUG_INFO;

	//--------------------------------------------------------------------------------
	typedef struct _EXIT_PROCESS_DEBUG_INFO 
	{
		unsigned long dwExitCode;
	} EXIT_PROCESS_DEBUG_INFO, *LPEXIT_PROCESS_DEBUG_INFO;

	//--------------------------------------------------------------------------------
	typedef struct _LOAD_DLL_DEBUG_INFO 
	{
		void* hFile;
		void* lpBaseOfDll;
		unsigned long dwDebugInfoFileOffset;
		unsigned long nDebugInfoSize;
		void* lpImageName;
		unsigned short fUnicode;
	} LOAD_DLL_DEBUG_INFO, *LPLOAD_DLL_DEBUG_INFO;

	//--------------------------------------------------------------------------------
	typedef struct _UNLOAD_DLL_DEBUG_INFO 
	{
		void* lpBaseOfDll;
	} UNLOAD_DLL_DEBUG_INFO, *LPUNLOAD_DLL_DEBUG_INFO;

	//--------------------------------------------------------------------------------
	typedef struct _OUTPUT_DEBUG_STRING_INFO 
	{
		char* lpDebugStringData;
		unsigned short fUnicode;
		unsigned short nDebugStringLength;
	} OUTPUT_DEBUG_STRING_INFO, *LPOUTPUT_DEBUG_STRING_INFO;

	//--------------------------------------------------------------------------------
	typedef struct _RIP_INFO 
	{
		unsigned long dwError;
		unsigned long dwType;
	} RIP_INFO, *LPRIP_INFO;

	//--------------------------------------------------------------------------------
	typedef struct _DEBUG_EVENT 
	{
		unsigned long dwDebugEventCode;
		unsigned long dwProcessId;
		unsigned long dwThreadId;
		union 
		{
			EXCEPTION_DEBUG_INFO Exception;
			CREATE_THREAD_DEBUG_INFO CreateThread;
			CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
			EXIT_THREAD_DEBUG_INFO ExitThread;
			EXIT_PROCESS_DEBUG_INFO ExitProcess;
			LOAD_DLL_DEBUG_INFO LoadDll;
			UNLOAD_DLL_DEBUG_INFO UnloadDll;
			OUTPUT_DEBUG_STRING_INFO DebugString;
			RIP_INFO RipInfo;
		} u;
	} DEBUG_EVENT, *LPDEBUG_EVENT;

	//--------------------------------------------------------------------------------
	typedef struct tagHEAPLIST32
	{
		Cmp_ulong_ptr dwSize;
		unsigned long th32ProcessID;   // owning process
		Cmp_ulong_ptr th32HeapID;      // heap (in owning process's context!)
		unsigned long dwFlags;
	} HEAPLIST32;
	typedef HEAPLIST32 *  PHEAPLIST32;
	typedef HEAPLIST32 *  LPHEAPLIST32;

	//--------------------------------------------------------------------------------
	typedef struct tagHEAPENTRY32
	{
		Cmp_ulong_ptr dwSize;
		void* hHandle;     // Handle of this heap block
		Cmp_ulong_ptr dwAddress;   // Linear address of start of block
		Cmp_ulong_ptr dwBlockSize; // Size of block in bytes
		unsigned long dwFlags;
		unsigned long dwLockCount;
		unsigned long dwResvd;
		unsigned long th32ProcessID;   // owning process
		Cmp_ulong_ptr th32HeapID;      // heap block is in
	} HEAPENTRY32;
	typedef HEAPENTRY32 *  PHEAPENTRY32;
	typedef HEAPENTRY32 *  LPHEAPENTRY32;
	
	//--------------------------------------------------------------------------------
	typedef struct tagTHREADENTRY32
	{
		unsigned long dwSize;
		unsigned long cntUsage;
		unsigned long th32ThreadID;       // this thread
		unsigned long th32OwnerProcessID; // Process this thread is associated with
		long tpBasePri;
		long tpDeltaPri;
		unsigned long dwFlags;
	} THREADENTRY32;
	typedef THREADENTRY32 *  PTHREADENTRY32;
	typedef THREADENTRY32 *  LPTHREADENTRY32;

	//--------------------------------------------------------------------------------
	typedef struct tagProcessEntry32
	{
		unsigned long dwSize;
		unsigned long cntUsage;
		unsigned long th32ProcessID;          // this process
		Cmp_ulong_ptr th32DefaultHeapID;
		unsigned long th32ModuleID;           // associated exe
		unsigned long cntThreads;
		unsigned long th32ParentProcessID;    // this process's parent process
		long pcPriClassBase;         // Base priority of process's threads
		unsigned long dwFlags;
		wchar_t szExeFile[ Max_Path ];    // Path
	} ProcessEntry32;
	typedef ProcessEntry32*  pProcessEntry32;	

	//--------------------------------------------------------------------------------
	typedef struct tagModuleEntry32
	{
		unsigned long dwSize;
		unsigned long th32ModuleID;       // This module
		unsigned long th32ProcessID;      // owning process
		unsigned long GlblcntUsage;       // Global usage count on the module
		unsigned long ProccntUsage;       // Module usage count in th32ProcessID's context
		unsigned char* modBaseAddr;        // Base address of module in th32ProcessID's context
		unsigned long modBaseSize;        // Size in bytes of module starting at modBaseAddr
		ModuleHandle hModule;            // The hModule of this module in th32ProcessID's context
		TCHAR szModule[ Max_Module_Name32 + 1 ];
		TCHAR szExePath[ Max_Path ];
	} ModuleEntry32;
	typedef ModuleEntry32*  pModuleEntry32;

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE( __WINQL ) CDebuggingHelper
	{
	public:

		__QOR_DECLARE_OCLASS_ID( CDebuggingHelper );

		CDebuggingHelper();
		~CDebuggingHelper();
		bool CheckRemoteDebuggerPresent( void* hProcess, int* pbDebuggerPresent );
		bool ContinueDebugEvent( unsigned long dwProcessId, unsigned long dwThreadId, unsigned long dwContinueStatus );
		bool DebugActiveProcess( unsigned long dwProcessId );
		bool DebugActiveProcessStop( unsigned long dwProcessId );
		void Break( void );
		bool DebugBreakProcess( void* Process );
		bool DebugSetProcessKillOnExit( bool KillOnExit );
		void FatalExit( int ExitCode );
		bool FlushInstructionCache( void* hProcess, const void* lpBaseAddress, Cmp_ulong_ptr dwSize );
		bool GetThreadContext( void* hThread, nsWin32::CONTEXT* lpContext );
		bool GetThreadSelectorEntry( void* hThread, unsigned long dwSelector, nsWin32::LPLDT_ENTRY lpSelectorEntry );
		bool IsDebuggerPresent( void );
		void OutputDebugStringT( const TCHAR* lpOutputString );
		bool ReadProcessMemory( void* hProcess, const void* lpBaseAddress, void* lpBuffer, Cmp_ulong_ptr nSize, Cmp_ulong_ptr * lpNumberOfBytesRead );
		bool SetThreadContext( void* hThread, const nsWin32::CONTEXT* lpContext );
		bool WaitForDebugEvent( nsWin32::LPDEBUG_EVENT lpDebugEvent, unsigned long dwMilliseconds );
		bool Wow64GetThreadContext( void* hThread, nsWin32::PWOW64_CONTEXT lpContext );
		bool Wow64SetThreadContext( void* hThread, const nsWin32::WOW64_CONTEXT* lpContext );
		bool WriteProcessMemory( void* hProcess, void* lpBaseAddress, const void* lpBuffer, Cmp_ulong_ptr nSize, Cmp_ulong_ptr* lpNumberOfBytesWritten );
		bool Toolhelp32ReadProcessMemory( unsigned long th32ProcessID, const void* lpBaseAddress, void* lpBuffer, Cmp_ulong_ptr cbRead, Cmp_ulong_ptr* lpNumberOfBytesRead );
		bool Heap32First( nsWin32::LPHEAPENTRY32 lphe, unsigned long th32ProcessID, Cmp_ulong_ptr th32HeapID );
		bool Heap32Next( nsWin32::LPHEAPENTRY32 lphe );
		bool IsBadHugeReadPtr( const void* lp, Cmp_uint_ptr ucb );
		bool IsBadHugeWritePtr( void* lp, Cmp_uint_ptr ucb );
	};

}//nsWin32

#endif//WINQL_DEBUGGING_H_2
