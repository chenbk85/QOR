//WinQLDisplay.h

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef WINQL_GRAPHICS_DISPLAY_H_3
#define WINQL_GRAPHICS_DISPLAY_H_3

#ifdef	__QCMP_OPTIMIZEINCLUDE
#pragma	__QCMP_OPTIMIZEINCLUDE
#endif//__QCMP_OPTIMIZEINCLUDE

#include "WinQL/Definitions/Handles.h"
#include "WinQL/GUI/Desktop.h"
#include "WinQL/Application/Graphics/WinQLRectangle.h"
#include "WinQL/GUI/Window.h"
#include "WinQL/CodeServices/WinQLSharedRef.h"

//--------------------------------------------------------------------------------
namespace nsWin32
{
	//--------------------------------------------------------------------------------
	typedef struct _DISPLAY_DEVICE 
	{
		unsigned long cb;
		TCHAR DeviceName[ 32 ];
		TCHAR DeviceString[ 128 ];
		unsigned long StateFlags;
		TCHAR DeviceID[ 128 ];
		TCHAR DeviceKey[ 128 ];
	} DISPLAY_DEVICE, *PDISPLAY_DEVICE, *LPDISPLAY_DEVICE;

	//--------------------------------------------------------------------------------
	typedef struct tagMONITORINFO
	{
		unsigned long cbSize;
		RECT rcMonitor;
		RECT rcWork;
		unsigned long dwFlags;
	} MONITORINFO, *LPMONITORINFO;

	typedef int ( __QCMP_STDCALLCONVENTION *MONITORENUMPROC )( void*, void*, nsWin32::RECT*, Cmp_long_ptr );


	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE( __WINQL ) CDisplayHelper
	{
	public:

		__QCMP_STATIC_CONSTANT( int, _EDD_GET_DEVICE_INTERFACE_NAME = 0x00000001 );

		__QOR_DECLARE_OCLASS_ID( CDisplayHelper );

		CDisplayHelper();
		virtual ~CDisplayHelper();
		long ChangeSettings( nsWin32::LPDEVMODE lpDevMode, unsigned long dwflags );
		long ChangeSettings( const TCHAR* lpszDeviceName, nsWin32::LPDEVMODE lpDevMode, COSWindow::refType Window, unsigned long dwflags, void* lParam );
		bool EnumDevices( const TCHAR* lpDevice, unsigned long iDevNum, nsWin32::PDISPLAY_DEVICE lpDisplayDevice, unsigned long dwFlags );
		bool EnumSettings( const TCHAR* lpszDeviceName, unsigned long iModeNum, nsWin32::LPDEVMODE lpDevMode, unsigned long dwFlags = 0 );
		bool EnumDisplayMonitors( CDeviceContext::refType dc, const nsWin32::RECT* lprcClip, nsWin32::MONITORENUMPROC lpfnEnum, Cmp_long_ptr dwData );
		bool SetProcessDPIAware( void );
		bool GetProcessDefaultLayout( unsigned long* pdwDefaultLayout );
		bool SetProcessDefaultLayout( unsigned long dwDefaultLayout );
		bool IsProcessDPIAware( void );

	private:

		nsWinQAPI::CUser32& m_User32Library;
			
		CDisplayHelper ( const CDisplayHelper& );
		CDisplayHelper& operator=( const CDisplayHelper& );

	};

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE( __WINQL ) CMonitorHelper
	{
	public:

		__QOR_DECLARE_OCLASS_ID( CMonitorHelper );

		CMonitorHelper( CMonitorHandle::refType hMonitor );
		CMonitorHelper( const CMonitorHelper& Monitor );		
		CMonitorHelper ( nsWin32::POINT pt, unsigned long dwFlags );
		CMonitorHelper( const nsWin32::RECT* lprc, unsigned long dwFlags );
		CMonitorHelper( COSWindow::refType Window, unsigned long dwFlags );
		virtual ~CMonitorHelper();
		bool GetInfo( nsWin32::LPMONITORINFO lpmi );

	protected:

		CMonitorHandle m_Handle;		

	private:

		nsWinQAPI::CUser32& m_User32Library;

		__QCS_DECLARE_NONASSIGNABLE( CMonitorHelper );
	};

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE( __WINQL ) CDisplay
	{
		QOR_PP_WINQL_SHARED;

	public:

		__QOR_DECLARE_OCLASS_ID( CDisplay );

		//--------------------------------------------------------------------------------
		class __QOR_INTERFACE( __WINQL ) CDevice : public nsWin32::DISPLAY_DEVICE
		{
			friend class CDisplay;

		public:

			__QOR_DECLARE_OCLASS_ID( CDevice );

			CDevice();
			~CDevice();
			CDevice( const CDevice& );
			CDevice& operator=( const CDevice& Src );
			bool EnumSettings( unsigned long iModeNum, nsWin32::LPDEVMODE lpDevMode, unsigned long dwFlags );
			long ChangeSettings( nsWin32::LPDEVMODE lpDevMode, COSWindow::refType Window, unsigned long dwflags, void* lParam );
			CTString GetDeviceID( void );
			CTString GetDeviceString( void );

		private:

			CDisplayHelper m_Win32DisplayHelper;
			bool m_bInitialised;
		};

		//--------------------------------------------------------------------------------
		class __QOR_INTERFACE( __WINQL ) CMonitor : public nsWin32::MONITORINFO
		{
		public:

			__QOR_DECLARE_OCLASS_ID( CMonitor );

			CMonitor( const CMonitor& Monitor );
			CMonitor( CMonitorHandle::refType hMonitor );
			CMonitor( nsWin32::POINT pt, unsigned long dwFlags );
			CMonitor( const CRectangle* lprc, unsigned long dwFlags );
			CMonitor( COSWindow::refType Window, unsigned long dwFlags );
			bool IsPrimary( void );
			virtual ~CMonitor();

		protected:

			CMonitorHelper m_Win32Monitor;
		};

		CDisplay();
		virtual ~CDisplay();
		CDisplay::CDevice DefaultDevice();
		CDisplay::CDevice Device( unsigned int uiDevice );
		CDisplay::CMonitor& Monitor( unsigned int uiMonitor );
		CDisplay::CMonitor MonitorFromPoint( nsWin32::POINT pt, unsigned long dwFlags );
		CDisplay::CMonitor MonitorFromRect( const CRectangle* lprc, unsigned long dwFlags );
		CDisplay::CMonitor MonitorFromWindow( COSWindow::refType Window, unsigned long dwFlags );
		long ChangeSettingsForDefaultDevice( nsWin32::LPDEVMODE lpDevMode, unsigned long dwflags );
		bool EnumMonitors( CDeviceContext::refType dc, const CRectangle* lprcClip, nsWin32::MONITORENUMPROC lpfnEnum, Cmp_long_ptr dwData );

	private:

		//--------------------------------------------------------------------------------
		bool EnumDevices();
		bool EnumAllMonitors();
		static bool __QCMP_STDCALLCONVENTION EnumMonitorProc( void* hMonitor, void* hdcMonitor, nsWin32::LPRECT lprcMonitor, Cmp_long_ptr dwData );
		bool AddMonitor( void* hMonitor, CDeviceContext::refType dcMonitor, nsWin32::LPRECT lprcMonitor );

		bool m_bDevicesEnumerated;
		bool m_bMonitorsEnumerated;
		nsCodeQOR::CTArray< CDevice, CWinQLPolicy > m_Devices;
		nsCodeQOR::CTArray< CMonitor*, CWinQLPolicy > m_apMonitors;
		CDisplayHelper m_Win32DisplayHelper;

	};

}//nsWin32

#endif//WINQL_GRAPHICS_DISPLAY_H_3
