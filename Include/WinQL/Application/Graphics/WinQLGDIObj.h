//WinQLGDIObj.h

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef WINQL_GRAPHICS_GDIOBJ_H_3
#define WINQL_GRAPHICS_GDIOBJ_H_3

#ifdef	__QCMP_OPTIMIZEINCLUDE
#pragma	__QCMP_OPTIMIZEINCLUDE
#endif//__QCMP_OPTIMIZEINCLUDE

#include "WinQL/Definitions/Handles.h"
#include "WinQL/CodeServices/Handles/WinQLHandleMap.h"
#include "WinQL/CodeServices/Handles/WinQLRAIISessionHandle.h"
#include "WinQL/Application/ErrorSystem/WinQLFunctionContext.h"
//--------------------------------------------------------------------------------
namespace nsWinQAPI
{
	class __QOR_INTERFACE( __WINQAPI ) CGDI32;
}

//--------------------------------------------------------------------------------
namespace nsWin32
{
	class __QOR_INTERFACE( __WINQL ) CDCInternal;
	class CGDIObjectSelection;

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE( __WINQL ) CBaseGDIObject
	{
		friend class CGDIObjectSelection;

	public:

		typedef nsCodeQOR::CTLRef< CBaseGDIObject > refType;

		__QOR_DECLARE_OCLASS_ID( CBaseGDIObject );

		CBaseGDIObject();
		CBaseGDIObject( const CBaseGDIObject& );
		CBaseGDIObject& operator = ( const CBaseGDIObject& );
		virtual ~CBaseGDIObject();
		virtual int GetData( int cbBuffer, void* lpvObject );
		unsigned long GetType( void );
		
	protected:

		virtual void PreSelect( void );
		refType Select( CDCInternal& DC );
		virtual void PostSelect( CDCInternal& DC );
		virtual void Deselect( CDCInternal& DC );

		virtual CRAIISessionHandle& Internal_Handle( void ) = 0;
		virtual refType FromHandle( void* Handle ) = 0;

		nsWinQAPI::CGDI32& m_GDI32Library;

	};

	//--------------------------------------------------------------------------------
	template< class TObject >
	class CGDIObject : public CBaseGDIObject
	{
	public:

		typedef nsCodeQOR::CTLRef< CGDIObject > refType;

	__QCMP_WARNING_PUSH
	__QCMP_WARNING_DISABLE( __QCMP_WARN_THIS_USED_IN_BASE_INIT_LIST, "Safe usage: stored in member for later use" );

		//--------------------------------------------------------------------------------
		CGDIObject() : CBaseGDIObject()
		,	m_Handle( (TObject*)this, 0 )
		,	m_bOwner( true )
		{
			_WINQ_FCONTEXT( "CBaseGDIObject::CBaseGDIObject" );
			Init();
		}

		//--------------------------------------------------------------------------------
		CGDIObject( void* handle ) : CBaseGDIObject()
		,	m_Handle( (TObject*)this, handle )
		,	m_bOwner( false )
		{
			_WINQ_FCONTEXT( "CGDIObject::CGDIObject" );
			Init();
		}

		//--------------------------------------------------------------------------------
		CGDIObject( const CGDIObject& src ) : CBaseGDIObject( src )
		,	m_Handle( (TObject*)this, ( const_cast< CGDIObject& >( src ) ).Handle()->AsHandle().ptr() )
		,	m_bOwner( false )
		{
			_WINQ_FCONTEXT( "CGDIObject::CGDIObject" );
		}

	__QCMP_WARNING_POP

		//--------------------------------------------------------------------------------
		virtual ~CGDIObject()
		{
			_WINQ_FCONTEXT( "CGDIObject::~CGDIObject" );
			Uninit();
		}

		//--------------------------------------------------------------------------------
		CGDIObject& operator = ( const CGDIObject& src )
		{
			_WINQ_FCONTEXT( "CBaseGDIObject::operator =" );
			if( this != &src )
			{
				m_Handle = ( const_cast< CGDIObject& >( src ) ).Handle()->AsHandle().ptr();
				m_bOwner = false;
			}
			return *this;
		}

		//--------------------------------------------------------------------------------
		virtual typename CTypedSessionHandle< TObject >::refType Handle( void )
		{
			_WINQ_FCONTEXT( "CBaseGDIObject::Handle" );
			return m_Handle.Ref();
		}

		//--------------------------------------------------------------------------------
		virtual void SetHandle( void* h )
		{
			_WINQ_FCONTEXT( "CBaseGDIObject::SetHandle" );
			//if( m_bOwner )
			{
				if( ! m_Handle.IsNull() )
				{
					TObject::HandleMap().Remove( m_Handle.Ref() );
				}

				m_Handle = h;
				if( ! m_Handle.IsNull() )
				{
					TObject::HandleMap().Add( m_Handle.Ref(), (TObject*)this );
				}
			}
		}

		//--------------------------------------------------------------------------------
		static refType FromHandle( typename CTypedSessionHandle< TObject >::refType RefHandle )
		{
			TObject* pObject = dynamic_cast< TObject* >( TObject::HandleMap().FindHandle( RefHandle ) );
			refType Ref( pObject, false );
			return Ref;
		}		

		//--------------------------------------------------------------------------------
		void ClearOwnership()
		{
			_WINQ_FCONTEXT( "CBaseGDIObject::ClearOwnership" );
			m_bOwner = false;
		}

    protected:

		//--------------------------------------------------------------------------------
		CBaseGDIObject::refType FromHandle( void* Handle )
		{
			CTypedSessionHandle< TObject >::refType RefHandle( new CTypedSessionHandle< TObject >( (TObject*)this, Handle ), true );
			CBaseGDIObject::refType refObject( FromHandle( RefHandle ), false );
			return refObject;
		}

		//--------------------------------------------------------------------------------
		void Uninit( void )
		{
			if( ! m_Handle.IsNull() )
			{
				TObject::HandleMap().Remove( m_Handle.Ref() );
			}
		}

		//--------------------------------------------------------------------------------
		void Init( void )
		{
			if( ! m_Handle.IsNull() )
			{
				TObject::HandleMap().Add( m_Handle.Ref(), (TObject*)this );
			}
		}

		//--------------------------------------------------------------------------------
		virtual CRAIISessionHandle& Internal_Handle( void )
		{
			return m_Handle;
		}

	protected:

		//virtual CTHandleMap< typename CTypedSessionHandle< TObject >::refType, TObject >& HandleMap( void ) = 0;
		
		bool m_bOwner;			

		CTypedSessionHandle< TObject > m_Handle;
		
	};

	template< class TObject > class CSelectableGDIObject;

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE( __WINQL ) CGDIObjectSelection
	{
	public:

		__QOR_DECLARE_OCLASS_ID( CGDIObjectSelection );

		typedef nsCodeQOR::CTLRef< CGDIObjectSelection > refType;

		CGDIObjectSelection( CBaseGDIObject& Object, CDCInternal& DC );		
		virtual ~CGDIObjectSelection();		

	protected:

		void Select( void );

		nsWinQAPI::CGDI32& m_GDI32Library;

		CBaseGDIObject& m_Object;
		CDCInternal& m_DC;

	private:

		void* m_pPrev;

		CGDIObjectSelection();
		CGDIObjectSelection( const CGDIObjectSelection& );
		CGDIObjectSelection& operator = ( const CGDIObjectSelection& );
	};

	//--------------------------------------------------------------------------------
	template< class TObject >
	class CSelectableGDIObject : public CGDIObject< TObject >
	{
	public:			

		//--------------------------------------------------------------------------------
		CSelectableGDIObject() : CGDIObject< TObject >()
		{
			_WINQ_FCONTEXT( "CSelectableGDIObject::CSelectableGDIObject" );
		}

		//--------------------------------------------------------------------------------
		CSelectableGDIObject( const CSelectableGDIObject& src ) : CGDIObject< TObject >( src )
		{
			_WINQ_FCONTEXT( "CSelectableGDIObject::CSelectableGDIObject" );
			m_Selection = src.m_Selection;
		}

		//--------------------------------------------------------------------------------
		CSelectableGDIObject& operator = ( const CSelectableGDIObject& src )
		{
			_WINQ_FCONTEXT( "CSelectableGDIObject::operator =" );
			if( &src != this )
			{
				CGDIObject< TObject >::operator = ( src );
				m_Selection = src.m_Selection;
			}
			return *this;
		}

		//--------------------------------------------------------------------------------
		virtual ~CSelectableGDIObject()
		{
			_WINQ_FCONTEXT( "CSelectableGDIObject::~CSelectableGDIObject" );
			//Check for an undo any outstanding selection
		}
		
		//--------------------------------------------------------------------------------
		virtual void Select( CDCInternal& DC )
		{
			_WINQ_FCONTEXT( "CSelectableGDIObject::Select" );

			m_Selection = new CGDIObjectSelection( *this, DC );
		}

	protected:

		CGDIObjectSelection::refType m_Selection;
	};

}//nsWin32

#endif//WINQL_GRAPHICS_GDIOBJ_H_3
