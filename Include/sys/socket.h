//socket.h

// Copyright Querysoft Limited 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef	QOR_SYS_SOCKET_H_3
#define QOR_SYS_SOCKET_H_3

#include <sys/uio.h>
#include "SystemQOR.h"
#include QOR_SYS_PLATFORMSYSTYPES(socket)

typedef nsPlatform::socklen_t socklen_t;
typedef nsPlatform::sa_family_t sa_family_t;
typedef nsPlatform::sockaddr sockaddr;
typedef nsPlatform::sockaddr_storage sockaddr_storage ;
typedef nsPlatform::msghdr msghdr;
typedef nsPlatform::iovec iovec;
typedef nsPlatform::cmsghdr cmsghdr;

//the following symbolic constant for use as the cmsg_type value when cmsg_level is SOL_SOCKET:

#define SCM_RIGHTS				( nsPlatform::SCMRights )						//Indicates that the data array contains the access rights to be sent or received. 

//the following macros to gain access to the data arrays in the ancillary data associated with a message header:

#define CMSG_DATA(cmsg)			( nsPlatform::CMsgData( cmsg ) )				//If the argument is a pointer to a cmsghdr structure, this macro shall return an unsigned character pointer to the data array associated with the cmsghdr structure. 
#define CMSG_NXTHDR(mhdr,cmsg)	( nsPlatform::CMsgNextHeader( mhdr, cmsg ) )	//If the first argument is a pointer to a msghdr structure and the second argument is a pointer to a cmsghdr structure in the ancillary data pointed to by the msg_control field of that msghdr structure, this macro shall return a pointer to the next cmsghdr structure, or a null pointer if this structure is the last cmsghdr in the ancillary data. 
#define CMSG_FIRSTHDR(mhdr)		( nsPlatform::CMsgFirstHeader( mhdr ) )			//If the argument is a pointer to a msghdr structure, this macro shall return a pointer to the first cmsghdr structure in the ancillary data associated with this msghdr structure, or a null pointer if there is no ancillary data associated with the msghdr structure.

typedef nsPlatform::linger linger;

//the following symbolic constants with distinct values:

#define SOCK_DGRAM				( nsPlatform::SockDatagram )					//Datagram socket. 
#define SOCK_RAW				( nsPlatform::SockRaw )							//[RS]  Raw Protocol Interface.  
#define SOCK_SEQPACKET			( nsPlatform::SockSeqPacket )					//Sequenced-packet socket. 
#define SOCK_STREAM				( nsPlatform::SockStream )						//Byte-stream socket. 

//the following symbolic constant for use as the level argument of setsockopt() and getsockopt().

#define SOL_SOCKET				( nsPlatform::SoLSocket )						//Options to be accessed at socket level, not protocol level. 

//the following symbolic constants with distinct values for use as the option_name argument in getsockopt() or setsockopt() calls (see XSH Use of Options ):

#define SO_ACCEPTCONN			( nsPlatform::SoAcceptConnection )				//Socket is accepting connections. 
#define SO_BROADCAST			( nsPlatform::SoBroadcast )						//Transmission of broadcast messages is supported. 
#define SO_DEBUG				( nsPlatform::SoDebug )							//Debugging information is being recorded. 
#define SO_DONTROUTE			( nsPlatform::SoDontRoute )						//Bypass normal routing. 
#define SO_ERROR				( nsPlatform::SoError )							//Socket error status. 
#define SO_KEEPALIVE			( nsPlatform::SoKeepAlive )						//Connections are kept alive with periodic messages. 
#define SO_LINGER				( nsPlatform::SoLinger )						//Socket lingers on close. 
#define SO_OOBINLINE			( nsPlatform::SoOutOfBandInline )				//Out-of-band data is transmitted in line. 
#define SO_RCVBUF				( nsPlatform::SoRecvBuffer )					//Receive buffer size. 
#define SO_RCVLOWAT				( nsPlatform::SoRecvLowWaterMark )				//Receive ``low water mark''. 
#define SO_RCVTIMEO				( nsPlatform::SoRecvTimeout )					//Receive timeout. 
#define SO_REUSEADDR			( nsPlatform::SoReuseAddress )					//Reuse of local addresses is supported. 
#define SO_SNDBUF				( nsPlatform::SoSendBuffer )					//Send buffer size. 
#define SO_SNDLOWAT				( nsPlatform::SoSendLowWaterMark )				//Send ``low water mark''. 
#define SO_SNDTIMEO				( nsPlatform::SoSendTimeout )					//Send timeout. 
#define SO_TYPE					( nsPlatform::SoType )							//Socket type. 

//the following symbolic constant for use as the maximum backlog queue length which may be specified by the backlog field of the listen() function:

#define SOMAXCONN				( nsPlatform::SoMaxConn )						//The maximum backlog queue length. 

//the following symbolic constants with distinct values for use as the valid values for the msg_flags field in the msghdr structure, or the flags parameter in recv(), recvfrom(), recvmsg(), send(), sendmsg(), or sendto() calls:

#define MSG_CTRUNC				( nsPlatform::MsgCTrunc )						//Control data truncated. 
#define MSG_DONTROUTE			( nsPlatform::MsgDontRoute )					//Send without using routing tables. 
#define MSG_EOR					( nsPlatform::MsgEOR )							//Terminates a record (if supported by the protocol). 
#define MSG_OOB					( nsPlatform::MsgOOB )							//ut-of-band data. 
#define MSG_NOSIGNAL			( nsPlatform::MsgNoSignal )						//No SIGPIPE generated when an attempt to send is made on a stream-oriented socket that is no longer connected. 
#define MSG_PEEK				( nsPlatform::MsgPeek )							//Leave received data in queue. 
#define MSG_TRUNC				( nsPlatform::MsgTrunc )						//Normal data truncated. 
#define MSG_WAITALL				( nsPlatform::MsgWaitAll )						//Attempt to fill the read buffer. 

//the following symbolic constants with distinct values:

#define AF_INET					( nsPlatform::AFINet )							//Internet domain sockets for use with IPv4 addresses. 
#define AF_INET6				( nsPlatform::AFINet6 )							//[IP6]  Internet domain sockets for use with IPv6 addresses.  
#define AF_UNIX					( nsPlatform::AFUnix )							//UNIX domain sockets. 
#define AF_UNSPEC				( nsPlatform::AFUnspec )						//Unspecified. 

//The <sys/socket.h> header shall define the following symbolic constants with distinct values:

#define SHUT_RD					( nsPlatform::ShutRead )						//Disables further receive operations. 
#define SHUT_RDWR				( nsPlatform::ShutReadWrite )					//Disables further send and receive operations. 
#define SHUT_WR					( nsPlatform::ShutWrite )						//Disables further send operations. 

//typedef nsPlatform::size_t size_t;
typedef nsPlatform::ssize_t ssize_t;

__QCMP_STARTLINKAGE_C

	__QOR_INTERFACE( __CQOR ) int accept( int, ::sockaddr* __QCMP_RESTRICT, ::socklen_t* __QCMP_RESTRICT );
	__QOR_INTERFACE( __CQOR ) int bind( int, const ::sockaddr*, ::socklen_t );
	__QOR_INTERFACE( __CQOR ) int connect( int, const ::sockaddr*, ::socklen_t );
	__QOR_INTERFACE( __CQOR ) int getpeername( int, ::sockaddr* __QCMP_RESTRICT, ::socklen_t* __QCMP_RESTRICT );
	__QOR_INTERFACE( __CQOR ) int getsockname( int, ::sockaddr* __QCMP_RESTRICT, ::socklen_t* __QCMP_RESTRICT );
	__QOR_INTERFACE( __CQOR ) int getsockopt( int, int, int, void* __QCMP_RESTRICT, ::socklen_t* __QCMP_RESTRICT );
	__QOR_INTERFACE( __CQOR ) int listen( int, int );
	__QOR_INTERFACE( __CQOR ) ::ssize_t recv( int, void*, size_t, int );
	__QOR_INTERFACE( __CQOR ) ::ssize_t recvfrom( int, void* __QCMP_RESTRICT, size_t, int, ::sockaddr* __QCMP_RESTRICT, ::socklen_t* __QCMP_RESTRICT );
	__QOR_INTERFACE( __CQOR ) ::ssize_t recvmsg( int, ::msghdr*, int );
	__QOR_INTERFACE( __CQOR ) ::ssize_t send( int, const void*, size_t, int );
	__QOR_INTERFACE( __CQOR ) ::ssize_t sendmsg( int, const ::msghdr*, int );
	__QOR_INTERFACE( __CQOR ) ::ssize_t sendto( int, const void*, ::size_t, int, const ::sockaddr*, ::socklen_t);
	__QOR_INTERFACE( __CQOR ) int setsockopt( int, int, int, const void*, ::socklen_t );
	__QOR_INTERFACE( __CQOR ) int shutdown( int, int );
	__QOR_INTERFACE( __CQOR ) int sockatmark( int );
	__QOR_INTERFACE( __CQOR ) int socket( int, int, int );
	__QOR_INTERFACE( __CQOR ) int socketpair( int, int, int, int[ 2 ] );

__QCMP_ENDLINKAGE_C

#endif//QOR_SYS_SOCKET_H_3

