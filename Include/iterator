#include "../Source/libcxx/include/iterator"

//// -*- C++ -*-
////===-------------------------- iterator ----------------------------------===//
////
////                     The LLVM Compiler Infrastructure
////
//// This file is dual licensed under the MIT and the University of Illinois Open
//// Source Licenses. See LICENSE.TXT for details.
////
////===----------------------------------------------------------------------===//
//
//#ifndef _LIBCPP_ITERATOR
//#define _LIBCPP_ITERATOR
//
///*
//    iterator synopsis
//
//namespace std
//{
//
//template<class Iterator>
//struct iterator_traits
//{
//    typedef typename Iterator::difference_type difference_type;
//    typedef typename Iterator::value_type value_type;
//    typedef typename Iterator::pointer pointer;
//    typedef typename Iterator::reference reference;
//    typedef typename Iterator::iterator_category iterator_category;
//};
//
//template<class T>
//struct iterator_traits<T*>
//{
//    typedef ptrdiff_t difference_type;
//    typedef T value_type;
//    typedef T* pointer;
//    typedef T& reference;
//    typedef random_access_iterator_tag iterator_category;
//};
//
//template<class T>
//struct iterator_traits<const T*>
//{
//    typedef ptrdiff_t difference_type;
//    typedef T value_type;
//    typedef const T* pointer;
//    typedef const T& reference;
//    typedef random_access_iterator_tag iterator_category;
//};
//
//template<class Category, class T, class Distance = ptrdiff_t,
//         class Pointer = T*, class Reference = T&>
//struct iterator
//{
//    typedef T         value_type;
//    typedef Distance  difference_type;
//    typedef Pointer   pointer;
//    typedef Reference reference;
//    typedef Category  iterator_category;
//};
//
//struct input_iterator_tag  {};
//struct output_iterator_tag {};
//struct forward_iterator_tag       : public input_iterator_tag         {};
//struct bidirectional_iterator_tag : public forward_iterator_tag       {};
//struct random_access_iterator_tag : public bidirectional_iterator_tag {};
//
//// extension: second argument not conforming to C++03
//template <class InputIterator>
//void advance(InputIterator& i,
//             typename iterator_traits<InputIterator>::difference_type n);
//
//template <class InputIterator>
//typename iterator_traits<InputIterator>::difference_type
//distance(InputIterator first, InputIterator last);
//
//template <class Iterator>
//class reverse_iterator
//    : public iterator<typename iterator_traits<Iterator>::iterator_category,
//                      typename iterator_traits<Iterator>::value_type,
//                      typename iterator_traits<Iterator>::difference_type,
//                      typename iterator_traits<Iterator>::pointer,
//                      typename iterator_traits<Iterator>::reference>
//{
//protected:
//    Iterator current;
//public:
//    typedef Iterator                                            iterator_type;
//    typedef typename iterator_traits<Iterator>::difference_type difference_type;
//    typedef typename iterator_traits<Iterator>::reference       reference;
//    typedef typename iterator_traits<Iterator>::pointer         pointer;
//
//    reverse_iterator();
//    explicit reverse_iterator(Iterator x);
//    template <class U> reverse_iterator(const reverse_iterator<U>& u);
//    Iterator base() const;
//    reference operator*() const;
//    pointer   operator->() const;
//    reverse_iterator& operator++();
//    reverse_iterator  operator++(int);
//    reverse_iterator& operator--();
//    reverse_iterator  operator--(int);
//    reverse_iterator  operator+ (difference_type n) const;
//    reverse_iterator& operator+=(difference_type n);
//    reverse_iterator  operator- (difference_type n) const;
//    reverse_iterator& operator-=(difference_type n);
//    reference         operator[](difference_type n) const;
//};
//
//template <class Iterator1, class Iterator2>
//bool
//operator==(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);
//
//template <class Iterator1, class Iterator2>
//bool
//operator<(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);
//
//template <class Iterator1, class Iterator2>
//bool
//operator!=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);
//
//template <class Iterator1, class Iterator2>
//bool
//operator>(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);
//
//template <class Iterator1, class Iterator2>
//bool
//operator>=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);
//
//template <class Iterator1, class Iterator2>
//bool
//operator<=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);
//
//template <class Iterator1, class Iterator2>
//typename reverse_iterator<Iterator1>::difference_type
//operator-(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);
//
//template <class Iterator>
//reverse_iterator<Iterator>
//operator+(typename reverse_iterator<Iterator>::difference_type n, const reverse_iterator<Iterator>& x);
//
//template <class Container>
//class back_insert_iterator
//{
//protected:
//    Container* container;
//public:
//    typedef Container                   container_type;
//    typedef void                        value_type;
//    typedef void                        difference_type;
//    typedef back_insert_iterator<Cont>& reference;
//    typedef void                        pointer;
//
//    explicit back_insert_iterator(Container& x);
//    back_insert_iterator& operator=(const typename Container::value_type& value);
//    back_insert_iterator& operator*();
//    back_insert_iterator& operator++();
//    back_insert_iterator  operator++(int);
//};
//
//template <class Container> back_insert_iterator<Container> back_inserter(Container& x);
//
//template <class Container>
//class front_insert_iterator
//{
//protected:
//    Container* container;
//public:
//    typedef Container                    container_type;
//    typedef void                         value_type;
//    typedef void                         difference_type;
//    typedef front_insert_iterator<Cont>& reference;
//    typedef void                         pointer;
//
//    explicit front_insert_iterator(Container& x);
//    front_insert_iterator& operator=(const typename Container::value_type& value);
//    front_insert_iterator& operator*();
//    front_insert_iterator& operator++();
//    front_insert_iterator  operator++(int);
//};
//
//template <class Container> front_insert_iterator<Container> front_inserter(Container& x);
//
//template <class Container>
//class insert_iterator
//{
//protected:
//    Container* container;
//    typename Container::iterator iter;
//public:
//    typedef Container              container_type;
//    typedef void                   value_type;
//    typedef void                   difference_type;
//    typedef insert_iterator<Cont>& reference;
//    typedef void                   pointer;
//
//    insert_iterator(Container& x, typename Container::iterator i);
//    insert_iterator& operator=(const typename Container::value_type& value);
//    insert_iterator& operator*();
//    insert_iterator& operator++();
//    insert_iterator& operator++(int);
//};
//
//template <class Container, class Iterator>
//insert_iterator<Container> inserter(Container& x, Iterator i);
//
//template <class T, class charT = char, class traits = char_traits<charT>, class Distance = ptrdiff_t>
//class istream_iterator
//    : public iterator<input_iterator_tag, T, Distance, const T*, const T&>
//{
//public:
//    typedef charT char_type;
//    typedef traits traits_type;
//    typedef basic_istream<charT,traits> istream_type;
//
//    istream_iterator();
//    istream_iterator(istream_type& s);
//    istream_iterator(const istream_iterator& x);
//    ~istream_iterator();
//
//    const T& operator*() const;
//    const T* operator->() const;
//    istream_iterator& operator++();
//    istream_iterator  operator++(int);
//};
//
//template <class T, class charT, class traits, class Distance>
//bool operator==(const istream_iterator<T,charT,traits,Distance>& x,
//                const istream_iterator<T,charT,traits,Distance>& y);
//template <class T, class charT, class traits, class Distance>
//bool operator!=(const istream_iterator<T,charT,traits,Distance>& x,
//                const istream_iterator<T,charT,traits,Distance>& y);
//
//template <class T, class charT = char, class traits = char_traits<charT> >
//class ostream_iterator
//    : public iterator<output_iterator_tag, void, void, void ,void>
//{
//public:
//    typedef charT char_type;
//    typedef traits traits_type;
//    typedef basic_ostream<charT,traits> ostream_type;
//
//    ostream_iterator(ostream_type& s);
//    ostream_iterator(ostream_type& s, const charT* delimiter);
//    ostream_iterator(const ostream_iterator& x);
//    ~ostream_iterator();
//    ostream_iterator& operator=(const T& value);
//
//    ostream_iterator& operator*();
//    ostream_iterator& operator++();
//    ostream_iterator& operator++(int);
//};
//
//template<class charT, class traits = char_traits<charT> >
//class istreambuf_iterator
//    : public iterator<input_iterator_tag, charT,
//                      typename traits::off_type, unspecified,
//                      charT>
//{
//public:
//    typedef charT                         char_type;
//    typedef traits                        traits_type;
//    typedef typename traits::int_type     int_type;
//    typedef basic_streambuf<charT,traits> streambuf_type;
//    typedef basic_istream<charT,traits>   istream_type;
//
//    istreambuf_iterator() throw();
//    istreambuf_iterator(istream_type& s) throw();
//    istreambuf_iterator(streambuf_type* s) throw();
//    istreambuf_iterator(a-private-type) throw();
//
//    charT                operator*() const;
//    pointer operator->() const;
//    istreambuf_iterator& operator++();
//    a-private-type       operator++(int);
//
//    bool equal(const istreambuf_iterator& b) const;
//};
//
//template <class charT, class traits>
//bool operator==(const istreambuf_iterator<charT,traits>& a,
//                const istreambuf_iterator<charT,traits>& b);
//template <class charT, class traits>
//bool operator!=(const istreambuf_iterator<charT,traits>& a,
//                const istreambuf_iterator<charT,traits>& b);
//
//template <class charT, class traits = char_traits<charT> >
//class ostreambuf_iterator
//    : public iterator<output_iterator_tag, void, void, void, void>
//{
//public:
//    typedef charT                         char_type;
//    typedef traits                        traits_type;
//    typedef basic_streambuf<charT,traits> streambuf_type;
//    typedef basic_ostream<charT,traits>   ostream_type;
//
//    ostreambuf_iterator(ostream_type& s) throw();
//    ostreambuf_iterator(streambuf_type* s) throw();
//    ostreambuf_iterator& operator=(charT c);
//    ostreambuf_iterator& operator*();
//    ostreambuf_iterator& operator++();
//    ostreambuf_iterator& operator++(int);
//    bool failed() const throw();
//};
//
//template <class C> auto begin(C& c) -> decltype(c.begin());
//template <class C> auto begin(const C& c) -> decltype(c.begin());
//template <class C> auto end(C& c) -> decltype(c.end());
//template <class C> auto end(const C& c) -> decltype(c.end());
//template <class T, size_t N> T* begin(T (&array)[N]);
//template <class T, size_t N> T* end(T (&array)[N]);
//
//}  // std
//
//*/
//
//#include "SystemQOR.h"
////#include <__config>
//#include <type_traits>
//#include <cstddef>
//#include <iosfwd>
//#ifndef NDEBUG
//#include <cassert>
//#endif
//
//#if __QCMP_SUPPORTS( __QCMP_FEATURE_PRAGMA_SYSTEM_HEADER )
//#pragma GCC system_header
//#endif
//
//namespace std
//{
//
//struct __QOR_INTERFACE( __STDQOR ) input_iterator_tag {};
//struct __QOR_INTERFACE( __STDQOR ) output_iterator_tag {};
//struct __QOR_INTERFACE( __STDQOR ) forward_iterator_tag       : public input_iterator_tag {};
//struct __QOR_INTERFACE( __STDQOR ) bidirectional_iterator_tag : public forward_iterator_tag {};
//struct __QOR_INTERFACE( __STDQOR ) random_access_iterator_tag : public bidirectional_iterator_tag {};
//
////--------------------------------------------------------------------------------
//template <class _Tp>
//struct __has_iterator_category
//{
//private:
//    struct __two {char _; char __;};
//    template <class _Up> static __two __test(...);
//    template <class _Up> static char __test(typename _Up::iterator_category* = 0);
//public:
//    static const bool value = sizeof(__test<_Tp>(0)) == 1;
//};
//
////--------------------------------------------------------------------------------
//template <class _Iter, bool> struct ____iterator_traits {};
//
////--------------------------------------------------------------------------------
//template <class _Iter>
//struct ____iterator_traits<_Iter, true>
//{
//    typedef typename _Iter::difference_type   difference_type;
//    typedef typename _Iter::value_type        value_type;
//    typedef typename _Iter::pointer           pointer;
//    typedef typename _Iter::reference         reference;
//    typedef typename _Iter::iterator_category iterator_category;
//};
//
////--------------------------------------------------------------------------------
//template <class _Iter, bool> struct __iterator_traits {};
//
////--------------------------------------------------------------------------------
//template <class _Iter>
//struct __iterator_traits<_Iter, true>
//    :  ____iterator_traits
//      <
//        _Iter,
//        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||
//        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value
//      >
//{};
//
//// iterator_traits<Iterator> will only have the nested types if Iterator::iterator_category
////    exists.  Else iterator_traits<Iterator> will be an empty class.  This is a
////    conforming extension which allows some programs to compile and behave as
////    the client expects instead of failing at compile time.
//
////--------------------------------------------------------------------------------
//template <class _Iter>
//struct __QOR_INTERFACE( __STDQOR ) iterator_traits
//    : __iterator_traits<_Iter, __has_iterator_category<_Iter>::value> {};
//
////--------------------------------------------------------------------------------
//template<class _Tp>
//struct __QOR_INTERFACE( __STDQOR ) iterator_traits<_Tp*>
//{
//    typedef ptrdiff_t difference_type;
//    typedef typename remove_const<_Tp>::type value_type;
//    typedef _Tp* pointer;
//    typedef _Tp& reference;
//    typedef random_access_iterator_tag iterator_category;
//};
//
////--------------------------------------------------------------------------------
//template< class _Tp, class _Up, bool = __has_iterator_category< iterator_traits< _Tp > >::value >
//struct __has_iterator_category_convertible_to : public integral_constant< bool, is_convertible< typename iterator_traits< _Tp >::iterator_category, _Up >::value >
//{
//};
//
////--------------------------------------------------------------------------------
//template <class _Tp, class _Up>
//struct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};
//
////--------------------------------------------------------------------------------
//template <class _Tp>
//struct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};
//
////--------------------------------------------------------------------------------
//template <class _Tp>
//struct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};
//
////--------------------------------------------------------------------------------
//template <class _Tp>
//struct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};
//
////--------------------------------------------------------------------------------
//template <class _Tp>
//struct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};
//
////--------------------------------------------------------------------------------
//template<class _Category, class _Tp, class _Distance = ptrdiff_t, class _Pointer = _Tp*, class _Reference = _Tp&>
//struct __QOR_INTERFACE( __STDQOR ) iterator
//{
//    typedef _Tp        value_type;
//    typedef _Distance  difference_type;
//    typedef _Pointer   pointer;
//    typedef _Reference reference;
//    typedef _Category  iterator_category;
//};
//
////--------------------------------------------------------------------------------
//template <class _InputIter>
//__QCMP_ALWAYSINLINE void __advance(_InputIter& __i, typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)
//{
//    for (; __n > 0; --__n)
//        ++__i;
//}
//
////--------------------------------------------------------------------------------
//template <class _BiDirIter>
//__QCMP_ALWAYSINLINE void __advance(_BiDirIter& __i, typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)
//{
//    if (__n >= 0)
//        for (; __n > 0; --__n)
//            ++__i;
//    else
//        for (; __n < 0; ++__n)
//            --__i;
//}
//
////--------------------------------------------------------------------------------
//template <class _RandIter>
//__QCMP_ALWAYSINLINE void __advance(_RandIter& __i, typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)
//{
//   __i += __n;
//}
//
////--------------------------------------------------------------------------------
//template <class _InputIter>
//__QCMP_ALWAYSINLINE void advance(_InputIter& __i, typename iterator_traits<_InputIter>::difference_type __n)
//{
//    __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());
//}
//
////--------------------------------------------------------------------------------
//template <class _InputIter>
//__QCMP_ALWAYSINLINE typename iterator_traits<_InputIter>::difference_type
//__distance(_InputIter __first, _InputIter __last, input_iterator_tag)
//{
//    typename iterator_traits<_InputIter>::difference_type __r(0);
//    for (; __first != __last; ++__first)
//        ++__r;
//    return __r;
//}
//
////--------------------------------------------------------------------------------
//template <class _RandIter>
//__QCMP_ALWAYSINLINE typename iterator_traits<_RandIter>::difference_type
//__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)
//{
//    return __last - __first;
//}
//
////--------------------------------------------------------------------------------
//template <class _InputIter>
//__QCMP_ALWAYSINLINE typename iterator_traits<_InputIter>::difference_type
//distance(_InputIter __first, _InputIter __last)
//{
//    return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());
//}
//
////--------------------------------------------------------------------------------
//template <class _ForwardIter>
//__QCMP_ALWAYSINLINE _ForwardIter next(_ForwardIter __x,
//     typename iterator_traits<_ForwardIter>::difference_type __n = 1,
//     typename enable_if<__is_forward_iterator<_ForwardIter>::value>::type* = 0)
//{
//    std::advance(__x, __n);
//    return __x;
//}
//
////--------------------------------------------------------------------------------
//template <class _BidiretionalIter>
//__QCMP_ALWAYSINLINE _BidiretionalIter prev(_BidiretionalIter __x,
//     typename iterator_traits<_BidiretionalIter>::difference_type __n = 1,
//     typename enable_if<__is_bidirectional_iterator<_BidiretionalIter>::value>::type* = 0)
//{
//    std::advance(__x, -__n);
//    return __x;
//}
//
////--------------------------------------------------------------------------------
//template <class _Iter>
//class reverse_iterator : public iterator<typename iterator_traits<_Iter>::iterator_category,
//                      typename iterator_traits<_Iter>::value_type,
//                      typename iterator_traits<_Iter>::difference_type,
//                      typename iterator_traits<_Iter>::pointer,
//                      typename iterator_traits<_Iter>::reference>
//{
//private:
//    mutable _Iter __t;
//protected:
//    _Iter current;
//public:
//    typedef _Iter                                            iterator_type;
//    typedef typename iterator_traits<_Iter>::difference_type difference_type;
//    typedef typename iterator_traits<_Iter>::reference       reference;
//    typedef typename iterator_traits<_Iter>::pointer         pointer;
//
//    __QCMP_ALWAYSINLINE reverse_iterator() : current() {}
//    __QCMP_ALWAYSINLINE explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}
//    template <class _Up> __QCMP_ALWAYSINLINE reverse_iterator(const reverse_iterator<_Up>& __u)
//        : __t(__u.base()), current(__u.base()) {}
//    __QCMP_ALWAYSINLINE _Iter base() const {return current;}
//    __QCMP_ALWAYSINLINE reference operator*() const {__t = current; return *--__t;}
//    __QCMP_ALWAYSINLINE pointer  operator->() const {return &(operator*());}
//    __QCMP_ALWAYSINLINE reverse_iterator& operator++() {--current; return *this;}
//    __QCMP_ALWAYSINLINE reverse_iterator  operator++(int)
//        {reverse_iterator __tmp(*this); --current; return __tmp;}
//    __QCMP_ALWAYSINLINE reverse_iterator& operator--() {++current; return *this;}
//    __QCMP_ALWAYSINLINE reverse_iterator  operator--(int)
//        {reverse_iterator __tmp(*this); ++current; return __tmp;}
//    __QCMP_ALWAYSINLINE reverse_iterator  operator+ (difference_type __n) const
//        {return reverse_iterator(current - __n);}
//    __QCMP_ALWAYSINLINE reverse_iterator& operator+=(difference_type __n)
//        {current -= __n; return *this;}
//    __QCMP_ALWAYSINLINE reverse_iterator  operator- (difference_type __n) const
//        {return reverse_iterator(current + __n);}
//    __QCMP_ALWAYSINLINE reverse_iterator& operator-=(difference_type __n)
//        {current += __n; return *this;}
//    __QCMP_ALWAYSINLINE reference         operator[](difference_type __n) const
//        {return current[-__n-1];}
//};
//
////--------------------------------------------------------------------------------
//template <class _Iter1, class _Iter2>
//__QCMP_ALWAYSINLINE bool operator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
//{
//    return __x.base() == __y.base();
//}
//
////--------------------------------------------------------------------------------
//template <class _Iter1, class _Iter2>
//__QCMP_ALWAYSINLINE bool operator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
//{
//    return __x.base() > __y.base();
//}
//
////--------------------------------------------------------------------------------
//template <class _Iter1, class _Iter2>
//__QCMP_ALWAYSINLINE bool operator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
//{
//    return __x.base() != __y.base();
//}
//
////--------------------------------------------------------------------------------
//template <class _Iter1, class _Iter2>
//__QCMP_ALWAYSINLINE bool operator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
//{
//    return __x.base() < __y.base();
//}
//
////--------------------------------------------------------------------------------
//template <class _Iter1, class _Iter2>
//__QCMP_ALWAYSINLINE bool operator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
//{
//    return __x.base() <= __y.base();
//}
//
////--------------------------------------------------------------------------------
//template <class _Iter1, class _Iter2>
//__QCMP_ALWAYSINLINE bool operator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
//{
//    return __x.base() >= __y.base();
//}
//
////--------------------------------------------------------------------------------
//template <class _Iter1, class _Iter2>
//__QCMP_ALWAYSINLINE typename reverse_iterator<_Iter1>::difference_type operator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
//{
//    return __y.base() - __x.base();
//}
//
////--------------------------------------------------------------------------------
//template <class _Iter>
//__QCMP_ALWAYSINLINE reverse_iterator<_Iter> operator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)
//{
//    return reverse_iterator<_Iter>(__x.base() - __n);
//}
//
////--------------------------------------------------------------------------------
//template <class _Container>
//class __QOR_INTERFACE( __STDQOR ) back_insert_iterator : public iterator< output_iterator_tag, void, void, void, back_insert_iterator< _Container >& >
//{
//protected:
//    _Container* container;
//public:
//    typedef _Container container_type;
//
//    __QCMP_ALWAYSINLINE explicit back_insert_iterator(_Container& __x) : container(&__x) {}
//    __QCMP_ALWAYSINLINE back_insert_iterator& operator=(const typename _Container::value_type& __value_)
//        {container->push_back(__value_); return *this;}
//#if	( __QCMP_SUPPORTS( __QCMP_FEATURE_RVALUE_REFERENCES ) )
//    __QCMP_ALWAYSINLINE back_insert_iterator& operator=(typename _Container::value_type&& __value_)
//        {container->push_back(std::move(__value_)); return *this;}
//#endif  
//    __QCMP_ALWAYSINLINE back_insert_iterator& operator*()     {return *this;}
//    __QCMP_ALWAYSINLINE back_insert_iterator& operator++()    {return *this;}
//    __QCMP_ALWAYSINLINE back_insert_iterator  operator++(int) {return *this;}
//};
//
////--------------------------------------------------------------------------------
//template <class _Container>
//__QCMP_ALWAYSINLINE back_insert_iterator<_Container> back_inserter(_Container& __x)
//{
//    return back_insert_iterator<_Container>(__x);
//}
//
////--------------------------------------------------------------------------------
//template <class _Container>
//class __QOR_INTERFACE( __STDQOR ) front_insert_iterator : public iterator<output_iterator_tag, void, void, void, front_insert_iterator< _Container >& >
//{
//protected:
//    _Container* container;
//public:
//    typedef _Container container_type;
//
//    __QCMP_ALWAYSINLINE explicit front_insert_iterator(_Container& __x) : container(&__x) {}
//    __QCMP_ALWAYSINLINE front_insert_iterator& operator=(const typename _Container::value_type& __value_)
//        {container->push_front(__value_); return *this;}
//#if	( __QCMP_SUPPORTS( __QCMP_FEATURE_RVALUE_REFERENCES ) )
//    __QCMP_ALWAYSINLINE front_insert_iterator& operator=(typename _Container::value_type&& __value_)
//        {container->push_front(std::move(__value_)); return *this;}
//#endif 
//    __QCMP_ALWAYSINLINE front_insert_iterator& operator*()     {return *this;}
//    __QCMP_ALWAYSINLINE front_insert_iterator& operator++()    {return *this;}
//    __QCMP_ALWAYSINLINE front_insert_iterator  operator++(int) {return *this;}
//};
//
////--------------------------------------------------------------------------------
//template< class _Container >
//__QCMP_ALWAYSINLINE front_insert_iterator<_Container> front_inserter(_Container& __x)
//{
//    return front_insert_iterator<_Container>(__x);
//}
//
////--------------------------------------------------------------------------------
//template <class _Container>
//class __QOR_INTERFACE( __STDQOR ) insert_iterator : public iterator<output_iterator_tag, void, void, void, insert_iterator<_Container>&>
//{
//protected:
//    _Container* container;
//    typename _Container::iterator iter;
//public:
//    typedef _Container container_type;
//
//    __QCMP_ALWAYSINLINE insert_iterator(_Container& __x, typename _Container::iterator __i)
//        : container(&__x), iter(__i) {}
//    __QCMP_ALWAYSINLINE insert_iterator& operator=(const typename _Container::value_type& __value_)
//        {iter = container->insert(iter, __value_); ++iter; return *this;}
//#if	( __QCMP_SUPPORTS( __QCMP_FEATURE_RVALUE_REFERENCES ) )
//    __QCMP_ALWAYSINLINE insert_iterator& operator=(typename _Container::value_type&& __value_)
//        {iter = container->insert(iter, std::move(__value_)); ++iter; return *this;}
//#endif  
//    __QCMP_ALWAYSINLINE insert_iterator& operator*()        {return *this;}
//    __QCMP_ALWAYSINLINE insert_iterator& operator++()       {return *this;}
//    __QCMP_ALWAYSINLINE insert_iterator& operator++(int)    {return *this;}
//};
//
////--------------------------------------------------------------------------------
//template <class _Container>
//__QCMP_ALWAYSINLINE insert_iterator<_Container> inserter(_Container& __x, typename _Container::iterator __i)
//{
//    return insert_iterator<_Container>(__x, __i);
//}
//
////--------------------------------------------------------------------------------
//template <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>
//class __QOR_INTERFACE( __STDQOR ) istream_iterator : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>
//{
//public:
//    typedef _CharT char_type;
//    typedef _Traits traits_type;
//    typedef basic_istream<_CharT,_Traits> istream_type;
//private:
//    istream_type* __in_stream_;
//    _Tp __value_;
//public:
//    __QCMP_ALWAYSINLINE istream_iterator() : __in_stream_(0) {}
//    __QCMP_ALWAYSINLINE istream_iterator(istream_type& __s) : __in_stream_(&__s)
//        {
//            if (!(*__in_stream_ >> __value_))
//                __in_stream_ = 0;
//        }
//
//    __QCMP_ALWAYSINLINE const _Tp& operator*() const {return __value_;}
//    __QCMP_ALWAYSINLINE const _Tp* operator->() const {return &(operator*());}
//    __QCMP_ALWAYSINLINE istream_iterator& operator++()
//        {
//            if (!(*__in_stream_ >> __value_))
//                __in_stream_ = 0;
//            return *this;
//        }
//    __QCMP_ALWAYSINLINE istream_iterator  operator++(int)
//        {istream_iterator __t(*this); ++(*this); return __t;}
//
//    friend __QCMP_ALWAYSINLINE
//    bool operator==(const istream_iterator& __x, const istream_iterator& __y)
//        {return __x.__in_stream_ == __y.__in_stream_;}
//
//    friend __QCMP_ALWAYSINLINE
//    bool operator!=(const istream_iterator& __x, const istream_iterator& __y)
//        {return !(__x == __y);}
//};
//
////--------------------------------------------------------------------------------
//template <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >
//class __QOR_INTERFACE( __STDQOR ) ostream_iterator : public iterator< output_iterator_tag, void, void, void, void >
//{
//public:
//    typedef _CharT char_type;
//    typedef _Traits traits_type;
//    typedef basic_ostream<_CharT,_Traits> ostream_type;
//private:
//    ostream_type* __out_stream_;
//    const char_type* __delim_;
//public:
//    __QCMP_ALWAYSINLINE ostream_iterator(ostream_type& __s)
//        : __out_stream_(&__s), __delim_(0) {}
//    __QCMP_ALWAYSINLINE ostream_iterator(ostream_type& __s, const _CharT* __delimiter)
//        : __out_stream_(&__s), __delim_(__delimiter) {}
//    __QCMP_ALWAYSINLINE ostream_iterator& operator=(const _Tp& __value_)
//        {
//            *__out_stream_ << __value_;
//            if (__delim_)
//                *__out_stream_ << __delim_;
//            return *this;
//        }
//
//    __QCMP_ALWAYSINLINE ostream_iterator& operator*()     {return *this;}
//    __QCMP_ALWAYSINLINE ostream_iterator& operator++()    {return *this;}
//    __QCMP_ALWAYSINLINE ostream_iterator& operator++(int) {return *this;}
//};
//
////--------------------------------------------------------------------------------
//template<class _CharT, class _Traits>
//class __QOR_INTERFACE( __STDQOR ) istreambuf_iterator : public iterator< input_iterator_tag, _CharT, typename _Traits::off_type, _CharT*, _CharT >
//{
//public:
//    typedef _CharT                          char_type;
//    typedef _Traits                         traits_type;
//    typedef typename _Traits::int_type      int_type;
//    typedef basic_streambuf<_CharT,_Traits> streambuf_type;
//    typedef basic_istream<_CharT,_Traits>   istream_type;
//private:
//    streambuf_type* __sbuf_;
//
//    class __proxy
//    {
//        char_type __keep_;
//        streambuf_type* __sbuf_;
//        __QCMP_ALWAYSINLINE __proxy(char_type __c, streambuf_type* __s)
//            : __keep_(__c), __sbuf_(__s) {}
//        friend class istreambuf_iterator;
//    public:
//        __QCMP_ALWAYSINLINE char_type operator*() const {return __keep_;}
//    };
//
//    __QCMP_ALWAYSINLINE
//    void __test_for_eof()
//    {
//        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))
//            __sbuf_ = 0;
//    }
//public:
//    __QCMP_ALWAYSINLINE istreambuf_iterator() throw() : __sbuf_(0) {}
//    __QCMP_ALWAYSINLINE istreambuf_iterator(istream_type& __s) throw()
//        : __sbuf_(__s.rdbuf()) {__test_for_eof();}
//    __QCMP_ALWAYSINLINE istreambuf_iterator(streambuf_type* __s) throw()
//        : __sbuf_(__s) {__test_for_eof();}
//    __QCMP_ALWAYSINLINE istreambuf_iterator(const __proxy& __p) throw()
//        : __sbuf_(__p.__sbuf_) {}
//
//    __QCMP_ALWAYSINLINE char_type  operator*() const
//        {return static_cast<char_type>(__sbuf_->sgetc());}
//    __QCMP_ALWAYSINLINE char_type* operator->() const {return nullptr;}
//    __QCMP_ALWAYSINLINE istreambuf_iterator& operator++()
//        {
//            if (traits_type::eq_int_type(__sbuf_->snextc(), traits_type::eof()))
//                __sbuf_ = 0;
//            return *this;
//        }
//    __QCMP_ALWAYSINLINE __proxy              operator++(int)
//        {
//            char_type __c = __sbuf_->sgetc();
//            ++(*this);
//            return __proxy(__c, __sbuf_);
//        }
//
//    __QCMP_ALWAYSINLINE bool equal(const istreambuf_iterator& __b) const
//        {return (__sbuf_ == 0) == (__b.__sbuf_ == 0);}
//};
//
////--------------------------------------------------------------------------------
//template< class _CharT, class _Traits >
//__QCMP_ALWAYSINLINE bool operator == ( const istreambuf_iterator<_CharT,_Traits>& __a, const istreambuf_iterator<_CharT,_Traits>& __b )
//{
//	return __a.equal(__b);
//}
//
////--------------------------------------------------------------------------------
//template <class _CharT, class _Traits>
//__QCMP_ALWAYSINLINE bool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a, const istreambuf_iterator<_CharT,_Traits>& __b)
//{
//	return !__a.equal(__b);
//}
//
////--------------------------------------------------------------------------------
//template <class _CharT, class _Traits>
//class __QOR_INTERFACE( __STDQOR ) ostreambuf_iterator : public iterator<output_iterator_tag, void, void, void, void>
//{
//public:
//    typedef _CharT                          char_type;
//    typedef _Traits                         traits_type;
//    typedef basic_streambuf<_CharT,_Traits> streambuf_type;
//    typedef basic_ostream<_CharT,_Traits>   ostream_type;
//private:
//    streambuf_type* __sbuf_;
//public:
//    __QCMP_ALWAYSINLINE ostreambuf_iterator(ostream_type& __s) throw()
//        : __sbuf_(__s.rdbuf()) {}
//    __QCMP_ALWAYSINLINE ostreambuf_iterator(streambuf_type* __s) throw()
//        : __sbuf_(__s) {}
//    __QCMP_ALWAYSINLINE ostreambuf_iterator& operator=(_CharT __c)
//        {
//            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))
//                __sbuf_ = 0;
//            return *this;
//        }
//    __QCMP_ALWAYSINLINE ostreambuf_iterator& operator*()     {return *this;}
//    __QCMP_ALWAYSINLINE ostreambuf_iterator& operator++()    {return *this;}
//    __QCMP_ALWAYSINLINE ostreambuf_iterator& operator++(int) {return *this;}
//    __QCMP_ALWAYSINLINE bool failed() const throw() {return __sbuf_ == 0;}
//};
//
////--------------------------------------------------------------------------------
//template <class _Iter>
//class __QOR_INTERFACE( __STDQOR ) move_iterator
//{
//private:
//    _Iter __i;
//public:
//    typedef _Iter                                            iterator_type;
//    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
//    typedef typename iterator_traits<iterator_type>::value_type value_type;
//    typedef typename iterator_traits<iterator_type>::difference_type difference_type;
//    typedef typename iterator_traits<iterator_type>::pointer pointer;
//#if	( __QCMP_SUPPORTS( __QCMP_FEATURE_RVALUE_REFERENCES ) )
//    typedef value_type&& reference;
//#else
//    typedef typename iterator_traits<iterator_type>::reference reference;
//#endif
//
//    __QCMP_ALWAYSINLINE move_iterator() : __i() {}
//    __QCMP_ALWAYSINLINE explicit move_iterator(_Iter __x) : __i(__x) {}
//    template <class _Up> __QCMP_ALWAYSINLINE move_iterator(const move_iterator<_Up>& __u)
//        : __i(__u.base()) {}
//    __QCMP_ALWAYSINLINE _Iter base() const {return __i;}
//    __QCMP_ALWAYSINLINE reference operator*() const {
//      return static_cast<reference>(*__i);
//    }
//    __QCMP_ALWAYSINLINE pointer  operator->() const {
//      typename iterator_traits<iterator_type>::reference __ref = *__i;
//      return &__ref;
//    }
//    __QCMP_ALWAYSINLINE move_iterator& operator++() {++__i; return *this;}
//    __QCMP_ALWAYSINLINE move_iterator  operator++(int)
//        {move_iterator __tmp(*this); ++__i; return __tmp;}
//    __QCMP_ALWAYSINLINE move_iterator& operator--() {--__i; return *this;}
//    __QCMP_ALWAYSINLINE move_iterator  operator--(int)
//        {move_iterator __tmp(*this); --__i; return __tmp;}
//    __QCMP_ALWAYSINLINE move_iterator  operator+ (difference_type __n) const
//        {return move_iterator(__i + __n);}
//    __QCMP_ALWAYSINLINE move_iterator& operator+=(difference_type __n)
//        {__i += __n; return *this;}
//    __QCMP_ALWAYSINLINE move_iterator  operator- (difference_type __n) const
//        {return move_iterator(__i - __n);}
//    __QCMP_ALWAYSINLINE move_iterator& operator-=(difference_type __n)
//        {__i -= __n; return *this;}
//    __QCMP_ALWAYSINLINE reference         operator[](difference_type __n) const
//    {
//      return static_cast<reference>(__i[__n]);
//    }
//};
//
////--------------------------------------------------------------------------------
//template <class _Iter1, class _Iter2>
//__QCMP_ALWAYSINLINE bool operator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
//{
//    return __x.base() == __y.base();
//}
//
////--------------------------------------------------------------------------------
//template <class _Iter1, class _Iter2>
//__QCMP_ALWAYSINLINE bool operator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
//{
//    return __x.base() < __y.base();
//}
//
////--------------------------------------------------------------------------------
//template <class _Iter1, class _Iter2>
//__QCMP_ALWAYSINLINE bool operator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
//{
//    return __x.base() != __y.base();
//}
//
////--------------------------------------------------------------------------------
//template <class _Iter1, class _Iter2>
//__QCMP_ALWAYSINLINE bool operator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
//{
//    return __x.base() > __y.base();
//}
//
////--------------------------------------------------------------------------------
//template <class _Iter1, class _Iter2>
//__QCMP_ALWAYSINLINE bool operator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
//{
//    return __x.base() >= __y.base();
//}
//
////--------------------------------------------------------------------------------
//template <class _Iter1, class _Iter2>
//__QCMP_ALWAYSINLINE bool operator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
//{
//    return __x.base() <= __y.base();
//}
//
////--------------------------------------------------------------------------------
//template <class _Iter1, class _Iter2>
//__QCMP_ALWAYSINLINE typename move_iterator<_Iter1>::difference_type operator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
//{
//    return __x.base() - __y.base();
//}
//
////--------------------------------------------------------------------------------
//template <class _Iter>
//__QCMP_ALWAYSINLINE move_iterator<_Iter> operator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)
//{
//    return move_iterator<_Iter>(__x.base() + __n);
//}
//
////--------------------------------------------------------------------------------
//template <class _Iter>
//__QCMP_ALWAYSINLINE move_iterator<_Iter> make_move_iterator(const _Iter& __i)
//{
//    return move_iterator<_Iter>(__i);
//}
//
//// __wrap_iter
//
//template <class _Iter> class __wrap_iter;
//
//template <class _Iter1, class _Iter2>
//bool operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) __QCMP_THROW;
//
//template <class _Iter1, class _Iter2>
//bool operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) __QCMP_THROW;
//
//template <class _Iter1, class _Iter2>
//bool operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) __QCMP_THROW;
//
//template <class _Iter1, class _Iter2>
//bool operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) __QCMP_THROW;
//
//template <class _Iter1, class _Iter2>
//bool operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) __QCMP_THROW;
//
//template <class _Iter1, class _Iter2>
//bool operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) __QCMP_THROW;
//
//template <class _Iter1, class _Iter2>
//typename __wrap_iter<_Iter1>::difference_type
//operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) __QCMP_THROW;
//
//template <class _Iter>
//__wrap_iter<_Iter> operator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) __QCMP_THROW;
//
//template <class _Ip, class _Op> _Op copy(_Ip, _Ip, _Op);
//template <class _B1, class _B2> _B2 copy_backward(_B1, _B1, _B2);
//template <class _Ip, class _Op> _Op move(_Ip, _Ip, _Op);
//template <class _B1, class _B2> _B2 move_backward(_B1, _B1, _B2);
//
//template <class _Tp>
//typename enable_if< is_trivially_copy_assignable< _Tp >::value, _Tp* >::type __unwrap_iter( __wrap_iter< _Tp* > );
//
////--------------------------------------------------------------------------------
//template< class _Iter >
//class __wrap_iter
//{
//public:
//    typedef _Iter                                                      iterator_type;
//    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
//    typedef typename iterator_traits<iterator_type>::value_type        value_type;
//    typedef typename iterator_traits<iterator_type>::difference_type   difference_type;
//    typedef typename iterator_traits<iterator_type>::pointer           pointer;
//    typedef typename iterator_traits<iterator_type>::reference         reference;
//private:
//    iterator_type __i;
//public:
//    __QCMP_ALWAYSINLINE __wrap_iter() __QCMP_THROW
//    {
//#if _LIBCPP_DEBUG_LEVEL >= 2
//        __get_db()->__insert_i(this);
//#endif
//    }
//    template <class _Up> __QCMP_ALWAYSINLINE __wrap_iter(const __wrap_iter<_Up>& __u,
//        typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) __QCMP_THROW
//        : __i(__u.base())
//    {
//#if _LIBCPP_DEBUG_LEVEL >= 2
//        __get_db()->__iterator_copy(this, &__u);
//#endif
//    }
//#if _LIBCPP_DEBUG_LEVEL >= 2
//    __QCMP_ALWAYSINLINE
//    __wrap_iter(const __wrap_iter& __x)
//        : __i(__x.base())
//    {
//        __get_db()->__iterator_copy(this, &__x);
//    }
//    __QCMP_ALWAYSINLINE
//    __wrap_iter& operator=(const __wrap_iter& __x)
//    {
//        if (this != &__x)
//        {
//            __get_db()->__iterator_copy(this, &__x);
//            __i = __x.__i;
//        }
//        return *this;
//    }
//    __QCMP_ALWAYSINLINE
//    ~__wrap_iter()
//    {
//        __get_db()->__erase_i(this);
//    }
//#endif
//    __QCMP_ALWAYSINLINE reference operator*() const __QCMP_THROW
//    {
//#if _LIBCPP_DEBUG_LEVEL >= 2
//        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),
//                       "Attempted to dereference a non-dereferenceable iterator");
//#endif
//        return *__i;
//    }
//    __QCMP_ALWAYSINLINE pointer  operator->() const __QCMP_THROW {return &(operator*());}
//    __QCMP_ALWAYSINLINE __wrap_iter& operator++() __QCMP_THROW
//    {
//#if _LIBCPP_DEBUG_LEVEL >= 2
//        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),
//                       "Attempted to increment non-incrementable iterator");
//#endif
//        ++__i;
//        return *this;
//    }
//    __QCMP_ALWAYSINLINE __wrap_iter  operator++(int) __QCMP_THROW
//        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}
//    __QCMP_ALWAYSINLINE __wrap_iter& operator--() __QCMP_THROW
//    {
//#if _LIBCPP_DEBUG_LEVEL >= 2
//        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),
//                       "Attempted to decrement non-decrementable iterator");
//#endif
//        --__i;
//        return *this;
//    }
//    __QCMP_ALWAYSINLINE __wrap_iter  operator--(int) __QCMP_THROW
//        {__wrap_iter __tmp(*this); --(*this); return __tmp;}
//    __QCMP_ALWAYSINLINE __wrap_iter  operator+ (difference_type __n) const __QCMP_THROW
//        {__wrap_iter __w(*this); __w += __n; return __w;}
//    __QCMP_ALWAYSINLINE __wrap_iter& operator+=(difference_type __n) __QCMP_THROW
//    {
//#if _LIBCPP_DEBUG_LEVEL >= 2
//        _LIBCPP_ASSERT(__get_const_db()->__addable(this, __n),
//                   "Attempted to add/subtract iterator outside of valid range");
//#endif
//        __i += __n;
//        return *this;
//    }
//    __QCMP_ALWAYSINLINE __wrap_iter  operator- (difference_type __n) const __QCMP_THROW
//        {return *this + (-__n);}
//    __QCMP_ALWAYSINLINE __wrap_iter& operator-=(difference_type __n) __QCMP_THROW
//        {*this += -__n; return *this;}
//    __QCMP_ALWAYSINLINE reference        operator[](difference_type __n) const __QCMP_THROW
//    {
//#if _LIBCPP_DEBUG_LEVEL >= 2
//        _LIBCPP_ASSERT(__get_const_db()->__subscriptable(this, __n),
//                   "Attempted to subscript iterator outside of valid range");
//#endif
//        return __i[__n];
//    }
//
//    __QCMP_ALWAYSINLINE iterator_type base() const __QCMP_THROW {return __i;}
//
//private:
//    __QCMP_ALWAYSINLINE __wrap_iter(iterator_type __x) __QCMP_THROW : __i(__x) {}
//#if _LIBCPP_DEBUG_LEVEL >= 2
//    __QCMP_ALWAYSINLINE __wrap_iter(const void* __p, iterator_type __x) : __i(__x)
//    {
//        __get_db()->__insert_ic(this, __p);
//    }
//#endif
//
//    template <class _Up> friend class __wrap_iter;
//    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;
//    template <class _Tp, class _Alloc> friend class vector;
//
//    template <class _Iter1, class _Iter2>
//    friend
//    bool
//    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) __QCMP_THROW;
//
//    template <class _Iter1, class _Iter2>
//    friend
//    bool
//    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) __QCMP_THROW;
//
//    template <class _Iter1, class _Iter2>
//    friend
//    bool
//    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) __QCMP_THROW;
//
//    template <class _Iter1, class _Iter2>
//    friend
//    bool
//    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) __QCMP_THROW;
//
//    template <class _Iter1, class _Iter2>
//    friend
//    bool
//    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) __QCMP_THROW;
//
//    template <class _Iter1, class _Iter2>
//    friend
//    bool
//    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) __QCMP_THROW;
//
//    template <class _Iter1, class _Iter2>
//    friend
//    typename __wrap_iter<_Iter1>::difference_type
//    operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) __QCMP_THROW;
//
//    template <class _Iter1>
//    friend
//    __wrap_iter<_Iter1>
//    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) __QCMP_THROW;
//
//    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);
//    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);
//    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);
//    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);
//
//    template <class _Tp>
//    friend
//    typename enable_if
//    <
//        is_trivially_copy_assignable<_Tp>::value,
//        _Tp*
//    >::type
//    __unwrap_iter(__wrap_iter<_Tp*>);
//};
//
////--------------------------------------------------------------------------------
//template < class _Iter1, class _Iter2 >
//__QCMP_ALWAYSINLINE bool operator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) __QCMP_THROW
//{
//#if _LIBCPP_DEBUG_LEVEL >= 2
//    _LIBCPP_ASSERT(__get_const_db()->__comparable(&__x, &__y),
//                   "Attempted to compare incomparable iterators");
//#endif
//    return __x.base() == __y.base();
//}
//
////--------------------------------------------------------------------------------
//template <class _Iter1, class _Iter2>
//__QCMP_ALWAYSINLINE bool operator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) __QCMP_THROW
//{
//#if _LIBCPP_DEBUG_LEVEL >= 2
//    _LIBCPP_ASSERT(__get_const_db()->__comparable(&__x, &__y),
//                   "Attempted to compare incomparable iterators");
//#endif
//    return __x.base() < __y.base();
//}
//
////--------------------------------------------------------------------------------
//template <class _Iter1, class _Iter2>
//__QCMP_ALWAYSINLINE bool operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) __QCMP_THROW
//{
//    return !(__x == __y);
//}
//
////--------------------------------------------------------------------------------
//template <class _Iter1, class _Iter2>
//__QCMP_ALWAYSINLINE bool operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) __QCMP_THROW
//{
//    return __y < __x;
//}
//
////--------------------------------------------------------------------------------
//template <class _Iter1, class _Iter2>
//__QCMP_ALWAYSINLINE bool operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) __QCMP_THROW
//{
//    return !(__x < __y);
//}
//
////--------------------------------------------------------------------------------
//template <class _Iter1, class _Iter2>
//__QCMP_ALWAYSINLINE bool operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) __QCMP_THROW
//{
//    return !(__y < __x);
//}
//
////--------------------------------------------------------------------------------
//template <class _Iter1, class _Iter2>
//__QCMP_ALWAYSINLINE typename __wrap_iter<_Iter1>::difference_type operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) __QCMP_THROW
//{
//#if _LIBCPP_DEBUG_LEVEL >= 2
//    _LIBCPP_ASSERT(__get_const_db()->__comparable(&__x, &__y),
//                   "Attempted to subtract incompatible iterators");
//#endif
//    return __x.base() - __y.base();
//}
//
////--------------------------------------------------------------------------------
//template <class _Iter>
//__QCMP_ALWAYSINLINE __wrap_iter<_Iter> operator+(typename __wrap_iter<_Iter>::difference_type __n,
//          __wrap_iter<_Iter> __x) __QCMP_THROW
//{
//    __x += __n;
//    return __x;
//}
//
//#ifndef NDEBUG
//
//// __debug_iter
//
//template <class _Container, class _Iter> class __debug_iter;
//
//template <class _Container, class _Iter1, class _Iter2>
//bool operator==(const __debug_iter<_Container, _Iter1>&, const __debug_iter<_Container, _Iter2>&);
//
//template <class _Container, class _Iter1, class _Iter2>
//bool operator<(const __debug_iter<_Container, _Iter1>&, const __debug_iter<_Container, _Iter2>&);
//
//template <class _Container, class _Iter1, class _Iter2>
//bool operator!=(const __debug_iter<_Container, _Iter1>&, const __debug_iter<_Container, _Iter2>&);
//
//template <class _Container, class _Iter1, class _Iter2>
//bool operator>(const __debug_iter<_Container, _Iter1>&, const __debug_iter<_Container, _Iter2>&);
//
//template <class _Container, class _Iter1, class _Iter2>
//bool operator>=(const __debug_iter<_Container, _Iter1>&, const __debug_iter<_Container, _Iter2>&);
//
//template <class _Container, class _Iter1, class _Iter2>
//bool operator<=(const __debug_iter<_Container, _Iter1>&, const __debug_iter<_Container, _Iter2>&);
//
//template <class _Container, class _Iter1, class _Iter2>
//typename __debug_iter<_Container, _Iter1>::difference_type
//operator-(const __debug_iter<_Container, _Iter1>&, const __debug_iter<_Container, _Iter2>&);
//
//template <class _Container, class _Iter>
//__debug_iter<_Container, _Iter>
//operator+(typename __debug_iter<_Container, _Iter>::difference_type, const __debug_iter<_Container, _Iter>&);
//
////--------------------------------------------------------------------------------
//template <class _Container, class _Iter>
//class __debug_iter
//{
//public:
//    typedef _Iter                                                      iterator_type;
//    typedef _Container                                                 __container_type;
//    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
//    typedef typename iterator_traits<iterator_type>::value_type        value_type;
//    typedef typename iterator_traits<iterator_type>::difference_type   difference_type;
//    typedef typename iterator_traits<iterator_type>::pointer           pointer;
//    typedef typename iterator_traits<iterator_type>::reference         reference;
//private:
//    iterator_type __i;
//    __debug_iter* __next;
//    __container_type* __cont;
//
//public:
//    __QCMP_ALWAYSINLINE __debug_iter() : __next(0), __cont(0) {}
//    __QCMP_ALWAYSINLINE __debug_iter(const __debug_iter& __x)
//        : __i(__x.base()), __next(0), __cont(0) {__set_owner(__x.__cont);}
//    __debug_iter& operator=(const __debug_iter& __x);
//    template <class _Up> __QCMP_ALWAYSINLINE __debug_iter(const __debug_iter<_Container, _Up>& __u,
//        typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0)
//        : __i(__u.base()), __next(0), __cont(0) {__set_owner(__u.__cont);}
//    __QCMP_ALWAYSINLINE ~__debug_iter() {__remove_owner();}
//    __QCMP_ALWAYSINLINE reference operator*() const {assert(__is_deref()); return *__i;}
//    __QCMP_ALWAYSINLINE pointer  operator->() const {return &(operator*());}
//    __QCMP_ALWAYSINLINE __debug_iter& operator++() {assert(__can_increment()); ++__i; return *this;}
//    __QCMP_ALWAYSINLINE __debug_iter  operator++(int)
//        {__debug_iter __tmp(*this); operator++(); return __tmp;}
//    __QCMP_ALWAYSINLINE __debug_iter& operator--() {assert(__can_decrement()); --__i; return *this;}
//    __QCMP_ALWAYSINLINE __debug_iter  operator--(int)
//        {__debug_iter __tmp(*this); operator--(); return __tmp;}
//    __QCMP_ALWAYSINLINE __debug_iter  operator+ (difference_type __n) const
//        {__debug_iter __t(*this); __t += __n; return __t;}
//    __debug_iter& operator+=(difference_type __n);
//    __QCMP_ALWAYSINLINE __debug_iter  operator- (difference_type __n) const
//        {__debug_iter __t(*this); __t -= __n; return __t;}
//    __QCMP_ALWAYSINLINE __debug_iter& operator-=(difference_type __n)
//        {*this += -__n; return *this;}
//    __QCMP_ALWAYSINLINE reference        operator[](difference_type __n) const
//        {return *(*this + __n);}
//
//private:
//    __QCMP_ALWAYSINLINE __debug_iter(const __container_type* __c, iterator_type __x)
//        : __i(__x), __next(0), __cont(0) {__set_owner(__c);}
//    __QCMP_ALWAYSINLINE iterator_type base() const {return __i;}
//
//    void __set_owner(const __container_type* __c);
//    void __remove_owner();
//    static void __remove_all(__container_type* __c);
//    static void swap(__container_type* __x, __container_type* __y);
//
//    __QCMP_ALWAYSINLINE bool __is_deref() const
//        {return __is_deref(__is_random_access_iterator<iterator_type>());}
//    bool __is_deref(false_type) const;
//    bool __is_deref(true_type) const;
//    __QCMP_ALWAYSINLINE bool __can_decrement() const
//        {return __can_decrement(integral_constant<int, is_pointer<iterator_type>::value ? 2:
//                                                       __is_random_access_iterator<iterator_type>::value ? 1 : 0>());}
//    bool __can_decrement(integral_constant<int, 0>) const;
//    bool __can_decrement(integral_constant<int, 1>) const;
//    bool __can_decrement(integral_constant<int, 2>) const;
//    __QCMP_ALWAYSINLINE bool __can_increment() const
//        {return __can_increment(integral_constant<int, is_pointer<iterator_type>::value ? 2:
//                                                       __is_random_access_iterator<iterator_type>::value ? 1 : 0>());}
//    bool __can_increment(integral_constant<int, 0>) const;
//    bool __can_increment(integral_constant<int, 1>) const;
//    bool __can_increment(integral_constant<int, 2>) const;
//
//    __QCMP_ALWAYSINLINE bool __can_add(difference_type __n) const
//        {return __can_add(__n, is_pointer<iterator_type>());}
//    bool __can_add(difference_type __n, false_type) const;
//    bool __can_add(difference_type __n, true_type) const;
//
//    template <class _Cp, class _Up> friend class __debug_iter;
//    friend typename _Container::__self;
//
//    template <class _Cp, class _Iter1, class _Iter2>
//    friend bool operator==(const __debug_iter<_Cp, _Iter1>&, const __debug_iter<_Cp, _Iter2>&);
//
//    template <class _Cp, class _Iter1, class _Iter2>
//    friend bool operator<(const __debug_iter<_Cp, _Iter1>&, const __debug_iter<_Cp, _Iter2>&);
//
//    template <class _Cp, class _Iter1, class _Iter2>
//    friend bool operator!=(const __debug_iter<_Cp, _Iter1>&, const __debug_iter<_Cp, _Iter2>&);
//
//    template <class _Cp, class _Iter1, class _Iter2>
//    friend bool operator>(const __debug_iter<_Cp, _Iter1>&, const __debug_iter<_Cp, _Iter2>&);
//
//    template <class _Cp, class _Iter1, class _Iter2>
//    friend bool operator>=(const __debug_iter<_Cp, _Iter1>&, const __debug_iter<_Cp, _Iter2>&);
//
//    template <class _Cp, class _Iter1, class _Iter2>
//    friend bool operator<=(const __debug_iter<_Cp, _Iter1>&, const __debug_iter<_Cp, _Iter2>&);
//
//    template <class _Cp, class _Iter1, class _Iter2>
//    friend typename __debug_iter<_Cp, _Iter1>::difference_type operator-(const __debug_iter<_Cp, _Iter1>&, const __debug_iter<_Cp, _Iter2>&);
//
//    template <class _Cp, class _Iter1>
//    friend __debug_iter<_Cp, _Iter1> operator+(typename __debug_iter<_Cp, _Iter1>::difference_type, const __debug_iter<_Cp, _Iter1>&);
//};
//
////--------------------------------------------------------------------------------
//template <class _Container, class _Iter>
//__debug_iter<_Container, _Iter>&
//__debug_iter<_Container, _Iter>::operator=(const __debug_iter& __x)
//{
//    if (this != &__x)
//    {
//        __remove_owner();
//        __i = __x.__i;
//        __set_owner(__x.__cont);
//    }
//    return *this;
//}
//
////--------------------------------------------------------------------------------
//template <class _Container, class _Iter>
//void
//__debug_iter<_Container, _Iter>::__set_owner(const __container_type* __c)
//{
//    __cont = const_cast<__container_type*>(__c);
//    __debug_iter*& __head = __cont->__get_iterator_list(this);
//    __next = __head;
//    __head = this;
//}
//
////--------------------------------------------------------------------------------
//template <class _Container, class _Iter>
//void
//__debug_iter<_Container, _Iter>::__remove_owner()
//{
//    if (__cont)
//    {
//        __debug_iter*& __head = __cont->__get_iterator_list(this);
//        if (__head == this)
//            __head = __next;
//        else
//        {
//            __debug_iter* __prev = __head;
//            for (__debug_iter* __p = __head->__next; __p != this; __p = __p->__next)
//                __prev = __p;
//            __prev->__next = __next;
//        }
//        __cont = 0;
//    }
//}
//
////--------------------------------------------------------------------------------
//template <class _Container, class _Iter>
//void __debug_iter<_Container, _Iter>::__remove_all(__container_type* __c)
//{
//    __debug_iter*& __head = __c->__get_iterator_list((__debug_iter*)0);
//    __debug_iter* __p = __head;
//    __head = 0;
//    while (__p)
//    {
//        __p->__cont = 0;
//        __debug_iter* __n = __p->__next;
//        __p->__next = 0;
//        __p = __n;
//    }
//}
//
////--------------------------------------------------------------------------------
//template <class _Container, class _Iter>
//void __debug_iter<_Container, _Iter>::swap(__container_type* __x, __container_type* __y)
//{
//    __debug_iter*& __head_x = __x->__get_iterator_list((__debug_iter*)0);
//    __debug_iter*& __head_y = __y->__get_iterator_list((__debug_iter*)0);
//    __debug_iter* __p = __head_x;
//    __head_x = __head_y;
//    __head_y = __p;
//    for (__p = __head_x; __p; __p = __p->__next)
//        __p->__cont = __x;
//    for (__p = __head_y; __p; __p = __p->__next)
//        __p->__cont = __y;
//}
//
////--------------------------------------------------------------------------------
//template <class _Container, class _Iter>
//bool __debug_iter<_Container, _Iter>::__is_deref(false_type) const
//{
//    if (__cont == 0)
//        return false;
//    return __i != __cont->end().base();
//}
//
////--------------------------------------------------------------------------------
//template <class _Container, class _Iter>
//bool __debug_iter<_Container, _Iter>::__is_deref(true_type) const
//{
//    if (__cont == 0)
//        return false;
//    return __i < __cont->end().base();
//}
//
////--------------------------------------------------------------------------------
//template <class _Container, class _Iter>
//bool __debug_iter<_Container, _Iter>::__can_decrement(integral_constant<int, 0>) const
//{
//    if (__cont == 0)
//        return false;
//    return __i != __cont->begin().base();
//}
//
////--------------------------------------------------------------------------------
//template <class _Container, class _Iter>
//bool __debug_iter<_Container, _Iter>::__can_decrement(integral_constant<int, 1>) const
//{
//    if (__cont == 0)
//        return false;
//    iterator_type __b = __cont->begin().base();
//    return __b < __i && __i <= __b + __cont->size();
//}
//
////--------------------------------------------------------------------------------
//template <class _Container, class _Iter>
//bool __debug_iter<_Container, _Iter>::__can_decrement(integral_constant<int, 2>) const
//{
//    if (__cont == 0)
//        return false;
//    iterator_type __b = __cont->begin().base();
//    return __b < __i && __i <= __b + __cont->size();
//}
//
////--------------------------------------------------------------------------------
//template <class _Container, class _Iter>
//bool __debug_iter<_Container, _Iter>::__can_increment(integral_constant<int, 0>) const
//{
//    if (__cont == 0)
//        return false;
//    return __i != __cont->end().base();
//}
//
////--------------------------------------------------------------------------------
//template <class _Container, class _Iter>
//bool __debug_iter<_Container, _Iter>::__can_increment(integral_constant<int, 1>) const
//{
//    if (__cont == 0)
//        return false;
//    iterator_type __b = __cont->begin().base();
//    return __b <= __i && __i < __b + __cont->size();
//}
//
////--------------------------------------------------------------------------------
//template <class _Container, class _Iter>
//bool __debug_iter<_Container, _Iter>::__can_increment(integral_constant<int, 2>) const
//{
//    if (__cont == 0)
//        return false;
//    iterator_type __b = __cont->begin().base();
//    return __b <= __i && __i < __b + __cont->size();
//}
//
////--------------------------------------------------------------------------------
//template <class _Container, class _Iter>
//bool __debug_iter<_Container, _Iter>::__can_add(difference_type __n, false_type) const
//{
//    if (__cont == 0)
//        return false;
//    iterator_type __b = __cont->begin().base();
//    iterator_type __j = __i + __n;
//    return __b <= __j && __j <= __b + __cont->size();
//}
//
////--------------------------------------------------------------------------------
//template <class _Container, class _Iter>
//bool __debug_iter<_Container, _Iter>::__can_add(difference_type __n, true_type) const
//{
//    if (__cont == 0)
//        return false;
//    iterator_type __b = __cont->begin().base();
//    iterator_type __j = __i + __n;
//    return __b <= __j && __j <= __b + __cont->size();
//}
//
////--------------------------------------------------------------------------------
//template <class _Container, class _Iter>
//__debug_iter<_Container, _Iter>&
//__debug_iter<_Container, _Iter>::operator+=(difference_type __n)
//{
//    assert(__can_add(__n));
//    __i += __n;
//    return *this;
//}
//
////--------------------------------------------------------------------------------
//template <class _Container, class _Iter1, class _Iter2>
//__QCMP_ALWAYSINLINE bool operator==(const __debug_iter<_Container, _Iter1>& __x, const __debug_iter<_Container, _Iter2>& __y)
//{
//    assert(__x.__cont && __x.__cont == __y.__cont);
//    return __x.base() == __y.base();
//}
//
////--------------------------------------------------------------------------------
//template <class _Container, class _Iter1, class _Iter2>
//__QCMP_ALWAYSINLINE bool operator!=(const __debug_iter<_Container, _Iter1>& __x, const __debug_iter<_Container, _Iter2>& __y)
//{
//    return !(__x == __y);
//}
//
////--------------------------------------------------------------------------------
//template <class _Container, class _Iter1, class _Iter2>
//__QCMP_ALWAYSINLINE bool operator<(const __debug_iter<_Container, _Iter1>& __x, const __debug_iter<_Container, _Iter2>& __y)
//{
//    assert(__x.__cont && __x.__cont == __y.__cont);
//    return __x.base() < __y.base();
//}
//
////--------------------------------------------------------------------------------
//template <class _Container, class _Iter1, class _Iter2>
//__QCMP_ALWAYSINLINE bool operator>(const __debug_iter<_Container, _Iter1>& __x, const __debug_iter<_Container, _Iter2>& __y)
//{
//    return __y < __x;
//}
//
////--------------------------------------------------------------------------------
//template <class _Container, class _Iter1, class _Iter2>
//__QCMP_ALWAYSINLINE bool operator>=(const __debug_iter<_Container, _Iter1>& __x, const __debug_iter<_Container, _Iter2>& __y)
//{
//    return !(__x < __y);
//}
//
////--------------------------------------------------------------------------------
//template <class _Container, class _Iter1, class _Iter2>
//__QCMP_ALWAYSINLINE bool operator<=(const __debug_iter<_Container, _Iter1>& __x, const __debug_iter<_Container, _Iter2>& __y)
//{
//    return !(__y < __x);
//}
//
////--------------------------------------------------------------------------------
//template <class _Container, class _Iter1, class _Iter2>
//__QCMP_ALWAYSINLINE typename __debug_iter<_Container, _Iter1>::difference_type
//operator-(const __debug_iter<_Container, _Iter1>& __x, const __debug_iter<_Container, _Iter2>& __y)
//{
//    assert(__x.__cont && __x.__cont == __y.__cont);
//    return __x.base() - __y.base();
//}
//
////--------------------------------------------------------------------------------
//template <class _Container, class _Iter>
//__QCMP_ALWAYSINLINE __debug_iter<_Container, _Iter> operator+(typename __debug_iter<_Container, _Iter>::difference_type __n, const __debug_iter<_Container, _Iter>& __x)
//{
//    return __x + __n;
//}
//
//#endif  // NDEBUG
//
//#if (__QCMP_SUPPORTS( __QCMP_FEATURE_RVALUE_REFERENCES )) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)
//
////--------------------------------------------------------------------------------
//template <class _Cp>
//__QCMP_ALWAYSINLINE auto begin(_Cp& __c) -> decltype(__c.begin())
//{
//    return __c.begin();
//}
//
////--------------------------------------------------------------------------------
//template <class _Cp>
//__QCMP_ALWAYSINLINE auto begin(const _Cp& __c) -> decltype(__c.begin())
//{
//    return __c.begin();
//}
//
////--------------------------------------------------------------------------------
//template <class _Cp>
//__QCMP_ALWAYSINLINE auto end(_Cp& __c) -> decltype(__c.end())
//{
//    return __c.end();
//}
//
////--------------------------------------------------------------------------------
//template <class _Cp>
//__QCMP_ALWAYSINLINE auto end(const _Cp& __c) -> decltype(__c.end())
//{
//    return __c.end();
//}
//
//#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)
//
////--------------------------------------------------------------------------------
//template <class _Cp>
//__QCMP_ALWAYSINLINE typename _Cp::iterator begin(_Cp& __c)
//{
//    return __c.begin();
//}
//
////--------------------------------------------------------------------------------
//template <class _Cp>
//__QCMP_ALWAYSINLINE typename _Cp::const_iterator begin(const _Cp& __c)
//{
//    return __c.begin();
//}
//
////--------------------------------------------------------------------------------
//template <class _Cp>
//__QCMP_ALWAYSINLINE typename _Cp::iterator end(_Cp& __c)
//{
//    return __c.end();
//}
//
////--------------------------------------------------------------------------------
//template <class _Cp>
//__QCMP_ALWAYSINLINE typename _Cp::const_iterator end(const _Cp& __c)
//{
//    return __c.end();
//}
//
//#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)
//
////--------------------------------------------------------------------------------
//template <class _Tp, size_t _Np>
//__QCMP_ALWAYSINLINE _Tp* begin( _Tp ( &__array )[ _Np ])
//{
//    return __array;
//}
//
////--------------------------------------------------------------------------------
//template <class _Tp, size_t _Np>
//__QCMP_ALWAYSINLINE _Tp* end( _Tp ( &__array )[ _Np ] )
//{
//    return __array + _Np;
//}
//
//};//namespace std
//
//#endif  // _LIBCPP_ITERATOR
