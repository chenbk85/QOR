//Basepthread.h

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Base CRT class for POSIX threads

#ifndef SYSTEMQOR_POSIX_PTHREAD_H_3
#define SYSTEMQOR_POSIX_PTHREAD_H_3

#include "SystemQOR.h"
#include QOR_SYS_PLATFORMTYPES(pthread)
#include "CodeQOR/ClassReg/ClassRegEntry.h"

//--------------------------------------------------------------------------------
namespace nsBaseCRT
{
	using nsPlatform::pthread_attr_t;
	using nsPlatform::pthread_barrier_t;
	using nsPlatform::sched_param;
	using nsPlatform::pthread_barrierattr_t;
	using nsPlatform::pthread_t;
	using nsPlatform::clockid_t;
	using nsPlatform::pthread_key_t;
	using nsPlatform::pthread_cond_t;
	using nsPlatform::pthread_condattr_t;
	using nsPlatform::pthread_mutex_t;
	using nsPlatform::timespec;
	using nsPlatform::pthread_mutexattr_t;
	using nsPlatform::pthread_once_t;
	using nsPlatform::pthread_rwlock_t;
	using nsPlatform::pthread_rwlockattr_t;
	using nsPlatform::pthread_spinlock_t;
	using nsPlatform::sem_t;

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE( __QSYS ) Cpthread
	{
	
	public:

		__QOR_DECLARE_OCLASS_ID( Cpthread );
		
		virtual int atfork( void (*)(void), void (*)(void), void(*)(void) );
		virtual int attr_destroy( pthread_attr_t* p_pthread_attr );
		virtual int attr_getdetachstate( const pthread_attr_t* p_pthread_attr, int* pDetachState );
		virtual int attr_getguardsize( const pthread_attr_t* p_pthread_attr, size_t* guardsize );
		virtual int attr_getinheritsched( const pthread_attr_t* p_pthread_attr, int* inheritsched );
		virtual int attr_getschedparam( const pthread_attr_t* p_pthread_attr, sched_param* param );
		virtual int attr_getschedpolicy( const pthread_attr_t* p_pthread_attr, int* policy );
		virtual int attr_getscope( const pthread_attr_t* p_pthread_attr, int* contentionscope );
		virtual int attr_getstack( const pthread_attr_t* p_pthread_attr, void** stackaddr, size_t* stacksize );
		virtual int attr_getstackaddr( const pthread_attr_t* p_pthread_attr, void** stackaddr );
		virtual int attr_getstacksize( const pthread_attr_t* p_pthread_attr, size_t* stacksize );
		virtual int attr_init( pthread_attr_t* p_pthread_attr );
		virtual int attr_setdetachstate( pthread_attr_t* p_pthread_attr, int iDetachState );
		virtual int attr_setguardsize( pthread_attr_t* p_pthread_attr, size_t guardsize );
		virtual int attr_setinheritsched( pthread_attr_t* p_pthread_attr, int inheritsched );
		virtual int attr_setschedparam( pthread_attr_t* p_pthread_attr, const sched_param* param );
		virtual int attr_setschedpolicy( pthread_attr_t* p_pthread_attr, int iPolicy );
		virtual int attr_setscope( pthread_attr_t* p_pthread_attr, int iContentionScope );
		virtual int attr_setstack( pthread_attr_t* p_pthread_attr, void* stackaddr, size_t stacksize );
		virtual int attr_setstackaddr( pthread_attr_t* p_pthread_attr, void* pStackAddr );
		virtual int attr_setstacksize( pthread_attr_t* p_pthread_attr, size_t StackSize );

		virtual int barrier_destroy( pthread_barrier_t* p_pthread_barrier );
		virtual int barrier_init( pthread_barrier_t* pp_barrier, const pthread_barrierattr_t* pp_barrier_attr, unsigned uiCount );
		virtual int barrier_wait( pthread_barrier_t* pp_barrier );

		virtual int barrierattr_destroy( pthread_barrierattr_t* pp_barrierattr );
		virtual int barrierattr_getpshared( const pthread_barrierattr_t* pp_barrierattr, int* p_pshared );
		virtual int barrierattr_init( pthread_barrierattr_t* pp_barrierattr );
		virtual int barrierattr_setpshared( pthread_barrierattr_t* pp_barrierattr, int iPShared );

		virtual int cancel( pthread_t hpthread );
		//virtual int cleanup_push( void ( *routine )(void *), void* arg );
		//virtual int cleanup_pop( int iExecute );
		virtual int create( pthread_t* phThread, const pthread_attr_t* pp_threadattr, void *(*start_routine)(void *), void* arg );
		virtual int detach( pthread_t hThread );
		virtual int equal( pthread_t hThread1, pthread_t hThread2 );
		virtual void exit( void* value_ptr );
		virtual int getconcurrency( void );
		virtual int getcpuclockid( pthread_t hThread, clockid_t* pClockId );
		virtual int getschedparam( pthread_t hThread, int* pPolicy, sched_param* pParam );
		virtual void* getspecific( pthread_key_t p_pthreadkey );
		virtual int join( pthread_t hThread, void** ppValue );
		virtual pthread_t self( void );
		virtual int setcancelstate( int iState, int* piOldState );
		virtual int setcanceltype( int iType, int* piOldType );
		virtual int setconcurrency( int iConcurrency );
		virtual int setschedparam( pthread_t hThread, int iPolicy, const sched_param* pParam );
		virtual int setschedprio( pthread_t hThread, int iPriority );
		virtual int setspecific( pthread_key_t key, const void* pValue );
		virtual void testcancel( void );

		virtual int key_create( pthread_key_t* pp_pthreadkey, void (*destructor)(void *) );
		virtual int key_delete( pthread_key_t p_pthreadkey );

		virtual int cond_broadcast( pthread_cond_t* pp_pthread_cond );
		virtual int cond_destroy( pthread_cond_t* pp_pthread_cond );
		virtual int cond_init( pthread_cond_t* pp_pthread_cond, const pthread_condattr_t* pp_pthread_condattr );
		virtual int cond_signal( pthread_cond_t* pp_pthread_cond );
		virtual int cond_timedwait( pthread_cond_t* pp_pthread_cond, pthread_mutex_t* pp_pthread_mutex, const timespec* ptimespec );
		virtual int cond_wait( pthread_cond_t* pp_pthread_cond, pthread_mutex_t* pp_pthread_mutex );

		virtual int condattr_destroy( pthread_condattr_t* pp_pthread_condattr );
		virtual int condattr_getclock( const pthread_condattr_t* pp_pthread_condattr, clockid_t* pClockId );
		virtual int condattr_getpshared( const pthread_condattr_t* pp_pthread_condattr, int* piPShared );
		virtual int condattr_init( pthread_condattr_t* pp_pthread_condattr );
		virtual int condattr_setclock( pthread_condattr_t* pp_pthread_condattr, clockid_t ClockId );
		virtual int condattr_setpshared( pthread_condattr_t* pp_pthread_condattr, int iPShared );

		virtual int mutex_consistent( pthread_mutex_t* pp_pthreadmutex );
		virtual int mutex_destroy( pthread_mutex_t* pp_pthreadmutex );
		virtual int mutex_getprioceiling( const pthread_mutex_t* pp_pthreadmutex, int* pPrioCeiling );
		virtual int mutex_init( pthread_mutex_t* pp_pthreadmutex, const pthread_mutexattr_t* pp_pthreadmutexattr );
		virtual int mutex_lock( pthread_mutex_t* pp_pthreadmutex );
		virtual int mutex_setprioceiling( pthread_mutex_t* pp_pthreadmutex, int iPrioCeiling, int* pOldCieling );
		virtual int mutex_timedlock( pthread_mutex_t* pp_pthreadmutex, const timespec* ptimespec );
		virtual int mutex_trylock( pthread_mutex_t* pp_pthreadmutex );
		virtual int mutex_unlock( pthread_mutex_t* pp_pthreadmutex );

		virtual int mutexattr_destroy( pthread_mutexattr_t* pp_pthreadmutexattr );
		virtual int mutexattr_getprioceiling( const pthread_mutexattr_t* pp_pthreadmutexattr, int* piPrioCeiling );
		virtual int mutexattr_getprotocol( const pthread_mutexattr_t* pp_pthreadmutexattr, int* piProtocol );
		virtual int mutexattr_getpshared( const pthread_mutexattr_t* pp_pthreadmutexattr, int* piPShared );
		virtual int mutexattr_getrobust( const pthread_mutexattr_t* pp_pthreadmutexattr, int* piPRobust );
		virtual int mutexattr_gettype( const pthread_mutexattr_t* pp_pthreadmutexattr, int* piType );
		virtual int mutexattr_init( pthread_mutexattr_t* pp_pthreadmutexattr );
		virtual int mutexattr_setprioceiling( pthread_mutexattr_t* pp_pthreadmutexattr, int iPrioCeiling );
		virtual int mutexattr_setprotocol( pthread_mutexattr_t* pp_pthreadmutexattr, int iProtocol );
		virtual int mutexattr_setpshared( pthread_mutexattr_t* pp_pthreadmutexattr, int iPShared );
		virtual int mutexattr_settype( pthread_mutexattr_t* pp_pthreadmutexattr, int iType );

		virtual int once( pthread_once_t* pp_pthreadonce, void (*init_routine)( void ) );

		virtual int rwlock_destroy( pthread_rwlock_t* pp_pthreadrwlock );
		virtual int rwlock_init( pthread_rwlock_t* pp_pthreadrwlock, const pthread_rwlockattr_t* pp_pthreadrwlockattr );
		virtual int rwlock_rdlock( pthread_rwlock_t* pp_pthreadrwlock );
		virtual int rwlock_timedrdlock( pthread_rwlock_t* pp_pthreadrwlock, const timespec* ptimespec );
		virtual int rwlock_timedwrlock( pthread_rwlock_t* pp_pthreadrwlock, const timespec* ptimespec );
		virtual int rwlock_tryrdlock( pthread_rwlock_t* pp_pthreadrwlock );
		virtual int rwlock_trywrlock( pthread_rwlock_t* pp_pthreadrwlock );
		virtual int rwlock_unlock( pthread_rwlock_t* pp_pthreadrwlock );
		virtual int rwlock_wrlock( pthread_rwlock_t* pp_pthreadrwlock );

		virtual int rwlockattr_destroy( pthread_rwlockattr_t* pp_pthreadrwlockattr );
		virtual int rwlockattr_getpshared( const pthread_rwlockattr_t* pp_pthreadrwlockattr, int* piPShared );
		virtual int rwlockattr_init( pthread_rwlockattr_t* pp_pthreadrwlockattr );
		virtual	int rwlockattr_setpshared( pthread_rwlockattr_t* pp_pthreadrwlockattr, int iPShared );

		virtual int spin_destroy( pthread_spinlock_t* pp_pthreadspinlock );
		virtual int spin_init( pthread_spinlock_t* pp_pthreadspinlock, int iPShared );
		virtual int spin_lock( pthread_spinlock_t* pp_pthreadspinlock );
		virtual int spin_trylock( pthread_spinlock_t* pp_pthreadspinlock );
		virtual int spin_unlock( pthread_spinlock_t* pp_pthreadspinlock );
		
		virtual int sem_post_multiple( sem_t* sem, int count );
		virtual int sem_wait( sem_t* pSem );
		virtual int sem_unlink( const char* szName );
		virtual int sem_trywait( sem_t* pSem );
		virtual int sem_timedwait( sem_t* pSem, const timespec* pAbs_Timeout );
		virtual int sem_post( sem_t* pSem );
		virtual sem_t* sem_open( const char* szName, int iOFlags );//TODO vargs
		virtual int sem_init( sem_t* pSem, int iPShared, unsigned uValue );
		virtual int sem_getvalue( sem_t* pSem, int* piValue );
		virtual int sem_destroy( sem_t* pSem );
		virtual int sem_close( sem_t* pSem );

	protected:

		Cpthread();
		virtual ~Cpthread();

	private:

		Cpthread( const Cpthread& );
		Cpthread& operator = ( const Cpthread& );
	};

}//nsBaseCRT

#endif//SYSTEMQOR_POSIX_PTHREAD_H_3
