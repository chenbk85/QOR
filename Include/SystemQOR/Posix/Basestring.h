//Basestring.h

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Base CRT class for Cstring

//Portions derived from newlib

#ifndef SYSTEMQOR_POSIX_STRING_H_3
#define SYSTEMQOR_POSIX_STRING_H_3

#include "SystemQOR.h"
#include QOR_SYS_PLATFORMTYPES(string)
#include "CodeQOR/ClassReg/ClassRegEntry.h"


/*
// Nonzero if X (a long int) contains a NULL byte.
#if LONG_MAX == 2147483647L
#	define DETECTNULL( X ) ( ( ( X ) - 0x01010101 ) & ~( X ) & 0x80808080 )
#else
#	if LONG_MAX == 9223372036854775807L
#		define DETECTNULL( X ) ( ( ( X ) - 0x0101010101010101 ) & ~( X ) & 0x8080808080808080 )
#	else
//#		error long int is not a 32bit or 64bit type.
#       define DETECTNULL( X ) ( ( ( X ) - 0x01010101 ) & ~( X ) & 0x80808080 )
#	endif
#endif
*/
#define DETECTNULL( X ) ( (sizeof(LONG_MAX) == 4 ) ? ( ( ( X ) - 0x01010101 ) & ~( X ) & 0x80808080 ) : ( (sizeof(LONG_MAX) == 8 ) ? ( ( ( X ) - 0x0101010101010101 ) & ~( X ) & 0x8080808080808080 ) : ( ( ( X ) - 0x01010101 ) & ~( X ) & 0x80808080 ) ) )
// DETECTCHAR returns nonzero if (long)X contains the byte used to fill (long)MASK.
#define DETECTCHAR( X, MASK ) ( DETECTNULL( X ^ MASK ) )

//--------------------------------------------------------------------------------
namespace nsBaseCRT
{
	typedef nsPlatform::errno_t errno_t;

    //--------------------------------------------------------------------------------
    class __QOR_INTERFACE( __QSYS ) Cstring
    {
    public:

		__QOR_DECLARE_OCLASS_ID( Cstring );

        virtual void* memccpy( void* dst0, const void* src0, int endchar0, size_t len0 );
        virtual void* memcpy( void* s1, const void* s2, size_t n );
        virtual errno_t memcpy_s( void* dst, size_t sizeInBytes, const void* src, size_t count );
        virtual void* memmove( void* dst_void, const void* src_void, size_t length );
        virtual errno_t memmove_s( void* dst, size_t sizeInBytes, const void* src, size_t count );
        virtual char* strcpy( char* dst0, const char* src0 );
        virtual errno_t strcpy_s( char* dst, size_t SizeInBytes, const char* src );
        virtual char* strncpy( char* dst0, const char* src0, size_t count );
        virtual errno_t strncpy_s( char* dst, size_t SizeInBytes, const char* src, size_t MaxCount );
        virtual char* strcat( char* s1, const char* s2 );
        virtual errno_t strcat_s( char* dst, size_t SizeInBytes, const char* src );
        virtual char* strncat( char* s1, const char* s2, size_t n );
        virtual errno_t strncat_s( char* dst, size_t SizeInBytes, const char* src, size_t MaxCount );
        virtual int memcmp( const void* m1, const void* m2, size_t n );
        virtual int strcmp( const char* s1, const char* s2 );
        virtual int strcoll( const char* s1, const char* s2 );
        virtual int strncmp( const char* s1, const char* s2, size_t n );
        virtual int stricmp( const char* s1, const char* s2 );
        virtual int strnicmp( const char* s1, const char* s2, size_t n );
        virtual size_t strxfrm( char* s1, const char* s2, size_t n );
        virtual void* memchr( const void* src_void, int c, size_t length );
        virtual char* strchr( const char* s1, int i );
        virtual size_t strcspn( const char* s1, const char* s2 );
        virtual char* strpbrk( const char* s1, const char* s2 );
        virtual char* strrchr( const char* s, int i );
        virtual size_t strspn( const char* s1, const char* s2 );
        virtual char* strstr( const char* searchee, const char* lookfor );
        virtual char* strtok( char* s, const char* delim );
        virtual char* strtok_r( char*, const char*, char** );
        virtual char* strtok_s( char* , const char* , char** );
        virtual void* memset( void* m, int c, size_t n );
        virtual char* strerror( int errnum );
        virtual int strerror_r( int errnum, char* strerrbuf, size_t buflen );
        virtual errno_t strerror_s( char* Buf, size_t SizeInBytes, int ErrNum );
        virtual size_t strlen( const char* str );
        virtual size_t strnlen( const char* s, size_t MaxCount );
        virtual int strnicoll( const char* s1, const char* s2, size_t count );
        virtual char* strdup( char const* str );

	protected:

		Cstring();
		virtual ~Cstring();

    private:

        //--------------------------------------------------------------------------------
        template< typename t >
        bool aligned( t* pT )
        {
            long l = reinterpret_cast< long >( pT );
            return ( ( l & ( sizeof( long ) - 1 ) ) == 0 );
        }

        //--------------------------------------------------------------------------------
        template < typename t >
        bool unaligned( t& x )
        {
            long l = reinterpret_cast< long >( x );
            return ( l & ( sizeof( long ) - 1 ) ) ? true : false;
        }

        //--------------------------------------------------------------------------------
        template < typename t1, typename t2 >
        bool unaligned( t1& x, t2& y )
        {
            long la = reinterpret_cast< long >( x );
            long lb = reinterpret_cast< long >( y );
            return ( ( reinterpret_cast< Cmp_unsigned__int32 >( x ) & ( sizeof (long) - 1 ) ) | ( reinterpret_cast< Cmp_unsigned__int32 >( y ) & (sizeof (long) - 1) ) ) ? true : false;
        }

		Cstring( const Cstring& );
		Cstring& operator = ( const Cstring& );
    };

}//nsBaseCRT

#endif//SYSTEMQOR_POSIX_STRING_H_3
