//MSW_pthread.h

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//MS Windows pthread interface

#ifndef SYSTEMQOR_MSW_PTHREAD_H_3
#define SYSTEMQOR_MSW_PTHREAD_H_3

#include <time.h>
#include "SystemQOR/Posix/Basepthread.h"
#include <exception>
#include <pthread.h>
#include <stdint.h>
#include <stdlib.h>
#include "WinQL/WinQL.h"
#include "WinQL/Application/Threading/WinQLThread.h"
#include "WinQL/Application/Process/WinQLProcess.h"
#include "WinQL/Application/Threading/WinQLCriticalSection.h"
#include "WinQL/Application/Threading/WinQLSynchronization.h"
#include "WinQL/Application/Threading/WinQLEvent.h"
#include "WinQL/Application/Threading/WinQLWait.h"
#include "WinQL/Application/Threading/WinQLTLS.h"

/*typedef nsPlatform::ptw32_cleanup_t ptw32_cleanup_t;

#if PTW32_LEVEL >= PTW32_LEVEL_MAX
	__QSYS_INTERFACE ptw32_cleanup_t* ptw32_pop_cleanup( int execute );
	__QSYS_INTERFACE void ptw32_push_cleanup( ptw32_cleanup_t* cleanup, void (*routine) (void *), void* arg );
#endif
	*/
extern int ptw32_processInitialize (void);
extern void ptw32_processTerminate (void);
//Useful if an application wants to statically link the lib rather than load the DLL at run-time.
extern int pthread_win32_process_attach_np(void);
extern int pthread_win32_process_detach_np(void);
extern int pthread_win32_thread_attach_np(void);
//extern int pthread_win32_thread_detach_np(void);

//extern void ptw32_threadReusePush( pthread_t thread );
//extern void __cdecl _endthreadex ( unsigned retcode );


//--------------------------------------------------------------------------------
namespace nsWin32
{
	_pthread_v* __pth_gpointer_locked( pthread_t id );

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE( __QSYS ) Cpthread : public nsBaseCRT::Cpthread
	{
	public:

		Cpthread();
		virtual ~Cpthread();

		virtual int atfork( void (*)(void), void (*)(void), void(*)(void) );
		virtual int attr_destroy( pthread_attr_t* p_pthread_attr );
		virtual int attr_getdetachstate( const pthread_attr_t* p_pthread_attr, int* pDetachState );
		virtual int attr_getguardsize( const pthread_attr_t* p_pthread_attr, size_t* guardsize );
		virtual int attr_getinheritsched( const pthread_attr_t* p_pthread_attr, int* inheritsched );
		virtual int attr_getschedparam( const pthread_attr_t* p_pthread_attr, sched_param* param );
		virtual int attr_getschedpolicy( const pthread_attr_t* p_pthread_attr, int* policy );
		virtual int attr_getscope( const pthread_attr_t* p_pthread_attr, int* contentionscope );
		virtual int attr_getstack( const pthread_attr_t* p_pthread_attr, void** stackaddr, size_t* stacksize );
		virtual int attr_getstackaddr( const pthread_attr_t* p_pthread_attr, void** stackaddr );
		virtual int attr_getstacksize( const pthread_attr_t* p_pthread_attr, size_t* stacksize );
		virtual int attr_init( pthread_attr_t* p_pthread_attr );
		virtual int attr_setdetachstate( pthread_attr_t* p_pthread_attr, int iDetachState );
		virtual int attr_setguardsize( pthread_attr_t* p_pthread_attr, size_t guardsize );
		virtual int attr_setinheritsched( pthread_attr_t* p_pthread_attr, int inheritsched );
		virtual int attr_setschedparam( pthread_attr_t* p_pthread_attr, const sched_param* param );
		virtual int attr_setschedpolicy( pthread_attr_t* p_pthread_attr, int iPolicy );
		virtual int attr_setscope( pthread_attr_t* p_pthread_attr, int iContentionScope );
		virtual int attr_setstack( pthread_attr_t* p_pthread_attr, void* stackaddr, size_t stacksize );
		virtual int attr_setstackaddr( pthread_attr_t* p_pthread_attr, void* pStackAddr );
		virtual int attr_setstacksize( pthread_attr_t* p_pthread_attr, size_t StackSize );

		virtual int barrier_destroy( pthread_barrier_t* p_pthread_barrier );
		virtual int barrier_init( pthread_barrier_t* pp_barrier, const pthread_barrierattr_t* pp_barrier_attr, unsigned uiCount );
		virtual int barrier_wait( pthread_barrier_t* pp_barrier );

		virtual int barrierattr_destroy( pthread_barrierattr_t* pp_barrierattr );
		virtual int barrierattr_getpshared( const pthread_barrierattr_t* pp_barrierattr, int* p_pshared );
		virtual int barrierattr_init( pthread_barrierattr_t* pp_barrierattr );
		virtual int barrierattr_setpshared( pthread_barrierattr_t* pp_barrierattr, int iPShared );

		virtual int cancel( pthread_t hpthread );
		//virtual int cleanup_push( void ( *routine )(void *), void* arg );
		//virtual int cleanup_pop( int iExecute );
		virtual int create( pthread_t* phThread, const pthread_attr_t* pp_threadattr, void *(*start_routine)(void *), void* arg );
		virtual int detach( pthread_t hThread );
		virtual int equal( pthread_t hThread1, pthread_t hThread2 );
		virtual void exit( void* value_ptr );
		virtual int getconcurrency( void );
		virtual int getcpuclockid( pthread_t hThread, clockid_t* pClockId );
		virtual int getschedparam( pthread_t hThread, int* pPolicy, sched_param* pParam );
		virtual void* getspecific( pthread_key_t p_pthreadkey );
		virtual int join( pthread_t hThread, void** ppValue );
		virtual pthread_t self( void );
		virtual int setcancelstate( int iState, int* piOldState );
		virtual int setcanceltype( int iType, int* piOldType );
		virtual int setconcurrency( int iConcurrency );
		virtual int setschedparam( pthread_t hThread, int iPolicy, const sched_param* pParam );
		virtual int setschedprio( pthread_t hThread, int iPriority );
		virtual int setspecific( pthread_key_t key, const void* pValue );
		virtual void testcancel( void );

		virtual int key_create( pthread_key_t* pp_pthreadkey, void (*destructor)(void *) );
		virtual int key_delete( pthread_key_t p_pthreadkey );

		virtual int cond_broadcast( pthread_cond_t* pp_pthread_cond );
		virtual int cond_destroy( pthread_cond_t* pp_pthread_cond );
		virtual int cond_init( pthread_cond_t* pp_pthread_cond, const pthread_condattr_t* pp_pthread_condattr );
		virtual int cond_signal( pthread_cond_t* pp_pthread_cond );
		virtual int cond_timedwait( pthread_cond_t* pp_pthread_cond, pthread_mutex_t* pp_pthread_mutex, const timespec* ptimespec );
		virtual int cond_wait( pthread_cond_t* pp_pthread_cond, pthread_mutex_t* pp_pthread_mutex );

		virtual int condattr_destroy( pthread_condattr_t* pp_pthread_condattr );
		virtual int condattr_getclock( const pthread_condattr_t* pp_pthread_condattr, clockid_t* pClockId );
		virtual int condattr_getpshared( const pthread_condattr_t* pp_pthread_condattr, int* piPShared );
		virtual int condattr_init( pthread_condattr_t* pp_pthread_condattr );
		virtual int condattr_setclock( pthread_condattr_t* pp_pthread_condattr, clockid_t ClockId );
		virtual int condattr_setpshared( pthread_condattr_t* pp_pthread_condattr, int iPShared );

		virtual int mutex_consistent( pthread_mutex_t* pp_pthreadmutex );
		virtual int mutex_destroy( pthread_mutex_t* pp_pthreadmutex );
		virtual int mutex_getprioceiling( const pthread_mutex_t* pp_pthreadmutex, int* pPrioCeiling );
		virtual int mutex_init( pthread_mutex_t* pp_pthreadmutex, const pthread_mutexattr_t* pp_pthreadmutexattr );
		virtual int mutex_lock( pthread_mutex_t* pp_pthreadmutex );
		virtual int mutex_setprioceiling( pthread_mutex_t* pp_pthreadmutex, int iPrioCeiling, int* pOldCieling );
		virtual int mutex_timedlock( pthread_mutex_t* pp_pthreadmutex, const timespec* ptimespec );
		virtual int mutex_trylock( pthread_mutex_t* pp_pthreadmutex );
		virtual int mutex_unlock( pthread_mutex_t* pp_pthreadmutex );

		virtual int mutexattr_destroy( pthread_mutexattr_t* pp_pthreadmutexattr );
		virtual int mutexattr_getprioceiling( const pthread_mutexattr_t* pp_pthreadmutexattr, int* piPrioCeiling );
		virtual int mutexattr_getprotocol( const pthread_mutexattr_t* pp_pthreadmutexattr, int* piProtocol );
		virtual int mutexattr_getpshared( const pthread_mutexattr_t* pp_pthreadmutexattr, int* piPShared );
		virtual int mutexattr_getrobust( const pthread_mutexattr_t* pp_pthreadmutexattr, int* piPRobust );
		virtual int mutexattr_gettype( const pthread_mutexattr_t* pp_pthreadmutexattr, int* piType );
		virtual int mutexattr_init( pthread_mutexattr_t* pp_pthreadmutexattr );
		virtual int mutexattr_setprioceiling( pthread_mutexattr_t* pp_pthreadmutexattr, int iPrioCeiling );
		virtual int mutexattr_setprotocol( pthread_mutexattr_t* pp_pthreadmutexattr, int iProtocol );
		virtual int mutexattr_setpshared( pthread_mutexattr_t* pp_pthreadmutexattr, int iPShared );
		virtual int mutexattr_settype( pthread_mutexattr_t* pp_pthreadmutexattr, int iType );

		virtual int once( pthread_once_t* pp_pthreadonce, void (*init_routine)( void ) );

		virtual int rwlock_destroy( pthread_rwlock_t* pp_pthreadrwlock );
		virtual int rwlock_init( pthread_rwlock_t* pp_pthreadrwlock, const pthread_rwlockattr_t* pp_pthreadrwlockattr );
		virtual int rwlock_rdlock( pthread_rwlock_t* pp_pthreadrwlock );
		virtual int rwlock_timedrdlock( pthread_rwlock_t* pp_pthreadrwlock, const timespec* ptimespec );
		virtual int rwlock_timedwrlock( pthread_rwlock_t* pp_pthreadrwlock, const timespec* ptimespec );
		virtual int rwlock_tryrdlock( pthread_rwlock_t* pp_pthreadrwlock );
		virtual int rwlock_trywrlock( pthread_rwlock_t* pp_pthreadrwlock );
		virtual int rwlock_unlock( pthread_rwlock_t* pp_pthreadrwlock );
		virtual int rwlock_wrlock( pthread_rwlock_t* pp_pthreadrwlock );

		virtual int rwlockattr_destroy( pthread_rwlockattr_t* pp_pthreadrwlockattr );
		virtual int rwlockattr_getpshared( const pthread_rwlockattr_t* pp_pthreadrwlockattr, int* piPShared );
		virtual int rwlockattr_init( pthread_rwlockattr_t* pp_pthreadrwlockattr );
		virtual	int rwlockattr_setpshared( pthread_rwlockattr_t* pp_pthreadrwlockattr, int iPShared );

		virtual int spin_destroy( pthread_spinlock_t* pp_pthreadspinlock );
		virtual int spin_init( pthread_spinlock_t* pp_pthreadspinlock, int iPShared );
		virtual int spin_lock( pthread_spinlock_t* pp_pthreadspinlock );
		virtual int spin_trylock( pthread_spinlock_t* pp_pthreadspinlock );
		virtual int spin_unlock( pthread_spinlock_t* pp_pthreadspinlock );

		virtual int sem_post_multiple( sem_t* sem, int count );
		virtual int sem_wait( sem_t* pSem );
		virtual int sem_unlink( const char* szName );
		virtual int sem_trywait( sem_t* pSem );
		virtual int sem_timedwait( sem_t* pSem, const timespec* pAbs_Timeout );
		virtual int sem_post( sem_t* pSem );
		virtual sem_t* sem_open( const char* szName, int iOFlags );//TODO vargs
		virtual int sem_init( sem_t* pSem, int iPShared, unsigned uValue );
		virtual int sem_getvalue( sem_t* pSem, int* piValue );
		virtual int sem_destroy( sem_t* pSem );
		virtual int sem_close( sem_t* pSem );

	protected:
	public:

		int nanosleep( const timespec* request, timespec* remain );
		int clock_nanosleep( clockid_t clock_id, int flags, const timespec* request, timespec* remain );
		int clock_getres( clockid_t clock_id, timespec* res );
		int clock_gettime( clockid_t clock_id, timespec* tp );
		int clock_settime( clockid_t clock_id, const timespec* tp );

		static void* getevent( pthread_t t );
		void* gethandle( pthread_t t );
		static _pthread_cleanup** getclean( void );
		int get_concurrency( int* val );
		int set_concurrency( int val );
		static void invoke_cancel( void );
		void setnobreak( int v );
		int kill( pthread_t t, int sig );
		unsigned get_state( const pthread_attr_t* attr, unsigned flag );
		int set_state( pthread_attr_t* attr, unsigned flag, unsigned val );
		int tryjoin( pthread_t t, void **res );
		static unsigned long long time_in_ms( void );
		static unsigned long long time_in_ms_from_timespec( const timespec* ts );
		static unsigned long long rel_time_in_ms( const timespec* ts );
		static int check( pthread_t t );
		static void once_cleanup( void* o );
		static int once_raw( pthread_once_t* o, void (*func)(void) );
		void* timechange_handler_np( void* dummy );
		static void cleanup_dest( pthread_t t );
		static int delay_np( const timespec* interval );
		static int delay_np_ms( unsigned long to );
		static int num_processors_np( void );
		static int set_num_processors_np( int n );
		static void tls_init( void );
		static unsigned long create_wrapper( void* args );

	private:

		nsWin32::CInterlockedHelper m_InterlockedHelper;

		Cpthread( const Cpthread& );
		Cpthread& operator = ( const Cpthread& );
	};
	
}//nsWin32

#endif//SYSTEMQOR_MSW_PTHREAD_H_3
