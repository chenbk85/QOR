//MSW_stdlib.h

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//MSWindows overrides for stdlib

#ifndef SYSTEMQOR_MSW_STDLIB_H_3
#define SYSTEMQOR_MSW_STDLIB_H_3

#include "SystemQOR/Posix/Basestdlib.h"
#include "WinQL/WinQL.h"
#include "WinQL/Application/Memory/WinQLHeap.h"
#include "WinQL/Application/Process/WinQLProcess.h"
#include "WinQL/Application/Process/WinQLAtExit.h"
#include "WinQL/CodeServices/Locale/WinQLLocaleThreadData.h"

// _countof helper
#if !defined(_countof)
#	if !defined(__cplusplus)
#		define _countof( _Array ) ( sizeof( _Array ) / sizeof( _Array[ 0 ] ) )
#	else
		extern "C++"
		{
		template < typename _CountofType, size_t _SizeOfArray >
		char ( *__countof_helper( UNALIGNED _CountofType ( &_Array )[ _SizeOfArray ] ) )[ _SizeOfArray ];
#		define _countof( _Array ) sizeof( *__countof_helper( _Array ) )
		}
#	endif
#endif

//--------------------------------------------------------------------------------
namespace nsWin32
{

	__QOR_INTERFACE( __QSYS ) int WaitExitStatus( int status );
	__QOR_INTERFACE( __QSYS ) int WaitIfExited( int status );
	__QOR_INTERFACE( __QSYS ) int WaitIfSignaled( int status );
	__QOR_INTERFACE( __QSYS ) int WaitIfStopped( int status );
	__QOR_INTERFACE( __QSYS ) int WaitStopSignal( int status );
	__QOR_INTERFACE( __QSYS ) int WaitTermSignal( int status );
	__QOR_INTERFACE( __QSYS ) int _WaitUntraced( void );
	__QOR_INTERFACE( __QSYS ) int _WaitNoHang( void );
	__QOR_INTERFACE( __QSYS ) int MBCurMax_l( locale_t l );

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE( __QSYS ) Cstdlib : public nsBaseCRT::Cstdlib
	{
		
	public:

		// flag values
		__QCMP_STATIC_CONSTANT( int,  FL_UNSIGNED	= 1 );
		__QCMP_STATIC_CONSTANT( int,  FL_NEG			= 2 );
		__QCMP_STATIC_CONSTANT( int,  FL_OVERFLOW	= 4 );
		__QCMP_STATIC_CONSTANT( int,  FL_READDIGIT	= 8 );

		Cstdlib();
		virtual ~Cstdlib();

		static nsBaseCRT::Cstdlib* Thestdlib( void );

		errno_t _get_doserrno( int* pValue );
		errno_t _set_doserrno( int value );
		__QCMP_NORETURN virtual void abort( void );
		int atexit( void (*pFunc)(void) );		
		void* calloc( size_t nNum, size_t nSize );
		void exit( int status );
		void free( void* ptr );
		char* getenv( const char* name);
		errno_t getenv_s( size_t* pReturnSize, char* pDstBuf, size_t DstSize, const char* pszVarName );
		int grantpt( int iFileDes );
		char* initstate( unsigned int uiSeed, char* pState, size_t Size );
		void* malloc( size_t size );
		size_t mbstowcs( wchar_t* pwcs, const char* s, size_t n );
		errno_t mbstowcs_s( size_t* pNumOfCharConverted, wchar_t* pDstBuf, size_t SizeInWords, const char* s, size_t MaxCount );
		int mbtowc( wchar_t* pwc, const char* s, size_t n );
		int posix_openpt( int oflag );
		char* ptsname( int iFileDes );
		void qsort_s( void* base, size_t nmemb, size_t SizeOfElements, int ( *pFuncCompare )( void*, const void*, const void* ), void* pvContext );
		long random( void );
		void* realloc( void* ptr, size_t size );
		int setenv( const char* envname, const char* envval, int overwrite );
		void setkey( const char* pszKey );
		char* setstate( const char* state );
		void srandom( unsigned int uiSeed );
		long double strtold( const char* nptr, char** endptr );
		int system( const char* string );
		int unlockpt( int iFileDes );
		size_t wcstombs( char* s, const wchar_t* pwcs, size_t n );
		int wctomb( char* s, wchar_t wchar );
		errno_t wcstombs_s( size_t* pReturnValue, char* mbstr, size_t sizeInBytes, const wchar_t* wcstr, size_t count );
		errno_t wctomb_s( int* pRetValue, char* mbchar, size_t sizeInBytes, wchar_t wchar );

//extensions

		void _exit( int status );
		errno_t dupenv_s( char** pBuffer, size_t* pBufferSizeInChars, const char* varname );
		errno_t dupenv_s_helper( char** pBuffer, size_t* pBufferSizeInChars, const char* varname );
		errno_t _access_s ( const char* path, int amode );
		intptr_t _spawnve( int mode, const char* name, const char* const *argv, const char* const *envp );
		intptr_t spawnvpe( int modeflag, const char* filename, const char* const *argv, const char* const *envptr );
		char* _getpath ( const char* src, char* dst, size_t maxlen );
		intptr_t comexecmd ( int mode, const char* name, const char* const *argv, const char* const *envp );		
		
		void crtInit( void );
		void crtCleanup( void );

		static int WaitExitStatus( int status );
		static int WaitIfExited( int status );
		static int WaitIfSignaled( int status );
		static int WaitIfStopped( int status );
		static int WaitStopSignal( int status );
		static int WaitTermSignal( int status );
		static int WaitUntraced( void );
		static int WaitNoHang( void );

	private:

		long double strtox( const char *s, char** p, int prec );
		Cmp_unsigned__int64 strtoxq ( nsWin32::CLocaleThreadData* plocinfo, const char* nptr, const char** endptr, int ibase, int flags );
		unsigned long strtoxl ( nsWin32::CLocaleThreadData* plocinfo, const char* nptr, const char** endptr, int ibase, int flags );
		int _wctomb_s_l( int* pRetValue, char* dst, size_t sizeInBytes, wchar_t wchar, nsWin32::CLocaleThreadData* plocinfo );
		errno_t _wcstombs_s_l( size_t* pConvertedChars, char* dst, size_t sizeInBytes, const wchar_t* src, size_t n, nsWin32::CLocaleThreadData* plocinfo );
		size_t _wcstombs_l_helper( char* s, const wchar_t* pwcs, size_t n, nsWin32::CLocaleThreadData* plocinfo );

		nsWin32::CHeap m_ProcessHeap;
		nsWin32::CAtExit m_AtExitList;

		//------------------------------------------------------------------------------
		static void doexit( int code, int /*quick*/, int /*retcaller*/ )
		{
//#ifdef _DEBUG
//			static int fExit = 0;
//#endif  /* _DEBUG */
//
//#ifdef CRTDLL
//			if( !retcaller && check_managed_app() )
//			{
//				/*Only if the EXE is managed then we call CorExitProcess.
//				Native cleanup is done in .cctor of the EXE
//				If the Exe is Native then native clean up should be done
//				before calling (Cor)ExitProcess.
//				*/
//				__crtCorExitProcess(code);
//			}
//#endif  /* CRTDLL */
//
//			_lockexit();        /* assure only 1 thread in exit path */
//			
//			__CQOR_TRY
//			{
//				if( _C_Exit_Done != TRUE ) 
//				{
//					_C_Termination_Done = TRUE;
//
//					// save callable exit flag (for use by terminators)
//					_exitflag = (char) retcaller;  // 0 = term, !0 = callable exit
//
//					if( !quick ) 
//					{
//						/*do _onexit/atexit() terminators
//						 * (if there are any)
//						 *
//						 * These terminators MUST be executed in reverse order (LIFO)!
//						 *
//						 * NOTE:
//						 *  This code assumes that __onexitbegin points
//						 *  to the first valid onexit() entry and that
//						 *  __onexitend points past the last valid entry.
//						 *  If __onexitbegin == __onexitend, the table
//						 *  is empty and there are no routines to call.
//						 */
//
//						_PVFV * onexitbegin = (_PVFV *)_decode_pointer(__onexitbegin);
//						_PVFV * onexitend   = (_PVFV *)_decode_pointer(__onexitend);
//
//						if( onexitbegin ) 
//						{
//							while( --onexitend >= onexitbegin )
//							{
//								//if current table entry is non-NULL,call thru it.
//								if( *onexitend != 0 && *onexitend != _encoded_null() )
//								{
//									(*(_PVFV)_decode_pointer(*onexitend))();
//								}
//							}
//						}
//#ifndef CRTDLL
//						//do pre-terminators
//						_initterm( __xp_a, __xp_z );
//#endif//CRTDLL
//					}
//
//#ifndef CRTDLL
//					//do terminators
//					_initterm( __xt_a, __xt_z );
//#endif//CRTDLL
//
//#ifdef _DEBUG
//					// Dump all memory leaks
//					if( !fExit && _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG ) & _CRTDBG_LEAK_CHECK_DF )
//					{
//						fExit = 1;
//#ifndef CRTDLL
//						__freeCrtMemory();
//						_CrtDumpMemoryLeaks();
//#endif//CRTDLL
//					}
//#endif//_DEBUG
//
//				}
//
//				// return to OS or to caller				
//			}
//			__CQOR_FINALLY
//			{
//
//				if( retcaller )
//				{
//					_unlockexit();      // unlock the exit code path
//				}
//			}
//
//			if( retcaller )
//			{
//				return;
//			}
//
//			_C_Exit_Done = TRUE;
//			_unlockexit();      // unlock the exit code path
//			__crtExitProcess( code );
			ThisProcess()->Exit( code );
		}

		Cstdlib( const Cstdlib& );
		Cstdlib& operator = ( const Cstdlib& );
	};

}//nsWin32

#endif//SYSTEMQOR_MSW_STDLIB_H_3

