//math_types.h

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.


#ifndef SYSTEMQOR_LIN_TYPES_MATH_H_3
#define SYSTEMQOR_LIN_TYPES_MATH_H_3

#include "SystemQOR/Linux/LIN_features.h"

#define __NEED_float_t
#define __NEED_double_t
#include QOR_SYS_ARCHHEADER(alltypes.h)

#if 100*__GNUC__+__GNUC_MINOR__ >= 303
#	define LIN_NAN       __builtin_nanf("")
#	define LIN_INFINITY  __builtin_inff()
#else
#	define LIN_NAN       (0.0f/0.0f)
#	define LIN_INFINITY  1e5000f
#endif

#define LIN_HUGE_VALF LIN_INFINITY
#define LIN_HUGE_VAL  ((double)LIN_INFINITY)
#define LIN_HUGE_VALL ((long double)LIN_INFINITY)

#define LIN_MATH_ERRNO  1
#define LIN_MATH_ERREXCEPT 2
#define LIN_math_errhandling 2

#define LIN_FP_ILOGBNAN (-1-(int)(((unsigned)-1)>>1))
#define LIN_FP_ILOGB0 LIN_FP_ILOGBNAN

namespace nsLinux
{
    __QCMP_STATIC_CONSTANT( double, HugeValue = LIN_HUGE_VAL );
    __QCMP_STATIC_CONSTANT( float, HugeValueF = LIN_INFINITY );
    __QCMP_STATIC_CONSTANT( float, NaN =        LIN_NAN );
	__QCMP_STATIC_CONSTANT( int, FpNAN =		0 );
	__QCMP_STATIC_CONSTANT( int, FpInfinite	=	1 );
	__QCMP_STATIC_CONSTANT( int, FpZero =		2 );
	__QCMP_STATIC_CONSTANT( int, FpSubNormal =	3 );
	__QCMP_STATIC_CONSTANT( int, FpNormal =		4 );
}//nsLinux

/*
#define FP_NAN       0
#define FP_INFINITE  1
#define FP_ZERO      2
#define FP_SUBNORMAL 3
#define FP_NORMAL    4
*/
/*
#define fpclassify(x) ( \
	sizeof(x) == sizeof(float) ? __fpclassifyf(x) : \
	sizeof(x) == sizeof(double) ? __fpclassify(x) : \
	__fpclassifyl(x) )

#define isinf(x) ( \
	sizeof(x) == sizeof(float) ? (__FLOAT_BITS(x) & 0x7fffffff) == 0x7f800000 : \
	sizeof(x) == sizeof(double) ? (__DOUBLE_BITS(x) & -1ULL>>1) == 0x7ffULL<<52 : \
	__fpclassifyl(x) == FP_INFINITE)

#define isnan(x) ( \
	sizeof(x) == sizeof(float) ? (__FLOAT_BITS(x) & 0x7fffffff) > 0x7f800000 : \
	sizeof(x) == sizeof(double) ? (__DOUBLE_BITS(x) & -1ULL>>1) > 0x7ffULL<<52 : \
	__fpclassifyl(x) == FP_NAN)

#define isnormal(x) ( \
	sizeof(x) == sizeof(float) ? ((__FLOAT_BITS(x)+0x00800000) & 0x7fffffff) >= 0x01000000 : \
	sizeof(x) == sizeof(double) ? ((__DOUBLE_BITS(x)+(1ULL<<52)) & -1ULL>>1) >= 1ULL<<53 : \
	__fpclassifyl(x) == FP_NORMAL)

#define isfinite(x) ( \
	sizeof(x) == sizeof(float) ? (__FLOAT_BITS(x) & 0x7fffffff) < 0x7f800000 : \
	sizeof(x) == sizeof(double) ? (__DOUBLE_BITS(x) & -1ULL>>1) < 0x7ffULL<<52 : \
	__fpclassifyl(x) > FP_INFINITE)

#define signbit(x) ( \
	sizeof(x) == sizeof(float) ? (int)(__FLOAT_BITS(x)>>31) : \
	sizeof(x) == sizeof(double) ? (int)(__DOUBLE_BITS(x)>>63) : \
	__signbitl(x) )

#define isunordered(x,y) (isnan((x)) ? ((void)(y),1) : isnan((y)))
*/
#define __ISREL_DEF(rel, op, type) \
__inline int is##rel(type __x, type __y) \
{ return !isunordered(__x,__y) && __x op __y; }
/*
#define __tg_pred_2(x, y, p) ( \
	sizeof((x)+(y)) == sizeof(float) ? p##f(x, y) : \
	sizeof((x)+(y)) == sizeof(double) ? p(x, y) : \
	p##l(x, y) )

#define isless(x, y)            __tg_pred_2(x, y, __isless)
#define islessequal(x, y)       __tg_pred_2(x, y, __islessequal)
#define islessgreater(x, y)     __tg_pred_2(x, y, __islessgreater)
#define isgreater(x, y)         __tg_pred_2(x, y, __isgreater)
#define isgreaterequal(x, y)    __tg_pred_2(x, y, __isgreaterequal)
*/
#if defined(_XOPEN_SOURCE) || defined(_BSD_SOURCE)
#	undef  MAXFLOAT
#	define MAXFLOAT        3.40282346638528859812e+38F
#endif
/*
#if defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
#	define M_E             2.7182818284590452354   // e
#	define M_LOG2E         1.4426950408889634074   // log_2 e
#	define M_LOG10E        0.43429448190325182765  // log_10 e
#	define M_LN2           0.69314718055994530942  // log_e 2
#	define M_LN10          2.30258509299404568402  // log_e 10
#	define M_PI            3.14159265358979323846  // pi
#	define M_PI_2          1.57079632679489661923  // pi/2
#	define M_PI_4          0.78539816339744830962  // pi/4
#	define M_1_PI          0.31830988618379067154  // 1/pi
#	define M_2_PI          0.63661977236758134308  // 2/pi
#	define M_2_SQRTPI      1.12837916709551257390  // 2/sqrt(pi)
#	define M_SQRT2         1.41421356237309504880  // sqrt(2)
#	define M_SQRT1_2       0.70710678118654752440  // 1/sqrt(2)
#endif
*/
#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
#	define HUGE            3.40282346638528859812e+38F
#endif

#endif//SYSTEMQOR_LIN_TYPES_MATH_H_3
