//SanQOS.h

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef SANQAPI_OS_H_1
#define SANQAPI_OS_H_1

#include "../SystemQOR/SanOS/SanQAPI/include/Library.h"
#include <os.h>

#define _SANQ_USESAPI( _NAME ) static const DefProc pFunc = reinterpret_cast< DefProc>( COS::dlsym( m_hModule, #_NAME ) )

//------------------------------------------------------------------------------
namespace nsSanQAPI
{
	//------------------------------------------------------------------------------
	class COS : public CLibrary
	{
	public:

		COS();
		~COS();

		static COS& Instance( void );

		int syscall( int syscallno, void* params );
		int mkfs( const char* devname, const char* type, const char* opts );
		int mount( const char* type, const char* mntto, const char* mntfrom, const char* opts );
		int umount( const char* path );
		int getfsstat(struct statfs *buf, size_t size);
		int fstatfs(handle_t f, struct statfs *buf);
		int statfs(const char *name, struct statfs *buf);
		handle_t open(const char *name, int flags, ...);
		handle_t sopen(const char *name, int flags, int shflags, ...);
		handle_t creat(const char *name, int mode);
		int close(handle_t h);
		int fsync(handle_t f);
		handle_t dup(handle_t h);
		handle_t dup2(handle_t h1, handle_t h2);
		int read(handle_t f, void *data, size_t size);
		int write(handle_t f, const void *data, size_t size);
		int pread(handle_t f, void *data, size_t size, off64_t offset);
		int pwrite(handle_t f, const void *data, size_t size, off64_t offset);
		int ioctl(handle_t f, int cmd, const void *data, size_t size);
		int readv(handle_t f, const struct iovec *iov, int count);
		int writev(handle_t f, const struct iovec *iov, int count);
		loff_t tell(handle_t f);
		off64_t tell64(handle_t f);
		loff_t lseek(handle_t f, loff_t offset, int origin);
		off64_t lseek64(handle_t f, off64_t offset, int origin);
		int ftruncate(handle_t f, loff_t size);
		int ftruncate64(handle_t f, off64_t size);
		int futime(handle_t f, struct utimbuf *times);
		int utime(const char *name, struct utimbuf *times);
		int fstat(handle_t f, struct stat *buffer);
		int fstat64(handle_t f, struct stat64 *buffer);
		int stat(const char *name, struct stat *buffer);
		int stat64(const char *name, struct stat64 *buffer);
		int lstat(const char *name, struct stat *buffer);
		int lstat64(const char *name, struct stat64 *buffer);
		int access(const char *name, int mode);
		loff_t filelength(handle_t f);
		off64_t filelength64(handle_t f);
		int isatty(handle_t f);
		int eof(handle_t f);
		int umask(int mask);
		int setmode(handle_t f, int mode);
		int chmod(const char *name, int mode);
		int fchmod(handle_t f, int mode);
		int chown(const char *name, int owner, int group);
		int fchown(handle_t f, int owner, int group);
		int chdir(const char *name);
		char *getcwd(char *buf, size_t size);
		int mkdir(const char *name, int mode);
		int rmdir(const char *name);
		int rename(const char *oldname, const char *newname);
		int link(const char *oldname, const char *newname);
		int unlink(const char *name);
		handle_t _opendir(const char *name);
		int _readdir(handle_t f, struct direntry *dirp, int count);
		int pipe(handle_t fildes[2]);
		/*
		void *mmap(void *addr, unsigned long size, int type, int protect, unsigned long tag);
		int munmap(void *addr, unsigned long size, int type);
		void *mremap(void *addr, unsigned long oldsize, unsigned long newsize, int type, int protect, unsigned long tag);
		int mprotect(void *addr, unsigned long size, int protect);
		int mlock(void *addr, unsigned long size);
		int munlock(void *addr, unsigned long size);
		*/
		int waitone(handle_t h, int timeout);
		int waitall(handle_t *h, int count, int timeout);
		int waitany(handle_t *h, int count, int timeout);
		handle_t mkevent(int manual_reset, int initial_state);
		int epulse(handle_t h);
		int eset(handle_t h);
		int ereset(handle_t h);
		handle_t mksem(int initial_count);
		int semrel(handle_t h, int count);
		handle_t mkmutex(int owned);
		int mutexrel(handle_t h);
		handle_t mkiomux(int flags);
		int dispatch(handle_t iomux, handle_t h, int events, int context);
		int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timeval *timeout);
		int poll(struct pollfd fds[], unsigned int nfds, int timeout);
		int sysinfo(int cmd, void *data, size_t size);
		int uname(struct utsname *buf);
		handle_t self();
		void exitos(int mode);
		void dbgbreak();
		char *strerror(int errnum);
		char *crypt(const char *key, const char *salt);
		char *crypt_r(const char *key, const char *salt, char *buf);
		struct passwd *getpwnam(const char *name);
		struct passwd *getpwuid(uid_t uid);
		struct group *getgrnam(const char *name);
		struct group *getgrgid(uid_t uid);
		int initgroups(const char *user, gid_t basegid);
		int getuid();
		int getgid();
		int setuid(uid_t uid);
		int setgid(gid_t gid);
		int geteuid();
		int getegid();
		int seteuid(uid_t uid);
		int setegid(gid_t gid);
		int getgroups(int size, gid_t list[]);
		int setgroups(int size, const gid_t list[]);
		handle_t beginthread(void (__stdcall *startaddr)(void *), unsigned int stacksize, void *arg, int flags, struct tib **ptib);
		int suspend(handle_t thread);
		int resume(handle_t thread);
		struct tib *getthreadblock(handle_t thread);
		handle_t getprochandle(pid_t pid);
		void endthread(int status);
		tid_t gettid();
		pid_t getpid();
		pid_t getppid();
		int getchildstat(pid_t pid, int *status);
		int setchildstat(pid_t pid, int status);
		int setcontext(handle_t thread, void *context);
		int getcontext(handle_t thread, void *context);
		int getprio(handle_t thread);
		int setprio(handle_t thread, int priority);
		int msleep(int millisecs);
		unsigned sleep(unsigned seconds);
		struct tib *gettib();
		int spawn(int mode, const char *pgm, const char *cmdline, char **env, struct tib **tibptr);
		void exit(int status);
		sighandler_t signal(int signum, sighandler_t handler);
		int raise(int signum);
		int kill(pid_t pid, int signum);
		int sendsig(handle_t thread, int signum);
		void sigexit(struct siginfo *info, int action);
		char *strsignal(int signum);
		int sigemptyset(sigset_t *set);
		int sigfillset(sigset_t *set);
		int sigaddset(sigset_t *set, int signum);
		int sigdelset(sigset_t *set, int signum);
		int sigismember(sigset_t *set, int signum);
		int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
		int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
		int sigpending(sigset_t *set);
		int sigsuspend(const sigset_t *mask);
		unsigned alarm(unsigned seconds);
		time_t time(time_t *timeptr);
		int gettimeofday(struct timeval *tv, void *tzp);
		int settimeofday(struct timeval *tv);
		clock_t clock();
		void openlog(char *ident, int option, int facility);
		void closelog();
		int setlogmask(int mask);
		void syslog(int pri, const char *fmt, ...);
		void vsyslog(int pri, const char *fmt, va_list args);
		void panic(const char *msg);
		int canonicalize(const char *filename, char *buffer, int size);
		void mkcs(critsect_t cs);
		void csfree(critsect_t cs);
		void enter(critsect_t cs);
		void leave(critsect_t cs);
		void *_lmalloc(size_t size);
		void *_lrealloc(void *mem, size_t size);
		void *_lcalloc(size_t num, size_t size);
		void _lfree(void *p);

		void* malloc( size_t size );
		void* realloc( void* mem, size_t size );
		void* calloc( size_t num, size_t size );
		void free( void* p );

		struct mallinfo mallinfo();
		int malloc_usable_size(void *p);
		hmodule_t dlopen(const char *name, int mode);
		int dlclose(hmodule_t hmod);
		static void* dlsym( hmodule_t hmod, const char* procname );
		char *dlerror();
		hmodule_t getmodule(const char *name);
		int getmodpath(hmodule_t hmod, char *buffer, int size);
		int exec(hmodule_t hmod, const char *args, char **env);
		void *getresdata(hmodule_t hmod, int type, char *name, int lang, int *len);
		int getreslen(hmodule_t hmod, int type, char *name, int lang);
		struct verinfo *getverinfo(hmodule_t hmod);
		int getvervalue(hmodule_t hmod, char *name, char *buf, int size);

		tls_t tlsalloc();
		void tlsfree(tls_t index);
		void *tlsget(tls_t index);
		int tlsset(tls_t index, void *value);
		int accept(int s, struct sockaddr *addr, int *addrlen);
		int bind(int s, const struct sockaddr *name, int namelen);
		int connect(int s, const struct sockaddr *name, int namelen);
		int getpeername(int s, struct sockaddr *name, int *namelen);
		int getsockname(int s, struct sockaddr *name, int *namelen);
		int getsockopt(int s, int level, int optname, char *optval, int *optlen);
		int listen(int s, int backlog);
		int recv(int s, void *data, int size, unsigned int flags);
		int recvfrom(int s, void *data, int size, unsigned int flags, struct sockaddr *from, int *fromlen);
		int recvmsg(int s, struct msghdr *hdr, unsigned int flags);
		int send(int s, const void *data, int size, unsigned int flags);
		int sendto(int s, const void *data, int size, unsigned int flags, const struct sockaddr *to, int tolen);
		int sendmsg(int s, struct msghdr *hdr, unsigned int flags);
		int setsockopt(int s, int level, int optname, const char *optval, int optlen);
		int shutdown(int s, int how);
		int socket(int domain, int type, int protocol);
		int res_send(const char *buf, int buflen, char *answer, int anslen);
		int res_query(const char *dname, int cls, int type, unsigned char *answer, int anslen);
		int res_search(const char *name, int cls, int type, unsigned char *answer, int anslen);
		int res_querydomain(const char *name, const char *domain, int cls, int type, unsigned char *answer, int anslen); 
		int res_mkquery(int op, const char *dname, int cls, int type, char *data, int datalen, unsigned char *newrr, char *buf, int buflen);
		int dn_comp(const char *src, unsigned char *dst, int dstsiz, unsigned char **dnptrs, unsigned char **lastdnptr);
		int dn_expand(const unsigned char *msg, const unsigned char *eom, const unsigned char *src,  char *dst, int dstsiz);
		struct hostent *gethostbyname(const char *name);
		struct hostent *gethostbyaddr(const char *addr, int len, int type);
		char *inet_ntoa(struct in_addr in);
		unsigned long inet_addr(const char *cp);
		int gethostname(char *name, int namelen);
		struct protoent *getprotobyname(const char *name);
		struct protoent *getprotobynumber(int proto);
		struct servent *getservbyname(const char *name, const char *proto);
		struct servent *getservbyport(int port, const char *proto);
		char *getenv(const char *name);
		int setenv(const char *name, const char *value, int rewrite);
		void unsetenv(const char *name);
		int putenv(const char *str);

//osapi extern struct section *osconfig;
//osapi extern struct peb *peb;

		int __getstdhndl(int n);
/*
#ifndef errno
osapi int *_errno();
#define errno (*_errno())
#endif

#ifndef fmode
osapi int *_fmode();
#define fmode (*_fmode())
#endif

#ifndef environ
osapi char ***_environ();
#define environ (*_environ())
#endif
*/
	private:

		hmodule_t m_hModule;

	};

}//nsSanQAPI

#endif//SANQAPI_OS_H_1
