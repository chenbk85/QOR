//WS2_32.h

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef _QSYS_API_WIN32_MODULES_WS2_32_H_
#define _QSYS_API_WIN32_MODULES_WS2_32_H_

#include "SystemQOR.h"
#include <string.h>
#define WIN32_NO_STATUS 1
#include <WinSock2.h>
#include <Ws2tcpip.h>
#include <mswsock.h>
#if		( _WIN32_WINNT == 0x0500 )
#	include <WSPiApi.h>
#endif//( _WIN32_WINNT == 0x0500 )
#include <Ws2spi.h>
#undef WIN32_NO_STATUS
#include "WinQAPI/Kernel32.h"
#include "../Source/SystemQOR/MSWindows/WinQAPI/include/DynamicLibrary.h"

#ifdef	__MINGW32__
typedef addrinfo ADDRINFOA, *PADDRINFOA;

#if(_WIN32_WINNT >= 0x0600)
typedef struct pollfd
{
    SOCKET  fd;
    SHORT   events;
    SHORT   revents;

} WSAPOLLFD, *PWSAPOLLFD, FAR *LPWSAPOLLFD;
#endif

typedef struct _WSAMSG
{
    LPSOCKADDR       name;              /* Remote address */
    INT              namelen;           /* Remote address length */
    LPWSABUF         lpBuffers;         /* Data buffer array */

#if(_WIN32_WINNT >= 0x0600)
    ULONG            dwBufferCount;     /* Number of elements in the array */
#else
    DWORD            dwBufferCount;     /* Number of elements in the array */
#endif //(_WIN32_WINNT>=0x0600)

    WSABUF           Control;           /* Control buffer */

#if(_WIN32_WINNT >= 0x0600)
    ULONG            dwFlags;           /* Flags */
#else
    DWORD            dwFlags;           /* Flags */
#endif //(_WIN32_WINNT>=0x0600)

} WSAMSG, *PWSAMSG, * FAR LPWSAMSG;

#ifdef UNICODE
#if(_WIN32_WINNT >= 0x0600)
	typedef ADDRINFOEXW     ADDRINFOEX, *PADDRINFOEX;
#endif
#	define GetAddrInfoEx	GetAddrInfoExW
#	define GetAddrInfo		GetAddrInfoW
#	define FreeAddrInfo		FreeAddrInfoW
#	define SetAddrInfoEx	SetAddrInfoExW
#	define GetNameInfo		GetNameInfoW
#	define WSAEnumNameSpaceProvidersEx	WSAEnumNameSpaceProvidersExW
#	define InetNtop			InetNtopW
#	define InetPton			InetPtonW
#else
#if(_WIN32_WINNT >= 0x0600)
	typedef ADDRINFOEXA     ADDRINFOEX, *PADDRINFOEX;
#endif
#	define GetAddrInfoEx	GetAddrInfoExA
#	define GetAddrInfo		getaddrinfo
#	define FreeAddrInfo		freeaddrinfo
#	define SetAddrInfoEx	SetAddrInfoExA
#	define GetNameInfo		getnameinfo
#	define WSAEnumNameSpaceProvidersEx	WSAEnumNameSpaceProvidersExA
#	define InetNtop			inet_ntop
#	define InetPton			inet_pton
#endif

#endif//__MINGW32__




#if		( _WIN32_WINNT < 0x0501 )

//WinSock 2 extension -- manifest constants and associated structures for WSANSPIoctl()

#define SIO_NSP_NOTIFY_CHANGE         _WSAIOW(IOC_WS2,25)

typedef enum _WSACOMPLETIONTYPE 
{
    NSP_NOTIFY_IMMEDIATELY = 0,
    NSP_NOTIFY_HWND,
    NSP_NOTIFY_EVENT,
    NSP_NOTIFY_PORT,
    NSP_NOTIFY_APC,
} WSACOMPLETIONTYPE, *PWSACOMPLETIONTYPE, FAR * LPWSACOMPLETIONTYPE;

typedef struct _WSACOMPLETION 
{
    WSACOMPLETIONTYPE Type;
    union 
	{
        struct 
		{
            HWND hWnd;
            UINT uMsg;
            WPARAM context;
        } WindowMessage;
        struct 
		{
            LPWSAOVERLAPPED lpOverlapped;
        } Event;
        struct 
		{
            LPWSAOVERLAPPED lpOverlapped;
            LPWSAOVERLAPPED_COMPLETION_ROUTINE lpfnCompletionProc;
        } Apc;
        struct 
		{
            LPWSAOVERLAPPED lpOverlapped;
            HANDLE hPort;
            ULONG_PTR Key;
        } Port;
    } Parameters;
} WSACOMPLETION, *PWSACOMPLETION, FAR *LPWSACOMPLETION;
#endif

#if		( _WIN32_WINNT < 0x0600 )
typedef struct addrinfoexA
{
    int                 ai_flags;       // AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST
    int                 ai_family;      // PF_xxx
    int                 ai_socktype;    // SOCK_xxx
    int                 ai_protocol;    // 0 or IPPROTO_xxx for IPv4 and IPv6
    size_t              ai_addrlen;     // Length of ai_addr
    char               *ai_canonname;   // Canonical name for nodename
    struct sockaddr    *ai_addr;        // Binary address
    void               *ai_blob;
    size_t              ai_bloblen;
    LPGUID              ai_provider;
    struct addrinfoexA *ai_next;        // Next structure in linked list
} ADDRINFOEXA, *PADDRINFOEXA, *LPADDRINFOEXA;

typedef struct addrinfoexW
{
    int                 ai_flags;       // AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST
    int                 ai_family;      // PF_xxx
    int                 ai_socktype;    // SOCK_xxx
    int                 ai_protocol;    // 0 or IPPROTO_xxx for IPv4 and IPv6
    size_t              ai_addrlen;     // Length of ai_addr
    PWSTR               ai_canonname;   // Canonical name for nodename
    struct sockaddr    *ai_addr;        // Binary address
    void               *ai_blob;
    size_t              ai_bloblen;
    LPGUID              ai_provider;
    struct addrinfoexW *ai_next;        // Next structure in linked list
} ADDRINFOEXW, *PADDRINFOEXW, *LPADDRINFOEXW;

#	ifdef UNICODE
		typedef ADDRINFOEXW     ADDRINFOEX, *PADDRINFOEX;
#		define GetAddrInfoEx	GetAddrInfoExW
#		define GetAddrInfo		GetAddrInfoW
#		define FreeAddrInfo		FreeAddrInfoW
#		define SetAddrInfoEx	SetAddrInfoExW
#		define GetNameInfo		GetNameInfoW
#		define WSAEnumNameSpaceProvidersEx	WSAEnumNameSpaceProvidersExW
#		define InetNtop			InetNtopW
#		define InetPton			InetPtonW
#	else
		typedef ADDRINFOEXA     ADDRINFOEX, *PADDRINFOEX;
#		define GetAddrInfoEx	GetAddrInfoExA
#		define GetAddrInfo		getaddrinfo
#		define FreeAddrInfo		freeaddrinfo
#		define SetAddrInfoEx	SetAddrInfoExA
#		define GetNameInfo		getnameinfo
#		define WSAEnumNameSpaceProvidersEx	WSAEnumNameSpaceProvidersExA
#		define InetNtop			inet_ntop
#		define InetPton			inet_pton
#	endif

typedef void ( CALLBACK * LPLOOKUPSERVICE_COMPLETION_ROUTINE)( DWORD dwError, DWORD dwBytes, LPWSAOVERLAPPED lpOverlapped );

typedef struct pollfd 
{
    SOCKET  fd;
    SHORT   events;
    SHORT   revents;

} WSAPOLLFD, *PWSAPOLLFD, FAR *LPWSAPOLLFD;

typedef enum _WSC_PROVIDER_INFO_TYPE 
{
//  InfoType is:                  Info points to:
    ProviderInfoLspCategories, // DWORD (LspCategories)
    ProviderInfoAudit,         // struct WSC_PROVIDER_AUDIT_INFO
} WSC_PROVIDER_INFO_TYPE ;

#endif

//--------------------------------------------------------------------------------
namespace nsWinQAPI
{
	//Updated to comply with Windows 7 64bit Pro WS2_32.dll
	//--------------------------------------------------------------------------------	
	class __QOR_INTERFACE( __WINQAPI ) CWS2_32 : public CDll
	{
	public:

		//--------------------------------------------------------------------------------
		CWS2_32() : CDll( TEXT("WS2_32") )
		{						
		}

		//--------------------------------------------------------------------------------
		static CWS2_32& Instance( void )
		{
			static CWS2_32 _instance;
			return _instance;
		}

		//--------------------------------------------------------------------------------
		~CWS2_32()
		{						
		}

		SOCKET accept( SOCKET s, sockaddr* addr, int* addrlen );
		int bind( SOCKET s, const sockaddr* name, int namelen );
		int closesocket( SOCKET s );
		int connect( SOCKET s, const sockaddr* name, int namelen );
		int getpeername( SOCKET s, sockaddr* name, int* namelen );
		int getsockname( SOCKET s, struct sockaddr* name, int* namelen );
		int getsockopt( SOCKET s, int level, int optname, char* optval, int* optlen );
		u_long htonl( u_long hostlong );
		u_short htons( u_short hostshort );
		int ioctlsocket( SOCKET s, long cmd, u_long* argp );
		unsigned long inet_addr( const char* cp );
		char* inet_ntoa( in_addr in );
		int listen( SOCKET s, int backlog );
		u_long ntohl( u_long netlong );
		u_short ntohs( u_short netshort );
		int recv( SOCKET s, char* buf, int len, int flags );
		int recvfrom( SOCKET s, char* buf, int len, int flags, sockaddr* from, int* fromlen );
		int select( int nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, const timeval* timeout );
		int send( SOCKET s, const char* buf, int len, int flags );
		int sendto( SOCKET s, const char* buf, int len, int flags, const sockaddr* to, int tolen );
		int setsockopt( SOCKET s, int level, int optname, const char* optval, int optlen );
		int shutdown( SOCKET s, int how );
		SOCKET socket( int af, int type, int protocol );
		void FreeAddrInfoEx( PADDRINFOEX pAddrInfo );
		void FreeAddrInfoW( PADDRINFOW pAddrInfo );
		int GetAddrInfoExA( PCSTR pName, PCSTR pServiceName, DWORD dwNameSpace, LPGUID lpNspId, const ADDRINFOEX* pHints, PADDRINFOEX* ppResult, timeval* timeout, LPOVERLAPPED lpOverlapped, LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine, LPHANDLE lpNameHandle );
		int GetAddrInfoExW( PCWSTR pName, PCWSTR pServiceName, DWORD dwNameSpace, LPGUID lpNspId, const ADDRINFOEX* pHints, PADDRINFOEX* ppResult, timeval* timeout, LPOVERLAPPED lpOverlapped, LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine, LPHANDLE lpNameHandle );
		int GetAddrInfoW( PCWSTR pNodeName, PCWSTR pServiceName, const ADDRINFOW* pHints, PADDRINFOW* ppResult );
		int GetNameInfoW( const SOCKADDR* pSockaddr, socklen_t SockaddrLength, PWCHAR pNodeBuffer, DWORD NodeBufferSize, PWCHAR pServiceBuffer, DWORD ServiceBufferSize, INT Flags );
		PCWSTR InetNtopW( INT Family, PVOID pAddr, PWSTR pStringBuf, size_t StringBufSize );
		INT InetPtonW( INT Family, PCWSTR pszAddrString, PVOID pAddrBuf );
		int SetAddrInfoExA( PCSTR pName, PCSTR pServiceName, SOCKET_ADDRESS* pAddresses, DWORD dwAddressCount, LPBLOB lpBlob, DWORD dwFlags, DWORD dwNameSpace, LPGUID lpNspId, timeval* timeout, LPOVERLAPPED lpOverlapped, LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine, LPHANDLE lpNameHandle );
		int SetAddrInfoExW( PCWSTR pName, PCWSTR pServiceName, SOCKET_ADDRESS* pAddresses, DWORD dwAddressCount, LPBLOB lpBlob, DWORD dwFlags, DWORD dwNameSpace, LPGUID lpNspId, timeval* timeout, LPOVERLAPPED lpOverlapped, LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine, LPHANDLE lpNameHandle );
		SOCKET WSAAccept( SOCKET s, sockaddr* addr, LPINT addrlen, LPCONDITIONPROC lpfnCondition, DWORD_PTR dwCallbackData );
		INT WSAAddressToStringA( LPSOCKADDR lpsaAddress, DWORD dwAddressLength, LPWSAPROTOCOL_INFO lpProtocolInfo, LPSTR lpszAddressString, LPDWORD lpdwAddressStringLength );
		INT WSAAddressToStringW( LPSOCKADDR lpsaAddress, DWORD dwAddressLength, LPWSAPROTOCOL_INFO lpProtocolInfo, LPWSTR lpszAddressString, LPDWORD lpdwAddressStringLength );
		INT WSAAdvertiseProvider( const GUID* puuidProviderId, const LPCNSPV2_ROUTINE* pNSPv2Routine );
		BOOL WSACloseEvent( WSAEVENT hEvent );
		int WSAConnect( SOCKET s, const sockaddr* name, int namelen, LPWSABUF lpCallerData, LPWSABUF lpCalleeData, LPQOS lpSQOS, LPQOS lpGQOS );
		BOOL WSAConnectByList( SOCKET s, PSOCKET_ADDRESS_LIST SocketAddressList, LPDWORD LocalAddressLength, LPSOCKADDR LocalAddress, LPDWORD RemoteAddressLength, LPSOCKADDR RemoteAddress, const timeval* timeout, LPWSAOVERLAPPED Reserved );
		BOOL WSAConnectByNameA( SOCKET s, LPSTR nodename, LPSTR servicename, LPDWORD LocalAddressLength, LPSOCKADDR LocalAddress, LPDWORD RemoteAddressLength, LPSOCKADDR RemoteAddress, const timeval* timeout, LPWSAOVERLAPPED Reserved );
		BOOL WSAConnectByNameW( SOCKET s, LPWSTR nodename, LPWSTR servicename, LPDWORD LocalAddressLength, LPSOCKADDR LocalAddress, LPDWORD RemoteAddressLength, LPSOCKADDR RemoteAddress, const timeval* timeout, LPWSAOVERLAPPED Reserved );
		WSAEVENT WSACreateEvent(void);
		int WSADuplicateSocketA( SOCKET s, DWORD dwProcessId, LPWSAPROTOCOL_INFO lpProtocolInfo );
		int WSADuplicateSocketW( SOCKET s, DWORD dwProcessId, LPWSAPROTOCOL_INFO lpProtocolInfo );
		INT WSAEnumNameSpaceProvidersA( LPDWORD lpdwBufferLength, LPWSANAMESPACE_INFO lpnspBuffer );
		INT WSAEnumNameSpaceProvidersExA( LPDWORD lpdwBufferLength, LPWSANAMESPACE_INFOEX lpnspBuffer );
		hostent* gethostbyaddr( const char* addr, int len, int type );
		hostent* gethostbyname( const char* name );
		::PROTOENT* getprotobyname( const char* name );
		::PROTOENT* getprotobynumber( int number );
		servent* getservbyname( const char* name, const char* proto );
		servent* getservbyport( int port, const char* proto );
		int gethostname( char* name, int namelen );
		INT WSAEnumNameSpaceProvidersExW( LPDWORD lpdwBufferLength, LPWSANAMESPACE_INFOEX lpnspBuffer );
		INT WSAEnumNameSpaceProvidersW( LPDWORD lpdwBufferLength, LPWSANAMESPACE_INFO lpnspBuffer );
		int WSAEnumNetworkEvents( SOCKET s, WSAEVENT hEventObject, LPWSANETWORKEVENTS lpNetworkEvents );
		int WSAEnumProtocolsA( LPINT lpiProtocols, LPWSAPROTOCOL_INFO lpProtocolBuffer, LPDWORD lpdwBufferLength );
		int WSAEnumProtocolsW( LPINT lpiProtocols, LPWSAPROTOCOL_INFO lpProtocolBuffer, LPDWORD lpdwBufferLength );
		int WSAEventSelect( SOCKET s, WSAEVENT hEventObject, long lNetworkEvents );
		BOOL WSAGetOverlappedResult( SOCKET s, LPWSAOVERLAPPED lpOverlapped, LPDWORD lpcbTransfer, BOOL fWait, LPDWORD lpdwFlags );
		BOOL WSAGetQOSByName( SOCKET s, LPWSABUF lpQOSName, LPQOS lpQOS );
		INT WSAGetServiceClassInfoA( LPGUID lpProviderId, LPGUID lpServiceClassId, LPDWORD lpdwBufferLength, LPWSASERVICECLASSINFO lpServiceClassInfo );
		INT WSAGetServiceClassInfoW( LPGUID lpProviderId, LPGUID lpServiceClassId, LPDWORD lpdwBufferLength, LPWSASERVICECLASSINFO lpServiceClassInfo );
		INT WSAGetServiceClassNameByClassIdA( LPGUID lpServiceClassId, LPSTR lpszServiceClassName, LPDWORD lpdwBufferLength );
		INT WSAGetServiceClassNameByClassIdW( LPGUID lpServiceClassId, LPWSTR lpszServiceClassName, LPDWORD lpdwBufferLength );
		int WSAHtonl( SOCKET s, u_long hostlong, u_long* lpnetlong );
		int WSAHtons( SOCKET s, u_short hostshort, u_short* lpnetshort );
		INT WSAInstallServiceClassA( LPWSASERVICECLASSINFO lpServiceClassInfo );
		INT WSAInstallServiceClassW( LPWSASERVICECLASSINFO lpServiceClassInfo );
		int WSAIoctl( SOCKET s, DWORD dwIoControlCode, LPVOID lpvInBuffer, DWORD cbInBuffer, LPVOID lpvOutBuffer, DWORD cbOutBuffer, LPDWORD lpcbBytesReturned, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine );
		SOCKET WSAJoinLeaf( SOCKET s, const sockaddr* name, int namelen, LPWSABUF lpCallerData, LPWSABUF lpCalleeData, LPQOS lpSQOS, LPQOS lpGQOS, DWORD dwFlags );
		INT WSALookupServiceBeginA( LPWSAQUERYSET lpqsRestrictions, DWORD dwControlFlags, LPHANDLE lphLookup );
		INT WSALookupServiceBeginW( LPWSAQUERYSET lpqsRestrictions, DWORD dwControlFlags, LPHANDLE lphLookup );
		INT WSALookupServiceEnd( HANDLE hLookup );
		INT WSALookupServiceNextA( HANDLE hLookup, DWORD dwControlFlags, LPDWORD lpdwBufferLength, LPWSAQUERYSET lpqsResults );
		INT WSALookupServiceNextW( HANDLE hLookup, DWORD dwControlFlags, LPDWORD lpdwBufferLength, LPWSAQUERYSET lpqsResults );
		int WSANSPIoctl( HANDLE hLookup, DWORD dwControlCode, LPVOID lpvInBuffer, DWORD cbInBuffer, LPVOID lpvOutBuffer, DWORD cbOutBuffer, LPDWORD lpcbBytesReturned, LPWSACOMPLETION lpCompletion );
		int WSANtohl( SOCKET s, u_long netlong, u_long* lphostlong );
		int WSANtohs( SOCKET s, u_short netshort, u_short* lphostshort );
		int WSAPoll( WSAPOLLFD fdarray[], ULONG nfds, INT timeout );
		INT WSAProviderCompleteAsyncCall( HANDLE hAsyncCall, INT iRetCode );
		int WSAProviderConfigChange( LPHANDLE lpNotificationHandle, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine );
		int WSARecv( SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesRecvd, LPDWORD lpFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine );
		int WSARecvDisconnect( SOCKET s, LPWSABUF lpInboundDisconnectData );
		int WSARecvFrom( SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesRecvd, LPDWORD lpFlags, struct sockaddr* lpFrom, LPINT lpFromLen, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine );
		INT WSARemoveServiceClass( LPGUID lpServiceClassId );
		BOOL WSAResetEvent( WSAEVENT hEvent );
		int WSASend( SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesSent, DWORD dwFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine );
		int WSASendDisconnect( SOCKET s, LPWSABUF lpOutboundDisconnectData );
		int WSASendMsg( SOCKET s, LPWSAMSG lpMsg, DWORD dwFlags, LPDWORD lpNumberOfBytesSent, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine );
		int WSASendTo( SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesSent, DWORD dwFlags, const sockaddr* lpTo, int iToLen, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine );
		BOOL WSASetEvent( WSAEVENT hEvent );
		INT WSASetServiceA( LPWSAQUERYSET lpqsRegInfo, WSAESETSERVICEOP essOperation, DWORD dwControlFlags );
		INT WSASetServiceW( LPWSAQUERYSET lpqsRegInfo, WSAESETSERVICEOP essOperation, DWORD dwControlFlags );
		SOCKET WSASocketA( int af, int type, int protocol, LPWSAPROTOCOL_INFO lpProtocolInfo, GROUP g, DWORD dwFlags );
		SOCKET WSASocketW( int af, int type, int protocol, LPWSAPROTOCOL_INFO lpProtocolInfo, GROUP g, DWORD dwFlags );
		int WSAAsyncSelect( SOCKET s, HWND hWnd, unsigned int wMsg, long lEvent );
		HANDLE WSAAsyncGetHostByAddr( HWND hWnd, unsigned int wMsg, const char* addr, int len, int type, char* buf, int buflen );
		HANDLE WSAAsyncGetHostByName( HWND hWnd, unsigned int wMsg, const char* name, char* buf, int buflen );
		HANDLE WSAAsyncGetProtoByNumber( HWND hWnd, unsigned int wMsg, int number, char* buf, int buflen );
		HANDLE WSAAsyncGetProtoByName( HWND hWnd, unsigned int wMsg, const char* name, char* buf, int buflen );
		HANDLE WSAAsyncGetServByPort( HWND hWnd, unsigned int wMsg, int port, const char* proto, char* buf, int buflen );
		HANDLE WSAAsyncGetServByName( HWND hWnd, unsigned int wMsg, const char* name, const char* proto, char* buf, int buflen );
		int WSACancelAsyncRequest( HANDLE hAsyncTaskHandle );
		int WSAGetLastError( void );
		void WSASetLastError( int iError );
		int WSAStartup( WORD wVersionRequested, LPWSADATA lpWSAData );
		int WSACleanup( void );
		INT WSAStringToAddressA( LPSTR AddressString, INT AddressFamily, LPWSAPROTOCOL_INFO lpProtocolInfo, LPSOCKADDR lpAddress, LPINT lpAddressLength );
		INT WSAStringToAddressW( LPWSTR AddressString, INT AddressFamily, LPWSAPROTOCOL_INFO lpProtocolInfo, LPSOCKADDR lpAddress, LPINT lpAddressLength );
		INT WSAUnadvertiseProvider( const GUID* puuidProviderId );
		DWORD WSAWaitForMultipleEvents( DWORD cEvents, const WSAEVENT* lphEvents, BOOL fWaitAll, DWORD dwTimeout, BOOL fAlertable );
		int WSCDeinstallProvider( LPGUID lpProviderId, LPINT lpErrno );
		int WSCEnableNSProvider( LPGUID lpProviderId, BOOL fEnable );
		int WSCEnumProtocols( LPINT lpiProtocols, LPWSAPROTOCOL_INFOW lpProtocolBuffer, LPDWORD lpdwBufferLength, LPINT lpErrno );
		int WSCGetApplicationCategory( LPCWSTR Path, DWORD PathLength, LPCWSTR Extra, DWORD ExtraLength, DWORD* pPermittedLspCategories, LPINT lpErrno );
		int WSCGetProviderInfo( LPGUID lpProviderId, WSC_PROVIDER_INFO_TYPE InfoType, PBYTE Info, size_t* InfoSize, DWORD Flags, LPINT lpErrno );
		int WSCGetProviderPath( LPGUID lpProviderId, LPWSTR lpszProviderDllPath, LPINT lpProviderDllPathLen, LPINT lpErrno );
		int WSCInstallNameSpace( LPWSTR lpszIdentifier, LPWSTR lpszPathName, DWORD dwNameSpace, DWORD dwVersion, LPGUID lpProviderId );
		int WSCInstallNameSpaceEx( LPWSTR lpszIdentifier, LPWSTR lpszPathName, DWORD dwNameSpace, DWORD dwVersion, LPGUID lpProviderId, LPBLOB lpProviderInfo );
		int WSCInstallProvider( const LPGUID lpProviderId, const LPWSTR lpszProviderDllPath, const LPWSAPROTOCOL_INFO lpProtocolInfoList, DWORD dwNumberOfEntries, LPINT lpErrno );
		int WSCInstallProviderAndChains( const LPGUID lpProviderId, const LPWSTR lpszProviderDllPath, const LPWSTR lpszLspName, DWORD dwServiceFlags, const LPWSAPROTOCOL_INFO lpProtocolInfoList, DWORD dwNumberOfEntries, LPDWORD lpdwCatalogEntryId, LPINT lpErrno );
		int WSCSetApplicationCategory( LPCWSTR Path, DWORD PathLength, LPCWSTR Extra, DWORD ExtraLength, DWORD PermittedLspCategories, DWORD* pPrevPermLspCat, LPINT lpErrno );
		int WSCSetProviderInfo( LPGUID lpProviderId, WSC_PROVIDER_INFO_TYPE InfoType, PBYTE Info, size_t InfoSize, DWORD Flags, LPINT lpErrno );
		int WSCUnInstallNameSpace( LPGUID lpProviderId );
		int WSCUpdateProvider( LPGUID lpProviderId, const WCHAR* lpszProviderDllPath, const LPWSAPROTOCOL_INFO lpProtocolInfoList, DWORD dwNumberOfEntries, LPINT lpErrno );
		int WSCWriteNameSpaceOrder( LPGUID lpProviderId, DWORD dwNumberOfEntries );
		int WSCWriteProviderOrder( LPDWORD lpwdCatalogEntryId, DWORD dwNumberOfEntries );
		int __WSAFDIsSet( SOCKET fd, fd_set* set );
		void freeaddrinfo( addrinfo* ai );
		int getaddrinfo( PCSTR pNodeName, PCSTR pServiceName, const ADDRINFOA* pHints, PADDRINFOA* ppResult );
		int getnameinfo( const sockaddr* sa, socklen_t salen, char* host, DWORD hostlen, char* serv, DWORD servlen, int flags );
		PCSTR inet_ntop( INT Family, PVOID pAddr, PSTR pStringBuf, size_t StringBufSize );
		INT inet_pton( INT Family, PCSTR pszAddrString, PVOID pAddrBuf );

		//WEP
	};

}//nsWinQAPI

#endif//_QSYS_API_WIN32_MODULES_WS2_32_H_

