//AdvAPI32.h

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef WINQAPI_ADVAPI32_H_1
#define WINQAPI_ADVAPI32_H_1

#include "WinQAPI/Kernel32.h"
#include "../Source/SystemQOR/MSWindows/WinQAPI/include/DynamicLibrary.h"

//#if(_MSC_VER < 1700 )
#	ifndef __MINGW32__
#		include <MsChapp.h>
#	endif//__MINGW32__
//#endif

#define WIN32_NO_STATUS 1
#include <winnt.h>
#undef WIN32_NO_STATUS

#	ifndef __MINGW32__

__QCMP_WARNING_PUSH
__QCMP_WARNING_DISABLE( __QCMP_WARN_MACRO_REDEFINITION, "NTSTATUS macros defined awkwardly in Windows headers" )
#		include <ntstatus.h>
__QCMP_WARNING_POP

#	endif

#include <Sddl.h>
#include <AccCtrl.h>
#include <AclAPI.h>
//#endif

#if ( _WIN32_WINNT > 0x0000 )
//#	if( _MSC_VER < 1700 )
#		define _NTDEF_ //because we already included WInternal in Kernel32
#		include <ntsecapi.h>
//#	endif
#else
typedef PVOID LSA_HANDLE, *PLSA_HANDLE;
typedef struct _LSA_UNICODE_STRING 
{
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength/2), length_is(Length/2)]
#endif // MIDL_PASS
    PWSTR  Buffer;
} LSA_UNICODE_STRING, *PLSA_UNICODE_STRING;

typedef struct _LSA_STRING 
{
    USHORT Length;
    USHORT MaximumLength;
    PCHAR Buffer;
} LSA_STRING, *PLSA_STRING;

typedef struct _UNICODE_STRING 
{
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;

typedef struct _TRUSTED_DOMAIN_INFORMATION_EX 
{

    LSA_UNICODE_STRING Name;
    LSA_UNICODE_STRING FlatName;
    PSID  Sid;
    ULONG TrustDirection;
    ULONG TrustType;
    ULONG TrustAttributes;

} TRUSTED_DOMAIN_INFORMATION_EX, *PTRUSTED_DOMAIN_INFORMATION_EX;

typedef ULONG LSA_ENUMERATION_HANDLE, *PLSA_ENUMERATION_HANDLE;

typedef struct _LSA_AUTH_INFORMATION 
{
    LARGE_INTEGER LastUpdateTime;
    ULONG AuthType;
    ULONG AuthInfoLength;
    PUCHAR AuthInfo;
} LSA_AUTH_INFORMATION, *PLSA_AUTH_INFORMATION;

typedef struct _TRUSTED_DOMAIN_AUTH_INFORMATION 
{
    ULONG IncomingAuthInfos;
    PLSA_AUTH_INFORMATION   IncomingAuthenticationInformation;
    PLSA_AUTH_INFORMATION   IncomingPreviousAuthenticationInformation;
    ULONG OutgoingAuthInfos;
    PLSA_AUTH_INFORMATION   OutgoingAuthenticationInformation;
    PLSA_AUTH_INFORMATION   OutgoingPreviousAuthenticationInformation;

} TRUSTED_DOMAIN_AUTH_INFORMATION, *PTRUSTED_DOMAIN_AUTH_INFORMATION;

typedef struct _LSA_TRUST_INFORMATION 
{
    LSA_UNICODE_STRING Name;
    PSID Sid;

} LSA_TRUST_INFORMATION, *PLSA_TRUST_INFORMATION;

typedef struct _LSA_REFERENCED_DOMAIN_LIST 
{
    ULONG Entries;
    PLSA_TRUST_INFORMATION Domains;

} LSA_REFERENCED_DOMAIN_LIST, *PLSA_REFERENCED_DOMAIN_LIST;

typedef struct _LSA_TRANSLATED_SID 
{
    SID_NAME_USE Use;
    ULONG RelativeId;
    LONG DomainIndex;

} LSA_TRANSLATED_SID, *PLSA_TRANSLATED_SID;

typedef struct _LSA_TRANSLATED_SID2 
{
    SID_NAME_USE Use;
    PSID         Sid;
    LONG         DomainIndex;
    ULONG        Flags;

} LSA_TRANSLATED_SID2, *PLSA_TRANSLATED_SID2;

typedef struct _LSA_TRANSLATED_NAME 
{
    SID_NAME_USE Use;
    LSA_UNICODE_STRING Name;
    LONG DomainIndex;

} LSA_TRANSLATED_NAME, *PLSA_TRANSLATED_NAME;

typedef struct _OBJECT_ATTRIBUTES 
{
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;
    PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;

typedef OBJECT_ATTRIBUTES LSA_OBJECT_ATTRIBUTES, *PLSA_OBJECT_ATTRIBUTES;

typedef enum _TRUSTED_INFORMATION_CLASS 
{
    TrustedDomainNameInformation = 1,
    TrustedControllersInformation,
    TrustedPosixOffsetInformation,
    TrustedPasswordInformation,
    TrustedDomainInformationBasic,
    TrustedDomainInformationEx,
    TrustedDomainAuthInformation,
    TrustedDomainFullInformation,
    TrustedDomainAuthInformationInternal,
    TrustedDomainFullInformationInternal,
    TrustedDomainInformationEx2Internal,
    TrustedDomainFullInformation2Internal,
    TrustedDomainSupportedEncryptionTypes,
} TRUSTED_INFORMATION_CLASS, *PTRUSTED_INFORMATION_CLASS;

typedef struct _CERTIFICATE_BLOB 
{
    DWORD   dwCertEncodingType;

#ifdef MIDL_PASS
    [range(0,32768)] 
#endif // MIDL_PASS

    DWORD   cbData;

#ifdef MIDL_PASS
    [size_is(cbData)]
#endif // MIDL_PASS
    PBYTE    pbData;

} EFS_CERTIFICATE_BLOB, *PEFS_CERTIFICATE_BLOB;

typedef struct _ENCRYPTION_CERTIFICATE 
{
    DWORD cbTotalLength;
    SID * pUserSid;
    PEFS_CERTIFICATE_BLOB pCertBlob;
} ENCRYPTION_CERTIFICATE, *PENCRYPTION_CERTIFICATE;

typedef struct _ENCRYPTION_CERTIFICATE_LIST 
{    
#ifdef MIDL_PASS
    [range(0,500)] 
#endif // MIDL_PASS
    DWORD nUsers;
#ifdef MIDL_PASS
    [size_is(nUsers)]
#endif // MIDL_PASS
     PENCRYPTION_CERTIFICATE * pUsers;
} ENCRYPTION_CERTIFICATE_LIST, *PENCRYPTION_CERTIFICATE_LIST;

typedef struct _EFS_HASH_BLOB 
{
#ifdef MIDL_PASS
    [range(0,100)] 
#endif // MIDL_PASS
    DWORD   cbData;

#ifdef MIDL_PASS
    [size_is(cbData)]
#endif // MIDL_PASS
    PBYTE    pbData;

} EFS_HASH_BLOB, *PEFS_HASH_BLOB;

typedef struct _ENCRYPTION_CERTIFICATE_HASH 
{
    DWORD cbTotalLength;
    SID * pUserSid;
    PEFS_HASH_BLOB  pHash;

#ifdef MIDL_PASS
    [string]
#endif // MIDL_PASS
    LPWSTR lpDisplayInformation;

} ENCRYPTION_CERTIFICATE_HASH, *PENCRYPTION_CERTIFICATE_HASH;

typedef struct _ENCRYPTION_CERTIFICATE_HASH_LIST 
{
#ifdef MIDL_PASS
    [range(0,500)] 
#endif // MIDL_PASS
    DWORD nCert_Hash;
#ifdef MIDL_PASS
    [size_is(nCert_Hash)]
#endif // MIDL_PASS
     PENCRYPTION_CERTIFICATE_HASH * pUsers;
} ENCRYPTION_CERTIFICATE_HASH_LIST, *PENCRYPTION_CERTIFICATE_HASH_LIST;

#endif

#ifndef __MINGW32__
#	include <Wmistr.h>
#	include <evntrace.h>
//#	if( _MSC_VER < 1700 )
#		include <wincred.h>
#		include <WinSafer.h>
//#	endif
#endif//__MINGW32__


#if		( _WIN32_WINNT < 0x0500 )
#	if		( __QOR_UNICODE )
#		define AccessCheckByTypeResultListAndAuditAlarm				AccessCheckByTypeResultListAndAuditAlarmW
#		define AccessCheckByTypeAndAuditAlarm						AccessCheckByTypeAndAuditAlarmW
#		define AccessCheckByTypeResultListAndAuditAlarm				AccessCheckByTypeResultListAndAuditAlarmW
#		define ConvertStringSidToSid								ConvertStringSidToSidW
#		define ConvertSidToStringSid								ConvertSidToStringSidW
#		define ConvertStringSecurityDescriptorToSecurityDescriptor	ConvertStringSecurityDescriptorToSecurityDescriptorW
#		define ConvertSecurityDescriptorToStringSecurityDescriptor	ConvertSecurityDescriptorToStringSecurityDescriptorW
#		define AccessCheckByTypeResultListAndAuditAlarmByHandle		AccessCheckByTypeResultListAndAuditAlarmByHandleW
#	else//ANSI
#		define AccessCheckByTypeResultListAndAuditAlarm				AccessCheckByTypeResultListAndAuditAlarmA
#		define AccessCheckByTypeAndAuditAlarm						AccessCheckByTypeAndAuditAlarmA
#		define AccessCheckByTypeResultListAndAuditAlarm				AccessCheckByTypeResultListAndAuditAlarmA
#		define ConvertStringSidToSid								ConvertStringSidToSidA
#		define ConvertSidToStringSid								ConvertSidToStringSidA
#		define ConvertStringSecurityDescriptorToSecurityDescriptor	ConvertStringSecurityDescriptorToSecurityDescriptorA
#		define ConvertSecurityDescriptorToStringSecurityDescriptor	ConvertSecurityDescriptorToStringSecurityDescriptorA
#		define AccessCheckByTypeResultListAndAuditAlarmByHandle		AccessCheckByTypeResultListAndAuditAlarmByHandleA
#	endif//( __QOR_UNICODE )
#endif//( _WIN32_WINNT < 0x0500 )

#if		( _WIN32_WINNT < 0x0600 )
#	if		( __QOR_UNICODE )
#		define RegDeleteKeyValue	RegDeleteKeyValueW
#		define RegSetKeyValue		RegSetKeyValueW
#		define RegDeleteTree		RegDeleteTreeW
#		define RegCopyTree			RegCopyTreeW
#		define RegGetValue			RegGetValueW
#		define RegLoadMUIString		RegLoadMUIStringW
#		define RegLoadAppKey		RegLoadAppKeyW
#	else
#		define RegDeleteKeyValue	RegDeleteKeyValueA
#		define RegSetKeyValue		RegSetKeyValueA
#		define RegDeleteTree		RegDeleteTreeA
#		define RegCopyTree			RegCopyTreeA
#		define RegGetValue			RegGetValueA
#		define RegLoadMUIString		RegLoadMUIStringA
#		define RegLoadAppKey		RegLoadAppKeyA
#	endif//	( __QOR_UNICODE )
#endif//( _WIN32_WINNT < 0x0600 )

//--------------------------------------------------------------------------------
namespace nsWinQAPI
{
	//Updated to Windows XP SP2 System32\AdvAPI32.dll
	//--------------------------------------------------------------------------------	
	class __QOR_INTERFACE( __WINQAPI ) CAdvAPI32 : public CDll
	{
	public:

		__QOR_DECLARE_OCLASS_ID( CAdvAPI32 );

		//--------------------------------------------------------------------------------
		CAdvAPI32() : CDll( TEXT("ADVAPI32") )
		{						
		}

		//--------------------------------------------------------------------------------
		static CAdvAPI32& Instance( void )
		{
			static CAdvAPI32 _instance;
			return _instance;
		}

		//--------------------------------------------------------------------------------
		~CAdvAPI32()
		{						
		}

		//Basic Access Control
		//------------------------------------------------------------------------------
		BOOL AllocateAndInitializeSid( PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount, DWORD dwSubAuthority0, DWORD dwSubAuthority1, DWORD dwSubAuthority2, DWORD dwSubAuthority3, DWORD dwSubAuthority4, DWORD dwSubAuthority5, DWORD dwSubAuthority6, DWORD dwSubAuthority7, PSID* pSid );
		PVOID FreeSid( PSID pSid );
		BOOL ConvertSidToStringSidA( PSID Sid, LPSTR* StringSid ) const;
		BOOL ConvertSidToStringSidW( PSID Sid, LPWSTR* StringSid ) const;
		BOOL ConvertStringSidToSidA( LPCSTR StringSid, PSID* Sid );
		BOOL ConvertStringSidToSidW( LPCWSTR StringSid, PSID* Sid );
		BOOL CopySid( DWORD nDestinationSidLength, PSID pDestinationSid, PSID pSourceSid );
		DWORD GetLengthSid( PSID pSid );
		BOOL CreateWellKnownSid( WELL_KNOWN_SID_TYPE WellKnownSidType, PSID DomainSid, PSID pSid, DWORD* cbSid );
		BOOL EqualDomainSid( PSID pSid1, PSID pSid2, BOOL* pfEqual );
		BOOL EqualPrefixSid( PSID pSid1, PSID pSid2 );
		BOOL EqualSid( PSID pSid1, PSID pSid2 );
		PSID_IDENTIFIER_AUTHORITY GetSidIdentifierAuthority( PSID pSid );
		DWORD GetSidLengthRequired( UCHAR nSubAuthorityCount );
		PDWORD GetSidSubAuthority( PSID pSid, DWORD nSubAuthority );
		PUCHAR GetSidSubAuthorityCount( PSID pSid );
		BOOL GetWindowsAccountDomainSid( PSID pSid, PSID ppDomainSid, DWORD* cbSid );
		BOOL InitializeSid( PSID Sid, PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount );
		BOOL IsValidSid( PSID pSid );
		BOOL IsWellKnownSid( PSID pSid, WELL_KNOWN_SID_TYPE WellKnownSidType );
		BOOL LookupAccountSidA( LPCSTR lpSystemName, PSID lpSid, LPSTR lpName, LPDWORD cchName, LPSTR lpReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse );
		BOOL LookupAccountSidW( LPCWSTR lpSystemName, PSID lpSid, LPWSTR lpName, LPDWORD cchName, LPWSTR lpReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse );

		//Access Control functions
		BOOL AccessCheck( PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, ::PGENERIC_MAPPING GenericMapping, ::PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus );
		BOOL AccessCheckAndAuditAlarmA( LPCSTR SubsystemName, LPVOID HandleId, LPSTR ObjectTypeName, LPSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, DWORD DesiredAccess, ::PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose );
		BOOL WINAPI AccessCheckAndAuditAlarmW( LPCWSTR SubsystemName, LPVOID HandleId, LPWSTR ObjectTypeName, LPWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, DWORD DesiredAccess, ::PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose );
		BOOL AccessCheckByType( PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, DWORD DesiredAccess, ::POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, ::PGENERIC_MAPPING GenericMapping, ::PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus );
		BOOL AccessCheckByTypeAndAuditAlarmA( LPCSTR SubsystemName, LPVOID HandleId, LPCSTR ObjectTypeName,
											 LPCSTR ObjectName, PSECURITY_DESCRIPTOR pSecurityDescriptor,
											 PSID PrincipalSelfSid, DWORD DesiredAccess, ::AUDIT_EVENT_TYPE AuditType,
											 DWORD Flags, ::POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength,
											 ::PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess,
											 LPBOOL AccessStatus, LPBOOL pfGenerateOnClose );
		BOOL AccessCheckByTypeAndAuditAlarmW( LPCWSTR SubsystemName, LPVOID HandleId, LPCWSTR ObjectTypeName,
											 LPCWSTR ObjectName, PSECURITY_DESCRIPTOR pSecurityDescriptor,
											 PSID PrincipalSelfSid, DWORD DesiredAccess, ::AUDIT_EVENT_TYPE AuditType,
											 DWORD Flags, ::POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength,
											 ::PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess,
											 LPBOOL AccessStatus, LPBOOL pfGenerateOnClose );
		BOOL AccessCheckByTypeResultList( PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken,
										 DWORD DesiredAccess, ::POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength,
										  ::PGENERIC_MAPPING GenericMapping, ::PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength,
										  LPDWORD GrantedAccessList, LPDWORD AccessStatusList );
		BOOL AccessCheckByTypeResultListAndAuditAlarmA( LPCSTR SubsystemName, LPVOID HandleId, LPCSTR ObjectTypeName,
													  LPCSTR ObjectName, PSECURITY_DESCRIPTOR pSecurityDescriptor,
													  PSID PrincipalSelfSid, DWORD DesiredAccess, 
													  ::AUDIT_EVENT_TYPE AuditType, DWORD Flags, 
													  ::POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength,
													  ::PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, 
													  LPDWORD GrantedAccess, LPDWORD AccessStatusList, 
													  LPBOOL pfGenerateOnClose );
		BOOL AccessCheckByTypeResultListAndAuditAlarmW( LPCWSTR SubsystemName, LPVOID HandleId, LPCWSTR ObjectTypeName,
													  LPCWSTR ObjectName, PSECURITY_DESCRIPTOR pSecurityDescriptor,
													  PSID PrincipalSelfSid, DWORD DesiredAccess, 
													  ::AUDIT_EVENT_TYPE AuditType, DWORD Flags, 
													  ::POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength,
													  ::PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, 
													  LPDWORD GrantedAccess, LPDWORD AccessStatusList, 
													  LPBOOL pfGenerateOnClose );
		BOOL AccessCheckByTypeResultListAndAuditAlarmByHandleA( LPCSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken,
															   LPCSTR ObjectTypeName, LPCSTR ObjectName, 
															   PSECURITY_DESCRIPTOR pSecurityDescriptor, 
															   PSID PrincipalSelfSid, DWORD DesiredAccess, 
															   ::AUDIT_EVENT_TYPE AuditType, DWORD Flags, 
															   ::POBJECT_TYPE_LIST ObjectTypeList, 
															   DWORD ObjectTypeListLength, ::PGENERIC_MAPPING GenericMapping,
															   BOOL ObjectCreation, LPDWORD GrantedAccess, 
															   LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose );
		BOOL AccessCheckByTypeResultListAndAuditAlarmByHandleW( LPCWSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken,
															   LPCWSTR ObjectTypeName, LPCWSTR ObjectName,
															   PSECURITY_DESCRIPTOR pSecurityDescriptor,
															   PSID PrincipalSelfSid, DWORD DesiredAccess,
															   ::AUDIT_EVENT_TYPE AuditType, DWORD Flags,
															   ::POBJECT_TYPE_LIST ObjectTypeList,
															   DWORD ObjectTypeListLength, ::PGENERIC_MAPPING GenericMapping,
															   BOOL ObjectCreation, LPDWORD GrantedAccess,
															   LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose );
		BOOL AdjustTokenGroups( HANDLE TokenHandle, BOOL ResetToDefault, PTOKEN_GROUPS NewState, DWORD BufferLength,
							   PTOKEN_GROUPS PreviousState, PDWORD ReturnLength );
		BOOL AdjustTokenPrivileges( HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, 
								   DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength, BOOL& bAllSuccess );
		BOOL AllocateLocallyUniqueId( ::PLUID Luid );
		VOID BuildExplicitAccessWithNameA( ::PEXPLICIT_ACCESS pExplicitAccess, LPSTR pTrusteeName, DWORD AccessPermissions, ::ACCESS_MODE AccessMode, DWORD Inheritance );
		VOID BuildExplicitAccessWithNameW( ::PEXPLICIT_ACCESS pExplicitAccess, LPWSTR pTrusteeName, DWORD AccessPermissions, ::ACCESS_MODE AccessMode, DWORD Inheritance );
		VOID BuildTrusteeWithNameA( ::PTRUSTEE pTrustee, LPSTR pName );
		VOID BuildTrusteeWithNameW( ::PTRUSTEE pTrustee, LPWSTR pName );
		void BuildTrusteeWithObjectsAndNameA( ::PTRUSTEE pTrustee, ::POBJECTS_AND_NAME_ pObjName, ::SE_OBJECT_TYPE ObjectType,
											 LPSTR ObjectTypeName, LPSTR InheritedObjectTypeName, LPSTR Name );
		void BuildTrusteeWithObjectsAndNameW( ::PTRUSTEE pTrustee, ::POBJECTS_AND_NAME_ pObjName, 
													::SE_OBJECT_TYPE ObjectType, LPWSTR ObjectTypeName, 
													LPWSTR InheritedObjectTypeName, LPWSTR Name );
		void BuildTrusteeWithObjectsAndSidA( ::PTRUSTEE pTrustee, ::POBJECTS_AND_SID pObjSid, ::GUID* pObjectGuid, ::GUID* pInheritedObjectGuid, PSID pSid );
		void BuildTrusteeWithObjectsAndSidW( ::PTRUSTEE pTrustee, ::POBJECTS_AND_SID pObjSid, ::GUID* pObjectGuid, ::GUID* pInheritedObjectGuid, PSID pSid );
		VOID BuildTrusteeWithSidA( ::PTRUSTEE pTrustee, PSID pSid );
		VOID BuildTrusteeWithSidW( ::PTRUSTEE pTrustee, PSID pSid );
		BOOL CheckTokenMembership( HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember );
		BOOL ConvertSecurityDescriptorToStringSecurityDescriptorA( PSECURITY_DESCRIPTOR SecurityDescriptor,
																  DWORD RequestedStringSDRevision,
																  SECURITY_INFORMATION SecurityInformation,
																  LPSTR* StringSecurityDescriptor,
																  PULONG StringSecurityDescriptorLen );
		BOOL ConvertSecurityDescriptorToStringSecurityDescriptorW( PSECURITY_DESCRIPTOR SecurityDescriptor,
																		DWORD RequestedStringSDRevision,
																		SECURITY_INFORMATION SecurityInformation,
																		LPWSTR* StringSecurityDescriptor,
																		PULONG StringSecurityDescriptorLen );
		BOOL ConvertStringSecurityDescriptorToSecurityDescriptorA( LPCSTR StringSecurityDescriptor, DWORD StringSDRevision,
																  PSECURITY_DESCRIPTOR* SecurityDescriptor, PULONG SecurityDescriptorSize );
		BOOL ConvertStringSecurityDescriptorToSecurityDescriptorW( LPCWSTR StringSecurityDescriptor, DWORD StringSDRevision, 
																  PSECURITY_DESCRIPTOR* SecurityDescriptor, PULONG SecurityDescriptorSize );
		BOOL CreateRestrictedToken( HANDLE ExistingTokenHandle, DWORD Flags, DWORD DisableSidCount, 
								   PSID_AND_ATTRIBUTES SidsToDisable, DWORD DeletePrivilegeCount, 
								   PLUID_AND_ATTRIBUTES PrivilegesToDelete, DWORD RestrictedSidCount, 
								   PSID_AND_ATTRIBUTES SidsToRestrict, PHANDLE NewTokenHandle );
		BOOL DuplicateToken( HANDLE ExistingTokenHandle, ::SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, PHANDLE DuplicateTokenHandle );
		BOOL DuplicateTokenEx( HANDLE hExistingToken, DWORD dwDesiredAccess, ::LPSECURITY_ATTRIBUTES lpTokenAttributes,
							  ::SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, ::TOKEN_TYPE TokenType, PHANDLE phNewToken );
		DWORD GetAuditedPermissionsFromAclA( ::PACL pacl, ::PTRUSTEE pTrustee, PACCESS_MASK pSuccessfulAuditedRights, PACCESS_MASK pFailedAuditRights );
		DWORD GetAuditedPermissionsFromAclW( ::PACL pacl, ::PTRUSTEE pTrustee, PACCESS_MASK pSuccessfulAuditedRights, PACCESS_MASK pFailedAuditRights );
		DWORD GetEffectiveRightsFromAclA( ::PACL pacl, ::PTRUSTEE pTrustee, PACCESS_MASK pAccessRights );
		DWORD GetEffectiveRightsFromAclW( ::PACL pacl, ::PTRUSTEE pTrustee, PACCESS_MASK pAccessRights );
		DWORD GetExplicitEntriesFromAclA( ::PACL pacl, PULONG pcCountOfExplicitEntries, ::PEXPLICIT_ACCESS* pListOfExplicitEntries ) const;
		DWORD GetExplicitEntriesFromAclW( ::PACL pacl, PULONG pcCountOfExplicitEntries, ::PEXPLICIT_ACCESS* pListOfExplicitEntries ) const;
		DWORD GetNamedSecurityInfoA( LPCSTR pObjectName, ::SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo,
									PSID* ppsidOwner, PSID* ppsidGroup, ::PACL* ppDacl, ::PACL* ppSacl, PSECURITY_DESCRIPTOR* ppSecurityDescriptor );
		DWORD GetNamedSecurityInfoW( LPCWSTR pObjectName, ::SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo,
									PSID* ppsidOwner, PSID* ppsidGroup, ::PACL* ppDacl, ::PACL* ppSacl, PSECURITY_DESCRIPTOR* ppSecurityDescriptor );
		DWORD GetNamedSecurityInfoExA( LPCSTR lpObject, ::SE_OBJECT_TYPE objectType, SECURITY_INFORMATION securityInfo, 
									  LPCSTR lpProvider, LPCSTR lpProperty, PACTRL_ACCESS* ppAccessList, 
									  PACTRL_AUDIT* ppAuditList, LPSTR* lppOwner, LPSTR* lppGroup );
		DWORD GetNamedSecurityInfoExW( LPCWSTR lpObject, ::SE_OBJECT_TYPE objectType, SECURITY_INFORMATION securityInfo,
									  LPCWSTR lpProvider, LPCWSTR lpProperty, PACTRL_ACCESS* ppAccessList, 
									  PACTRL_AUDIT* ppAuditList, LPWSTR* lppOwner, LPWSTR* lppGroup );
		BOOL GetSecurityDescriptorControl( PSECURITY_DESCRIPTOR pSecurityDescriptor, PSECURITY_DESCRIPTOR_CONTROL pControl, LPDWORD lpdwRevision );
		DWORD GetSecurityInfo( HANDLE handle, ::SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, 
							   PSID* ppsidOwner, PSID* ppsidGroup, PACL* ppDacl, PACL* ppSacl, 
							   PSECURITY_DESCRIPTOR* ppSecurityDescriptor );
		DWORD GetSecurityInfoExA( HANDLE hObject, ::SE_OBJECT_TYPE objectType, SECURITY_INFORMATION securityInfo, 
								  LPCSTR lpProvider, LPCSTR lpProperty, PACTRL_ACCESS* ppAccessList, 
								  PACTRL_AUDIT* ppAuditList, LPSTR* lppOwner, LPSTR* lppGroup );
		DWORD GetSecurityInfoExW( HANDLE hObject, ::SE_OBJECT_TYPE objectType, SECURITY_INFORMATION securityInfo,
								 LPCWSTR lpProvider, LPCWSTR lpProperty, PACTRL_ACCESS* ppAccessList,
								 PACTRL_AUDIT* ppAuditList, LPWSTR* lppOwner, LPWSTR* lppGroup );
		BOOL GetTokenInformation( HANDLE TokenHandle, ::TOKEN_INFORMATION_CLASS TokenInformationClass, 
								 LPVOID TokenInformation, DWORD TokenInformationLength, PDWORD ReturnLength );
		TRUSTEE_FORM GetTrusteeFormA( ::PTRUSTEE pTrustee );
		TRUSTEE_FORM GetTrusteeFormW( ::PTRUSTEE pTrustee );
		LPSTR GetTrusteeNameA( ::PTRUSTEE pTrustee );
		LPWSTR GetTrusteeNameW( ::PTRUSTEE pTrustee );
		::TRUSTEE_TYPE GetTrusteeTypeA( ::PTRUSTEE pTrustee );
		::TRUSTEE_TYPE GetTrusteeTypeW( ::PTRUSTEE pTrustee );
		BOOL IsTokenRestricted( HANDLE TokenHandle );
		BOOL LookupAccountNameA( LPCSTR lpSystemName, LPCSTR lpAccountName, PSID Sid, LPDWORD cbSid, 
								LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, ::PSID_NAME_USE peUse );
		BOOL LookupAccountNameW( LPCWSTR lpSystemName, LPCWSTR lpAccountName, PSID Sid, LPDWORD cbSid, 
								LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, ::PSID_NAME_USE peUse );
		BOOL LookupPrivilegeDisplayNameA( LPCSTR lpSystemName, LPCSTR lpName, LPSTR lpDisplayName, LPDWORD cchDisplayName, 
										 LPDWORD lpLanguageId );
		BOOL LookupPrivilegeDisplayNameW( LPCWSTR lpSystemName, LPCWSTR lpName, LPWSTR lpDisplayName, LPDWORD cchDisplayName, LPDWORD lpLanguageId );
		BOOL LookupPrivilegeNameA( LPCSTR lpSystemName, PLUID lpLuid, LPSTR lpName, LPDWORD cchName );
		BOOL LookupPrivilegeNameW( LPCWSTR lpSystemName, PLUID lpLuid, LPWSTR lpName, LPDWORD cchName );
		BOOL LookupPrivilegeValueA( LPCSTR lpSystemName, LPCSTR lpName, ::PLUID lpLuid );
		BOOL LookupPrivilegeValueW( LPCWSTR lpSystemName, LPCWSTR lpName, ::PLUID lpLuid );
		BOOL OpenProcessToken( HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle );
		BOOL OpenThreadToken( HANDLE ThreadHandle, DWORD DesiredAccess, BOOL OpenAsSelf, PHANDLE TokenHandle );
		VOID QuerySecurityAccessMask( SECURITY_INFORMATION SecurityInformation, LPDWORD DesiredAccess );
		DWORD SetEntriesInAclA( ULONG cCountOfExplicitEntries, ::PEXPLICIT_ACCESS pListOfExplicitEntries, ::PACL OldAcl,
							   ::PACL* NewAcl );
		DWORD SetEntriesInAclW( ULONG cCountOfExplicitEntries, ::PEXPLICIT_ACCESS pListOfExplicitEntries, ::PACL OldAcl, 
							   ::PACL* NewAcl );
		DWORD SetNamedSecurityInfoA( LPSTR pObjectName, ::SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo,
									PSID psidOwner, PSID psidGroup, ::PACL pDacl, ::PACL pSacl );
		DWORD SetNamedSecurityInfoW( LPWSTR pObjectName, ::SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo,
								   PSID psidOwner, PSID psidGroup, ::PACL pDacl, ::PACL pSacl );
		DWORD SetNamedSecurityInfoExA( LPCSTR lpObject, ::SE_OBJECT_TYPE objectType, SECURITY_INFORMATION securityInfo,
									  LPCSTR lpProvider, PACTRL_ACCESS pAccessList, PACTRL_AUDIT pAuditList, 
									  LPSTR lpOwner, LPSTR lpGroup, PACTRL_OVERLAPPED pOverlapped );
		DWORD SetNamedSecurityInfoExW( LPCWSTR lpObject, ::SE_OBJECT_TYPE objectType, SECURITY_INFORMATION securityInfo,
									  LPCWSTR lpProvider, PACTRL_ACCESS pAccessList, PACTRL_AUDIT pAuditList, 
									  LPWSTR lpOwner, LPWSTR lpGroup, PACTRL_OVERLAPPED pOverlapped );
		VOID SetSecurityAccessMask( SECURITY_INFORMATION SecurityInformation, LPDWORD DesiredAccess );
		BOOL SetSecurityDescriptorControl( PSECURITY_DESCRIPTOR pSecurityDescriptor, 
										  SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest, 
										  SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet );
		DWORD SetSecurityInfo( HANDLE handle, ::SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, 
							  PSID psidOwner, PSID psidGroup, ::PACL pDacl, ::PACL pSacl );
		DWORD SetSecurityInfoExA( HANDLE hObject, ::SE_OBJECT_TYPE objectType, SECURITY_INFORMATION securityInfo, 
								 LPCSTR lpProvider, PACTRL_ACCESS pAccessList, PACTRL_AUDIT pAuditList, LPSTR lpOwner,
								 LPSTR lpGroup, PACTRL_OVERLAPPED pOverlapped );
		DWORD SetSecurityInfoExW( HANDLE hObject, ::SE_OBJECT_TYPE objectType, SECURITY_INFORMATION securityInfo, 
								 LPCWSTR lpProvider, PACTRL_ACCESS pAccessList, PACTRL_AUDIT pAuditList, LPWSTR lpOwner, 
								 LPWSTR lpGroup, PACTRL_OVERLAPPED pOverlapped );
		BOOL SetThreadToken( PHANDLE Thread, HANDLE Token );
		BOOL SetTokenInformation( HANDLE TokenHandle, ::TOKEN_INFORMATION_CLASS TokenInformationClass, 
								 LPVOID TokenInformation, DWORD TokenInformationLength );
		DWORD TreeResetNamedSecurityInfoA( LPSTR pObjectName, ::SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo,
										  PSID pOwner, PSID pGroup, ::PACL pDacl, ::PACL pSacl, BOOL KeepExplicit, 
										  FN_PROGRESS fnProgress, PROG_INVOKE_SETTING ProgressInvokeSetting, PVOID Args );
		DWORD TreeResetNamedSecurityInfoW( LPWSTR pObjectName, ::SE_OBJECT_TYPE ObjectType, 
										  SECURITY_INFORMATION SecurityInfo, PSID pOwner, PSID pGroup, ::PACL pDacl, 
										  ::PACL pSacl, BOOL KeepExplicit, FN_PROGRESS fnProgress, 
										  PROG_INVOKE_SETTING ProgressInvokeSetting, PVOID Args );
		DWORD TreeSetNamedSecurityInfoA( LPSTR pObjectName, ::SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, 
										PSID pOwner, PSID pGroup, ::PACL pDacl, ::PACL pSacl, DWORD dwAction, 
										FN_PROGRESS fnProgress, PROG_INVOKE_SETTING ProgressInvokeSetting, PVOID Args );
		DWORD TreeSetNamedSecurityInfoW( LPWSTR pObjectName, ::SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo,
										PSID pOwner, PSID pGroup, ::PACL pDacl, ::PACL pSacl, DWORD dwAction, 
										FN_PROGRESS fnProgress, PROG_INVOKE_SETTING ProgressInvokeSetting, PVOID Args );

		//Client Server Access Control functions
		BOOL AreAllAccessesGranted( DWORD GrantedAccess, DWORD DesiredAccess );
		BOOL AreAnyAccessesGranted( DWORD GrantedAccess, DWORD DesiredAccess );
		DWORD BuildSecurityDescriptorA( ::PTRUSTEE pOwner, ::PTRUSTEE pGroup, ULONG cCountOfAccessEntries, 
									   ::PEXPLICIT_ACCESS pListOfAccessEntries, ULONG cCountOfAuditEntries, 
									   ::PEXPLICIT_ACCESS pListOfAuditEntries, PSECURITY_DESCRIPTOR pOldSD, 
									   PULONG pSizeNewSD, PSECURITY_DESCRIPTOR* pNewSD );
		DWORD BuildSecurityDescriptorW( ::PTRUSTEE pOwner, ::PTRUSTEE pGroup, ULONG cCountOfAccessEntries, 
									   ::PEXPLICIT_ACCESS pListOfAccessEntries, ULONG cCountOfAuditEntries, 
									   ::PEXPLICIT_ACCESS pListOfAuditEntries, PSECURITY_DESCRIPTOR pOldSD, 
									   PULONG pSizeNewSD, PSECURITY_DESCRIPTOR* pNewSD );
		BOOL ConvertToAutoInheritPrivateObjectSecurity( PSECURITY_DESCRIPTOR ParentDescriptor, 
													   PSECURITY_DESCRIPTOR CurrentSecurityDescriptor, 
													   PSECURITY_DESCRIPTOR* NewSecurityDescriptor, ::GUID* ObjectType,
													   BOOLEAN IsDirectoryObject, ::PGENERIC_MAPPING GenericMapping );
		BOOL CreatePrivateObjectSecurity( PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor,
										 PSECURITY_DESCRIPTOR* NewDescriptor, BOOL IsDirectoryObject, HANDLE Token,
										 ::PGENERIC_MAPPING GenericMapping );
		BOOL CreatePrivateObjectSecurityEx( PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor,
										   PSECURITY_DESCRIPTOR* NewDescriptor, ::GUID* ObjectType, BOOL IsContainerObject,
										   ULONG AutoInheritFlags, HANDLE Token, ::PGENERIC_MAPPING GenericMapping );
		BOOL CreatePrivateObjectSecurityWithMultipleInheritance( PSECURITY_DESCRIPTOR ParentDescriptor,
																PSECURITY_DESCRIPTOR CreatorDescriptor,
																PSECURITY_DESCRIPTOR *NewDescriptor,
																::GUID** ObjectTypes, ULONG GuidCount, 
																BOOL IsContainerObject, ULONG AutoInheritFlags, 
																HANDLE Token, ::PGENERIC_MAPPING GenericMapping );
		BOOL CreateProcessAsUserA( HANDLE hToken, LPCSTR lpApplicationName, LPSTR lpCommandLine, 
								  LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes,
								  BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, 
								  LPCSTR lpCurrentDirectory, LPSTARTUPINFO lpStartupInfo, 
								  LPPROCESS_INFORMATION lpProcessInformation );
		BOOL CreateProcessAsUserW( HANDLE hToken, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, 
								  LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes,
								  BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, 
								  LPCWSTR lpCurrentDirectory, LPSTARTUPINFO lpStartupInfo, 
								  LPPROCESS_INFORMATION lpProcessInformation );
		BOOL CreateProcessWithLogonW( LPCWSTR lpUsername, LPCWSTR lpDomain, LPCWSTR lpPassword, DWORD dwLogonFlags, 
									 LPCWSTR lpApplicationName, LPWSTR lpCommandLine, DWORD dwCreationFlags, 
									 LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, 
									 LPPROCESS_INFORMATION lpProcessInfo );
		BOOL DestroyPrivateObjectSecurity( PSECURITY_DESCRIPTOR* ObjectDescriptor );
		BOOL GetPrivateObjectSecurity( PSECURITY_DESCRIPTOR ObjectDescriptor, SECURITY_INFORMATION SecurityInformation,
									  PSECURITY_DESCRIPTOR ResultantDescriptor, DWORD DescriptorLength, 
									  PDWORD ReturnLength );
		BOOL ImpersonateAnonymousToken( HANDLE ThreadHandle );
		BOOL ImpersonateLoggedOnUser( HANDLE hToken );
		BOOL ImpersonateNamedPipeClient( HANDLE hNamedPipe );
		BOOL ImpersonateSelf( SECURITY_IMPERSONATION_LEVEL ImpersonationLevel );
		DWORD LookupSecurityDescriptorPartsA( ::PTRUSTEE* pOwner, ::PTRUSTEE* pGroup, PULONG cCountOfAccessEntries, 
											 ::PEXPLICIT_ACCESS* pListOfAccessEntries, PULONG cCountOfAuditEntries, 
											 ::PEXPLICIT_ACCESS* pListOfAuditEntries, PSECURITY_DESCRIPTOR pSD );
		DWORD LookupSecurityDescriptorPartsW( ::PTRUSTEE* pOwner, ::PTRUSTEE* pGroup, PULONG cCountOfAccessEntries, 
											 ::PEXPLICIT_ACCESS* pListOfAccessEntries, PULONG cCountOfAuditEntries, 
											 ::PEXPLICIT_ACCESS* pListOfAuditEntries, PSECURITY_DESCRIPTOR pSD );
		VOID MapGenericMask( PDWORD AccessMask, ::PGENERIC_MAPPING GenericMapping );
		BOOL ObjectCloseAuditAlarmA( LPCSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose );
		BOOL ObjectCloseAuditAlarmW( LPCWSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose );
		BOOL ObjectDeleteAuditAlarmA( LPCSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose );
		BOOL ObjectDeleteAuditAlarmW( LPCWSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose );
		BOOL ObjectOpenAuditAlarmA( LPCSTR SubsystemName, LPVOID HandleId, LPSTR ObjectTypeName, LPSTR ObjectName, 
								   PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess,
								   DWORD GrantedAccess, ::PPRIVILEGE_SET Privileges, BOOL ObjectCreation, 
								   BOOL AccessGranted, LPBOOL GenerateOnClose );
		BOOL ObjectOpenAuditAlarmW( LPCWSTR SubsystemName, LPVOID HandleId, LPWSTR ObjectTypeName, LPWSTR ObjectName,
								   PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess,
								   DWORD GrantedAccess, ::PPRIVILEGE_SET Privileges, BOOL ObjectCreation,
								   BOOL AccessGranted, LPBOOL GenerateOnClose );
		BOOL ObjectPrivilegeAuditAlarmA( LPCSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, DWORD DesiredAccess,
										::PPRIVILEGE_SET Privileges, BOOL AccessGranted );
		BOOL ObjectPrivilegeAuditAlarmW( LPCWSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, DWORD DesiredAccess,
										::PPRIVILEGE_SET Privileges, BOOL AccessGranted );
		BOOL PrivilegeCheck( HANDLE ClientToken, ::PPRIVILEGE_SET RequiredPrivileges, LPBOOL pfResult );
		BOOL PrivilegedServiceAuditAlarmA( LPCSTR SubsystemName, LPCSTR ServiceName, HANDLE ClientToken, 
										  ::PPRIVILEGE_SET Privileges, BOOL AccessGranted );
		BOOL PrivilegedServiceAuditAlarmW( LPCWSTR SubsystemName, LPCWSTR ServiceName, HANDLE ClientToken, 
										  ::PPRIVILEGE_SET Privileges, BOOL AccessGranted );
		BOOL RevertToSelf( void );
		BOOL SetPrivateObjectSecurity( SECURITY_INFORMATION SecurityInformation, 
									  PSECURITY_DESCRIPTOR ModificationDescriptor, 
									  PSECURITY_DESCRIPTOR* ObjectsSecurityDescriptor, ::PGENERIC_MAPPING GenericMapping,
									  HANDLE Token );
		BOOL SetPrivateObjectSecurityEx( SECURITY_INFORMATION SecurityInformation, 
										PSECURITY_DESCRIPTOR ModificationDescriptor, 
										PSECURITY_DESCRIPTOR* ObjectsSecurityDescriptor, ULONG AutoInheritFlags,
										::PGENERIC_MAPPING GenericMapping, HANDLE Token );

		//------------------------------------------------------------------------------
		//Low Level Access
		BOOL AddAccessAllowedAce( ::PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid );
		BOOL AddAccessAllowedAceEx( ::PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid );
		BOOL AddAccessAllowedObjectAce( ::PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, 
									   ::GUID* ObjectTypeGuid, ::GUID* InheritedObjectTypeGuid, PSID pSid );
		BOOL AddAccessDeniedAce( ::PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid );
		BOOL AddAccessDeniedAceEx( ::PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid );
		BOOL AddAccessDeniedObjectAce( ::PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, 
									  ::GUID* ObjectTypeGuid, ::GUID* InheritedObjectTypeGuid, PSID pSid );
		BOOL AddAce( ::PACL pAcl, DWORD dwAceRevision, DWORD dwStartingAceIndex, LPVOID pAceList, DWORD nAceListLength );
		BOOL AddAuditAccessAce( ::PACL pAcl, DWORD dwAceRevision, DWORD dwAccessMask, PSID pSid, BOOL bAuditSuccess, 
							   BOOL bAuditFailure );
		BOOL AddAuditAccessAceEx( ::PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD dwAccessMask, PSID pSid, 
								 BOOL bAuditSuccess, BOOL bAuditFailure );
		BOOL AddAuditAccessObjectAce( ::PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD dwAccessMask, 
									 ::GUID* ObjectTypeGuid, ::GUID* InheritedObjectTypeGuid, PSID pSid, 
									 BOOL bAuditSuccess, BOOL bAuditFailure );
		BOOL DeleteAce( ::PACL pAcl, DWORD dwAceIndex );
		BOOL FindFirstFreeAce( ::PACL pAcl, LPVOID* pAce );
		DWORD FreeInheritedFromArray( PINHERITED_FROM pInheritArray, USHORT AceCnt, PFN_OBJECT_MGR_FUNCTS pfnArray );
		BOOL GetAce( ::PACL pAcl, DWORD dwAceIndex, LPVOID* pAce );
		BOOL GetAclInformation( ::PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, 
							   ::ACL_INFORMATION_CLASS dwAclInformationClass );
		BOOL GetFileSecurityA( LPCSTR lpFileName, SECURITY_INFORMATION RequestedInformation, 
							 PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded );
		BOOL GetFileSecurityW( LPCWSTR lpFileName, SECURITY_INFORMATION RequestedInformation, 
							 PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded );
		DWORD GetInheritanceSourceA( LPSTR pObjectName, SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, 
									BOOL Container, ::GUID** pObjectClassGuids, DWORD GuidCount, ::PACL pAcl, 
									PFN_OBJECT_MGR_FUNCTS pfnArray, PGENERIC_MAPPING pGenericMapping, 
									PINHERITED_FROM pInheritArray );
		DWORD GetInheritanceSourceW( LPWSTR pObjectName, SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo,
									BOOL Container, ::GUID** pObjectClassGuids, DWORD GuidCount, ::PACL pAcl,
									PFN_OBJECT_MGR_FUNCTS pfnArray, PGENERIC_MAPPING pGenericMapping,
									PINHERITED_FROM pInheritArray );
		BOOL GetKernelObjectSecurity( HANDLE Handle, SECURITY_INFORMATION RequestedInformation, 
									 PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded );
		BOOL GetSecurityDescriptorDacl( PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbDaclPresent, ::PACL* pDacl, 
									   LPBOOL lpbDaclDefaulted );
		BOOL GetSecurityDescriptorGroup( PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID* pGroup, LPBOOL lpbGroupDefaulted );
		DWORD GetSecurityDescriptorLength( PSECURITY_DESCRIPTOR pSecurityDescriptor );
		BOOL GetSecurityDescriptorOwner( PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID* pOwner, LPBOOL lpbOwnerDefaulted );
		DWORD GetSecurityDescriptorRMControl( PSECURITY_DESCRIPTOR SecurityDescriptor, PUCHAR RMControl );
		BOOL GetSecurityDescriptorSacl( PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbSaclPresent, ::PACL* pSacl, 
									   LPBOOL lpbSaclDefaulted );
		BOOL InitializeAcl( ::PACL pAcl, DWORD nAclLength, DWORD dwAclRevision );
		BOOL InitializeSecurityDescriptor( PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD dwRevision );
		BOOL IsValidAcl( ::PACL pAcl );
		BOOL IsValidSecurityDescriptor( PSECURITY_DESCRIPTOR pSecurityDescriptor );
		BOOL MakeAbsoluteSD( PSECURITY_DESCRIPTOR pSelfRelativeSD, PSECURITY_DESCRIPTOR pAbsoluteSD, 
							LPDWORD lpdwAbsoluteSDSize, ::PACL pDacl, LPDWORD lpdwDaclSize, ::PACL pSacl, 
							LPDWORD lpdwSaclSize, PSID pOwner, LPDWORD lpdwOwnerSize, PSID pPrimaryGroup, 
							LPDWORD lpdwPrimaryGroupSize );
		BOOL MakeAbsoluteSD2( PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor, LPDWORD lpdwBufferSize );
		BOOL MakeSelfRelativeSD( PSECURITY_DESCRIPTOR pAbsoluteSD, PSECURITY_DESCRIPTOR pSelfRelativeSD,
								LPDWORD lpdwBufferLength );
		BOOL QueryServiceObjectSecurity( SC_HANDLE hService, SECURITY_INFORMATION dwSecurityInformation, 
										PSECURITY_DESCRIPTOR lpSecurityDescriptor, DWORD cbBufSize, 
										LPDWORD pcbBytesNeeded );
		LONG RegGetKeySecurity( HKEY hKey, SECURITY_INFORMATION SecurityInformation, 
							   PSECURITY_DESCRIPTOR pSecurityDescriptor, LPDWORD lpcbSecurityDescriptor );
		LONG RegSetKeySecurity( HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor );
		BOOL SetAclInformation( ::PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, 
							   ::ACL_INFORMATION_CLASS dwAclInformationClass );
		BOOL SetFileSecurityA( LPCSTR lpFileName, SECURITY_INFORMATION SecurityInformation, 
							  PSECURITY_DESCRIPTOR pSecurityDescriptor );
		BOOL SetFileSecurityW( LPCWSTR lpFileName, SECURITY_INFORMATION SecurityInformation, 
							  PSECURITY_DESCRIPTOR pSecurityDescriptor );
		BOOL SetKernelObjectSecurity( HANDLE Handle, SECURITY_INFORMATION SecurityInformation, 
									 PSECURITY_DESCRIPTOR SecurityDescriptor );
		BOOL SetSecurityDescriptorDacl( PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bDaclPresent, ::PACL pDacl,
									   BOOL bDaclDefaulted );
		BOOL SetSecurityDescriptorGroup( PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pGroup, BOOL bGroupDefaulted );
		BOOL SetSecurityDescriptorOwner( PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pOwner, BOOL bOwnerDefaulted );
		DWORD SetSecurityDescriptorRMControl( PSECURITY_DESCRIPTOR SecurityDescriptor, PUCHAR RMControl );
		BOOL SetSecurityDescriptorSacl( PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bSaclPresent, ::PACL pSacl, BOOL bSaclDefaulted );
		BOOL SetServiceObjectSecurity( SC_HANDLE hService, SECURITY_INFORMATION dwSecurityInformation, 
									  PSECURITY_DESCRIPTOR lpSecurityDescriptor );
		DWORD ConvertAccessToSecurityDescriptorA( PACTRL_ACCESS pAccessList, PACTRL_AUDIT pAuditList, LPCSTR lpOwner,
												 LPCSTR lpGroup, PSECURITY_DESCRIPTOR* ppSecDescriptor );
		DWORD ConvertAccessToSecurityDescriptorW( PACTRL_ACCESS pAccessList, PACTRL_AUDIT pAuditList, LPCWSTR lpOwner, 
												 LPCWSTR lpGroup, PSECURITY_DESCRIPTOR *ppSecDescriptor );
		BOOL IsTokenUntrusted( HANDLE TokenHandle );
		DWORD SetEntriesInAccessListA( ULONG cEntries, PACTRL_ACCESS_ENTRY pAccessEntryList, ACCESS_MODE accessMode,
									  LPCSTR lpProperty, PACTRL_ACCESS pOldList, PACTRL_ACCESS* ppNewList );
		DWORD SetEntriesInAccessListW( ULONG cEntries, PACTRL_ACCESS_ENTRY pAccessEntryList, ACCESS_MODE accessMode, 
									 LPCWSTR lpProperty, PACTRL_ACCESS pOldList, PACTRL_ACCESS* ppNewList );
		DWORD SetEntriesInAuditListA( ULONG cEntries, PACTRL_ACCESS_ENTRY pAccessEntryList, ACCESS_MODE accessMode, 
									 LPCSTR lpProperty, PACTRL_AUDIT pOldList, PACTRL_AUDIT* ppNewList );
		DWORD SetEntriesInAuditListW( ULONG cEntries, PACTRL_ACCESS_ENTRY pAccessEntryList, ACCESS_MODE accessMode, 
									 LPCWSTR lpProperty, PACTRL_AUDIT pOldList, PACTRL_AUDIT* ppNewList );

		//------------------------------------------------------------------------------
		//Local Security Authority functions
		NTSTATUS LsaAddAccountRights( LSA_HANDLE PolicyHandle, PSID AccountSid, ::PLSA_UNICODE_STRING UserRights, 
									 ULONG CountOfRights );
		NTSTATUS LsaClose( LSA_HANDLE ObjectHandle );
		NTSTATUS LsaCreateTrustedDomainEx( LSA_HANDLE PolicyHandle, 
										  PTRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInformation, 
										  PTRUSTED_DOMAIN_AUTH_INFORMATION AuthenticationInformation, 
										  ACCESS_MASK DesiredAccess, PLSA_HANDLE TrustedDomainHandle );
		NTSTATUS LsaDeleteTrustedDomain( LSA_HANDLE PolicyHandle, PSID TrustedDomainSid );
		NTSTATUS LsaEnumerateAccountRights( LSA_HANDLE PolicyHandle, PSID AccountSid, ::PLSA_UNICODE_STRING *UserRights,
										   PULONG CountOfRights );
		NTSTATUS LsaEnumerateAccountsWithUserRight( LSA_HANDLE PolicyHandle, ::PLSA_UNICODE_STRING UserRights, 
												   PVOID* EnumerationBuffer, PULONG CountReturned );
		NTSTATUS LsaEnumerateTrustedDomains( LSA_HANDLE PolicyHandle, PLSA_ENUMERATION_HANDLE EnumerationContext, 
											PVOID* Buffer, ULONG PreferedMaximumLength, PULONG CountReturned );
		NTSTATUS LsaEnumerateTrustedDomainsEx( LSA_HANDLE PolicyHandle, PLSA_ENUMERATION_HANDLE EnumerationContext,
											  PVOID* Buffer, ULONG PreferredMaximumLength, PULONG CountReturned );
		NTSTATUS LsaFreeMemory( PVOID Buffer );
		NTSTATUS LsaLookupNames( LSA_HANDLE PolicyHandle, ULONG Count, ::PLSA_UNICODE_STRING Names, 
								::PLSA_REFERENCED_DOMAIN_LIST* ReferencedDomains, ::PLSA_TRANSLATED_SID* Sids );
		NTSTATUS LsaLookupNames2( LSA_HANDLE PolicyHandle, ULONG Flags, ULONG Count, ::PLSA_UNICODE_STRING Names,
								 ::PLSA_REFERENCED_DOMAIN_LIST* ReferencedDomains, ::PLSA_TRANSLATED_SID2* Sids );
		NTSTATUS WINAPI LsaLookupPrivilegeValue( LSA_HANDLE PolicyHandle, ::PUNICODE_STRING Name, ::PLUID Value );
		NTSTATUS LsaLookupSids( LSA_HANDLE PolicyHandle, ULONG Count, PSID* Sids, 
							   ::PLSA_REFERENCED_DOMAIN_LIST* ReferencedDomains, ::PLSA_TRANSLATED_NAME* Names );
		ULONG LsaNtStatusToWinError( NTSTATUS Status );
		NTSTATUS LsaOpenPolicy( ::PLSA_UNICODE_STRING SystemName, ::PLSA_OBJECT_ATTRIBUTES ObjectAttributes, 
							   ACCESS_MASK DesiredAccess, PLSA_HANDLE PolicyHandle );
		NTSTATUS LsaOpenTrustedDomainByName( LSA_HANDLE PolicyHandle, ::PLSA_UNICODE_STRING TrustedDomainName,
											ACCESS_MASK DesiredAccess, PLSA_HANDLE TrustedDomainHandle );
		NTSTATUS LsaQueryTrustedDomainInfo( LSA_HANDLE PolicyHandle, PSID TrustedDomainSid, 
										   ::TRUSTED_INFORMATION_CLASS InformationClass, PVOID* Buffer );
		NTSTATUS LsaQueryTrustedDomainInfoByName( LSA_HANDLE PolicyHandle, ::PLSA_UNICODE_STRING TrustedDomainName,
												 ::TRUSTED_INFORMATION_CLASS InformationClass, PVOID* Buffer );
		NTSTATUS LsaRemoveAccountRights( LSA_HANDLE PolicyHandle, PSID AccountSid, BOOLEAN AllRights, 
										::PLSA_UNICODE_STRING UserRights, ULONG CountOfRights );
		NTSTATUS LsaRetrievePrivateData( LSA_HANDLE PolicyHandle, ::PLSA_UNICODE_STRING KeyName, 
										::PLSA_UNICODE_STRING* PrivateData );
		NTSTATUS LsaSetTrustedDomainInfoByName( LSA_HANDLE PolicyHandle, ::PLSA_UNICODE_STRING TrustedDomainName, 
											   ::TRUSTED_INFORMATION_CLASS InformationClass, PVOID Buffer );
		NTSTATUS LsaSetTrustedDomainInformation( LSA_HANDLE PolicyHandle, PSID TrustedDomainSid, 
												::TRUSTED_INFORMATION_CLASS InformationClass, PVOID Buffer );
		NTSTATUS LsaStorePrivateData( LSA_HANDLE PolicyHandle, ::PLSA_UNICODE_STRING KeyName, 
									 ::PLSA_UNICODE_STRING PrivateData );

		//TODO: MessageDigst.inl

		//------------------------------------------------------------------------------
		//Authentication functions
		BOOL CredDeleteA( LPCSTR TargetName, DWORD Type, DWORD Flags );
		BOOL CredDeleteW( LPCWSTR TargetName, DWORD Type, DWORD Flags );
		BOOL CredEnumerateA( LPCSTR Filter, DWORD Flags, DWORD* Count, PCREDENTIAL** Credentials );
		BOOL CredEnumerateW( LPCWSTR Filter, DWORD Flags, DWORD* Count, PCREDENTIAL** Credentials );
		VOID CredFree( PVOID Buffer );
		BOOL CredGetSessionTypes( DWORD MaximumPersistCount, LPDWORD MaximumPersist );
		BOOL CredGetTargetInfoA( LPCSTR TargetName, DWORD Flags, PCREDENTIAL_TARGET_INFORMATION* TargetInfo );
		BOOL CredGetTargetInfoW( LPCWSTR TargetName, DWORD Flags, PCREDENTIAL_TARGET_INFORMATION* TargetInfo );
		BOOL CredIsMarshaledCredentialA( LPCSTR MarshaledCredential );
		BOOL CredIsMarshaledCredentialW( LPCWSTR MarshaledCredential );
		BOOL CredMarshalCredentialA( CRED_MARSHAL_TYPE CredType, PVOID Credential, LPSTR* MarshaledCredential );
		BOOL CredMarshalCredentialW( CRED_MARSHAL_TYPE CredType, PVOID Credential, LPWSTR* MarshaledCredential );
		BOOL CredReadDomainCredentialsA( PCREDENTIAL_TARGET_INFORMATION TargetInfo, DWORD Flags, DWORD* Count, PCREDENTIAL** Credentials );
		BOOL CredReadDomainCredentialsW( PCREDENTIAL_TARGET_INFORMATION TargetInfo, DWORD Flags, DWORD* Count, PCREDENTIAL** Credentials );
		BOOL CredReadA( LPCSTR TargetName, DWORD Type, DWORD Flags, PCREDENTIAL* Credential );
		BOOL CredReadW( LPCWSTR TargetName, DWORD Type, DWORD Flags, PCREDENTIAL* Credential );
		BOOL CredRenameA( LPCSTR OldTargetName, LPCSTR NewTargetName, DWORD Type, DWORD Flags );
		BOOL CredRenameW( LPCWSTR OldTargetName, LPCWSTR NewTargetName, DWORD Type, DWORD Flags );
		BOOL CredUnmarshalCredentialA( LPCSTR MarshaledCredential, PCRED_MARSHAL_TYPE CredType, PVOID* Credential );
		BOOL CredUnmarshalCredentialW( LPCWSTR MarshaledCredential, PCRED_MARSHAL_TYPE CredType, PVOID* Credential );
		BOOL CredWriteA( PCREDENTIAL Credential, DWORD Flags );
		BOOL CredWriteW( PCREDENTIAL Credential, DWORD Flags );
		BOOL CredWriteDomainCredentialsA( PCREDENTIAL_TARGET_INFORMATION TargetInfo, PCREDENTIAL Credential, DWORD Flags );
		BOOL CredWriteDomainCredentialsW( PCREDENTIAL_TARGET_INFORMATION TargetInfo, PCREDENTIAL Credential, DWORD Flags );

		//------------------------------------------------------------------------------
		//Session functions
		BOOL AbortSystemShutdownA( LPSTR lpMachineName );
		BOOL AbortSystemShutdownW( LPWSTR lpMachineName );
		DWORD InitiateShutdownA( LPSTR lpMachineName, LPSTR lpMessage, DWORD dwGracePeriod, DWORD dwShutdownFlags, DWORD dwReason );
		DWORD InitiateShutdownW( LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwGracePeriod, DWORD dwShutdownFlags, DWORD dwReason );
		BOOL InitiateSystemShutdownA( LPSTR lpMachineName, LPSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown );
		BOOL InitiateSystemShutdownW( LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown );
		BOOL InitiateSystemShutdownExA( LPSTR lpMachineName, LPSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown, DWORD dwReason );
		BOOL InitiateSystemShutdownExW( LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown, DWORD dwReason );
		BOOL GetUserNameA( LPSTR lpBuffer, LPDWORD lpnSize );
		BOOL GetUserNameW( LPWSTR lpBuffer, LPDWORD lpnSize );
		BOOL LogonUserA( LPSTR lpszUsername, LPSTR lpszDomain, LPSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken );
		BOOL LogonUserW( LPWSTR lpszUsername, LPWSTR lpszDomain, LPWSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken );
		BOOL LogonUserExA( LPSTR lpszUsername, LPSTR lpszDomain, LPSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken, PSID* ppLogonSid, PVOID* ppProfileBuffer, LPDWORD pdwProfileLength, PQUOTA_LIMITS pQuotaLimits );
		BOOL LogonUserExW( LPWSTR lpszUsername, LPWSTR lpszDomain, LPWSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken, PSID* ppLogonSid, PVOID* ppProfileBuffer, LPDWORD pdwProfileLength, ::PQUOTA_LIMITS pQuotaLimits );
		BOOL LogonUserExExW( LPWSTR lpszUsername, LPWSTR lpszDomain, LPWSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PTOKEN_GROUPS pTokenGroups, PHANDLE phToken, PSID* ppLogonSid, PVOID* ppProfileBuffer, LPDWORD pdwProfileLength, ::PQUOTA_LIMITS pQuotaLimits );
		DWORD MSChapSrvChangePassword( PWSTR ServerName, PWSTR UserName, BOOLEAN LmOldPresent, ::PLM_OWF_PASSWORD LmOldOwfPassword, ::PLM_OWF_PASSWORD LmNewOwfPassword, ::PNT_OWF_PASSWORD NtOldOwfPassword, ::PNT_OWF_PASSWORD NtNewOwfPassword );
		DWORD MSChapSrvChangePassword2( PWSTR ServerName, PWSTR UserName, ::PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldNt, ::PENCRYPTED_NT_OWF_PASSWORD OldNtOwfPasswordEncryptedWithNewNt, BOOLEAN LmPresent, ::PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldLm, ::PENCRYPTED_LM_OWF_PASSWORD OldLmOwfPasswordEncryptedWithNewLmOrNt );

		//------------------------------------------------------------------------------
		//FileSystem
		DWORD AddUsersToEncryptedFile( LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_LIST pUsers );
		void CloseEncryptedFileRaw( PVOID pvContext );
		BOOL DecryptFileA( LPCSTR lpFileName, DWORD dwReserved );
		BOOL DecryptFileW( LPCWSTR lpFileName, DWORD dwReserved );
		DWORD DuplicateEncryptionInfoFile( LPCTSTR SrcFileName, LPCTSTR DstFileName, DWORD dwCreationDistribution, DWORD dwAttributes, const LPSECURITY_ATTRIBUTES lpSecurityAttributes );
		BOOL EncryptFileA( LPCSTR lpFileName );
		BOOL EncryptFileW( LPCWSTR lpFileName );
		BOOL EncryptionDisable( LPCWSTR DirPath, BOOL Disable );
		BOOL FileEncryptionStatusA( LPCSTR lpFileName, LPDWORD lpStatus );
		BOOL FileEncryptionStatusW( LPCWSTR lpFileName, LPDWORD lpStatus );
		DWORD OpenEncryptedFileRawA( LPCSTR lpFileName, ULONG ulFlags, PVOID* pvContext );
		DWORD OpenEncryptedFileRawW( LPCWSTR lpFileName, ULONG ulFlags, PVOID* pvContext );
		DWORD ReadEncryptedFileRaw( PFE_EXPORT_FUNC pfExportCallback, PVOID pvCallbackContext, PVOID pvContext );
		DWORD QueryRecoveryAgentsOnEncryptedFile( LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST* pRecoveryAgents );
		DWORD QueryUsersOnEncryptedFile( LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST* pUsers );
		DWORD WriteEncryptedFileRaw( PFE_IMPORT_FUNC pfImportCallback, PVOID pvCallbackContext, PVOID pvContext );
		DWORD SetUserFileEncryptionKey( PENCRYPTION_CERTIFICATE pEncryptionCertificate );
		DWORD RemoveUsersFromEncryptedFile( LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST pHashes );
		void FreeEncryptionCertificateHashList( PENCRYPTION_CERTIFICATE_HASH_LIST pHashes );

		//Wmi
		//TODO: Wmi
		//WdmWmiServiceMain
		//WmiCloseBlock
		//WmiCloseTraceWithCursor
		//WmiConvertTimestamp
		//WmiDevInstToInstanceNameA
		//WmiDevInstToInstanceNameW
		//WmiEnumerateGuids
		//WmiExecuteMethodA
		//WmiExecuteMethodW
		//WmiFileHandleToInstanceNameA
		//WmiFileHandleToInstanceNameW
		//WmiFreeBuffer
		//WmiGetFirstTraceOffset
		//WmiGetNextEvent
		//WmiGetTraceHeader
		//WmiMofEnumerateResourcesA
		//WmiMofEnumerateResourcesW
		//WmiNotificationRegistrationA
		//WmiNotificationRegistrationW
		//WmiOpenBlock
		//WmiOpenTraceWithCursor
		//WmiParseTraceEvent
		//WmiQueryAllDataA
		//WmiQueryAllDataMultipleA
		//WmiQueryAllDataMultipleW
		//WmiQueryAllDataW
		//WmiQueryGuidInformation
		//WmiQuerySingleInstanceA
		//WmiQuerySingleInstanceMultipleA
		//WmiQuerySingleInstanceMultipleW
		//WmiQuerySingleInstanceW
		//WmiReceiveNotificationsA
		//WmiReceiveNotificationsW
		//WmiSetSingleInstanceA
		//WmiSetSingleInstanceW
		//WmiSetSingleItemA
		//WmiSetSingleItemW

		//------------------------------------------------------------------------------
		//Service functions
		BOOL CloseServiceHandle( SC_HANDLE hSCObject );
		BOOL ChangeServiceConfig2A( SC_HANDLE hService, DWORD dwInfoLevel, LPVOID lpInfo );
		BOOL ChangeServiceConfig2W( SC_HANDLE hService, DWORD dwInfoLevel, LPVOID lpInfo );
		BOOL ChangeServiceConfigA( SC_HANDLE hService, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword, LPCSTR lpDisplayName );
		BOOL ChangeServiceConfigW( SC_HANDLE hService, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword, LPCWSTR lpDisplayName );
		BOOL ControlService( SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus );
		SC_HANDLE CreateServiceA( SC_HANDLE hSCManager, LPCSTR lpServiceName, LPCSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword );
		SC_HANDLE CreateServiceW( SC_HANDLE hSCManager, LPCWSTR lpServiceName, LPCWSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword );
		BOOL DeleteService( SC_HANDLE hService );
		BOOL EnumDependentServicesA( SC_HANDLE hService, DWORD dwServiceState, LPENUM_SERVICE_STATUS lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned );
		BOOL EnumDependentServicesW( SC_HANDLE hService, DWORD dwServiceState, LPENUM_SERVICE_STATUS lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned );
		BOOL EnumServicesStatusA( SC_HANDLE hSCManager, DWORD dwServiceType, DWORD dwServiceState, LPENUM_SERVICE_STATUS lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle );
		BOOL EnumServicesStatusW( SC_HANDLE hSCManager, DWORD dwServiceType, DWORD dwServiceState, LPENUM_SERVICE_STATUS lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle );
		BOOL EnumServicesStatusExA( SC_HANDLE hSCManager, SC_ENUM_TYPE InfoLevel, DWORD dwServiceType, DWORD dwServiceState, LPBYTE lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle, LPCSTR pszGroupName );
		BOOL EnumServicesStatusExW( SC_HANDLE hSCManager, SC_ENUM_TYPE InfoLevel, DWORD dwServiceType, DWORD dwServiceState, LPBYTE lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle, LPCWSTR pszGroupName );
		BOOL GetServiceDisplayNameA( SC_HANDLE hSCManager, LPCSTR lpServiceName, LPSTR lpDisplayName, LPDWORD lpcchBuffer );
		BOOL GetServiceDisplayNameW( SC_HANDLE hSCManager, LPCWSTR lpServiceName, LPWSTR lpDisplayName, LPDWORD lpcchBuffer );
		BOOL GetServiceKeyNameA( SC_HANDLE hSCManager, LPCSTR lpDisplayName, LPSTR lpServiceName, LPDWORD lpcchBuffer );
		BOOL GetServiceKeyNameW( SC_HANDLE hSCManager, LPCWSTR lpDisplayName, LPWSTR lpServiceName, LPDWORD lpcchBuffer );
		SC_LOCK LockServiceDatabase( SC_HANDLE hSCManager );
		DWORD NotifyServiceStatusChange( SC_HANDLE hService, DWORD dwNotifyMask, PSERVICE_NOTIFY pNotifyBuffer );
		SC_HANDLE OpenSCManagerA( LPCSTR lpMachineName, LPCSTR lpDatabaseName, DWORD dwDesiredAccess );
		SC_HANDLE OpenSCManagerW( LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess );
		SC_HANDLE OpenServiceA( SC_HANDLE hSCManager, LPCSTR lpServiceName, DWORD dwDesiredAccess );
		SC_HANDLE OpenServiceW( SC_HANDLE hSCManager, LPCWSTR lpServiceName, DWORD dwDesiredAccess );
		BOOL QueryServiceConfig2A( SC_HANDLE hService, DWORD dwInfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded );
		BOOL QueryServiceConfig2W( SC_HANDLE hService, DWORD dwInfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded );
		BOOL QueryServiceConfigA( SC_HANDLE hService, LPQUERY_SERVICE_CONFIG lpServiceConfig, DWORD cbBufSize, LPDWORD pcbBytesNeeded );
		BOOL QueryServiceConfigW( SC_HANDLE hService, LPQUERY_SERVICE_CONFIG lpServiceConfig, DWORD cbBufSize, LPDWORD pcbBytesNeeded );
		BOOL QueryServiceLockStatusA( SC_HANDLE hSCManager, LPQUERY_SERVICE_LOCK_STATUS lpLockStatus, DWORD cbBufSize, LPDWORD pcbBytesNeeded );
		BOOL QueryServiceLockStatusW( SC_HANDLE hSCManager, LPQUERY_SERVICE_LOCK_STATUS lpLockStatus, DWORD cbBufSize, LPDWORD pcbBytesNeeded );
		BOOL QueryServiceStatus( SC_HANDLE hService, LPSERVICE_STATUS lpServiceStatus );
		BOOL QueryServiceStatusEx( SC_HANDLE hService, SC_STATUS_TYPE InfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded );
		SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerA( LPCSTR lpServiceName, LPHANDLER_FUNCTION lpHandlerProc );
		SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerW( LPCWSTR lpServiceName, LPHANDLER_FUNCTION lpHandlerProc );
		SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerExA( LPCSTR lpServiceName, LPHANDLER_FUNCTION_EX lpHandlerProc, LPVOID lpContext );
		SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerExW( LPCWSTR lpServiceName, LPHANDLER_FUNCTION_EX lpHandlerProc, LPVOID lpContext );
		BOOL SetServiceBits( SERVICE_STATUS_HANDLE hServiceStatus, DWORD dwServiceBits, BOOL bSetBitsOn, BOOL bUpdateImmediately );
		BOOL SetServiceStatus( SERVICE_STATUS_HANDLE hServiceStatus, LPSERVICE_STATUS lpServiceStatus );
		BOOL StartServiceA( SC_HANDLE hService, DWORD dwNumServiceArgs, LPCSTR* lpServiceArgVectors );
		BOOL StartServiceW( SC_HANDLE hService, DWORD dwNumServiceArgs, LPCWSTR* lpServiceArgVectors );
		BOOL StartServiceCtrlDispatcherA( const SERVICE_TABLE_ENTRY *lpServiceTable );
		BOOL StartServiceCtrlDispatcherW( const SERVICE_TABLE_ENTRY *lpServiceTable );
		BOOL UnlockServiceDatabase( SC_LOCK ScLock );

		//------------------------------------------------------------------------------
		//Registry functions
		LONG RegCloseKey( HKEY hKey );
		LONG RegConnectRegistryA( LPCSTR lpMachineName, HKEY hKey, PHKEY phkResult );
		LONG RegConnectRegistryW( LPCWSTR lpMachineName, HKEY hKey, PHKEY phkResult );
		LONG RegCopyTreeA( HKEY hKeySrc, LPCSTR lpSubKey, HKEY hKeyDest );
		LONG RegCopyTreeW( HKEY hKeySrc, LPCWSTR lpSubKey, HKEY hKeyDest );
		LONG RegCreateKeyA( HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult );
		LONG RegCreateKeyW( HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult );
		LONG RegCreateKeyExA( HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, 
							 REGSAM samDesired, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, 
							 LPDWORD lpdwDisposition );
		LONG RegCreateKeyExW( HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, 
							 REGSAM samDesired, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, 
							 LPDWORD lpdwDisposition );
		LONG RegCreateKeyTransactedA( HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, 
									 REGSAM samDesired, const ::LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult,
									 LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter );
		LONG RegCreateKeyTransactedW( HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, 
									 REGSAM samDesired, const ::LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult,
									 LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter );
		LONG RegDeleteKeyA( HKEY hKey, LPCSTR lpSubKey );
		LONG RegDeleteKeyW( HKEY hKey, LPCWSTR lpSubKey );
		LONG RegDeleteKeyExA( HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved );
		LONG RegDeleteKeyExW( HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved );
		LONG RegDeleteKeyTransactedA( HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction,
									 PVOID pExtendedParameter );
		LONG RegDeleteKeyTransactedW( HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction,
									 PVOID pExtendedParameter );
		LONG RegDeleteKeyValueA( HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName );
		LONG RegDeleteKeyValueW( HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName );
		LONG RegDeleteTreeA( HKEY hKey, LPCSTR lpSubKey );
		LONG RegDeleteTreeW( HKEY hKey, LPCWSTR lpSubKey );
		LONG RegDeleteValueA( HKEY hKey, LPCSTR lpValueName );
		LONG RegDeleteValueW( HKEY hKey, LPCWSTR lpValueName );
		LONG RegDisablePredefinedCache( void );
		LONG RegDisablePredefinedCacheEx( void );
		LONG RegDisableReflectionKey( HKEY hBase );
		LONG RegEnableReflectionKey( HKEY hBase );
		LONG RegEnumKeyA( HKEY hKey, DWORD dwIndex, LPSTR lpName, DWORD cchName );
		LONG RegEnumKeyW( HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cchName );
		LONG RegEnumKeyExA( HKEY hKey, DWORD dwIndex, LPSTR lpName, LPDWORD lpcName, LPDWORD lpReserved, LPSTR lpClass,
						   LPDWORD lpcClass, ::PFILETIME lpftLastWriteTime );
		LONG RegEnumKeyExW( HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcName, LPDWORD lpReserved, LPWSTR lpClass,
						   LPDWORD lpcClass, ::PFILETIME lpftLastWriteTime );
		LONG RegEnumValueA( HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, 
						   LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData );
		LONG RegEnumValue( HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, 
						   LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData );
		LONG RegFlushKey( HKEY hKey );
		LONG RegGetValueA( HKEY hkey, LPCSTR lpSubKey, LPCSTR lpValue, DWORD dwFlags, LPDWORD pdwType, PVOID pvData, 
						 LPDWORD pcbData );
		LONG RegGetValueW( HKEY hkey, LPCWSTR lpSubKey, LPCWSTR lpValue, DWORD dwFlags, LPDWORD pdwType, PVOID pvData, 
						  LPDWORD pcbData );
		LONG RegLoadAppKeyA( LPCSTR lpFile, PHKEY phkResult, REGSAM samDesired, DWORD dwOptions, DWORD Reserved );
		LONG RegLoadAppKeyW( LPCWSTR lpFile, PHKEY phkResult, REGSAM samDesired, DWORD dwOptions, DWORD Reserved );
		LONG RegLoadKeyA( HKEY hKey, LPCSTR lpSubKey, LPCSTR lpFile );
		LONG RegLoadKeyW( HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpFile );
		LONG RegLoadMUIStringA( HKEY hKey, LPCSTR pszValue, LPSTR pszOutBuf, DWORD cbOutBuf, LPDWORD pcbData, DWORD Flags,
							   LPCSTR pszDirectory );
		LONG RegLoadMUIStringW( HKEY hKey, LPCWSTR pszValue, LPWSTR pszOutBuf, DWORD cbOutBuf, LPDWORD pcbData, 
							   DWORD Flags, LPCWSTR pszDirectory );
		LONG RegNotifyChangeKeyValue( HKEY hKey, BOOL bWatchSubtree, DWORD dwNotifyFilter, HANDLE hEvent, 
									 BOOL fAsynchronous );
		LONG RegOpenCurrentUser( REGSAM samDesired, PHKEY phkResult );
		LONG RegOpenKeyA( HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult );
		LONG RegOpenKeyW( HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult );
		LONG RegOpenKeyExA( HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult );
		LONG RegOpenKeyExW( HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult );
		LONG RegOpenKeyTransactedA( HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, 
								   HANDLE hTransaction, PVOID pExtendedParameter );
		LONG RegOpenKeyTransactedW( HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, 
								   HANDLE hTransaction, PVOID pExtendedParameter );
		LONG RegOpenUserClassesRoot( HANDLE hToken, DWORD dwOptions, REGSAM samDesired, PHKEY phkResult );
		LONG RegOverridePredefKey( HKEY hKey, HKEY hNewHKey );
		LONG RegQueryInfoKeyA( HKEY hKey, LPSTR lpClass, LPDWORD lpcClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, 
							  LPDWORD lpcMaxSubKeyLen, LPDWORD lpcMaxClassLen, LPDWORD lpcValues, LPDWORD lpcMaxValueNameLen,
							  LPDWORD lpcMaxValueLen, LPDWORD lpcbSecurityDescriptor, ::PFILETIME lpftLastWriteTime );
		LONG RegQueryInfoKeyW( HKEY hKey, LPWSTR lpClass, LPDWORD lpcClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, 
							  LPDWORD lpcMaxSubKeyLen, LPDWORD lpcMaxClassLen, LPDWORD lpcValues, LPDWORD lpcMaxValueNameLen, 
							  LPDWORD lpcMaxValueLen, LPDWORD lpcbSecurityDescriptor, ::PFILETIME lpftLastWriteTime );
		LONG RegQueryMultipleValuesA( HKEY hKey, ::PVALENT val_list, DWORD num_vals, LPSTR lpValueBuf, LPDWORD ldwTotsize );
		LONG RegQueryMultipleValuesW( HKEY hKey, ::PVALENT val_list, DWORD num_vals, LPWSTR lpValueBuf, LPDWORD ldwTotsize );
		LONG RegQueryReflectionKey( HKEY hBase, BOOL* bIsReflectionDisabled );
		LONG RegQueryValueA( HKEY hKey, LPCSTR lpSubKey, LPSTR lpValue, PLONG lpcbValue );
		LONG RegQueryValueW( HKEY hKey, LPCWSTR lpSubKey, LPWSTR lpValue, PLONG lpcbValue );
		LONG RegQueryValueExA( HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, 
							  LPDWORD lpcbData );
		LONG RegQueryValueExW( HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, 
							  LPDWORD lpcbData );
		LONG RegReplaceKeyA( HKEY hKey, LPCSTR lpSubKey, LPCSTR lpNewFile, LPCSTR lpOldFile );
		LONG RegReplaceKeyW( HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpNewFile, LPCWSTR lpOldFile );
		LONG RegRestoreKeyA( HKEY hKey, LPCSTR lpFile, DWORD dwFlags );
		LONG RegRestoreKeyW( HKEY hKey, LPCWSTR lpFile, DWORD dwFlags );
		LONG RegSaveKeyA( HKEY hKey, LPCSTR lpFile, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes );
		LONG RegSaveKeyW( HKEY hKey, LPCWSTR lpFile, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes );
		LONG RegSaveKeyExA( HKEY hKey, LPCSTR lpFile, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags );
		LONG RegSaveKeyExW( HKEY hKey, LPCWSTR lpFile, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags );
		LONG RegSetKeyValueA( HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData );
		LONG RegSetKeyValueW( HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData );
		LONG RegSetValueA( HKEY hKey, LPCSTR lpSubKey, DWORD dwType, LPCSTR lpData, DWORD cbData );
		LONG RegSetValueW( HKEY hKey, LPCWSTR lpSubKey, DWORD dwType, LPCWSTR lpData, DWORD cbData );
		LONG RegSetValueExA( HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE* lpData, 
							DWORD cbData );
		LONG RegSetValueExW( HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE* lpData, 
							DWORD cbData );
		LONG RegUnLoadKeyA( HKEY hKey, LPCSTR lpSubKey );
		LONG RegUnLoadKeyW( HKEY hKey, LPCWSTR lpSubKey );

		//------------------------------------------------------------------------------
		//Cryptography functions
		BOOL CryptAcquireContextA( HCRYPTPROV* phProv, LPCSTR pszContainer, LPCSTR pszProvider, DWORD dwProvType, DWORD dwFlags );
		BOOL CryptAcquireContextW( HCRYPTPROV* phProv, LPCWSTR pszContainer, LPCWSTR pszProvider, DWORD dwProvType, DWORD dwFlags );
		BOOL CryptContextAddRef( HCRYPTPROV hProv, DWORD* pdwReserved, DWORD dwFlags );
		BOOL CryptCreateHash( HCRYPTPROV hProv, ALG_ID Algid, HCRYPTKEY hKey, DWORD dwFlags, HCRYPTHASH* phHash );
		BOOL CryptDecrypt( HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, BYTE* pbData, DWORD* pdwDataLen );
		BOOL CryptDeriveKey( HCRYPTPROV hProv, ALG_ID Algid, HCRYPTHASH hBaseData, DWORD dwFlags, HCRYPTKEY* phKey );
		BOOL CryptDestroyHash( HCRYPTHASH hHash );
		BOOL CryptDestroyKey( HCRYPTKEY hKey );
		BOOL CryptDuplicateHash( HCRYPTHASH hHash, DWORD* pdwReserved, DWORD dwFlags, HCRYPTHASH* phHash );
		BOOL CryptDuplicateKey( HCRYPTKEY hKey, DWORD* pdwReserved, DWORD dwFlags, HCRYPTKEY* phKey );
		BOOL CryptEncrypt( HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, BYTE* pbData, DWORD* pdwDataLen, DWORD dwBufLen );
		BOOL CryptEnumProvidersA( DWORD dwIndex, DWORD* pdwReserved, DWORD dwFlags, DWORD* pdwProvType, LPSTR pszProvName, DWORD* pcbProvName );
		BOOL CryptEnumProvidersW( DWORD dwIndex, DWORD* pdwReserved, DWORD dwFlags, DWORD* pdwProvType, LPWSTR pszProvName, DWORD* pcbProvName );
		BOOL CryptEnumProviderTypesA( DWORD dwIndex, DWORD* pdwReserved, DWORD dwFlags, DWORD* pdwProvType, LPSTR pszTypeName, DWORD* pcbTypeName );
		BOOL CryptEnumProviderTypesW( DWORD dwIndex, DWORD* pdwReserved, DWORD dwFlags, DWORD* pdwProvType, LPWSTR pszTypeName, DWORD* pcbTypeName );
		BOOL CryptExportKey( HCRYPTKEY hKey, HCRYPTKEY hExpKey, DWORD dwBlobType, DWORD dwFlags, BYTE* pbData, DWORD* pdwDataLen );
		BOOL CryptGenKey( HCRYPTPROV hProv, ALG_ID Algid, DWORD dwFlags, HCRYPTKEY* phKey );
		BOOL CryptGenRandom( HCRYPTPROV hProv, DWORD dwLen, BYTE* pbBuffer );
		BOOL CryptGetDefaultProviderA( DWORD dwProvType, DWORD* pdwReserved, DWORD dwFlags, LPSTR pszProvName, DWORD* pcbProvName );
		BOOL CryptGetDefaultProviderW( DWORD dwProvType, DWORD* pdwReserved, DWORD dwFlags, LPWSTR pszProvName, DWORD* pcbProvName );
		BOOL CryptGetHashParam( HCRYPTHASH hHash, DWORD dwParam, BYTE* pbData, DWORD* pdwDataLen, DWORD dwFlags );
		BOOL CryptGetKeyParam( HCRYPTKEY hKey, DWORD dwParam, BYTE* pbData, DWORD* pdwDataLen, DWORD dwFlags );
		BOOL CryptGetProvParam( HCRYPTPROV hProv, DWORD dwParam, BYTE* pbData, DWORD* pdwDataLen, DWORD dwFlags );
		BOOL CryptGetUserKey( HCRYPTPROV hProv, DWORD dwKeySpec, HCRYPTKEY* phUserKey );
		BOOL CryptHashData( HCRYPTHASH hHash, BYTE* pbData, DWORD dwDataLen, DWORD dwFlags );
		BOOL CryptHashSessionKey( HCRYPTHASH hHash, HCRYPTKEY hKey, DWORD dwFlags );
		BOOL CryptImportKey( HCRYPTPROV hProv, BYTE* pbData, DWORD dwDataLen, HCRYPTKEY hPubKey, DWORD dwFlags, HCRYPTKEY* phKey );
		BOOL CryptReleaseContext( HCRYPTPROV hProv, DWORD dwFlags );
		BOOL CryptSetHashParam( HCRYPTHASH hHash, DWORD dwParam, const BYTE *pbData, DWORD dwFlags );
		BOOL CryptSetKeyParam( HCRYPTKEY hKey, DWORD dwParam, const BYTE* pbData, DWORD dwFlags );
		BOOL CryptSetProviderA( LPCSTR pszProvName, DWORD dwProvType );
		BOOL CryptSetProviderW( LPCWSTR pszProvName, DWORD dwProvType );
		BOOL CryptSetProviderExA( LPCSTR pszProvName, DWORD dwProvType, DWORD* pdwReserved, DWORD dwFlags );
		BOOL CryptSetProviderExW( LPCWSTR pszProvName, DWORD dwProvType, DWORD* pdwReserved, DWORD dwFlags );
		BOOL CryptSetProvParam( HCRYPTPROV hProv, DWORD dwParam, const BYTE* pbData, DWORD dwFlags );
		BOOL CryptSignHashA( HCRYPTHASH hHash, DWORD dwKeySpec, LPCSTR sDescription, DWORD dwFlags, BYTE* pbSignature, DWORD* pdwSigLen );
		BOOL CryptSignHashW( HCRYPTHASH hHash, DWORD dwKeySpec, LPCWSTR sDescription, DWORD dwFlags, BYTE* pbSignature, DWORD* pdwSigLen );
		BOOL CryptVerifySignatureA( HCRYPTHASH hHash, BYTE* pbSignature, DWORD dwSigLen, HCRYPTKEY hPubKey, LPCSTR sDescription, DWORD dwFlags );
		BOOL CryptVerifySignatureW( HCRYPTHASH hHash, BYTE* pbSignature, DWORD dwSigLen, HCRYPTKEY hPubKey, LPCWSTR sDescription, DWORD dwFlags );

		//------------------------------------------------------------------------------
		//Event Logging functions
		BOOL BackupEventLogA( HANDLE hEventLog, LPCSTR lpBackupFileName );
		BOOL BackupEventLogW( HANDLE hEventLog, LPCWSTR lpBackupFileName );
		BOOL ClearEventLogA( HANDLE hEventLog, LPCSTR lpBackupFileName );
		BOOL ClearEventLogW( HANDLE hEventLog, LPCWSTR lpBackupFileName );
		BOOL CloseEventLog( HANDLE hEventLog );
		BOOL GetEventLogInformation( HANDLE hEventLog, DWORD dwInfoLevel, LPVOID lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded );
		BOOL GetNumberOfEventLogRecords( HANDLE hEventLog, PDWORD NumberOfRecords );
		BOOL GetOldestEventLogRecord( HANDLE hEventLog, PDWORD OldestRecord );
		BOOL NotifyChangeEventLog( HANDLE hEventLog, HANDLE hEvent );
		HANDLE OpenBackupEventLogA( LPCSTR lpUNCServerName, LPCSTR lpFileName );
		HANDLE OpenBackupEventLogW( LPCWSTR lpUNCServerName, LPCWSTR lpFileName );
		HANDLE OpenEventLogA( LPCSTR lpUNCServerName, LPCSTR lpSourceName );
		HANDLE OpenEventLogW( LPCWSTR lpUNCServerName, LPCWSTR lpSourceName );
		BOOL ReadEventLogA( HANDLE hEventLog, DWORD dwReadFlags, DWORD dwRecordOffset, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, DWORD* pnBytesRead, DWORD* pnMinNumberOfBytesNeeded );
		BOOL ReadEventLogW( HANDLE hEventLog, DWORD dwReadFlags, DWORD dwRecordOffset, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, DWORD* pnBytesRead, DWORD* pnMinNumberOfBytesNeeded );
		BOOL WINAPI SaferRecordEventLogEntry( SAFER_LEVEL_HANDLE hLevel, LPCWSTR szTargetPath, LPVOID lpReserved );
		BOOL DeregisterEventSource( HANDLE hEventLog );
		HANDLE RegisterEventSourceA( LPCSTR lpUNCServerName, LPCSTR lpSourceName );
		HANDLE RegisterEventSourceW( LPCWSTR lpUNCServerName, LPCWSTR lpSourceName );
		BOOL ReportEventA( HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCSTR* lpStrings, LPVOID lpRawData );
		BOOL ReportEventW( HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCWSTR* lpStrings, LPVOID lpRawData );

		//------------------------------------------------------------------------------
		//Event Tracing functions
		ULONG ControlTraceA( TRACEHANDLE SessionHandle, LPCSTR SessionName, PEVENT_TRACE_PROPERTIES Properties, ULONG ControlCode );
		ULONG ControlTraceW( TRACEHANDLE SessionHandle, LPCWSTR SessionName, PEVENT_TRACE_PROPERTIES Properties, ULONG ControlCode );
		ULONG CreateTraceInstanceId( HANDLE RegHandle, PEVENT_INSTANCE_INFO pInstInfo );
		ULONG EnableTrace( ULONG Enable, ULONG EnableFlag, ULONG EnableLevel, LPCGUID ControlGuid, TRACEHANDLE SessionHandle );
		ULONG CloseTrace( TRACEHANDLE TraceHandle );
		ULONG EnumerateTraceGuids( PTRACE_GUID_PROPERTIES *GuidPropertiesArray, ULONG PropertyArrayCount, PULONG GuidCount );
		ULONG FlushTraceA( TRACEHANDLE SessionHandle, LPCSTR SessionName, PEVENT_TRACE_PROPERTIES Properties );
		ULONG FlushTraceW( TRACEHANDLE SessionHandle, LPCWSTR SessionName, PEVENT_TRACE_PROPERTIES Properties );
		ULONG GetTraceEnableFlags( TRACEHANDLE SessionHandle );
		UCHAR GetTraceEnableLevel( TRACEHANDLE SessionHandle );
		TRACEHANDLE GetTraceLoggerHandle( PVOID Buffer );
		TRACEHANDLE OpenTraceA( PEVENT_TRACE_LOGFILE Logfile );
		TRACEHANDLE OpenTraceW( PEVENT_TRACE_LOGFILE Logfile );
		ULONG ProcessTrace( PTRACEHANDLE HandleArray, ULONG HandleCount, LPFILETIME StartTime, LPFILETIME EndTime );
		ULONG QueryAllTracesA( PEVENT_TRACE_PROPERTIES* PropertyArray, ULONG PropertyArrayCount, PULONG SessionCount );
		ULONG QueryAllTracesW( PEVENT_TRACE_PROPERTIES* PropertyArray, ULONG PropertyArrayCount, PULONG SessionCount );
		ULONG QueryTraceA( TRACEHANDLE SessionHandle, LPCSTR SessionName, PEVENT_TRACE_PROPERTIES Properties );
		ULONG QueryTraceW( TRACEHANDLE SessionHandle, LPCWSTR SessionName, PEVENT_TRACE_PROPERTIES Properties );
		ULONG RegisterTraceGuidsA( WMIDPREQUEST RequestAddress, PVOID RequestContext, LPCGUID ControlGuid, ULONG GuidCount, PTRACE_GUID_REGISTRATION TraceGuidReg, LPCSTR MofImagePath, LPCSTR MofResourceName, PTRACEHANDLE RegistrationHandle );
		ULONG RegisterTraceGuidsW( WMIDPREQUEST RequestAddress, PVOID RequestContext, LPCGUID ControlGuid, ULONG GuidCount, PTRACE_GUID_REGISTRATION TraceGuidReg, LPCWSTR MofImagePath, LPCWSTR MofResourceName, PTRACEHANDLE RegistrationHandle );
		ULONG SetTraceCallback( LPCGUID pGuid, PEVENT_CALLBACK EventCallback );
		ULONG StartTraceA( PTRACEHANDLE SessionHandle, LPCSTR SessionName, PEVENT_TRACE_PROPERTIES Properties );
		ULONG StartTraceW( PTRACEHANDLE SessionHandle, LPCWSTR SessionName, PEVENT_TRACE_PROPERTIES Properties );
		ULONG StopTraceA( TRACEHANDLE SessionHandle, LPCSTR SessionName, PEVENT_TRACE_PROPERTIES Properties );
		ULONG StopTraceW( TRACEHANDLE SessionHandle, LPCWSTR SessionName, PEVENT_TRACE_PROPERTIES Properties );
		ULONG TraceEvent( TRACEHANDLE SessionHandle, PEVENT_TRACE_HEADER EventTrace );
		ULONG TraceEventInstance( TRACEHANDLE SessionHandle, PEVENT_INSTANCE_HEADER EventTrace, PEVENT_INSTANCE_INFO pInstInfo, PEVENT_INSTANCE_INFO pParentInstInfo );
		ULONG TraceMessage( TRACEHANDLE SessionHandle, ULONG MessageFlags, LPGUID MessageGuid, USHORT MessageNumber, ... );
		ULONG TraceMessageVa( TRACEHANDLE SessionHandle, ULONG MessageFlags, LPGUID MessageGuid, USHORT MessageNumber, va_list MessageArgList );
		ULONG UpdateTraceA( TRACEHANDLE SessionHandle, LPCSTR SessionName, PEVENT_TRACE_PROPERTIES Properties );
		ULONG UpdateTraceW( TRACEHANDLE SessionHandle, LPCWSTR SessionName, PEVENT_TRACE_PROPERTIES Properties );
		ULONG UnregisterTraceGuids( TRACEHANDLE RegistrationHandle );
		ULONG RemoveTraceCallback( LPCGUID pGuid );

	};

}//nsWinQAPI

#endif//WINQAPI_ADVAPI32_H_1

