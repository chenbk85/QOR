//PSAPI32.h

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef WINQAPI_PSAPI_H_1
#define WINQAPI_PSAPI_H_1

#define PSAPI_VERSION 1
#include "../Source/SystemQOR/MSWindows/WinQAPI/include/DynamicLibrary.h"
#include "WinQAPI/Kernel32.h"

//--------------------------------------------------------------------------------
typedef struct _MODULEINFO 
{
    LPVOID lpBaseOfDll;
    DWORD SizeOfImage;
    LPVOID EntryPoint;
} MODULEINFO, *LPMODULEINFO;

//--------------------------------------------------------------------------------
typedef struct _PERFORMANCE_INFORMATION 
{
    DWORD cb;
    SIZE_T CommitTotal;
    SIZE_T CommitLimit;
    SIZE_T CommitPeak;
    SIZE_T PhysicalTotal;
    SIZE_T PhysicalAvailable;
    SIZE_T SystemCache;
    SIZE_T KernelTotal;
    SIZE_T KernelPaged;
    SIZE_T KernelNonpaged;
    SIZE_T PageSize;
    DWORD HandleCount;
    DWORD ProcessCount;
    DWORD ThreadCount;
} PERFORMANCE_INFORMATION, *PPERFORMANCE_INFORMATION, PERFORMACE_INFORMATION, *PPERFORMACE_INFORMATION;

//--------------------------------------------------------------------------------
typedef struct _PROCESS_MEMORY_COUNTERS 
{
    DWORD cb;
    DWORD PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
} PROCESS_MEMORY_COUNTERS;

typedef PROCESS_MEMORY_COUNTERS *PPROCESS_MEMORY_COUNTERS;

//--------------------------------------------------------------------------------
typedef struct _PSAPI_WS_WATCH_INFORMATION 
{
    LPVOID FaultingPc;
    LPVOID FaultingVa;
} PSAPI_WS_WATCH_INFORMATION, *PPSAPI_WS_WATCH_INFORMATION;

//--------------------------------------------------------------------------------
typedef struct _PSAPI_WS_WATCH_INFORMATION_EX 
{
    PSAPI_WS_WATCH_INFORMATION BasicInfo;
    ULONG_PTR FaultingThreadId;
    ULONG_PTR Flags;    // Reserved
} PSAPI_WS_WATCH_INFORMATION_EX, *PPSAPI_WS_WATCH_INFORMATION_EX;

//--------------------------------------------------------------------------------
namespace nsWinQAPI
{
	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE( __WINQAPI ) CPSAPI : public CDll
	{
	public:

		typedef struct _ENUM_PAGE_FILE_INFORMATION 
		{
		  DWORD  cb;
		  DWORD  Reserved;
		  SIZE_T TotalSize;
		  SIZE_T TotalInUse;
		  SIZE_T PeakUsage;
		} ENUM_PAGE_FILE_INFORMATION, *PENUM_PAGE_FILE_INFORMATION;

		BOOL __QCMP_STDCALLCONVENTION EnumPageFilesProc( LPVOID pContext, PENUM_PAGE_FILE_INFORMATION pPageFileInfo, LPCTSTR lpFilename );

		typedef BOOL (*PENUM_PAGE_FILE_CALLBACKW) (LPVOID pContext, PENUM_PAGE_FILE_INFORMATION pPageFileInfo, LPCWSTR lpFilename);
		typedef BOOL (*PENUM_PAGE_FILE_CALLBACKA) (LPVOID pContext, PENUM_PAGE_FILE_INFORMATION pPageFileInfo, LPCSTR lpFilename);

#	ifdef UNICODE
#		define PENUM_PAGE_FILE_CALLBACK PENUM_PAGE_FILE_CALLBACKW
#		define EnumPageFiles EnumPageFilesW
#	else
#		define PENUM_PAGE_FILE_CALLBACK PENUM_PAGE_FILE_CALLBACKA
#		define EnumPageFiles EnumPageFilesA
#	endif // !UNICODE

		//--------------------------------------------------------------------------------
		CPSAPI() : CDll( TEXT("psapi.dll") )
		{						
		}

		//--------------------------------------------------------------------------------
		static CPSAPI Instance( void )
		{
			/*static*/ CPSAPI _instance;
			return _instance;
		}

		//--------------------------------------------------------------------------------
		~CPSAPI()
		{						
		}

		BOOL EmptyWorkingSet( HANDLE hProcess );//Removes as many pages as possible from the working set of the specified process.
		BOOL EnumDeviceDrivers( LPVOID* lpImageBase, DWORD cb, LPDWORD lpcbNeeded );//Retrieves the load address for each device driver in the system.
		BOOL EnumPageFiles( PENUM_PAGE_FILE_CALLBACK pCallbackRoutine, LPVOID lpContext );//Calls the callback routine for each installed pagefile in the system.
		BOOL EnumProcesses( DWORD* pProcessIds, DWORD cb, DWORD *pBytesReturned );
		BOOL EnumProcessModules( HANDLE hProcess, HMODULE* lphModule, DWORD cb, LPDWORD lpcbNeeded );
		BOOL EnumProcessModulesEx( HANDLE hProcess, HMODULE* lphModule, DWORD cb, LPDWORD lpcbNeeded, DWORD dwFilterFlag );
		DWORD GetDeviceDriverBaseName( LPVOID ImageBase, LPTSTR lpBaseName, DWORD nSize );
		DWORD GetDeviceDriverFileName( LPVOID ImageBase, LPTSTR lpFilename, DWORD nSize );
		DWORD GetMappedFileName( HANDLE hProcess, LPVOID lpv, LPTSTR lpFilename, DWORD nSize );
		DWORD GetModuleBaseName( HANDLE hProcess, HMODULE hModule, LPTSTR lpBaseName, DWORD nSize );
		DWORD GetModuleFileNameEx( HANDLE hProcess, HMODULE hModule, LPTSTR lpFilename, DWORD nSize );
		BOOL GetModuleInformation( HANDLE hProcess, HMODULE hModule, LPMODULEINFO lpmodinfo, DWORD cb );
		BOOL GetPerformanceInfo( PPERFORMANCE_INFORMATION pPerformanceInformation, DWORD cb );
		DWORD GetProcessImageFileName( HANDLE hProcess, LPTSTR lpImageFileName, DWORD nSize );
		BOOL GetProcessMemoryInfo( HANDLE Process, PPROCESS_MEMORY_COUNTERS ppsmemCounters, DWORD cb );

		BOOL GetWsChanges( HANDLE hProcess, PPSAPI_WS_WATCH_INFORMATION lpWatchInfo, DWORD cb );
		BOOL GetWsChangesEx( HANDLE hProcess, PPSAPI_WS_WATCH_INFORMATION_EX lpWatchInfoEx, DWORD cb );
		BOOL InitializeProcessForWsWatch( HANDLE hProcess );
		BOOL QueryWorkingSet( HANDLE hProcess, PVOID pv, DWORD cb );
		BOOL QueryWorkingSetEx( HANDLE hProcess, PVOID pv, DWORD cb );

	};

}//nsWinQAPI

#endif//WINQAPI_PSAPI_H_1
